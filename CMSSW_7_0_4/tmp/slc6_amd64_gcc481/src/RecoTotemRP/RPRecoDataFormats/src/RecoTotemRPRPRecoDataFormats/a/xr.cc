// Generated at Mon Jul 11 23:16:18 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/RecoTotemRP/RPRecoDataFormats/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_65 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_9 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_613 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_97 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1482 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1326 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_401 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_797 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_197 = ::Reflex::TypeBuilder(Reflex::Literal("TTimer"));
  ::Reflex::Type type_1987 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_1672 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_638 = ::Reflex::TypeBuilder(Reflex::Literal("TBrowser"));
  ::Reflex::Type type_1681 = ::Reflex::TypeBuilder(Reflex::Literal("TMethod"));
  ::Reflex::Type type_2316 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_1741 = ::Reflex::TypeBuilder(Reflex::Literal("RP2DHit"));
  ::Reflex::Type type_2017 = ::Reflex::TypeBuilder(Reflex::Literal("TVector3"));
  ::Reflex::Type type_2016 = ::Reflex::TypeBuilder(Reflex::Literal("TVector2"));
  ::Reflex::Type type_997 = ::Reflex::TypeBuilder(Reflex::Literal("TObjArray"));
  ::Reflex::Type type_2170 = ::Reflex::TypeBuilder(Reflex::Literal("RPRecoHit"));
  ::Reflex::Type type_2005 = ::Reflex::TypeBuilder(Reflex::Literal("TRotation"));
  ::Reflex::Type type_296 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_156 = ::Reflex::TypeBuilder(Reflex::Literal("RPFittedTrack"));
  ::Reflex::Type type_221 = ::Reflex::TypeBuilder(Reflex::Literal("RPDetHitPoint"));
  ::Reflex::Type type_1929 = ::Reflex::TypeBuilder(Reflex::Literal("RP2DHitDebug"));
  ::Reflex::Type type_288 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_416 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_4352 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_994 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixT<double>"));
  ::Reflex::Type type_1181 = ::Reflex::TypeBuilder(Reflex::Literal("CentralMassInfo"));
  ::Reflex::Type type_387 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_1658 = ::Reflex::TypeBuilder(Reflex::Literal("RPTrackCandidate"));
  ::Reflex::Type type_2018 = ::Reflex::TypeBuilder(Reflex::Literal("TVectorT<double>"));
  ::Reflex::Type type_1969 = ::Reflex::TypeBuilder(Reflex::Literal("RPStationTrackFit"));
  ::Reflex::Type type_2052 = ::Reflex::TypeBuilder(Reflex::Literal("RPRecoElasticEvent"));
  ::Reflex::Type type_2855 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2172 = ::Reflex::TypeBuilder(Reflex::Literal("RPRecognizedPatterns"));
  ::Reflex::Type type_1565 = ::Reflex::TypeBuilder(Reflex::Literal("RPReconstructedProton"));
  ::Reflex::Type type_4208 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RP2DHit>"));
  ::Reflex::Type type_4211 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TObject>"));
  ::Reflex::Type type_215 = ::Reflex::TypeBuilder(Reflex::Literal("RPFittedTrackCollection"));
  ::Reflex::Type type_2853 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRecoHit>"));
  ::Reflex::Type type_2618 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RP2DHit>"));
  ::Reflex::Type type_2621 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TObject>"));
  ::Reflex::Type type_4213 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TVector3>"));
  ::Reflex::Type type_1115 = ::Reflex::TypeBuilder(Reflex::Literal("RPRecoProtMADXVariables"));
  ::Reflex::Type type_2510 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned int>"));
  ::Reflex::Type type_2623 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TVector3>"));
  ::Reflex::Type type_2840 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_225 = ::Reflex::TypeBuilder(Reflex::Literal("RPMulFittedTrackCollection"));
  ::Reflex::Type type_1003 = ::Reflex::TypeBuilder(Reflex::Literal("RPReconstructedProtonPair"));
  ::Reflex::Type type_2848 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPDetHitPoint>"));
  ::Reflex::Type type_252 = ::Reflex::TypeBuilder(Reflex::Literal("RPStationTrackFitCollection"));
  ::Reflex::Type type_1597 = ::Reflex::TypeBuilder(Reflex::Literal("RPTrackCandidateCollection"));
  ::Reflex::Type type_2447 = ::Reflex::TypeBuilder(Reflex::Literal("std::set<const RPRecoHit*>"));
  ::Reflex::Type type_7382 = ::Reflex::TypeBuilder(Reflex::Literal("RPRecognizedPatterns::Line"));
  ::Reflex::Type type_2849 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPFittedTrack>"));
  ::Reflex::Type type_2841 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_4207 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RP2DHitDebug>"));
  ::Reflex::Type type_2854 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned short>"));
  ::Reflex::Type type_2617 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RP2DHitDebug>"));
  ::Reflex::Type type_4214 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPDetHitPoint>"));
  ::Reflex::Type type_4219 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPFittedTrack>"));
  ::Reflex::Type type_370 = ::Reflex::TypeBuilder(Reflex::Literal("RPMulTrackCandidateCollection"));
  ::Reflex::Type type_7344 = ::Reflex::TypeBuilder(Reflex::Literal("RPRecoElasticEvent::fit_type"));
  ::Reflex::Type type_2624 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPDetHitPoint>"));
  ::Reflex::Type type_2629 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPFittedTrack>"));
  ::Reflex::Type type_2874 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const RPRecoHit*>"));
  ::Reflex::Type type_7343 = ::Reflex::TypeBuilder(Reflex::Literal("RPRecoElasticEvent::road_type"));
  ::Reflex::Type type_3061 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPDetHitPoint>"));
  ::Reflex::Type type_3063 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPFittedTrack>"));
  ::Reflex::Type type_2851 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPTrackCandidate>"));
  ::Reflex::Type type_4229 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<CentralMassInfo>"));
  ::Reflex::Type type_2062 = ::Reflex::TypeBuilder(Reflex::Literal("RPRecognizedPatternsCollection"));
  ::Reflex::Type type_2842 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPStationTrackFit>"));
  ::Reflex::Type type_4269 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RP2DHit>"));
  ::Reflex::Type type_4272 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TObject>"));
  ::Reflex::Type type_1944 = ::Reflex::TypeBuilder(Reflex::Literal("RPMulFittedTrackSetsCollection"));
  ::Reflex::Type type_2639 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<CentralMassInfo>"));
  ::Reflex::Type type_2293 = ::Reflex::TypeBuilder(Reflex::Literal("RPReconstructedProtonCollection"));
  ::Reflex::Type type_4274 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TVector3>"));
  ::Reflex::Type type_586 = ::Reflex::TypeBuilder(Reflex::Literal("RPMulTrackCandidateSetsCollection"));
  ::Reflex::Type type_3067 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPTrackCandidate>"));
  ::Reflex::Type type_4203 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRecoElasticEvent>"));
  ::Reflex::Type type_3052 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPStationTrackFit>"));
  ::Reflex::Type type_2613 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRecoElasticEvent>"));
  ::Reflex::Type type_925 = ::Reflex::TypeBuilder(Reflex::Literal("RPReconstructedProtonPairCollection"));
  ::Reflex::Type type_2847 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPReconstructedProton>"));
  ::Reflex::Type type_4202 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRecognizedPatterns>"));
  ::Reflex::Type type_2975 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RP2DHitDebug>"));
  ::Reflex::Type type_7345 = ::Reflex::EnumTypeBuilder(Reflex::Literal("RPRecoElasticEvent::status_type"));
  ::Reflex::Type type_2612 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRecognizedPatterns>"));
  ::Reflex::Type type_4268 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RP2DHitDebug>"));
  ::Reflex::Type type_4210 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPReconstructedProton>"));
  ::Reflex::Type type_2977 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPFittedTrack>"));
  ::Reflex::Type type_7383 = ::Reflex::EnumTypeBuilder(Reflex::Literal("RPRecognizedPatterns::SourceType"));
  ::Reflex::Type type_2774 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,RP2DHitDebug>"));
  ::Reflex::Type type_2620 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPReconstructedProton>"));
  ::Reflex::Type type_4275 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPDetHitPoint>"));
  ::Reflex::Type type_4280 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPFittedTrack>"));
  ::Reflex::Type type_157 = ::Reflex::TypeBuilder(Reflex::Literal("RPTrackCandidateDistinctCollectionsSet"));
  ::Reflex::Type type_3060 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPReconstructedProton>"));
  ::Reflex::Type type_2778 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,RPFittedTrack>"));
  ::Reflex::Type type_4218 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPFittedTrackCollection>"));
  ::Reflex::Type type_2846 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPReconstructedProtonPair>"));
  ::Reflex::Type type_2628 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPFittedTrackCollection>"));
  ::Reflex::Type type_4290 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<CentralMassInfo>"));
  ::Reflex::Type type_2981 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPTrackCandidate>"));
  ::Reflex::Type type_2843 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRecognizedPatterns::Line>"));
  ::Reflex::Type type_2873 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPTrackCandidateCollection>"));
  ::Reflex::Type type_4205 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPReconstructedProtonPair>"));
  ::Reflex::Type type_2852 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<RPFittedTrack> >"));
  ::Reflex::Type type_2615 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPReconstructedProtonPair>"));
  ::Reflex::Type type_2784 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,RPTrackCandidate>"));
  ::Reflex::Type type_4217 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPMulFittedTrackCollection>"));
  ::Reflex::Type type_4228 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPTrackCandidateCollection>"));
  ::Reflex::Type type_2844 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>"));
  ::Reflex::Type type_3058 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPReconstructedProtonPair>"));
  ::Reflex::Type type_4264 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRecoElasticEvent>"));
  ::Reflex::Type type_2627 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPMulFittedTrackCollection>"));
  ::Reflex::Type type_2638 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPTrackCandidateCollection>"));
  ::Reflex::Type type_4200 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPStationTrackFitCollection>"));
  ::Reflex::Type type_4212 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPDetHitPoint> >"));
  ::Reflex::Type type_2845 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>"));
  ::Reflex::Type type_3055 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRecognizedPatterns::Line>"));
  ::Reflex::Type type_2610 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPStationTrackFitCollection>"));
  ::Reflex::Type type_2622 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<RPDetHitPoint> >"));
  ::Reflex::Type type_2775 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RP2DHitDebug>"));
  ::Reflex::Type type_2974 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>"));
  ::Reflex::Type type_2850 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >"));
  ::Reflex::Type type_3069 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<RPFittedTrack> >"));
  ::Reflex::Type type_2772 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RPFittedTrack>"));
  ::Reflex::Type type_4263 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRecognizedPatterns>"));
  ::Reflex::Type type_4227 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPMulTrackCandidateCollection>"));
  ::Reflex::Type type_3056 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRecoElasticEvent::fit_type>"));
  ::Reflex::Type type_4271 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPReconstructedProton>"));
  ::Reflex::Type type_2637 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPMulTrackCandidateCollection>"));
  ::Reflex::Type type_4201 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRecognizedPatternsCollection>"));
  ::Reflex::Type type_4223 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPMulFittedTrackSetsCollection>"));
  ::Reflex::Type type_3057 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRecoElasticEvent::road_type>"));
  ::Reflex::Type type_2611 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRecognizedPatternsCollection>"));
  ::Reflex::Type type_2633 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPMulFittedTrackSetsCollection>"));
  ::Reflex::Type type_4209 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPReconstructedProtonCollection>"));
  ::Reflex::Type type_3066 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<RPTrackCandidate> >"));
  ::Reflex::Type type_2779 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RPTrackCandidate>"));
  ::Reflex::Type type_2619 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPReconstructedProtonCollection>"));
  ::Reflex::Type type_4279 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPFittedTrackCollection>"));
  ::Reflex::Type type_4220 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPMulTrackCandidateSetsCollection>"));
  ::Reflex::Type type_2295 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_ostream<char,std::char_traits<char> >"));
  ::Reflex::Type type_4266 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPReconstructedProtonPair>"));
  ::Reflex::Type type_2630 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPMulTrackCandidateSetsCollection>"));
  ::Reflex::Type type_4278 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPMulFittedTrackCollection>"));
  ::Reflex::Type type_4289 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPTrackCandidateCollection>"));
  ::Reflex::Type type_4204 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPReconstructedProtonPairCollection>"));
  ::Reflex::Type type_2976 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >"));
  ::Reflex::Type type_2773 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RPRecognizedPatterns>"));
  ::Reflex::Type type_4261 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPStationTrackFitCollection>"));
  ::Reflex::Type type_2614 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPReconstructedProtonPairCollection>"));
  ::Reflex::Type type_4273 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<RPDetHitPoint> >"));
  ::Reflex::Type type_4206 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >"));
  ::Reflex::Type type_2777 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,std::vector<RPFittedTrack> >"));
  ::Reflex::Type type_2616 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,RP2DHitDebug> >"));
  ::Reflex::Type type_4216 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPFittedTrack> >"));
  ::Reflex::Type type_2990 = ::Reflex::TypeBuilder(Reflex::Literal("std::binary_function<unsigned int,unsigned int,bool>"));
  ::Reflex::Type type_4288 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPMulTrackCandidateCollection>"));
  ::Reflex::Type type_2626 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,RPFittedTrack> >"));
  ::Reflex::Type type_4226 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>"));
  ::Reflex::Type type_2980 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >"));
  ::Reflex::Type type_4262 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRecognizedPatternsCollection>"));
  ::Reflex::Type type_4284 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPMulFittedTrackSetsCollection>"));
  ::Reflex::Type type_2636 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPTrackCandidateDistinctCollectionsSet>"));
  ::Reflex::Type type_2973 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >"));
  ::Reflex::Type type_4093 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_4270 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPReconstructedProtonCollection>"));
  ::Reflex::Type type_2783 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,std::vector<RPTrackCandidate> >"));
  ::Reflex::Type type_4225 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_4281 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPMulTrackCandidateSetsCollection>"));
  ::Reflex::Type type_2635 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_6693 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPDetHitPoint> >"));
  ::Reflex::Type type_6683 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPFittedTrack> >"));
  ::Reflex::Type type_2776 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<RPFittedTrack> >"));
  ::Reflex::Type type_4265 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPReconstructedProtonPairCollection>"));
  ::Reflex::Type type_4222 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_2632 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_3059 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RP2DHitDebug> >"));
  ::Reflex::Type type_4267 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,RP2DHitDebug> >"));
  ::Reflex::Type type_6686 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPTrackCandidate> >"));
  ::Reflex::Type type_3053 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPFittedTrack> >"));
  ::Reflex::Type type_2782 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<RPTrackCandidate> >"));
  ::Reflex::Type type_4277 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,RPFittedTrack> >"));
  ::Reflex::Type type_6681 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPStationTrackFit> >"));
  ::Reflex::Type type_2771 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<RPStationTrackFit> >"));
  ::Reflex::Type type_4287 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPTrackCandidateDistinctCollectionsSet>"));
  ::Reflex::Type type_2984 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >"));
  ::Reflex::Type type_2364 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPDetHitPoint,std::allocator<RPDetHitPoint> >"));
  ::Reflex::Type type_2354 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPFittedTrack,std::allocator<RPFittedTrack> >"));
  ::Reflex::Type type_3064 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPTrackCandidate> >"));
  ::Reflex::Type type_4286 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_2979 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_6692 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPReconstructedProton> >"));
  ::Reflex::Type type_4215 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_2625 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_2978 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_3054 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPRecognizedPatterns> >"));
  ::Reflex::Type type_4283 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_2910 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >"));
  ::Reflex::Type type_2913 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >"));
  ::Reflex::Type type_6690 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPReconstructedProtonPair> >"));
  ::Reflex::Type type_2357 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPTrackCandidate,std::allocator<RPTrackCandidate> >"));
  ::Reflex::Type type_6188 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >"));
  ::Reflex::Type type_6687 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRecognizedPatterns::Line> >"));
  ::Reflex::Type type_6525 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<std::pair<const unsigned int,RPFittedTrack> >"));
  ::Reflex::Type type_2807 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> >"));
  ::Reflex::Type type_2352 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPStationTrackFit,std::allocator<RPStationTrackFit> >"));
  ::Reflex::Type type_6685 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_2781 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_2917 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >"));
  ::Reflex::Type type_6682 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRecoElasticEvent::fit_type> >"));
  ::Reflex::Type type_6611 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >"));
  ::Reflex::Type type_6591 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >"));
  ::Reflex::Type type_6688 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRecoElasticEvent::road_type> >"));
  ::Reflex::Type type_6551 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<std::pair<const unsigned int,RPTrackCandidate> >"));
  ::Reflex::Type type_2662 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RP2DHitDebug> >"));
  ::Reflex::Type type_6684 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_3062 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_2665 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPFittedTrack> >"));
  ::Reflex::Type type_2780 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_4276 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_2909 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >"));
  ::Reflex::Type type_3070 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_2669 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPTrackCandidate> >"));
  ::Reflex::Type type_6612 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPDetHitPoint*,std::vector<RPDetHitPoint> >"));
  ::Reflex::Type type_6592 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPFittedTrack*,std::vector<RPFittedTrack> >"));
  ::Reflex::Type type_6597 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >"));
  ::Reflex::Type type_3051 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >"));
  ::Reflex::Type type_2363 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPReconstructedProton,std::allocator<RPReconstructedProton> >"));
  ::Reflex::Type type_4224 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_6587 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >"));
  ::Reflex::Type type_2634 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_2661 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >"));
  ::Reflex::Type type_2912 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_4221 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_2794 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >,bool>"));
  ::Reflex::Type type_2631 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_6598 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPTrackCandidate*,std::vector<RPTrackCandidate> >"));
  ::Reflex::Type type_2803 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >,bool>"));
  ::Reflex::Type type_2916 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_6588 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPStationTrackFit*,std::vector<RPStationTrackFit> >"));
  ::Reflex::Type type_2908 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >"));
  ::Reflex::Type type_2361 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPReconstructedProtonPair,std::allocator<RPReconstructedProtonPair> >"));
  ::Reflex::Type type_2818 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >,bool>"));
  ::Reflex::Type type_3103 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >"));
  ::Reflex::Type type_6609 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >"));
  ::Reflex::Type type_2664 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_3068 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_4285 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_2358 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRecognizedPatterns::Line,std::allocator<RPRecognizedPatterns::Line> >"));
  ::Reflex::Type type_2356 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<RPFittedTrack>,std::allocator<std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_2791 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >,bool>"));
  ::Reflex::Type type_3227 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> > >"));
  ::Reflex::Type type_3065 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_2668 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_4282 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_2660 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >"));
  ::Reflex::Type type_3233 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> > >"));
  ::Reflex::Type type_2353 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRecoElasticEvent::fit_type,std::allocator<RPRecoElasticEvent::fit_type> >"));
  ::Reflex::Type type_6610 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPReconstructedProton*,std::vector<RPReconstructedProton> >"));
  ::Reflex::Type type_2359 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRecoElasticEvent::road_type,std::allocator<RPRecoElasticEvent::road_type> >"));
  ::Reflex::Type type_3281 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> > >"));
  ::Reflex::Type type_2914 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >"));
  ::Reflex::Type type_6605 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >"));
  ::Reflex::Type type_3235 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> > >"));
  ::Reflex::Type type_3203 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_2355 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<RPTrackCandidate>,std::allocator<std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_2911 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_3226 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RP2DHitDebug> > >"));
  ::Reflex::Type type_6599 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >"));
  ::Reflex::Type type_2800 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >,bool>"));
  ::Reflex::Type type_3232 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPFittedTrack> > >"));
  ::Reflex::Type type_6595 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_3213 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> > >"));
  ::Reflex::Type type_2915 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_2815 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >,bool>"));
  ::Reflex::Type type_3280 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPTrackCandidate> > >"));
  ::Reflex::Type type_2666 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >"));
  ::Reflex::Type type_6589 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >"));
  ::Reflex::Type type_6606 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >"));
  ::Reflex::Type type_3234 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPDetHitPoint*,std::vector<RPDetHitPoint> > >"));
  ::Reflex::Type type_3202 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPFittedTrack*,std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_3209 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_2787 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >,bool>"));
  ::Reflex::Type type_2663 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_3199 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> > >"));
  ::Reflex::Type type_6600 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >"));
  ::Reflex::Type type_6601 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >"));
  ::Reflex::Type type_6593 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_6596 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >"));
  ::Reflex::Type type_3212 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRecognizedPatterns> > >"));
  ::Reflex::Type type_2667 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_3231 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_6590 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >"));
  ::Reflex::Type type_3208 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPTrackCandidate*,std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_3279 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_3198 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPStationTrackFit*,std::vector<RPStationTrackFit> > >"));
  ::Reflex::Type type_6602 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >"));
  ::Reflex::Type type_3211 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > > >"));
  ::Reflex::Type type_6594 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >"));
  ::Reflex::Type type_2809 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >,bool>"));
  ::Reflex::Type type_3225 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> > >"));
  ::Reflex::Type type_3230 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_2797 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >,bool>"));
  ::Reflex::Type type_2812 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >,bool>"));
  ::Reflex::Type type_3278 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_3210 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > > >"));
  ::Reflex::Type type_3224 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPReconstructedProton*,std::vector<RPReconstructedProton> > >"));
  ::Reflex::Type type_3275 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > > >"));
  ::Reflex::Type type_3221 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> > >"));
  ::Reflex::Type type_3229 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > > >"));
  ::Reflex::Type type_3215 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> > >"));
  ::Reflex::Type type_3207 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_3277 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >"));
  ::Reflex::Type type_3274 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > > >"));
  ::Reflex::Type type_3201 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> > >"));
  ::Reflex::Type type_3220 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> > >"));
  ::Reflex::Type type_3228 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > > >"));
  ::Reflex::Type type_3214 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> > >"));
  ::Reflex::Type type_3217 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> > >"));
  ::Reflex::Type type_3205 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_3206 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_3276 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >"));
  ::Reflex::Type type_3200 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> > >"));
  ::Reflex::Type type_3216 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> > >"));
  ::Reflex::Type type_3204 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_2793 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> > >"));
  ::Reflex::Type type_2802 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> > >"));
  ::Reflex::Type type_2819 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >"));
  ::Reflex::Type type_2817 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> > >"));
  ::Reflex::Type type_2792 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RP2DHitDebug> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RP2DHitDebug> > >"));
  ::Reflex::Type type_2801 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPFittedTrack> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPFittedTrack> > >"));
  ::Reflex::Type type_2790 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> > >"));
  ::Reflex::Type type_2816 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPTrackCandidate> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPTrackCandidate> > >"));
  ::Reflex::Type type_2789 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRecognizedPatterns> > >"));
  ::Reflex::Type type_2799 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_2814 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_2786 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > > >"));
  ::Reflex::Type type_2798 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_2813 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_2785 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > > >"));
  ::Reflex::Type type_2808 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > > >"));
  ::Reflex::Type type_2796 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > > >"));
  ::Reflex::Type type_2811 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >"));
  ::Reflex::Type type_2806 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > > >"));
  ::Reflex::Type type_2558 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RP2DHitDebug>,std::_Select1st<std::pair<const unsigned int,RP2DHitDebug> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RP2DHitDebug> > >"));
  ::Reflex::Type type_2795 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > > >"));
  ::Reflex::Type type_2561 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPFittedTrack>,std::_Select1st<std::pair<const unsigned int,RPFittedTrack> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPFittedTrack> > >"));
  ::Reflex::Type type_2810 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >"));
  ::Reflex::Type type_2565 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPTrackCandidate>,std::_Select1st<std::pair<const unsigned int,RPTrackCandidate> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPTrackCandidate> > >"));
  ::Reflex::Type type_2557 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRecognizedPatterns>,std::_Select1st<std::pair<const unsigned int,RPRecognizedPatterns> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRecognizedPatterns> > >"));
  ::Reflex::Type type_2560 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPFittedTrack> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPFittedTrack> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPFittedTrack> > > >"));
  ::Reflex::Type type_2564 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPTrackCandidate> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > > >"));
  ::Reflex::Type type_2556 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPStationTrackFit> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > > >"));
  ::Reflex::Type type_2562 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > > >"));
  ::Reflex::Type type_2559 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > >,std::_Select1st<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > > >"));
  ::Reflex::Type type_2563 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > >,std::_Select1st<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >"));
  ::Reflex::Type type_16777 = ::Reflex::ArrayBuilder(type_97, 4);
  ::Reflex::Type type_16778 = ::Reflex::ArrayBuilder(type_97, 16);
  ::Reflex::Type type_12299 = ::Reflex::ReferenceBuilder(type_156);
  ::Reflex::Type type_156c = ::Reflex::ConstBuilder(type_156);
  ::Reflex::Type type_12301 = ::Reflex::ReferenceBuilder(type_156c);
  ::Reflex::Type type_2019 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TVectorD"), type_2018);
  ::Reflex::Type type_2019c = ::Reflex::ConstBuilder(type_2019);
  ::Reflex::Type type_16779 = ::Reflex::ReferenceBuilder(type_2019c);
  ::Reflex::Type type_995 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TMatrixD"), type_994);
  ::Reflex::Type type_995c = ::Reflex::ConstBuilder(type_995);
  ::Reflex::Type type_16780 = ::Reflex::ReferenceBuilder(type_995c);
  ::Reflex::Type type_221c = ::Reflex::ConstBuilder(type_221);
  ::Reflex::Type type_12236 = ::Reflex::ReferenceBuilder(type_221c);
  ::Reflex::Type type_12686 = ::Reflex::ReferenceBuilder(type_97);
  ::Reflex::Type type_16781 = ::Reflex::ReferenceBuilder(type_157);
  ::Reflex::Type type_157c = ::Reflex::ConstBuilder(type_157);
  ::Reflex::Type type_16782 = ::Reflex::ReferenceBuilder(type_157c);
  ::Reflex::Type type_16792 = ::Reflex::ReferenceBuilder(type_215);
  ::Reflex::Type type_215c = ::Reflex::ConstBuilder(type_215);
  ::Reflex::Type type_16793 = ::Reflex::ReferenceBuilder(type_215c);
  ::Reflex::Type type_12234 = ::Reflex::ReferenceBuilder(type_221);
  ::Reflex::Type type_2170c = ::Reflex::ConstBuilder(type_2170);
  ::Reflex::Type type_4793 = ::Reflex::ReferenceBuilder(type_2170c);
  ::Reflex::Type type_2017c = ::Reflex::ConstBuilder(type_2017);
  ::Reflex::Type type_7363 = ::Reflex::ReferenceBuilder(type_2017c);
  ::Reflex::Type type_16794 = ::Reflex::ReferenceBuilder(type_225);
  ::Reflex::Type type_225c = ::Reflex::ConstBuilder(type_225);
  ::Reflex::Type type_16795 = ::Reflex::ReferenceBuilder(type_225c);
  ::Reflex::Type type_16802 = ::Reflex::ReferenceBuilder(type_252);
  ::Reflex::Type type_252c = ::Reflex::ConstBuilder(type_252);
  ::Reflex::Type type_16803 = ::Reflex::ReferenceBuilder(type_252c);
  ::Reflex::Type type_18018 = ::Reflex::ReferenceBuilder(type_370);
  ::Reflex::Type type_370c = ::Reflex::ConstBuilder(type_370);
  ::Reflex::Type type_18019 = ::Reflex::ReferenceBuilder(type_370c);
  ::Reflex::Type type_19252 = ::Reflex::ReferenceBuilder(type_586);
  ::Reflex::Type type_586c = ::Reflex::ConstBuilder(type_586);
  ::Reflex::Type type_19253 = ::Reflex::ReferenceBuilder(type_586c);
  ::Reflex::Type type_19299 = ::Reflex::ReferenceBuilder(type_925);
  ::Reflex::Type type_925c = ::Reflex::ConstBuilder(type_925);
  ::Reflex::Type type_19300 = ::Reflex::ReferenceBuilder(type_925c);
  ::Reflex::Type type_19328 = ::Reflex::ArrayBuilder(type_97, 9);
  ::Reflex::Type type_19329 = ::Reflex::ArrayBuilder(type_97, 81);
  ::Reflex::Type type_12106 = ::Reflex::ReferenceBuilder(type_1003);
  ::Reflex::Type type_1003c = ::Reflex::ConstBuilder(type_1003);
  ::Reflex::Type type_5606 = ::Reflex::ReferenceBuilder(type_1003c);
  ::Reflex::Type type_1803 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("RPId"), type_296);
  ::Reflex::Type type_1929c = ::Reflex::ConstBuilder(type_1929);
  ::Reflex::Type type_19330 = ::Reflex::ReferenceBuilder(type_1929c);
  ::Reflex::Type type_2975c = ::Reflex::ConstBuilder(type_2975);
  ::Reflex::Type type_19331 = ::Reflex::ReferenceBuilder(type_2975c);
  ::Reflex::Type type_97c = ::Reflex::ConstBuilder(type_97);
  ::Reflex::Type type_12684 = ::Reflex::PointerBuilder(type_97c);
  ::Reflex::Type type_3816 = ::Reflex::PointerBuilder(type_97);
  ::Reflex::Type type_2855c = ::Reflex::ConstBuilder(type_2855);
  ::Reflex::Type type_19332 = ::Reflex::ReferenceBuilder(type_2855c);
  ::Reflex::Type type_19333 = ::Reflex::ReferenceBuilder(type_2855);
  ::Reflex::Type type_19381 = ::Reflex::ReferenceBuilder(type_1181);
  ::Reflex::Type type_1181c = ::Reflex::ConstBuilder(type_1181);
  ::Reflex::Type type_19382 = ::Reflex::ReferenceBuilder(type_1181c);
  ::Reflex::Type type_19408 = ::Reflex::ArrayBuilder(type_97, 5);
  ::Reflex::Type type_19312 = ::Reflex::ArrayBuilder(type_97, 25);
  ::Reflex::Type type_19409 = ::Reflex::ArrayBuilder(type_1482, 5);
  ::Reflex::Type type_12170 = ::Reflex::ReferenceBuilder(type_1565);
  ::Reflex::Type type_1565c = ::Reflex::ConstBuilder(type_1565);
  ::Reflex::Type type_5607 = ::Reflex::ReferenceBuilder(type_1565c);
  ::Reflex::Type type_19414 = ::Reflex::ReferenceBuilder(type_1597);
  ::Reflex::Type type_1597c = ::Reflex::ConstBuilder(type_1597);
  ::Reflex::Type type_19415 = ::Reflex::ReferenceBuilder(type_1597c);
  ::Reflex::Type type_12429 = ::Reflex::ReferenceBuilder(type_1658);
  ::Reflex::Type type_1658c = ::Reflex::ConstBuilder(type_1658);
  ::Reflex::Type type_12431 = ::Reflex::ReferenceBuilder(type_1658c);
  ::Reflex::Type type_2853c = ::Reflex::ConstBuilder(type_2853);
  ::Reflex::Type type_19530 = ::Reflex::ReferenceBuilder(type_2853c);
  ::Reflex::Type type_2874c = ::Reflex::ConstBuilder(type_2874);
  ::Reflex::Type type_19531 = ::Reflex::ReferenceBuilder(type_2874c);
  ::Reflex::Type type_2447c = ::Reflex::ConstBuilder(type_2447);
  ::Reflex::Type type_19532 = ::Reflex::ReferenceBuilder(type_2447c);
  ::Reflex::Type type_1166 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("UInt_t"), type_296);
  ::Reflex::Type type_1672c = ::Reflex::ConstBuilder(type_1672);
  ::Reflex::Type type_19533 = ::Reflex::ReferenceBuilder(type_1672c);
  ::Reflex::Type type_19378 = ::Reflex::ReferenceBuilder(type_1672);
  ::Reflex::Type type_1326c = ::Reflex::ConstBuilder(type_1326);
  ::Reflex::Type type_1789 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Option_t"), type_1326c);
  ::Reflex::Type type_16705 = ::Reflex::PointerBuilder(type_1789);
  ::Reflex::Type type_19249 = ::Reflex::PointerBuilder(type_638);
  ::Reflex::Type type_3338 = ::Reflex::PointerBuilder(type_1326c);
  ::Reflex::Type type_11323 = ::Reflex::PointerBuilder(type_1672);
  ::Reflex::Type type_353 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_65);
  ::Reflex::Type type_5611 = ::Reflex::PointerBuilder(type_1672c);
  ::Reflex::Type type_16711 = ::Reflex::PointerBuilder(type_353);
  ::Reflex::Type type_19534 = ::Reflex::PointerBuilder(type_1681);
  ::Reflex::Type type_16816 = ::Reflex::PointerBuilder(type_997);
  ::Reflex::Type type_1227 = ::Reflex::PointerBuilder(type_1326);
  ::Reflex::Type type_1483 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Bool_t"), type_1482);
  ::Reflex::Type type_19535 = ::Reflex::PointerBuilder(type_197);
  ::Reflex::Type type_2318 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("ULong_t"), type_288);
  ::Reflex::Type type_1987c = ::Reflex::ConstBuilder(type_1987);
  ::Reflex::Type type_19142 = ::Reflex::PointerBuilder(type_1987c);
  ::Reflex::Type type_2296 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ostream"), type_2295);
  ::Reflex::Type type_5604 = ::Reflex::ReferenceBuilder(type_2296);
  ::Reflex::Type type_594 = ::Reflex::PointerBuilder(type_613);
  ::Reflex::Type type_1975 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_288);
  ::Reflex::Type type_979 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Long_t"), type_9);
  ::Reflex::Type type_16702 = ::Reflex::PointerBuilder(type_1987);
  ::Reflex::Type type_2224 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_401);
  ::Reflex::Type type_16723 = ::Reflex::ReferenceBuilder(type_387);
  ::Reflex::Type type_5609 = ::Reflex::ReferenceBuilder(type_2316);
  ::Reflex::Type type_19543 = ::Reflex::ReferenceBuilder(type_1741);
  ::Reflex::Type type_1741c = ::Reflex::ConstBuilder(type_1741);
  ::Reflex::Type type_5608 = ::Reflex::ReferenceBuilder(type_1741c);
  ::Reflex::Type type_21916 = ::Reflex::ReferenceBuilder(type_1929);
  ::Reflex::Type type_11846 = ::Reflex::ReferenceBuilder(type_1969);
  ::Reflex::Type type_1969c = ::Reflex::ConstBuilder(type_1969);
  ::Reflex::Type type_11848 = ::Reflex::ReferenceBuilder(type_1969c);
  ::Reflex::Type type_941 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Double_t"), type_97);
  ::Reflex::Type type_941c = ::Reflex::ConstBuilder(type_941);
  ::Reflex::Type type_16725 = ::Reflex::PointerBuilder(type_941c);
  ::Reflex::Type type_961 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Float_t"), type_797);
  ::Reflex::Type type_961c = ::Reflex::ConstBuilder(type_961);
  ::Reflex::Type type_21948 = ::Reflex::PointerBuilder(type_961c);
  ::Reflex::Type type_5622 = ::Reflex::ReferenceBuilder(type_941);
  ::Reflex::Type type_16715 = ::Reflex::PointerBuilder(type_941);
  ::Reflex::Type type_16724 = ::Reflex::PointerBuilder(type_961);
  ::Reflex::Type type_21949 = ::Reflex::ReferenceBuilder(type_2017);
  ::Reflex::Type type_2005c = ::Reflex::ConstBuilder(type_2005);
  ::Reflex::Type type_21950 = ::Reflex::ReferenceBuilder(type_2005c);
  ::Reflex::Type type_23119 = ::Reflex::ReferenceBuilder(type_2052);
  ::Reflex::Type type_2052c = ::Reflex::ConstBuilder(type_2052);
  ::Reflex::Type type_5605 = ::Reflex::ReferenceBuilder(type_2052c);
  ::Reflex::Type type_23120 = ::Reflex::ReferenceBuilder(type_2062);
  ::Reflex::Type type_2062c = ::Reflex::ConstBuilder(type_2062);
  ::Reflex::Type type_23121 = ::Reflex::ReferenceBuilder(type_2062c);
  ::Reflex::Type type_23135 = ::Reflex::ReferenceBuilder(type_2172);
  ::Reflex::Type type_2172c = ::Reflex::ConstBuilder(type_2172);
  ::Reflex::Type type_23136 = ::Reflex::ReferenceBuilder(type_2172c);
  ::Reflex::Type type_23340 = ::Reflex::ReferenceBuilder(type_2293);
  ::Reflex::Type type_2293c = ::Reflex::ConstBuilder(type_2293);
  ::Reflex::Type type_23341 = ::Reflex::ReferenceBuilder(type_2293c);
  ::Reflex::Type type_23995 = ::Reflex::ReferenceBuilder(type_2510);
  ::Reflex::Type type_2510c = ::Reflex::ConstBuilder(type_2510);
  ::Reflex::Type type_23996 = ::Reflex::ReferenceBuilder(type_2510c);
  ::Reflex::Type type_296c = ::Reflex::ConstBuilder(type_296);
  ::Reflex::Type type_23997 = ::Reflex::ReferenceBuilder(type_296c);
  ::Reflex::Type type_24301 = ::Reflex::ReferenceBuilder(type_2774);
  ::Reflex::Type type_2774c = ::Reflex::ConstBuilder(type_2774);
  ::Reflex::Type type_24302 = ::Reflex::ReferenceBuilder(type_2774c);
  ::Reflex::Type type_8066 = ::Reflex::PointerBuilder(type_1969);
  ::Reflex::Type type_11844 = ::Reflex::PointerBuilder(type_1969c);
  ::Reflex::Type type_3037 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_288);
  ::Reflex::Type type_2946 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_9);
  ::Reflex::Type type_3052c = ::Reflex::ConstBuilder(type_3052);
  ::Reflex::Type type_23407 = ::Reflex::ReferenceBuilder(type_3052c);
  ::Reflex::Type type_2842c = ::Reflex::ConstBuilder(type_2842);
  ::Reflex::Type type_24328 = ::Reflex::ReferenceBuilder(type_2842c);
  ::Reflex::Type type_24329 = ::Reflex::ReferenceBuilder(type_2842);
  ::Reflex::Type type_11911 = ::Reflex::ReferenceBuilder(type_7382);
  ::Reflex::Type type_7382c = ::Reflex::ConstBuilder(type_7382);
  ::Reflex::Type type_11913 = ::Reflex::ReferenceBuilder(type_7382c);
  ::Reflex::Type type_8180 = ::Reflex::PointerBuilder(type_7382);
  ::Reflex::Type type_11909 = ::Reflex::PointerBuilder(type_7382c);
  ::Reflex::Type type_3055c = ::Reflex::ConstBuilder(type_3055);
  ::Reflex::Type type_23485 = ::Reflex::ReferenceBuilder(type_3055c);
  ::Reflex::Type type_2843c = ::Reflex::ConstBuilder(type_2843);
  ::Reflex::Type type_24331 = ::Reflex::ReferenceBuilder(type_2843c);
  ::Reflex::Type type_24332 = ::Reflex::ReferenceBuilder(type_2843);
  ::Reflex::Type type_11976 = ::Reflex::ReferenceBuilder(type_7344);
  ::Reflex::Type type_7344c = ::Reflex::ConstBuilder(type_7344);
  ::Reflex::Type type_11978 = ::Reflex::ReferenceBuilder(type_7344c);
  ::Reflex::Type type_8085 = ::Reflex::PointerBuilder(type_7344);
  ::Reflex::Type type_11974 = ::Reflex::PointerBuilder(type_7344c);
  ::Reflex::Type type_3056c = ::Reflex::ConstBuilder(type_3056);
  ::Reflex::Type type_23420 = ::Reflex::ReferenceBuilder(type_3056c);
  ::Reflex::Type type_2844c = ::Reflex::ConstBuilder(type_2844);
  ::Reflex::Type type_24334 = ::Reflex::ReferenceBuilder(type_2844c);
  ::Reflex::Type type_24335 = ::Reflex::ReferenceBuilder(type_2844);
  ::Reflex::Type type_12041 = ::Reflex::ReferenceBuilder(type_7343);
  ::Reflex::Type type_7343c = ::Reflex::ConstBuilder(type_7343);
  ::Reflex::Type type_12043 = ::Reflex::ReferenceBuilder(type_7343c);
  ::Reflex::Type type_8199 = ::Reflex::PointerBuilder(type_7343);
  ::Reflex::Type type_12039 = ::Reflex::PointerBuilder(type_7343c);
  ::Reflex::Type type_3057c = ::Reflex::ConstBuilder(type_3057);
  ::Reflex::Type type_23498 = ::Reflex::ReferenceBuilder(type_3057c);
  ::Reflex::Type type_2845c = ::Reflex::ConstBuilder(type_2845);
  ::Reflex::Type type_24337 = ::Reflex::ReferenceBuilder(type_2845c);
  ::Reflex::Type type_24338 = ::Reflex::ReferenceBuilder(type_2845);
  ::Reflex::Type type_8236 = ::Reflex::PointerBuilder(type_1003);
  ::Reflex::Type type_12104 = ::Reflex::PointerBuilder(type_1003c);
  ::Reflex::Type type_3058c = ::Reflex::ConstBuilder(type_3058);
  ::Reflex::Type type_23524 = ::Reflex::ReferenceBuilder(type_3058c);
  ::Reflex::Type type_2846c = ::Reflex::ConstBuilder(type_2846);
  ::Reflex::Type type_24339 = ::Reflex::ReferenceBuilder(type_2846c);
  ::Reflex::Type type_24340 = ::Reflex::ReferenceBuilder(type_2846);
  ::Reflex::Type type_8273 = ::Reflex::PointerBuilder(type_1565);
  ::Reflex::Type type_12168 = ::Reflex::PointerBuilder(type_1565c);
  ::Reflex::Type type_3060c = ::Reflex::ConstBuilder(type_3060);
  ::Reflex::Type type_23550 = ::Reflex::ReferenceBuilder(type_3060c);
  ::Reflex::Type type_2847c = ::Reflex::ConstBuilder(type_2847);
  ::Reflex::Type type_24341 = ::Reflex::ReferenceBuilder(type_2847c);
  ::Reflex::Type type_24342 = ::Reflex::ReferenceBuilder(type_2847);
  ::Reflex::Type type_8292 = ::Reflex::PointerBuilder(type_221);
  ::Reflex::Type type_12232 = ::Reflex::PointerBuilder(type_221c);
  ::Reflex::Type type_3061c = ::Reflex::ConstBuilder(type_3061);
  ::Reflex::Type type_23563 = ::Reflex::ReferenceBuilder(type_3061c);
  ::Reflex::Type type_2848c = ::Reflex::ConstBuilder(type_2848);
  ::Reflex::Type type_24344 = ::Reflex::ReferenceBuilder(type_2848c);
  ::Reflex::Type type_24345 = ::Reflex::ReferenceBuilder(type_2848);
  ::Reflex::Type type_8104 = ::Reflex::PointerBuilder(type_156);
  ::Reflex::Type type_12297 = ::Reflex::PointerBuilder(type_156c);
  ::Reflex::Type type_3063c = ::Reflex::ConstBuilder(type_3063);
  ::Reflex::Type type_23433 = ::Reflex::ReferenceBuilder(type_3063c);
  ::Reflex::Type type_2849c = ::Reflex::ConstBuilder(type_2849);
  ::Reflex::Type type_12496 = ::Reflex::ReferenceBuilder(type_2849c);
  ::Reflex::Type type_12494 = ::Reflex::ReferenceBuilder(type_2849);
  ::Reflex::Type type_8161 = ::Reflex::PointerBuilder(type_1658);
  ::Reflex::Type type_12427 = ::Reflex::PointerBuilder(type_1658c);
  ::Reflex::Type type_3067c = ::Reflex::ConstBuilder(type_3067);
  ::Reflex::Type type_23472 = ::Reflex::ReferenceBuilder(type_3067c);
  ::Reflex::Type type_2851c = ::Reflex::ConstBuilder(type_2851);
  ::Reflex::Type type_12366 = ::Reflex::ReferenceBuilder(type_2851c);
  ::Reflex::Type type_12364 = ::Reflex::ReferenceBuilder(type_2851);
  ::Reflex::Type type_8123 = ::Reflex::PointerBuilder(type_2851);
  ::Reflex::Type type_12362 = ::Reflex::PointerBuilder(type_2851c);
  ::Reflex::Type type_3066c = ::Reflex::ConstBuilder(type_3066);
  ::Reflex::Type type_23446 = ::Reflex::ReferenceBuilder(type_3066c);
  ::Reflex::Type type_2850c = ::Reflex::ConstBuilder(type_2850);
  ::Reflex::Type type_24348 = ::Reflex::ReferenceBuilder(type_2850c);
  ::Reflex::Type type_24349 = ::Reflex::ReferenceBuilder(type_2850);
  ::Reflex::Type type_8142 = ::Reflex::PointerBuilder(type_2849);
  ::Reflex::Type type_12492 = ::Reflex::PointerBuilder(type_2849c);
  ::Reflex::Type type_3069c = ::Reflex::ConstBuilder(type_3069);
  ::Reflex::Type type_23459 = ::Reflex::ReferenceBuilder(type_3069c);
  ::Reflex::Type type_2852c = ::Reflex::ConstBuilder(type_2852);
  ::Reflex::Type type_24352 = ::Reflex::ReferenceBuilder(type_2852c);
  ::Reflex::Type type_24353 = ::Reflex::ReferenceBuilder(type_2852);
  ::Reflex::Type type_9662 = ::Reflex::PointerBuilder(type_2771);
  ::Reflex::Type type_2771c = ::Reflex::ConstBuilder(type_2771);
  ::Reflex::Type type_9664 = ::Reflex::PointerBuilder(type_2771c);
  ::Reflex::Type type_9666 = ::Reflex::ReferenceBuilder(type_2771);
  ::Reflex::Type type_9668 = ::Reflex::ReferenceBuilder(type_2771c);
  ::Reflex::Type type_3051c = ::Reflex::ConstBuilder(type_3051);
  ::Reflex::Type type_24074 = ::Reflex::ReferenceBuilder(type_3051c);
  ::Reflex::Type type_2973c = ::Reflex::ConstBuilder(type_2973);
  ::Reflex::Type type_24481 = ::Reflex::ReferenceBuilder(type_2973c);
  ::Reflex::Type type_24482 = ::Reflex::ReferenceBuilder(type_2973);
  ::Reflex::Type type_9771 = ::Reflex::PointerBuilder(type_2773);
  ::Reflex::Type type_2773c = ::Reflex::ConstBuilder(type_2773);
  ::Reflex::Type type_9773 = ::Reflex::PointerBuilder(type_2773c);
  ::Reflex::Type type_9775 = ::Reflex::ReferenceBuilder(type_2773);
  ::Reflex::Type type_9777 = ::Reflex::ReferenceBuilder(type_2773c);
  ::Reflex::Type type_3054c = ::Reflex::ConstBuilder(type_3054);
  ::Reflex::Type type_24082 = ::Reflex::ReferenceBuilder(type_3054c);
  ::Reflex::Type type_2974c = ::Reflex::ConstBuilder(type_2974);
  ::Reflex::Type type_24483 = ::Reflex::ReferenceBuilder(type_2974c);
  ::Reflex::Type type_24484 = ::Reflex::ReferenceBuilder(type_2974);
  ::Reflex::Type type_24502 = ::Reflex::ReferenceBuilder(type_2990);
  ::Reflex::Type type_2990c = ::Reflex::ConstBuilder(type_2990);
  ::Reflex::Type type_24503 = ::Reflex::ReferenceBuilder(type_2990c);
  ::Reflex::Type type_10207 = ::Reflex::PointerBuilder(type_2772);
  ::Reflex::Type type_2772c = ::Reflex::ConstBuilder(type_2772);
  ::Reflex::Type type_10209 = ::Reflex::PointerBuilder(type_2772c);
  ::Reflex::Type type_10211 = ::Reflex::ReferenceBuilder(type_2772);
  ::Reflex::Type type_10213 = ::Reflex::ReferenceBuilder(type_2772c);
  ::Reflex::Type type_24532 = ::Reflex::ReferenceBuilder(type_3053);
  ::Reflex::Type type_3053c = ::Reflex::ConstBuilder(type_3053);
  ::Reflex::Type type_24110 = ::Reflex::ReferenceBuilder(type_3053c);
  ::Reflex::Type type_10643 = ::Reflex::PointerBuilder(type_2779);
  ::Reflex::Type type_2779c = ::Reflex::ConstBuilder(type_2779);
  ::Reflex::Type type_10645 = ::Reflex::PointerBuilder(type_2779c);
  ::Reflex::Type type_10647 = ::Reflex::ReferenceBuilder(type_2779);
  ::Reflex::Type type_10649 = ::Reflex::ReferenceBuilder(type_2779c);
  ::Reflex::Type type_24536 = ::Reflex::ReferenceBuilder(type_3064);
  ::Reflex::Type type_3064c = ::Reflex::ConstBuilder(type_3064);
  ::Reflex::Type type_24138 = ::Reflex::ReferenceBuilder(type_3064c);
  ::Reflex::Type type_26429 = ::Reflex::PointerBuilder(type_252c);
  ::Reflex::Type type_416c = ::Reflex::ConstBuilder(type_416);
  ::Reflex::Type type_16791 = ::Reflex::ReferenceBuilder(type_416c);
  ::Reflex::Type type_26430 = ::Reflex::PointerBuilder(type_252);
  ::Reflex::Type type_4261c = ::Reflex::ConstBuilder(type_4261);
  ::Reflex::Type type_26431 = ::Reflex::PointerBuilder(type_4261c);
  ::Reflex::Type type_4352c = ::Reflex::ConstBuilder(type_4352);
  ::Reflex::Type type_18758 = ::Reflex::ReferenceBuilder(type_4352c);
  ::Reflex::Type type_24324 = ::Reflex::ReferenceBuilder(type_2840);
  ::Reflex::Type type_26311 = ::Reflex::ReferenceBuilder(type_4093);
  ::Reflex::Type type_613c = ::Reflex::ConstBuilder(type_613);
  ::Reflex::Type type_3708 = ::Reflex::PointerBuilder(type_613c);
  ::Reflex::Type type_9051 = ::Reflex::ReferenceBuilder(type_3708);
  ::Reflex::Type type_2841c = ::Reflex::ConstBuilder(type_2841);
  ::Reflex::Type type_24325 = ::Reflex::ReferenceBuilder(type_2841c);
  ::Reflex::Type type_26434 = ::Reflex::PointerBuilder(type_2062c);
  ::Reflex::Type type_26435 = ::Reflex::PointerBuilder(type_2062);
  ::Reflex::Type type_4262c = ::Reflex::ConstBuilder(type_4262);
  ::Reflex::Type type_26436 = ::Reflex::PointerBuilder(type_4262c);
  ::Reflex::Type type_26439 = ::Reflex::PointerBuilder(type_2172c);
  ::Reflex::Type type_26440 = ::Reflex::PointerBuilder(type_2172);
  ::Reflex::Type type_4263c = ::Reflex::ConstBuilder(type_4263);
  ::Reflex::Type type_26441 = ::Reflex::PointerBuilder(type_4263c);
  ::Reflex::Type type_26444 = ::Reflex::PointerBuilder(type_2052c);
  ::Reflex::Type type_26445 = ::Reflex::PointerBuilder(type_2052);
  ::Reflex::Type type_4264c = ::Reflex::ConstBuilder(type_4264);
  ::Reflex::Type type_26446 = ::Reflex::PointerBuilder(type_4264c);
  ::Reflex::Type type_26449 = ::Reflex::PointerBuilder(type_925c);
  ::Reflex::Type type_26450 = ::Reflex::PointerBuilder(type_925);
  ::Reflex::Type type_4265c = ::Reflex::ConstBuilder(type_4265);
  ::Reflex::Type type_26451 = ::Reflex::PointerBuilder(type_4265c);
  ::Reflex::Type type_4266c = ::Reflex::ConstBuilder(type_4266);
  ::Reflex::Type type_26454 = ::Reflex::PointerBuilder(type_4266c);
  ::Reflex::Type type_26462 = ::Reflex::PointerBuilder(type_1929c);
  ::Reflex::Type type_26463 = ::Reflex::PointerBuilder(type_1929);
  ::Reflex::Type type_4268c = ::Reflex::ConstBuilder(type_4268);
  ::Reflex::Type type_26464 = ::Reflex::PointerBuilder(type_4268c);
  ::Reflex::Type type_26467 = ::Reflex::PointerBuilder(type_1741c);
  ::Reflex::Type type_26468 = ::Reflex::PointerBuilder(type_1741);
  ::Reflex::Type type_4269c = ::Reflex::ConstBuilder(type_4269);
  ::Reflex::Type type_26469 = ::Reflex::PointerBuilder(type_4269c);
  ::Reflex::Type type_26472 = ::Reflex::PointerBuilder(type_2293c);
  ::Reflex::Type type_26473 = ::Reflex::PointerBuilder(type_2293);
  ::Reflex::Type type_4270c = ::Reflex::ConstBuilder(type_4270);
  ::Reflex::Type type_26474 = ::Reflex::PointerBuilder(type_4270c);
  ::Reflex::Type type_4271c = ::Reflex::ConstBuilder(type_4271);
  ::Reflex::Type type_26477 = ::Reflex::PointerBuilder(type_4271c);
  ::Reflex::Type type_4272c = ::Reflex::ConstBuilder(type_4272);
  ::Reflex::Type type_26480 = ::Reflex::PointerBuilder(type_4272c);
  ::Reflex::Type type_26483 = ::Reflex::PointerBuilder(type_2848c);
  ::Reflex::Type type_26484 = ::Reflex::PointerBuilder(type_2848);
  ::Reflex::Type type_4273c = ::Reflex::ConstBuilder(type_4273);
  ::Reflex::Type type_26485 = ::Reflex::PointerBuilder(type_4273c);
  ::Reflex::Type type_26488 = ::Reflex::PointerBuilder(type_2017c);
  ::Reflex::Type type_26489 = ::Reflex::PointerBuilder(type_2017);
  ::Reflex::Type type_4274c = ::Reflex::ConstBuilder(type_4274);
  ::Reflex::Type type_26490 = ::Reflex::PointerBuilder(type_4274c);
  ::Reflex::Type type_4275c = ::Reflex::ConstBuilder(type_4275);
  ::Reflex::Type type_26493 = ::Reflex::PointerBuilder(type_4275c);
  ::Reflex::Type type_26506 = ::Reflex::PointerBuilder(type_225c);
  ::Reflex::Type type_26507 = ::Reflex::PointerBuilder(type_225);
  ::Reflex::Type type_4278c = ::Reflex::ConstBuilder(type_4278);
  ::Reflex::Type type_26508 = ::Reflex::PointerBuilder(type_4278c);
  ::Reflex::Type type_26511 = ::Reflex::PointerBuilder(type_215c);
  ::Reflex::Type type_26512 = ::Reflex::PointerBuilder(type_215);
  ::Reflex::Type type_4279c = ::Reflex::ConstBuilder(type_4279);
  ::Reflex::Type type_26513 = ::Reflex::PointerBuilder(type_4279c);
  ::Reflex::Type type_4280c = ::Reflex::ConstBuilder(type_4280);
  ::Reflex::Type type_26516 = ::Reflex::PointerBuilder(type_4280c);
  ::Reflex::Type type_26519 = ::Reflex::PointerBuilder(type_586c);
  ::Reflex::Type type_26520 = ::Reflex::PointerBuilder(type_586);
  ::Reflex::Type type_4281c = ::Reflex::ConstBuilder(type_4281);
  ::Reflex::Type type_26521 = ::Reflex::PointerBuilder(type_4281c);
  ::Reflex::Type type_26529 = ::Reflex::PointerBuilder(type_2850c);
  ::Reflex::Type type_26530 = ::Reflex::PointerBuilder(type_2850);
  ::Reflex::Type type_4283c = ::Reflex::ConstBuilder(type_4283);
  ::Reflex::Type type_26531 = ::Reflex::PointerBuilder(type_4283c);
  ::Reflex::Type type_1944c = ::Reflex::ConstBuilder(type_1944);
  ::Reflex::Type type_26534 = ::Reflex::PointerBuilder(type_1944c);
  ::Reflex::Type type_26535 = ::Reflex::PointerBuilder(type_1944);
  ::Reflex::Type type_4284c = ::Reflex::ConstBuilder(type_4284);
  ::Reflex::Type type_26536 = ::Reflex::PointerBuilder(type_4284c);
  ::Reflex::Type type_26544 = ::Reflex::PointerBuilder(type_2852c);
  ::Reflex::Type type_26545 = ::Reflex::PointerBuilder(type_2852);
  ::Reflex::Type type_4286c = ::Reflex::ConstBuilder(type_4286);
  ::Reflex::Type type_26546 = ::Reflex::PointerBuilder(type_4286c);
  ::Reflex::Type type_26549 = ::Reflex::PointerBuilder(type_157c);
  ::Reflex::Type type_26550 = ::Reflex::PointerBuilder(type_157);
  ::Reflex::Type type_4287c = ::Reflex::ConstBuilder(type_4287);
  ::Reflex::Type type_26551 = ::Reflex::PointerBuilder(type_4287c);
  ::Reflex::Type type_26554 = ::Reflex::PointerBuilder(type_370c);
  ::Reflex::Type type_26555 = ::Reflex::PointerBuilder(type_370);
  ::Reflex::Type type_4288c = ::Reflex::ConstBuilder(type_4288);
  ::Reflex::Type type_26556 = ::Reflex::PointerBuilder(type_4288c);
  ::Reflex::Type type_26559 = ::Reflex::PointerBuilder(type_1597c);
  ::Reflex::Type type_26560 = ::Reflex::PointerBuilder(type_1597);
  ::Reflex::Type type_4289c = ::Reflex::ConstBuilder(type_4289);
  ::Reflex::Type type_26561 = ::Reflex::PointerBuilder(type_4289c);
  ::Reflex::Type type_26564 = ::Reflex::PointerBuilder(type_1181c);
  ::Reflex::Type type_26565 = ::Reflex::PointerBuilder(type_1181);
  ::Reflex::Type type_4290c = ::Reflex::ConstBuilder(type_4290);
  ::Reflex::Type type_26566 = ::Reflex::PointerBuilder(type_4290c);
  ::Reflex::Type type_24303 = ::Reflex::ReferenceBuilder(type_2777);
  ::Reflex::Type type_2777c = ::Reflex::ConstBuilder(type_2777);
  ::Reflex::Type type_24304 = ::Reflex::ReferenceBuilder(type_2777c);
  ::Reflex::Type type_24305 = ::Reflex::ReferenceBuilder(type_2778);
  ::Reflex::Type type_2778c = ::Reflex::ConstBuilder(type_2778);
  ::Reflex::Type type_24306 = ::Reflex::ReferenceBuilder(type_2778c);
  ::Reflex::Type type_24307 = ::Reflex::ReferenceBuilder(type_2783);
  ::Reflex::Type type_2783c = ::Reflex::ConstBuilder(type_2783);
  ::Reflex::Type type_24308 = ::Reflex::ReferenceBuilder(type_2783c);
  ::Reflex::Type type_24309 = ::Reflex::ReferenceBuilder(type_2784);
  ::Reflex::Type type_2784c = ::Reflex::ConstBuilder(type_2784);
  ::Reflex::Type type_24310 = ::Reflex::ReferenceBuilder(type_2784c);
  ::Reflex::Type type_9880 = ::Reflex::PointerBuilder(type_2775);
  ::Reflex::Type type_2775c = ::Reflex::ConstBuilder(type_2775);
  ::Reflex::Type type_9882 = ::Reflex::PointerBuilder(type_2775c);
  ::Reflex::Type type_9884 = ::Reflex::ReferenceBuilder(type_2775);
  ::Reflex::Type type_9886 = ::Reflex::ReferenceBuilder(type_2775c);
  ::Reflex::Type type_3059c = ::Reflex::ConstBuilder(type_3059);
  ::Reflex::Type type_24089 = ::Reflex::ReferenceBuilder(type_3059c);
  ::Reflex::Type type_24485 = ::Reflex::ReferenceBuilder(type_2975);
  ::Reflex::Type type_10098 = ::Reflex::PointerBuilder(type_2776);
  ::Reflex::Type type_2776c = ::Reflex::ConstBuilder(type_2776);
  ::Reflex::Type type_10100 = ::Reflex::PointerBuilder(type_2776c);
  ::Reflex::Type type_10102 = ::Reflex::ReferenceBuilder(type_2776);
  ::Reflex::Type type_10104 = ::Reflex::ReferenceBuilder(type_2776c);
  ::Reflex::Type type_3062c = ::Reflex::ConstBuilder(type_3062);
  ::Reflex::Type type_24103 = ::Reflex::ReferenceBuilder(type_3062c);
  ::Reflex::Type type_2976c = ::Reflex::ConstBuilder(type_2976);
  ::Reflex::Type type_24486 = ::Reflex::ReferenceBuilder(type_2976c);
  ::Reflex::Type type_24487 = ::Reflex::ReferenceBuilder(type_2976);
  ::Reflex::Type type_2977c = ::Reflex::ConstBuilder(type_2977);
  ::Reflex::Type type_24488 = ::Reflex::ReferenceBuilder(type_2977c);
  ::Reflex::Type type_24489 = ::Reflex::ReferenceBuilder(type_2977);
  ::Reflex::Type type_10425 = ::Reflex::PointerBuilder(type_2780);
  ::Reflex::Type type_2780c = ::Reflex::ConstBuilder(type_2780);
  ::Reflex::Type type_10427 = ::Reflex::PointerBuilder(type_2780c);
  ::Reflex::Type type_10429 = ::Reflex::ReferenceBuilder(type_2780);
  ::Reflex::Type type_10431 = ::Reflex::ReferenceBuilder(type_2780c);
  ::Reflex::Type type_3065c = ::Reflex::ConstBuilder(type_3065);
  ::Reflex::Type type_24124 = ::Reflex::ReferenceBuilder(type_3065c);
  ::Reflex::Type type_2978c = ::Reflex::ConstBuilder(type_2978);
  ::Reflex::Type type_24490 = ::Reflex::ReferenceBuilder(type_2978c);
  ::Reflex::Type type_24491 = ::Reflex::ReferenceBuilder(type_2978);
  ::Reflex::Type type_9989 = ::Reflex::PointerBuilder(type_2781);
  ::Reflex::Type type_2781c = ::Reflex::ConstBuilder(type_2781);
  ::Reflex::Type type_9991 = ::Reflex::PointerBuilder(type_2781c);
  ::Reflex::Type type_9993 = ::Reflex::ReferenceBuilder(type_2781);
  ::Reflex::Type type_9995 = ::Reflex::ReferenceBuilder(type_2781c);
  ::Reflex::Type type_3068c = ::Reflex::ConstBuilder(type_3068);
  ::Reflex::Type type_24096 = ::Reflex::ReferenceBuilder(type_3068c);
  ::Reflex::Type type_2979c = ::Reflex::ConstBuilder(type_2979);
  ::Reflex::Type type_24492 = ::Reflex::ReferenceBuilder(type_2979c);
  ::Reflex::Type type_24493 = ::Reflex::ReferenceBuilder(type_2979);
  ::Reflex::Type type_10534 = ::Reflex::PointerBuilder(type_2782);
  ::Reflex::Type type_2782c = ::Reflex::ConstBuilder(type_2782);
  ::Reflex::Type type_10536 = ::Reflex::PointerBuilder(type_2782c);
  ::Reflex::Type type_10538 = ::Reflex::ReferenceBuilder(type_2782);
  ::Reflex::Type type_10540 = ::Reflex::ReferenceBuilder(type_2782c);
  ::Reflex::Type type_3070c = ::Reflex::ConstBuilder(type_3070);
  ::Reflex::Type type_24131 = ::Reflex::ReferenceBuilder(type_3070c);
  ::Reflex::Type type_2980c = ::Reflex::ConstBuilder(type_2980);
  ::Reflex::Type type_24494 = ::Reflex::ReferenceBuilder(type_2980c);
  ::Reflex::Type type_24495 = ::Reflex::ReferenceBuilder(type_2980);
  ::Reflex::Type type_2981c = ::Reflex::ConstBuilder(type_2981);
  ::Reflex::Type type_24496 = ::Reflex::ReferenceBuilder(type_2981c);
  ::Reflex::Type type_24497 = ::Reflex::ReferenceBuilder(type_2981);
  ::Reflex::Type type_10316 = ::Reflex::PointerBuilder(type_2807);
  ::Reflex::Type type_2807c = ::Reflex::ConstBuilder(type_2807);
  ::Reflex::Type type_10318 = ::Reflex::PointerBuilder(type_2807c);
  ::Reflex::Type type_10320 = ::Reflex::ReferenceBuilder(type_2807);
  ::Reflex::Type type_10322 = ::Reflex::ReferenceBuilder(type_2807c);
  ::Reflex::Type type_3103c = ::Reflex::ConstBuilder(type_3103);
  ::Reflex::Type type_24117 = ::Reflex::ReferenceBuilder(type_3103c);
  ::Reflex::Type type_2984c = ::Reflex::ConstBuilder(type_2984);
  ::Reflex::Type type_24498 = ::Reflex::ReferenceBuilder(type_2984c);
  ::Reflex::Type type_24499 = ::Reflex::ReferenceBuilder(type_2984);
  ::Reflex::Type type_24500 = ::Reflex::ReferenceBuilder(type_2873);
  ::Reflex::Type type_2873c = ::Reflex::ConstBuilder(type_2873);
  ::Reflex::Type type_24501 = ::Reflex::ReferenceBuilder(type_2873c);
  ::Reflex::Type type_26457 = ::Reflex::PointerBuilder(type_2975c);
  ::Reflex::Type type_26458 = ::Reflex::PointerBuilder(type_2975);
  ::Reflex::Type type_4267c = ::Reflex::ConstBuilder(type_4267);
  ::Reflex::Type type_26459 = ::Reflex::PointerBuilder(type_4267c);
  ::Reflex::Type type_26496 = ::Reflex::PointerBuilder(type_2976c);
  ::Reflex::Type type_26497 = ::Reflex::PointerBuilder(type_2976);
  ::Reflex::Type type_4276c = ::Reflex::ConstBuilder(type_4276);
  ::Reflex::Type type_26498 = ::Reflex::PointerBuilder(type_4276c);
  ::Reflex::Type type_26501 = ::Reflex::PointerBuilder(type_2977c);
  ::Reflex::Type type_26502 = ::Reflex::PointerBuilder(type_2977);
  ::Reflex::Type type_4277c = ::Reflex::ConstBuilder(type_4277);
  ::Reflex::Type type_26503 = ::Reflex::PointerBuilder(type_4277c);
  ::Reflex::Type type_26524 = ::Reflex::PointerBuilder(type_2978c);
  ::Reflex::Type type_26525 = ::Reflex::PointerBuilder(type_2978);
  ::Reflex::Type type_4282c = ::Reflex::ConstBuilder(type_4282);
  ::Reflex::Type type_26526 = ::Reflex::PointerBuilder(type_4282c);
  ::Reflex::Type type_26539 = ::Reflex::PointerBuilder(type_2979c);
  ::Reflex::Type type_26540 = ::Reflex::PointerBuilder(type_2979);
  ::Reflex::Type type_4285c = ::Reflex::ConstBuilder(type_4285);
  ::Reflex::Type type_26541 = ::Reflex::PointerBuilder(type_4285c);
  ::Reflex::Type type_2777f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<RPId, std::vector<RPFittedTrack> >"), type_2777);
  ::Reflex::Type type_2778f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<RPId, RPFittedTrack>"), type_2778);
  ::Reflex::Type type_2783f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<RPId, std::vector<RPTrackCandidate> >"), type_2783);
  ::Reflex::Type type_2784f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::pair<RPId, RPTrackCandidate>"), type_2784);
  ::Reflex::Type type_2975f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<RPId, RP2DHitDebug>"), type_2975);
  ::Reflex::Type type_2976f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<RPId, std::vector<RPFittedTrack> >"), type_2976);
  ::Reflex::Type type_2977f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<RPId, RPFittedTrack>"), type_2977);
  ::Reflex::Type type_2978f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<RPId, std::vector<std::vector<RPTrackCandidate> > >"), type_2978);
  ::Reflex::Type type_2979f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<RPId, std::vector<std::vector<RPFittedTrack> > >"), type_2979);
  ::Reflex::Type type_2980f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<RPId, std::vector<RPTrackCandidate> >"), type_2980);
  ::Reflex::Type type_2981f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<RPId, RPTrackCandidate>"), type_2981);
  ::Reflex::Type type_2984f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<RPId, std::vector<RPTrackCandidateCollection> >"), type_2984);
  ::Reflex::Type type_4206f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<std::map<RPId, RP2DHitDebug> >"), type_4206);
  ::Reflex::Type type_4215f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<std::map<RPId, std::vector<RPFittedTrack> > >"), type_4215);
  ::Reflex::Type type_4216f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<std::map<RPId, RPFittedTrack> >"), type_4216);
  ::Reflex::Type type_4221f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<std::map<RPId, std::vector<std::vector<RPTrackCandidate> > > >"), type_4221);
  ::Reflex::Type type_4224f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<std::map<RPId, std::vector<std::vector<RPFittedTrack> > > >"), type_4224);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __RPFittedTrack
#undef __RPFittedTrack
#endif
class __RPFittedTrack {
  public:
  __RPFittedTrack();
  virtual ~__RPFittedTrack() throw();
  ::RPTrackCandidate sourceTrackCandidate;
  ::std::vector<RPDetHitPoint> track_hits_vector_;
  double track_params_vector_[4];
  double z0_;
  double par_covariance_matrix_[16];
  double chiSquared_;
  bool valid_;
  unsigned int u_id_;
  unsigned int v_id_;
  bool sourceTrackCandidateValid;
};
#ifdef __RPTrackCandidateDistinctCollectionsSet
#undef __RPTrackCandidateDistinctCollectionsSet
#endif
class __RPTrackCandidateDistinctCollectionsSet : public ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> > {
  public:
  __RPTrackCandidateDistinctCollectionsSet();
};
#ifdef __RPFittedTrackCollection
#undef __RPFittedTrackCollection
#endif
class __RPFittedTrackCollection : public ::std::map<unsigned int,RPFittedTrack> {
  public:
  __RPFittedTrackCollection();
};
#ifdef __RPDetHitPoint
#undef __RPDetHitPoint
#endif
class __RPDetHitPoint : public ::RPRecoHit {
  public:
  __RPDetHitPoint();
  virtual ~__RPDetHitPoint() throw();
  ::TVector3 space_point_on_det_;
  double residual_;
  double pull_;
};
#ifdef __RPMulFittedTrackCollection
#undef __RPMulFittedTrackCollection
#endif
class __RPMulFittedTrackCollection : public ::std::map<unsigned int,std::vector<RPFittedTrack> > {
  public:
  __RPMulFittedTrackCollection();
};
#ifdef __RPStationTrackFitCollection
#undef __RPStationTrackFitCollection
#endif
class __RPStationTrackFitCollection : public ::std::map<unsigned int,std::vector<RPStationTrackFit> > {
  public:
  __RPStationTrackFitCollection();
};
#ifdef __RPMulTrackCandidateCollection
#undef __RPMulTrackCandidateCollection
#endif
class __RPMulTrackCandidateCollection : public ::std::map<unsigned int,std::vector<RPTrackCandidate> > {
  public:
  __RPMulTrackCandidateCollection();
};
#ifdef __RPMulTrackCandidateSetsCollection
#undef __RPMulTrackCandidateSetsCollection
#endif
class __RPMulTrackCandidateSetsCollection : public ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > {
  public:
  __RPMulTrackCandidateSetsCollection();
};
#ifdef __RPReconstructedProtonPairCollection
#undef __RPReconstructedProtonPairCollection
#endif
class __RPReconstructedProtonPairCollection : public ::std::vector<RPReconstructedProtonPair> {
  public:
  __RPReconstructedProtonPairCollection();
};
#ifdef __RPReconstructedProtonPair
#undef __RPReconstructedProtonPair
#endif
class __RPReconstructedProtonPair {
  public:
  __RPReconstructedProtonPair();
  virtual ~__RPReconstructedProtonPair() throw();
  bool valid_;
  double variables_[9];
  double covariance_[81];
  double Chi_2_;
  double Chi_2_over_n_;
  int degrees_of_freedom_;
  ::std::map<unsigned int,RP2DHitDebug> debug_hits_;
};
#ifdef __CentralMassInfo
#undef __CentralMassInfo
#endif
struct __CentralMassInfo {
  public:
  __CentralMassInfo();
  double px;
  double py;
  double pz;
  double pt;
  double e;
  double m;
  double min_rap;
  double max_rap;
  double rap;
  bool empty;
};
#ifdef __RPReconstructedProton
#undef __RPReconstructedProton
#endif
class __RPReconstructedProton {
  public:
  __RPReconstructedProton();
  virtual ~__RPReconstructedProton() throw();
  bool valid_;
  double variables_[5];
  double z_direction_;
  double covariance_[25];
  bool fitted_[5];
  double Chi_2_;
  double Chi_2_over_n_;
  int degrees_of_freedom_;
  ::std::map<unsigned int,RP2DHitDebug> debug_hits_;
};
#ifdef __RPTrackCandidateCollection
#undef __RPTrackCandidateCollection
#endif
class __RPTrackCandidateCollection : public ::std::map<unsigned int,RPTrackCandidate> {
  public:
  __RPTrackCandidateCollection();
};
#ifdef __RPTrackCandidate
#undef __RPTrackCandidate
#endif
class __RPTrackCandidate {
  public:
  __RPTrackCandidate();
  virtual ~__RPTrackCandidate() throw();
  ::std::vector<RPRecoHit> rh_;
  bool fittable_;
  double weight_;
  unsigned int u_id_;
  unsigned int v_id_;
};
#ifdef __TObject
#undef __TObject
#endif
class __TObject {
  public:
  __TObject();
  virtual ~__TObject() throw();
  ::UInt_t fUniqueID;
  ::UInt_t fBits;
};
#ifdef __RP2DHit
#undef __RP2DHit
#endif
class __RP2DHit {
  public:
  __RP2DHit();
  double x_;
  double y_;
  double z_;
  double vx_;
  double vy_;
};
#ifdef __RP2DHitDebug
#undef __RP2DHitDebug
#endif
class __RP2DHitDebug : public ::RP2DHit {
  public:
  __RP2DHitDebug();
  double d_x_;
  double d_y_;
  double pull_x_;
  double pull_y_;
};
#ifdef __RPStationTrackFit
#undef __RPStationTrackFit
#endif
class __RPStationTrackFit {
  public:
  __RPStationTrackFit();
  double ax;
  double ay;
  double bx;
  double by;
  double z0;
  ::TMatrixD covarianceMatrix;
  double chiSq;
  double ndf;
  bool valid;
  ::std::vector<RPRecoHit> hits;
};
#ifdef __TVector3
#undef __TVector3
#endif
class __TVector3 : public ::TObject {
  public:
  __TVector3();
  virtual ~__TVector3() throw();
  ::Double_t fX;
  ::Double_t fY;
  ::Double_t fZ;
};
#ifdef __RPRecoElasticEvent
#undef __RPRecoElasticEvent
#endif
class __RPRecoElasticEvent {
  public:
  __RPRecoElasticEvent();
  virtual ~__RPRecoElasticEvent() throw();
  ::std::vector<RPRecoElasticEvent::road_type> roads;
  int preferredRoad;
  ::RPRecoElasticEvent::fit_type leftFit;
  ::RPRecoElasticEvent::fit_type rightFit;
  ::RPRecoElasticEvent::fit_type globalFit;
  ::RPRecoElasticEvent::fit_type result;
  ::RPRecoElasticEvent::status_type status;
  unsigned int rejectReason;
};
#ifdef __RPRecognizedPatternsCollection
#undef __RPRecognizedPatternsCollection
#endif
class __RPRecognizedPatternsCollection : public ::std::map<unsigned int,RPRecognizedPatterns> {
  public:
  __RPRecognizedPatternsCollection();
};
#ifdef __RPRecognizedPatterns
#undef __RPRecognizedPatterns
#endif
class __RPRecognizedPatterns {
  public:
  __RPRecognizedPatterns();
  ::RPRecognizedPatterns::SourceType source;
  ::std::vector<RPRecognizedPatterns::Line> uLines;
  ::std::vector<RPRecognizedPatterns::Line> vLines;
};
#ifdef __RPReconstructedProtonCollection
#undef __RPReconstructedProtonCollection
#endif
class __RPReconstructedProtonCollection : public ::std::vector<RPReconstructedProton> {
  public:
  __RPReconstructedProtonCollection();
};
#ifdef __std__less_unsignedsint_
#undef __std__less_unsignedsint_
#endif
struct __std__less_unsignedsint_ : public ::std::binary_function<unsigned int,unsigned int,bool> {
  public:
  __std__less_unsignedsint_();
};
#ifdef __std__pair_unsignedsint_RP2DHitDebug_
#undef __std__pair_unsignedsint_RP2DHitDebug_
#endif
struct __std__pair_unsignedsint_RP2DHitDebug_ {
  public:
  __std__pair_unsignedsint_RP2DHitDebug_();
  unsigned int first;
  ::RP2DHitDebug second;
};
#ifdef __std__vector_RPStationTrackFit_
#undef __std__vector_RPStationTrackFit_
#endif
class __std__vector_RPStationTrackFit_ : protected ::std::_Vector_base<RPStationTrackFit,std::allocator<RPStationTrackFit> > {
  public:
  __std__vector_RPStationTrackFit_();
};
#ifdef __RPRecognizedPatterns__Line
#undef __RPRecognizedPatterns__Line
#endif
struct __RPRecognizedPatterns__Line {
  public:
  __RPRecognizedPatterns__Line();
  double a;
  double b;
  double w;
  ::std::vector<RPRecoHit> hits;
};
#ifdef __std__vector_RPRecognizedPatterns__Line_
#undef __std__vector_RPRecognizedPatterns__Line_
#endif
class __std__vector_RPRecognizedPatterns__Line_ : protected ::std::_Vector_base<RPRecognizedPatterns::Line,std::allocator<RPRecognizedPatterns::Line> > {
  public:
  __std__vector_RPRecognizedPatterns__Line_();
};
#ifdef __RPRecoElasticEvent__fit_type
#undef __RPRecoElasticEvent__fit_type
#endif
struct __RPRecoElasticEvent__fit_type {
  public:
  __RPRecoElasticEvent__fit_type();
  double th_x;
  double th_y;
  double x;
  double y;
  double si_th_x;
  double si_th_y;
  double si_x;
  double si_y;
  double s2min_x;
  double s2min_y;
  short ndf_x;
  short ndf_y;
};
#ifdef __std__vector_RPRecoElasticEvent__fit_type_
#undef __std__vector_RPRecoElasticEvent__fit_type_
#endif
class __std__vector_RPRecoElasticEvent__fit_type_ : protected ::std::_Vector_base<RPRecoElasticEvent::fit_type,std::allocator<RPRecoElasticEvent::fit_type> > {
  public:
  __std__vector_RPRecoElasticEvent__fit_type_();
};
#ifdef __RPRecoElasticEvent__road_type
#undef __RPRecoElasticEvent__road_type
#endif
struct __RPRecoElasticEvent__road_type {
  public:
  __RPRecoElasticEvent__road_type();
  double sumx;
  double sumy;
  double minx;
  double maxx;
  double miny;
  double maxy;
  ::std::vector<unsigned short> members;
};
#ifdef __std__vector_RPRecoElasticEvent__road_type_
#undef __std__vector_RPRecoElasticEvent__road_type_
#endif
class __std__vector_RPRecoElasticEvent__road_type_ : protected ::std::_Vector_base<RPRecoElasticEvent::road_type,std::allocator<RPRecoElasticEvent::road_type> > {
  public:
  __std__vector_RPRecoElasticEvent__road_type_();
};
#ifdef __std__vector_RPReconstructedProtonPair_
#undef __std__vector_RPReconstructedProtonPair_
#endif
class __std__vector_RPReconstructedProtonPair_ : protected ::std::_Vector_base<RPReconstructedProtonPair,std::allocator<RPReconstructedProtonPair> > {
  public:
  __std__vector_RPReconstructedProtonPair_();
};
#ifdef __std__vector_RPReconstructedProton_
#undef __std__vector_RPReconstructedProton_
#endif
class __std__vector_RPReconstructedProton_ : protected ::std::_Vector_base<RPReconstructedProton,std::allocator<RPReconstructedProton> > {
  public:
  __std__vector_RPReconstructedProton_();
};
#ifdef __std__vector_RPDetHitPoint_
#undef __std__vector_RPDetHitPoint_
#endif
class __std__vector_RPDetHitPoint_ : protected ::std::_Vector_base<RPDetHitPoint,std::allocator<RPDetHitPoint> > {
  public:
  __std__vector_RPDetHitPoint_();
};
#ifdef __std__vector_RPFittedTrack_
#undef __std__vector_RPFittedTrack_
#endif
class __std__vector_RPFittedTrack_ : protected ::std::_Vector_base<RPFittedTrack,std::allocator<RPFittedTrack> > {
  public:
  __std__vector_RPFittedTrack_();
};
#ifdef __std__vector_RPTrackCandidate_
#undef __std__vector_RPTrackCandidate_
#endif
class __std__vector_RPTrackCandidate_ : protected ::std::_Vector_base<RPTrackCandidate,std::allocator<RPTrackCandidate> > {
  public:
  __std__vector_RPTrackCandidate_();
};
#ifdef __std__vector_std__vector_RPTrackCandidate_s_
#undef __std__vector_std__vector_RPTrackCandidate_s_
#endif
class __std__vector_std__vector_RPTrackCandidate_s_ : protected ::std::_Vector_base<std::vector<RPTrackCandidate>,std::allocator<std::vector<RPTrackCandidate> > > {
  public:
  __std__vector_std__vector_RPTrackCandidate_s_();
};
#ifdef __std__vector_std__vector_RPFittedTrack_s_
#undef __std__vector_std__vector_RPFittedTrack_s_
#endif
class __std__vector_std__vector_RPFittedTrack_s_ : protected ::std::_Vector_base<std::vector<RPFittedTrack>,std::allocator<std::vector<RPFittedTrack> > > {
  public:
  __std__vector_std__vector_RPFittedTrack_s_();
};
#ifdef __std__map_unsignedsint_std__vector_RPStationTrackFit_s_
#undef __std__map_unsignedsint_std__vector_RPStationTrackFit_s_
#endif
class __std__map_unsignedsint_std__vector_RPStationTrackFit_s_ {
  public:
  __std__map_unsignedsint_std__vector_RPStationTrackFit_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPStationTrackFit> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > > > _M_t;
};
#ifdef __std__map_unsignedsint_RPRecognizedPatterns_
#undef __std__map_unsignedsint_RPRecognizedPatterns_
#endif
class __std__map_unsignedsint_RPRecognizedPatterns_ {
  public:
  __std__map_unsignedsint_RPRecognizedPatterns_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRecognizedPatterns>,std::_Select1st<std::pair<const unsigned int,RPRecognizedPatterns> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRecognizedPatterns> > > _M_t;
};
#ifdef __std__binary_function_unsignedsint_unsignedsint_bool_
#undef __std__binary_function_unsignedsint_unsignedsint_bool_
#endif
struct __std__binary_function_unsignedsint_unsignedsint_bool_ {
  public:
  __std__binary_function_unsignedsint_unsignedsint_bool_();
};
#ifdef __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s_
#undef __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s_
#endif
class __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s_ : public ::__gnu_cxx::new_allocator<std::pair<const unsigned int,RPFittedTrack> > {
  public:
  __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s_();
};
#ifdef __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s_
#undef __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s_
#endif
class __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s_ : public ::__gnu_cxx::new_allocator<std::pair<const unsigned int,RPTrackCandidate> > {
  public:
  __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s_();
};
#ifdef __edm__Wrapper_RPStationTrackFitCollection_
#undef __edm__Wrapper_RPStationTrackFitCollection_
#endif
class __edm__Wrapper_RPStationTrackFitCollection_ {
  public:
  __edm__Wrapper_RPStationTrackFitCollection_();
  bool present;
  ::RPStationTrackFitCollection obj;
};
#ifdef __edm__Wrapper_RPRecognizedPatternsCollection_
#undef __edm__Wrapper_RPRecognizedPatternsCollection_
#endif
class __edm__Wrapper_RPRecognizedPatternsCollection_ {
  public:
  __edm__Wrapper_RPRecognizedPatternsCollection_();
  bool present;
  ::RPRecognizedPatternsCollection obj;
};
#ifdef __edm__Wrapper_RPRecognizedPatterns_
#undef __edm__Wrapper_RPRecognizedPatterns_
#endif
class __edm__Wrapper_RPRecognizedPatterns_ {
  public:
  __edm__Wrapper_RPRecognizedPatterns_();
  bool present;
  ::RPRecognizedPatterns obj;
};
#ifdef __edm__Wrapper_RPRecoElasticEvent_
#undef __edm__Wrapper_RPRecoElasticEvent_
#endif
class __edm__Wrapper_RPRecoElasticEvent_ {
  public:
  __edm__Wrapper_RPRecoElasticEvent_();
  bool present;
  ::RPRecoElasticEvent obj;
};
#ifdef __edm__Wrapper_RPReconstructedProtonPairCollection_
#undef __edm__Wrapper_RPReconstructedProtonPairCollection_
#endif
class __edm__Wrapper_RPReconstructedProtonPairCollection_ {
  public:
  __edm__Wrapper_RPReconstructedProtonPairCollection_();
  bool present;
  ::RPReconstructedProtonPairCollection obj;
};
#ifdef __edm__Wrapper_RPReconstructedProtonPair_
#undef __edm__Wrapper_RPReconstructedProtonPair_
#endif
class __edm__Wrapper_RPReconstructedProtonPair_ {
  public:
  __edm__Wrapper_RPReconstructedProtonPair_();
  bool present;
  ::RPReconstructedProtonPair obj;
};
#ifdef __edm__Wrapper_RP2DHitDebug_
#undef __edm__Wrapper_RP2DHitDebug_
#endif
class __edm__Wrapper_RP2DHitDebug_ {
  public:
  __edm__Wrapper_RP2DHitDebug_();
  bool present;
  ::RP2DHitDebug obj;
};
#ifdef __edm__Wrapper_RP2DHit_
#undef __edm__Wrapper_RP2DHit_
#endif
class __edm__Wrapper_RP2DHit_ {
  public:
  __edm__Wrapper_RP2DHit_();
  bool present;
  ::RP2DHit obj;
};
#ifdef __edm__Wrapper_RPReconstructedProtonCollection_
#undef __edm__Wrapper_RPReconstructedProtonCollection_
#endif
class __edm__Wrapper_RPReconstructedProtonCollection_ {
  public:
  __edm__Wrapper_RPReconstructedProtonCollection_();
  bool present;
  ::RPReconstructedProtonCollection obj;
};
#ifdef __edm__Wrapper_RPReconstructedProton_
#undef __edm__Wrapper_RPReconstructedProton_
#endif
class __edm__Wrapper_RPReconstructedProton_ {
  public:
  __edm__Wrapper_RPReconstructedProton_();
  bool present;
  ::RPReconstructedProton obj;
};
#ifdef __edm__Wrapper_TObject_
#undef __edm__Wrapper_TObject_
#endif
class __edm__Wrapper_TObject_ {
  public:
  __edm__Wrapper_TObject_();
  bool present;
  ::TObject obj;
};
#ifdef __edm__Wrapper_std__vector_RPDetHitPoint_s_
#undef __edm__Wrapper_std__vector_RPDetHitPoint_s_
#endif
class __edm__Wrapper_std__vector_RPDetHitPoint_s_ {
  public:
  __edm__Wrapper_std__vector_RPDetHitPoint_s_();
  bool present;
  ::std::vector<RPDetHitPoint> obj;
};
#ifdef __edm__Wrapper_TVector3_
#undef __edm__Wrapper_TVector3_
#endif
class __edm__Wrapper_TVector3_ {
  public:
  __edm__Wrapper_TVector3_();
  bool present;
  ::TVector3 obj;
};
#ifdef __edm__Wrapper_RPDetHitPoint_
#undef __edm__Wrapper_RPDetHitPoint_
#endif
class __edm__Wrapper_RPDetHitPoint_ {
  public:
  __edm__Wrapper_RPDetHitPoint_();
  bool present;
  ::RPDetHitPoint obj;
};
#ifdef __edm__Wrapper_RPMulFittedTrackCollection_
#undef __edm__Wrapper_RPMulFittedTrackCollection_
#endif
class __edm__Wrapper_RPMulFittedTrackCollection_ {
  public:
  __edm__Wrapper_RPMulFittedTrackCollection_();
  bool present;
  ::RPMulFittedTrackCollection obj;
};
#ifdef __edm__Wrapper_RPFittedTrackCollection_
#undef __edm__Wrapper_RPFittedTrackCollection_
#endif
class __edm__Wrapper_RPFittedTrackCollection_ {
  public:
  __edm__Wrapper_RPFittedTrackCollection_();
  bool present;
  ::RPFittedTrackCollection obj;
};
#ifdef __edm__Wrapper_RPFittedTrack_
#undef __edm__Wrapper_RPFittedTrack_
#endif
class __edm__Wrapper_RPFittedTrack_ {
  public:
  __edm__Wrapper_RPFittedTrack_();
  bool present;
  ::RPFittedTrack obj;
};
#ifdef __edm__Wrapper_RPMulTrackCandidateSetsCollection_
#undef __edm__Wrapper_RPMulTrackCandidateSetsCollection_
#endif
class __edm__Wrapper_RPMulTrackCandidateSetsCollection_ {
  public:
  __edm__Wrapper_RPMulTrackCandidateSetsCollection_();
  bool present;
  ::RPMulTrackCandidateSetsCollection obj;
};
#ifdef __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s_
#undef __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s_
#endif
class __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s_ {
  public:
  __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s_();
  bool present;
  ::std::vector<std::vector<RPTrackCandidate> > obj;
};
#ifdef __edm__Wrapper_RPMulFittedTrackSetsCollection_
#undef __edm__Wrapper_RPMulFittedTrackSetsCollection_
#endif
class __edm__Wrapper_RPMulFittedTrackSetsCollection_ {
  public:
  __edm__Wrapper_RPMulFittedTrackSetsCollection_();
  bool present;
  ::RPMulFittedTrackSetsCollection obj;
};
#ifdef __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s_
#undef __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s_
#endif
class __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s_ {
  public:
  __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s_();
  bool present;
  ::std::vector<std::vector<RPFittedTrack> > obj;
};
#ifdef __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet_
#undef __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet_
#endif
class __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet_ {
  public:
  __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet_();
  bool present;
  ::RPTrackCandidateDistinctCollectionsSet obj;
};
#ifdef __edm__Wrapper_RPMulTrackCandidateCollection_
#undef __edm__Wrapper_RPMulTrackCandidateCollection_
#endif
class __edm__Wrapper_RPMulTrackCandidateCollection_ {
  public:
  __edm__Wrapper_RPMulTrackCandidateCollection_();
  bool present;
  ::RPMulTrackCandidateCollection obj;
};
#ifdef __edm__Wrapper_RPTrackCandidateCollection_
#undef __edm__Wrapper_RPTrackCandidateCollection_
#endif
class __edm__Wrapper_RPTrackCandidateCollection_ {
  public:
  __edm__Wrapper_RPTrackCandidateCollection_();
  bool present;
  ::RPTrackCandidateCollection obj;
};
#ifdef __edm__Wrapper_CentralMassInfo_
#undef __edm__Wrapper_CentralMassInfo_
#endif
class __edm__Wrapper_CentralMassInfo_ {
  public:
  __edm__Wrapper_CentralMassInfo_();
  bool present;
  ::CentralMassInfo obj;
};
#ifdef __std__pair_unsignedsint_std__vector_RPFittedTrack_s_
#undef __std__pair_unsignedsint_std__vector_RPFittedTrack_s_
#endif
struct __std__pair_unsignedsint_std__vector_RPFittedTrack_s_ {
  public:
  __std__pair_unsignedsint_std__vector_RPFittedTrack_s_();
  unsigned int first;
  ::std::vector<RPFittedTrack> second;
};
#ifdef __std__pair_unsignedsint_RPFittedTrack_
#undef __std__pair_unsignedsint_RPFittedTrack_
#endif
struct __std__pair_unsignedsint_RPFittedTrack_ {
  public:
  __std__pair_unsignedsint_RPFittedTrack_();
  unsigned int first;
  ::RPFittedTrack second;
};
#ifdef __std__pair_unsignedsint_std__vector_RPTrackCandidate_s_
#undef __std__pair_unsignedsint_std__vector_RPTrackCandidate_s_
#endif
struct __std__pair_unsignedsint_std__vector_RPTrackCandidate_s_ {
  public:
  __std__pair_unsignedsint_std__vector_RPTrackCandidate_s_();
  unsigned int first;
  ::std::vector<RPTrackCandidate> second;
};
#ifdef __std__pair_unsignedsint_RPTrackCandidate_
#undef __std__pair_unsignedsint_RPTrackCandidate_
#endif
struct __std__pair_unsignedsint_RPTrackCandidate_ {
  public:
  __std__pair_unsignedsint_RPTrackCandidate_();
  unsigned int first;
  ::RPTrackCandidate second;
};
#ifdef __std__map_unsignedsint_RP2DHitDebug_
#undef __std__map_unsignedsint_RP2DHitDebug_
#endif
class __std__map_unsignedsint_RP2DHitDebug_ {
  public:
  __std__map_unsignedsint_RP2DHitDebug_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RP2DHitDebug>,std::_Select1st<std::pair<const unsigned int,RP2DHitDebug> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RP2DHitDebug> > > _M_t;
};
#ifdef __std__map_unsignedsint_std__vector_RPFittedTrack_s_
#undef __std__map_unsignedsint_std__vector_RPFittedTrack_s_
#endif
class __std__map_unsignedsint_std__vector_RPFittedTrack_s_ {
  public:
  __std__map_unsignedsint_std__vector_RPFittedTrack_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPFittedTrack> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPFittedTrack> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPFittedTrack> > > > _M_t;
};
#ifdef __std__map_unsignedsint_RPFittedTrack_
#undef __std__map_unsignedsint_RPFittedTrack_
#endif
class __std__map_unsignedsint_RPFittedTrack_ {
  public:
  __std__map_unsignedsint_RPFittedTrack_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPFittedTrack>,std::_Select1st<std::pair<const unsigned int,RPFittedTrack> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPFittedTrack> > > _M_t;
};
#ifdef __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_
#undef __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_
#endif
class __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_ {
  public:
  __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > >,std::_Select1st<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > > > _M_t;
};
#ifdef __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_
#undef __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_
#endif
class __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_ {
  public:
  __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > >,std::_Select1st<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > > > _M_t;
};
#ifdef __std__map_unsignedsint_std__vector_RPTrackCandidate_s_
#undef __std__map_unsignedsint_std__vector_RPTrackCandidate_s_
#endif
class __std__map_unsignedsint_std__vector_RPTrackCandidate_s_ {
  public:
  __std__map_unsignedsint_std__vector_RPTrackCandidate_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPTrackCandidate> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > > > _M_t;
};
#ifdef __std__map_unsignedsint_RPTrackCandidate_
#undef __std__map_unsignedsint_RPTrackCandidate_
#endif
class __std__map_unsignedsint_RPTrackCandidate_ {
  public:
  __std__map_unsignedsint_RPTrackCandidate_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPTrackCandidate>,std::_Select1st<std::pair<const unsigned int,RPTrackCandidate> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPTrackCandidate> > > _M_t;
};
#ifdef __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s_
#undef __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s_
#endif
class __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s_ {
  public:
  __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > > > _M_t;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s_
#undef __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s_();
  bool present;
  ::std::map<unsigned int,RP2DHitDebug> obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s_
#undef __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s_();
  bool present;
  ::std::map<unsigned int,std::vector<RPFittedTrack> > obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s_
#undef __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s_();
  bool present;
  ::std::map<unsigned int,RPFittedTrack> obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s_
#undef __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s_();
  bool present;
  ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s_
#undef __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s_();
  bool present;
  ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > obj;
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
TClass* ::TObject::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("TObject");
   return fgIsA;
}
const char * ::TObject::Class_Name() {return "TObject";}
void ::TObject::Dictionary() {}
const char *::TObject::ImplFileName() {return "";}
int ::TObject::ImplFileLine() {return 1;}
void ::TObject::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TObject::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fUniqueID", &fUniqueID);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fBits", &fBits);
}
void ::TObject::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TObject::Class(),this);
   } else {
      b.WriteClassBuffer(::TObject::Class(),this);
   }
}
TClass* ::TObject::fgIsA = 0;

TClass* ::TVector3::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("TVector3");
   return fgIsA;
}
const char * ::TVector3::Class_Name() {return "TVector3";}
void ::TVector3::Dictionary() {}
const char *::TVector3::ImplFileName() {return "";}
int ::TVector3::ImplFileLine() {return 1;}
void ::TVector3::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TVector3::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fX", &fX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fY", &fY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "fZ", &fZ);
   TObject::ShowMembers(R__insp);
}
void ::TVector3::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TVector3::Class(),this);
   } else {
      b.WriteClassBuffer(::TVector3::Class(),this);
   }
}
TClass* ::TVector3::fgIsA = 0;


namespace {
//------Stub functions for class RPFittedTrack -------------------------------
static  void operator_3724( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPFittedTrack*)o)->operator=)(*(const ::RPFittedTrack*)arg[0]);
  else   (((::RPFittedTrack*)o)->operator=)(*(const ::RPFittedTrack*)arg[0]);
}

static void constructor_3725( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPFittedTrack(*(const ::RPFittedTrack*)arg[0]);
  else ::new(mem) ::RPFittedTrack(*(const ::RPFittedTrack*)arg[0]);
}

static void constructor_3726( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPFittedTrack();
  else ::new(mem) ::RPFittedTrack();
}

static void constructor_3727( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPFittedTrack(*(double*)arg[0],
      *(const ::TVectorD*)arg[1],
      *(const ::TMatrixD*)arg[2],
      *(double*)arg[3]);
  else ::new(mem) ::RPFittedTrack(*(double*)arg[0],
      *(const ::TVectorD*)arg[1],
      *(const ::TMatrixD*)arg[2],
      *(double*)arg[3]);
}

static void destructor_3728(void*, void * o, const std::vector<void*>&, void *) {
(((::RPFittedTrack*)o)->::RPFittedTrack::~RPFittedTrack)();
}
static  void method_3729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::RPFittedTrack*)o)->GetHitEntries)());
  else   (((const ::RPFittedTrack*)o)->GetHitEntries)();
}

static  void method_3730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RPFittedTrack*)o)->GetHit)(*(int*)arg[0]);
  else   (((const ::RPFittedTrack*)o)->GetHit)(*(int*)arg[0]);
}

static  void method_3731( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPFittedTrack*)o)->AddHit)(*(const ::RPDetHitPoint*)arg[0]);
}

static  void method_3732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->X0)());
  else   (((const ::RPFittedTrack*)o)->X0)();
}

static  void method_3733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->X0Sigma)());
  else   (((const ::RPFittedTrack*)o)->X0Sigma)();
}

static  void method_3734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->X0Variance)());
  else   (((const ::RPFittedTrack*)o)->X0Variance)();
}

static  void method_3735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->Y0)());
  else   (((const ::RPFittedTrack*)o)->Y0)();
}

static  void method_3736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->Y0Sigma)());
  else   (((const ::RPFittedTrack*)o)->Y0Sigma)();
}

static  void method_3737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->Y0Variance)());
  else   (((const ::RPFittedTrack*)o)->Y0Variance)();
}

static  void method_3738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->Z0)());
  else   (((const ::RPFittedTrack*)o)->Z0)();
}

static  void method_3739( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPFittedTrack*)o)->Z0)(*(double*)arg[0]);
}

static  void method_3740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->GetTx)());
  else   (((const ::RPFittedTrack*)o)->GetTx)();
}

static  void method_3741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->GetTxSigma)());
  else   (((const ::RPFittedTrack*)o)->GetTxSigma)();
}

static  void method_3742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->GetTy)());
  else   (((const ::RPFittedTrack*)o)->GetTy)();
}

static  void method_3743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->GetTySigma)());
  else   (((const ::RPFittedTrack*)o)->GetTySigma)();
}

static  void method_3744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::RPFittedTrack*)o)->GetDirectionVector)());
  else   (((const ::RPFittedTrack*)o)->GetDirectionVector)();
}

static  void method_3745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TVectorD)((((const ::RPFittedTrack*)o)->ParameterVector)());
  else   (((const ::RPFittedTrack*)o)->ParameterVector)();
}

static  void method_3746( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPFittedTrack*)o)->ParameterVector)(*(const ::TVectorD*)arg[0]);
}

static  void method_3747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TMatrixD)((((const ::RPFittedTrack*)o)->CovarianceMatrix)());
  else   (((const ::RPFittedTrack*)o)->CovarianceMatrix)();
}

static  void method_3748( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPFittedTrack*)o)->CovarianceMatrix)(*(const ::TMatrixD*)arg[0]);
}

static  void method_3749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->ChiSquared)());
  else   (((const ::RPFittedTrack*)o)->ChiSquared)();
}

static  void method_3750( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPFittedTrack*)o)->ChiSquared)(*(double*)arg[0]);
}

static  void method_3751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPFittedTrack*)o)->ChiSquaredOverN)());
  else   (((const ::RPFittedTrack*)o)->ChiSquaredOverN)();
}

static  void method_3752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector2)((((const ::RPFittedTrack*)o)->GetTrackPoint)(*(double*)arg[0]));
  else   (((const ::RPFittedTrack*)o)->GetTrackPoint)(*(double*)arg[0]);
}

static  void method_3753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((::RPFittedTrack*)o)->TrackCentrePoint)());
  else   (((::RPFittedTrack*)o)->TrackCentrePoint)();
}

static  void method_3754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TMatrixD)((((const ::RPFittedTrack*)o)->TrackPointInterpolationCovariance)(*(double*)arg[0]));
  else   (((const ::RPFittedTrack*)o)->TrackPointInterpolationCovariance)(*(double*)arg[0]);
}

static  void method_3755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::RPFittedTrack*)o)->IsValid)());
  else   (((const ::RPFittedTrack*)o)->IsValid)();
}

static  void method_3756( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPFittedTrack*)o)->IsValid)(*(bool*)arg[0]);
}

static  void method_3757( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RPFittedTrack*)o)->Reset)();
}

static  void method_3758( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPFittedTrack*)o)->SetUVid)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1]);
}

static  void method_3759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::RPFittedTrack*)o)->GetUid)());
  else   (((const ::RPFittedTrack*)o)->GetUid)();
}

static  void method_3760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::RPFittedTrack*)o)->GetVid)());
  else   (((const ::RPFittedTrack*)o)->GetVid)();
}

static  void method_3761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::RPFittedTrack*)o)->IsSourceTrackCandidateValid)());
  else   (((const ::RPFittedTrack*)o)->IsSourceTrackCandidateValid)();
}

static  void method_3762( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPFittedTrack*)o)->SetSourceTrackCandidateValidity)(*(bool*)arg[0]);
}

static void method_newdel_156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPFittedTrack >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPFittedTrack >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPFittedTrack >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPFittedTrack >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPFittedTrack >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPFittedTrack -------------------------------
void __RPFittedTrack_db_datamem(Reflex::Class*);
void __RPFittedTrack_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPFittedTrack_datamem_bld(&__RPFittedTrack_db_datamem);
Reflex::GenreflexMemberBuilder __RPFittedTrack_funcmem_bld(&__RPFittedTrack_db_funcmem);
void __RPFittedTrack_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPFittedTrack"), typeid(::RPFittedTrack), sizeof(::RPFittedTrack), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_156"), Reflex::Literal("dimension=4"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_157"), Reflex::Literal("covarianceSize=16"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12299, type_12301), Reflex::Literal("operator="), operator_3724, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12301), Reflex::Literal("RPFittedTrack"), constructor_3725, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPFittedTrack"), constructor_3726, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_97, type_16779, type_16780, type_97), Reflex::Literal("RPFittedTrack"), constructor_3727, 0, "z0;track_params_vector;par_covariance_matrix;chiSquared", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPFittedTrack"), destructor_3728, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPFittedTrack_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPFittedTrack_funcmem_bld);
}

//------Delayed data member builder for class RPFittedTrack -------------------
void __RPFittedTrack_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1658, Reflex::Literal("sourceTrackCandidate"), OffsetOf(__shadow__::__RPFittedTrack, sourceTrackCandidate), ::Reflex::PUBLIC)
  .AddDataMember(type_2848, Reflex::Literal("track_hits_vector_"), OffsetOf(__shadow__::__RPFittedTrack, track_hits_vector_), ::Reflex::PRIVATE)
  .AddDataMember(type_16777, Reflex::Literal("track_params_vector_"), OffsetOf(__shadow__::__RPFittedTrack, track_params_vector_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("z0_"), OffsetOf(__shadow__::__RPFittedTrack, z0_), ::Reflex::PRIVATE)
  .AddDataMember(type_16778, Reflex::Literal("par_covariance_matrix_"), OffsetOf(__shadow__::__RPFittedTrack, par_covariance_matrix_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("chiSquared_"), OffsetOf(__shadow__::__RPFittedTrack, chiSquared_), ::Reflex::PRIVATE)
  .AddDataMember(type_1482, Reflex::Literal("valid_"), OffsetOf(__shadow__::__RPFittedTrack, valid_), ::Reflex::PRIVATE)
  .AddDataMember(type_296, Reflex::Literal("u_id_"), OffsetOf(__shadow__::__RPFittedTrack, u_id_), ::Reflex::PRIVATE)
  .AddDataMember(type_296, Reflex::Literal("v_id_"), OffsetOf(__shadow__::__RPFittedTrack, v_id_), ::Reflex::PRIVATE)
  .AddDataMember(type_1482, Reflex::Literal("sourceTrackCandidateValid"), OffsetOf(__shadow__::__RPFittedTrack, sourceTrackCandidateValid), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPFittedTrack -------------------
void __RPFittedTrack_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65), Reflex::Literal("GetHitEntries"), method_3729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12236, type_65), Reflex::Literal("GetHit"), method_3730, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12236), Reflex::Literal("AddHit"), method_3731, 0, "hit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("X0"), method_3732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("X0Sigma"), method_3733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("X0Variance"), method_3734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Y0"), method_3735, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Y0Sigma"), method_3736, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Y0Variance"), method_3737, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Z0"), method_3738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Z0"), method_3739, 0, "z0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("GetTx"), method_3740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("GetTxSigma"), method_3741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("GetTy"), method_3742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("GetTySigma"), method_3743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2017), Reflex::Literal("GetDirectionVector"), method_3744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2019), Reflex::Literal("ParameterVector"), method_3745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16779), Reflex::Literal("ParameterVector"), method_3746, 0, "track_params_vector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_995), Reflex::Literal("CovarianceMatrix"), method_3747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16780), Reflex::Literal("CovarianceMatrix"), method_3748, 0, "par_covariance_matrix", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ChiSquared"), method_3749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12686), Reflex::Literal("ChiSquared"), method_3750, 0, "chiSquared", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ChiSquaredOverN"), method_3751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2016, type_97), Reflex::Literal("GetTrackPoint"), method_3752, 0, "z", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2017), Reflex::Literal("TrackCentrePoint"), method_3753, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_995, type_97), Reflex::Literal("TrackPointInterpolationCovariance"), method_3754, 0, "z", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("IsValid"), method_3755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1482), Reflex::Literal("IsValid"), method_3756, 0, "valid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("Reset"), method_3757, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_296, type_296), Reflex::Literal("SetUVid"), method_3758, 0, "u;v", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296), Reflex::Literal("GetUid"), method_3759, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296), Reflex::Literal("GetVid"), method_3760, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("IsSourceTrackCandidateValid"), method_3761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1482), Reflex::Literal("SetSourceTrackCandidateValidity"), method_3762, 0, "val", ::Reflex::PUBLIC);
}
//------Stub functions for class RPTrackCandidateDistinctCollectionsSet -------------------------------
static void destructor_3765(void*, void * o, const std::vector<void*>&, void *) {
(((::RPTrackCandidateDistinctCollectionsSet*)o)->::RPTrackCandidateDistinctCollectionsSet::~RPTrackCandidateDistinctCollectionsSet)();
}
static  void operator_3766( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPTrackCandidateDistinctCollectionsSet*)o)->operator=)(*(const ::RPTrackCandidateDistinctCollectionsSet*)arg[0]);
  else   (((::RPTrackCandidateDistinctCollectionsSet*)o)->operator=)(*(const ::RPTrackCandidateDistinctCollectionsSet*)arg[0]);
}

static void constructor_3767( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPTrackCandidateDistinctCollectionsSet(*(const ::RPTrackCandidateDistinctCollectionsSet*)arg[0]);
  else ::new(mem) ::RPTrackCandidateDistinctCollectionsSet(*(const ::RPTrackCandidateDistinctCollectionsSet*)arg[0]);
}

static void constructor_3768( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPTrackCandidateDistinctCollectionsSet();
  else ::new(mem) ::RPTrackCandidateDistinctCollectionsSet();
}

static void method_newdel_157( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPTrackCandidateDistinctCollectionsSet >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPTrackCandidateDistinctCollectionsSet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPTrackCandidateDistinctCollectionsSet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPTrackCandidateDistinctCollectionsSet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPTrackCandidateDistinctCollectionsSet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >")), ::Reflex::BaseOffset< ::RPTrackCandidateDistinctCollectionsSet,::std::map<unsigned int,std::vector<RPTrackCandidateCollection> > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RPTrackCandidateDistinctCollectionsSet -------------------------------
void __RPTrackCandidateDistinctCollectionsSet_db_datamem(Reflex::Class*);
void __RPTrackCandidateDistinctCollectionsSet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPTrackCandidateDistinctCollectionsSet_datamem_bld(&__RPTrackCandidateDistinctCollectionsSet_db_datamem);
Reflex::GenreflexMemberBuilder __RPTrackCandidateDistinctCollectionsSet_funcmem_bld(&__RPTrackCandidateDistinctCollectionsSet_db_funcmem);
void __RPTrackCandidateDistinctCollectionsSet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPTrackCandidateDistinctCollectionsSet"), typeid(::RPTrackCandidateDistinctCollectionsSet), sizeof(::RPTrackCandidateDistinctCollectionsSet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2984, ::Reflex::BaseOffset< ::RPTrackCandidateDistinctCollectionsSet, ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> > >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPTrackCandidateDistinctCollectionsSet"), destructor_3765, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16781, type_16782), Reflex::Literal("operator="), operator_3766, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16782), Reflex::Literal("RPTrackCandidateDistinctCollectionsSet"), constructor_3767, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPTrackCandidateDistinctCollectionsSet"), constructor_3768, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_157, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RPTrackCandidateDistinctCollectionsSet -------------------
void __RPTrackCandidateDistinctCollectionsSet_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RPTrackCandidateDistinctCollectionsSet -------------------
void __RPTrackCandidateDistinctCollectionsSet_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPFittedTrackCollection -------------------------------
static void destructor_3817(void*, void * o, const std::vector<void*>&, void *) {
(((::RPFittedTrackCollection*)o)->::RPFittedTrackCollection::~RPFittedTrackCollection)();
}
static  void operator_3818( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPFittedTrackCollection*)o)->operator=)(*(const ::RPFittedTrackCollection*)arg[0]);
  else   (((::RPFittedTrackCollection*)o)->operator=)(*(const ::RPFittedTrackCollection*)arg[0]);
}

static void constructor_3819( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPFittedTrackCollection(*(const ::RPFittedTrackCollection*)arg[0]);
  else ::new(mem) ::RPFittedTrackCollection(*(const ::RPFittedTrackCollection*)arg[0]);
}

static void constructor_3820( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPFittedTrackCollection();
  else ::new(mem) ::RPFittedTrackCollection();
}

static void method_newdel_215( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPFittedTrackCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPFittedTrackCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPFittedTrackCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPFittedTrackCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPFittedTrackCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPFittedTrack>")), ::Reflex::BaseOffset< ::RPFittedTrackCollection,::std::map<unsigned int,RPFittedTrack> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RPFittedTrackCollection -------------------------------
void __RPFittedTrackCollection_db_datamem(Reflex::Class*);
void __RPFittedTrackCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPFittedTrackCollection_datamem_bld(&__RPFittedTrackCollection_db_datamem);
Reflex::GenreflexMemberBuilder __RPFittedTrackCollection_funcmem_bld(&__RPFittedTrackCollection_db_funcmem);
void __RPFittedTrackCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPFittedTrackCollection"), typeid(::RPFittedTrackCollection), sizeof(::RPFittedTrackCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2977, ::Reflex::BaseOffset< ::RPFittedTrackCollection, ::std::map<unsigned int,RPFittedTrack> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPFittedTrackCollection"), destructor_3817, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16792, type_16793), Reflex::Literal("operator="), operator_3818, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16793), Reflex::Literal("RPFittedTrackCollection"), constructor_3819, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPFittedTrackCollection"), constructor_3820, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_215, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RPFittedTrackCollection -------------------
void __RPFittedTrackCollection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RPFittedTrackCollection -------------------
void __RPFittedTrackCollection_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPDetHitPoint -------------------------------
static  void operator_3825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPDetHitPoint*)o)->operator=)(*(const ::RPDetHitPoint*)arg[0]);
  else   (((::RPDetHitPoint*)o)->operator=)(*(const ::RPDetHitPoint*)arg[0]);
}

static void constructor_3826( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPDetHitPoint(*(const ::RPDetHitPoint*)arg[0]);
  else ::new(mem) ::RPDetHitPoint(*(const ::RPDetHitPoint*)arg[0]);
}

static void constructor_3827( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPDetHitPoint(*(const ::RPRecoHit*)arg[0],
      *(const ::TVector3*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  else ::new(mem) ::RPDetHitPoint(*(const ::RPRecoHit*)arg[0],
      *(const ::TVector3*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
}

static void constructor_3828( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPDetHitPoint();
  else ::new(mem) ::RPDetHitPoint();
}

static void destructor_3829(void*, void * o, const std::vector<void*>&, void *) {
(((::RPDetHitPoint*)o)->::RPDetHitPoint::~RPDetHitPoint)();
}
static  void method_3830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RPDetHitPoint*)o)->HitGlobalCoord)();
  else   (((const ::RPDetHitPoint*)o)->HitGlobalCoord)();
}

static  void method_3831( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPDetHitPoint*)o)->HitGlobalCoord)(*(const ::TVector3*)arg[0]);
}

static  void method_3832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPDetHitPoint*)o)->Residual)());
  else   (((const ::RPDetHitPoint*)o)->Residual)();
}

static  void method_3833( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPDetHitPoint*)o)->Residual)(*(double*)arg[0]);
}

static  void method_3834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPDetHitPoint*)o)->Pull)());
  else   (((const ::RPDetHitPoint*)o)->Pull)();
}

static  void method_3835( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPDetHitPoint*)o)->Pull)(*(double*)arg[0]);
}

static  void method_3836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPDetHitPoint*)o)->GetPullNormalization)());
  else   (((const ::RPDetHitPoint*)o)->GetPullNormalization)();
}

static void method_newdel_221( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPDetHitPoint >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPDetHitPoint >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPDetHitPoint >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPDetHitPoint >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPDetHitPoint >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RPRecoHit")), ::Reflex::BaseOffset< ::RPDetHitPoint,::RPRecoHit >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RPDetHitPoint -------------------------------
void __RPDetHitPoint_db_datamem(Reflex::Class*);
void __RPDetHitPoint_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPDetHitPoint_datamem_bld(&__RPDetHitPoint_db_datamem);
Reflex::GenreflexMemberBuilder __RPDetHitPoint_funcmem_bld(&__RPDetHitPoint_db_funcmem);
void __RPDetHitPoint_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPDetHitPoint"), typeid(::RPDetHitPoint), sizeof(::RPDetHitPoint), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_2170, ::Reflex::BaseOffset< ::RPDetHitPoint, ::RPRecoHit >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12234, type_12236), Reflex::Literal("operator="), operator_3825, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12236), Reflex::Literal("RPDetHitPoint"), constructor_3826, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4793, type_7363, type_97, type_97), Reflex::Literal("RPDetHitPoint"), constructor_3827, 0, "hit;space_point_on_det;residual;pull", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPDetHitPoint"), constructor_3828, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPDetHitPoint"), destructor_3829, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_221, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPDetHitPoint_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPDetHitPoint_funcmem_bld);
}

//------Delayed data member builder for class RPDetHitPoint -------------------
void __RPDetHitPoint_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2017, Reflex::Literal("space_point_on_det_"), OffsetOf(__shadow__::__RPDetHitPoint, space_point_on_det_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("residual_"), OffsetOf(__shadow__::__RPDetHitPoint, residual_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("pull_"), OffsetOf(__shadow__::__RPDetHitPoint, pull_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPDetHitPoint -------------------
void __RPDetHitPoint_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7363), Reflex::Literal("HitGlobalCoord"), method_3830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_7363), Reflex::Literal("HitGlobalCoord"), method_3831, 0, "space_point_on_det", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Residual"), method_3832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Residual"), method_3833, 0, "residual", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Pull"), method_3834, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Pull"), method_3835, 0, "pull", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("GetPullNormalization"), method_3836, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RPMulFittedTrackCollection -------------------------------
static void destructor_3837(void*, void * o, const std::vector<void*>&, void *) {
(((::RPMulFittedTrackCollection*)o)->::RPMulFittedTrackCollection::~RPMulFittedTrackCollection)();
}
static  void operator_3838( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPMulFittedTrackCollection*)o)->operator=)(*(const ::RPMulFittedTrackCollection*)arg[0]);
  else   (((::RPMulFittedTrackCollection*)o)->operator=)(*(const ::RPMulFittedTrackCollection*)arg[0]);
}

static void constructor_3839( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPMulFittedTrackCollection(*(const ::RPMulFittedTrackCollection*)arg[0]);
  else ::new(mem) ::RPMulFittedTrackCollection(*(const ::RPMulFittedTrackCollection*)arg[0]);
}

static void constructor_3840( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPMulFittedTrackCollection();
  else ::new(mem) ::RPMulFittedTrackCollection();
}

static void method_newdel_225( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPMulFittedTrackCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPMulFittedTrackCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPMulFittedTrackCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPMulFittedTrackCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPMulFittedTrackCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >")), ::Reflex::BaseOffset< ::RPMulFittedTrackCollection,::std::map<unsigned int,std::vector<RPFittedTrack> > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RPMulFittedTrackCollection -------------------------------
void __RPMulFittedTrackCollection_db_datamem(Reflex::Class*);
void __RPMulFittedTrackCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPMulFittedTrackCollection_datamem_bld(&__RPMulFittedTrackCollection_db_datamem);
Reflex::GenreflexMemberBuilder __RPMulFittedTrackCollection_funcmem_bld(&__RPMulFittedTrackCollection_db_funcmem);
void __RPMulFittedTrackCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPMulFittedTrackCollection"), typeid(::RPMulFittedTrackCollection), sizeof(::RPMulFittedTrackCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2976, ::Reflex::BaseOffset< ::RPMulFittedTrackCollection, ::std::map<unsigned int,std::vector<RPFittedTrack> > >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPMulFittedTrackCollection"), destructor_3837, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16794, type_16795), Reflex::Literal("operator="), operator_3838, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16795), Reflex::Literal("RPMulFittedTrackCollection"), constructor_3839, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPMulFittedTrackCollection"), constructor_3840, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_225, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RPMulFittedTrackCollection -------------------
void __RPMulFittedTrackCollection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RPMulFittedTrackCollection -------------------
void __RPMulFittedTrackCollection_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPStationTrackFitCollection -------------------------------
static void destructor_3859(void*, void * o, const std::vector<void*>&, void *) {
(((::RPStationTrackFitCollection*)o)->::RPStationTrackFitCollection::~RPStationTrackFitCollection)();
}
static  void operator_3860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPStationTrackFitCollection*)o)->operator=)(*(const ::RPStationTrackFitCollection*)arg[0]);
  else   (((::RPStationTrackFitCollection*)o)->operator=)(*(const ::RPStationTrackFitCollection*)arg[0]);
}

static void constructor_3861( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPStationTrackFitCollection(*(const ::RPStationTrackFitCollection*)arg[0]);
  else ::new(mem) ::RPStationTrackFitCollection(*(const ::RPStationTrackFitCollection*)arg[0]);
}

static void constructor_3862( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPStationTrackFitCollection();
  else ::new(mem) ::RPStationTrackFitCollection();
}

static void method_newdel_252( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPStationTrackFitCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPStationTrackFitCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPStationTrackFitCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPStationTrackFitCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPStationTrackFitCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >")), ::Reflex::BaseOffset< ::RPStationTrackFitCollection,::std::map<unsigned int,std::vector<RPStationTrackFit> > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RPStationTrackFitCollection -------------------------------
void __RPStationTrackFitCollection_db_datamem(Reflex::Class*);
void __RPStationTrackFitCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPStationTrackFitCollection_datamem_bld(&__RPStationTrackFitCollection_db_datamem);
Reflex::GenreflexMemberBuilder __RPStationTrackFitCollection_funcmem_bld(&__RPStationTrackFitCollection_db_funcmem);
void __RPStationTrackFitCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPStationTrackFitCollection"), typeid(::RPStationTrackFitCollection), sizeof(::RPStationTrackFitCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2973, ::Reflex::BaseOffset< ::RPStationTrackFitCollection, ::std::map<unsigned int,std::vector<RPStationTrackFit> > >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPStationTrackFitCollection"), destructor_3859, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16802, type_16803), Reflex::Literal("operator="), operator_3860, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16803), Reflex::Literal("RPStationTrackFitCollection"), constructor_3861, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPStationTrackFitCollection"), constructor_3862, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_252, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RPStationTrackFitCollection -------------------
void __RPStationTrackFitCollection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RPStationTrackFitCollection -------------------
void __RPStationTrackFitCollection_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPMulTrackCandidateCollection -------------------------------
static void destructor_4173(void*, void * o, const std::vector<void*>&, void *) {
(((::RPMulTrackCandidateCollection*)o)->::RPMulTrackCandidateCollection::~RPMulTrackCandidateCollection)();
}
static  void operator_4174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPMulTrackCandidateCollection*)o)->operator=)(*(const ::RPMulTrackCandidateCollection*)arg[0]);
  else   (((::RPMulTrackCandidateCollection*)o)->operator=)(*(const ::RPMulTrackCandidateCollection*)arg[0]);
}

static void constructor_4175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPMulTrackCandidateCollection(*(const ::RPMulTrackCandidateCollection*)arg[0]);
  else ::new(mem) ::RPMulTrackCandidateCollection(*(const ::RPMulTrackCandidateCollection*)arg[0]);
}

static void constructor_4176( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPMulTrackCandidateCollection();
  else ::new(mem) ::RPMulTrackCandidateCollection();
}

static void method_newdel_370( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPMulTrackCandidateCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPMulTrackCandidateCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPMulTrackCandidateCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPMulTrackCandidateCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPMulTrackCandidateCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >")), ::Reflex::BaseOffset< ::RPMulTrackCandidateCollection,::std::map<unsigned int,std::vector<RPTrackCandidate> > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RPMulTrackCandidateCollection -------------------------------
void __RPMulTrackCandidateCollection_db_datamem(Reflex::Class*);
void __RPMulTrackCandidateCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPMulTrackCandidateCollection_datamem_bld(&__RPMulTrackCandidateCollection_db_datamem);
Reflex::GenreflexMemberBuilder __RPMulTrackCandidateCollection_funcmem_bld(&__RPMulTrackCandidateCollection_db_funcmem);
void __RPMulTrackCandidateCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPMulTrackCandidateCollection"), typeid(::RPMulTrackCandidateCollection), sizeof(::RPMulTrackCandidateCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2980, ::Reflex::BaseOffset< ::RPMulTrackCandidateCollection, ::std::map<unsigned int,std::vector<RPTrackCandidate> > >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPMulTrackCandidateCollection"), destructor_4173, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18018, type_18019), Reflex::Literal("operator="), operator_4174, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18019), Reflex::Literal("RPMulTrackCandidateCollection"), constructor_4175, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPMulTrackCandidateCollection"), constructor_4176, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_370, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RPMulTrackCandidateCollection -------------------
void __RPMulTrackCandidateCollection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RPMulTrackCandidateCollection -------------------
void __RPMulTrackCandidateCollection_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPMulTrackCandidateSetsCollection -------------------------------
static void destructor_4872(void*, void * o, const std::vector<void*>&, void *) {
(((::RPMulTrackCandidateSetsCollection*)o)->::RPMulTrackCandidateSetsCollection::~RPMulTrackCandidateSetsCollection)();
}
static  void operator_4873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPMulTrackCandidateSetsCollection*)o)->operator=)(*(const ::RPMulTrackCandidateSetsCollection*)arg[0]);
  else   (((::RPMulTrackCandidateSetsCollection*)o)->operator=)(*(const ::RPMulTrackCandidateSetsCollection*)arg[0]);
}

static void constructor_4874( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPMulTrackCandidateSetsCollection(*(const ::RPMulTrackCandidateSetsCollection*)arg[0]);
  else ::new(mem) ::RPMulTrackCandidateSetsCollection(*(const ::RPMulTrackCandidateSetsCollection*)arg[0]);
}

static void constructor_4875( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPMulTrackCandidateSetsCollection();
  else ::new(mem) ::RPMulTrackCandidateSetsCollection();
}

static void method_newdel_586( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPMulTrackCandidateSetsCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPMulTrackCandidateSetsCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPMulTrackCandidateSetsCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPMulTrackCandidateSetsCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPMulTrackCandidateSetsCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >")), ::Reflex::BaseOffset< ::RPMulTrackCandidateSetsCollection,::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RPMulTrackCandidateSetsCollection -------------------------------
void __RPMulTrackCandidateSetsCollection_db_datamem(Reflex::Class*);
void __RPMulTrackCandidateSetsCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPMulTrackCandidateSetsCollection_datamem_bld(&__RPMulTrackCandidateSetsCollection_db_datamem);
Reflex::GenreflexMemberBuilder __RPMulTrackCandidateSetsCollection_funcmem_bld(&__RPMulTrackCandidateSetsCollection_db_funcmem);
void __RPMulTrackCandidateSetsCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPMulTrackCandidateSetsCollection"), typeid(::RPMulTrackCandidateSetsCollection), sizeof(::RPMulTrackCandidateSetsCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2978, ::Reflex::BaseOffset< ::RPMulTrackCandidateSetsCollection, ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPMulTrackCandidateSetsCollection"), destructor_4872, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19252, type_19253), Reflex::Literal("operator="), operator_4873, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19253), Reflex::Literal("RPMulTrackCandidateSetsCollection"), constructor_4874, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPMulTrackCandidateSetsCollection"), constructor_4875, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_586, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RPMulTrackCandidateSetsCollection -------------------
void __RPMulTrackCandidateSetsCollection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RPMulTrackCandidateSetsCollection -------------------
void __RPMulTrackCandidateSetsCollection_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPReconstructedProtonPairCollection -------------------------------
static void destructor_5098(void*, void * o, const std::vector<void*>&, void *) {
(((::RPReconstructedProtonPairCollection*)o)->::RPReconstructedProtonPairCollection::~RPReconstructedProtonPairCollection)();
}
static  void operator_5099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPReconstructedProtonPairCollection*)o)->operator=)(*(const ::RPReconstructedProtonPairCollection*)arg[0]);
  else   (((::RPReconstructedProtonPairCollection*)o)->operator=)(*(const ::RPReconstructedProtonPairCollection*)arg[0]);
}

static void constructor_5100( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPReconstructedProtonPairCollection(*(const ::RPReconstructedProtonPairCollection*)arg[0]);
  else ::new(mem) ::RPReconstructedProtonPairCollection(*(const ::RPReconstructedProtonPairCollection*)arg[0]);
}

static void constructor_5101( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPReconstructedProtonPairCollection();
  else ::new(mem) ::RPReconstructedProtonPairCollection();
}

static void method_newdel_925( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonPairCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonPairCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonPairCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonPairCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonPairCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPReconstructedProtonPair>")), ::Reflex::BaseOffset< ::RPReconstructedProtonPairCollection,::std::vector<RPReconstructedProtonPair> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPReconstructedProtonPair,std::allocator<RPReconstructedProtonPair> >")), ::Reflex::BaseOffset< ::RPReconstructedProtonPairCollection,::std::_Vector_base<RPReconstructedProtonPair,std::allocator<RPReconstructedProtonPair> > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RPReconstructedProtonPairCollection -------------------------------
void __RPReconstructedProtonPairCollection_db_datamem(Reflex::Class*);
void __RPReconstructedProtonPairCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPReconstructedProtonPairCollection_datamem_bld(&__RPReconstructedProtonPairCollection_db_datamem);
Reflex::GenreflexMemberBuilder __RPReconstructedProtonPairCollection_funcmem_bld(&__RPReconstructedProtonPairCollection_db_funcmem);
void __RPReconstructedProtonPairCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPReconstructedProtonPairCollection"), typeid(::RPReconstructedProtonPairCollection), sizeof(::RPReconstructedProtonPairCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2846, ::Reflex::BaseOffset< ::RPReconstructedProtonPairCollection, ::std::vector<RPReconstructedProtonPair> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPReconstructedProtonPairCollection"), destructor_5098, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19299, type_19300), Reflex::Literal("operator="), operator_5099, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19300), Reflex::Literal("RPReconstructedProtonPairCollection"), constructor_5100, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPReconstructedProtonPairCollection"), constructor_5101, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_925, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RPReconstructedProtonPairCollection -------------------
void __RPReconstructedProtonPairCollection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RPReconstructedProtonPairCollection -------------------
void __RPReconstructedProtonPairCollection_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPReconstructedProtonPair -------------------------------
static  void operator_5479( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPReconstructedProtonPair*)o)->operator=)(*(const ::RPReconstructedProtonPair*)arg[0]);
  else   (((::RPReconstructedProtonPair*)o)->operator=)(*(const ::RPReconstructedProtonPair*)arg[0]);
}

static void constructor_5480( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPReconstructedProtonPair(*(const ::RPReconstructedProtonPair*)arg[0]);
  else ::new(mem) ::RPReconstructedProtonPair(*(const ::RPReconstructedProtonPair*)arg[0]);
}

static void constructor_5481( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPReconstructedProtonPair();
  else ::new(mem) ::RPReconstructedProtonPair();
}

static void destructor_5482(void*, void * o, const std::vector<void*>&, void *) {
(((::RPReconstructedProtonPair*)o)->::RPReconstructedProtonPair::~RPReconstructedProtonPair)();
}
static  void method_5483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->X3D)());
  else   (((const ::RPReconstructedProtonPair*)o)->X3D)();
}

static  void method_5484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->Y3D)());
  else   (((const ::RPReconstructedProtonPair*)o)->Y3D)();
}

static  void method_5485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->Z3D)());
  else   (((const ::RPReconstructedProtonPair*)o)->Z3D)();
}

static  void method_5486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->X0Left)());
  else   (((const ::RPReconstructedProtonPair*)o)->X0Left)();
}

static  void method_5487( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->Y0Left)());
  else   (((const ::RPReconstructedProtonPair*)o)->Y0Left)();
}

static  void method_5488( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->X0Right)());
  else   (((const ::RPReconstructedProtonPair*)o)->X0Right)();
}

static  void method_5489( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->Y0Right)());
  else   (((const ::RPReconstructedProtonPair*)o)->Y0Right)();
}

static  void method_5490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->ThetaXLeft)());
  else   (((const ::RPReconstructedProtonPair*)o)->ThetaXLeft)();
}

static  void method_5491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->ThetaYLeft)());
  else   (((const ::RPReconstructedProtonPair*)o)->ThetaYLeft)();
}

static  void method_5492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->ThetaXRight)());
  else   (((const ::RPReconstructedProtonPair*)o)->ThetaXRight)();
}

static  void method_5493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->ThetaYRight)());
  else   (((const ::RPReconstructedProtonPair*)o)->ThetaYRight)();
}

static  void method_5494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->ThetaXAngleLeft)());
  else   (((const ::RPReconstructedProtonPair*)o)->ThetaXAngleLeft)();
}

static  void method_5495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->ThetaYAngleLeft)());
  else   (((const ::RPReconstructedProtonPair*)o)->ThetaYAngleLeft)();
}

static  void method_5496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->ThetaXAngleRight)());
  else   (((const ::RPReconstructedProtonPair*)o)->ThetaXAngleRight)();
}

static  void method_5497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->ThetaYAngleRight)());
  else   (((const ::RPReconstructedProtonPair*)o)->ThetaYAngleRight)();
}

static  void method_5498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->KsiLeft)());
  else   (((const ::RPReconstructedProtonPair*)o)->KsiLeft)();
}

static  void method_5499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->KsiRight)());
  else   (((const ::RPReconstructedProtonPair*)o)->KsiRight)();
}

static  void method_5500( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->X3D)(*(double*)arg[0]);
}

static  void method_5501( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->Y3D)(*(double*)arg[0]);
}

static  void method_5502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->Z3D)(*(double*)arg[0]);
}

static  void method_5503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->ThetaXLeft)(*(double*)arg[0]);
}

static  void method_5504( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->ThetaYLeft)(*(double*)arg[0]);
}

static  void method_5505( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->KsiLeft)(*(double*)arg[0]);
}

static  void method_5506( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->ThetaXRight)(*(double*)arg[0]);
}

static  void method_5507( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->ThetaYRight)(*(double*)arg[0]);
}

static  void method_5508( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->KsiRight)(*(double*)arg[0]);
}

static  void method_5509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPReconstructedProtonPair*)o)->ThetaXLeft)());
  else   (((::RPReconstructedProtonPair*)o)->ThetaXLeft)();
}

static  void method_5510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPReconstructedProtonPair*)o)->ThetaYLeft)());
  else   (((::RPReconstructedProtonPair*)o)->ThetaYLeft)();
}

static  void method_5511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPReconstructedProtonPair*)o)->KsiLeft)());
  else   (((::RPReconstructedProtonPair*)o)->KsiLeft)();
}

static  void method_5512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPReconstructedProtonPair*)o)->ThetaXRight)());
  else   (((::RPReconstructedProtonPair*)o)->ThetaXRight)();
}

static  void method_5513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPReconstructedProtonPair*)o)->ThetaYRight)());
  else   (((::RPReconstructedProtonPair*)o)->ThetaYRight)();
}

static  void method_5514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPReconstructedProtonPair*)o)->KsiRight)());
  else   (((::RPReconstructedProtonPair*)o)->KsiRight)();
}

static  void method_5515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->Parameter)(*(int*)arg[0]));
  else   (((const ::RPReconstructedProtonPair*)o)->Parameter)(*(int*)arg[0]);
}

static  void method_5516( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->Parameter)(*(int*)arg[0],
    *(double*)arg[1]);
}

static  void method_5517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->CovarianceMartixElement)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_5518( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->CovarianceMartixElement)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::RPReconstructedProtonPair*)o)->CovarianceMartixElement)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5519( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->Valid)(*(bool*)arg[0]);
}

static  void method_5520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::RPReconstructedProtonPair*)o)->Valid)());
  else   (((const ::RPReconstructedProtonPair*)o)->Valid)();
}

static  void method_5521( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->Chi2)(*(double*)arg[0]);
}

static  void method_5522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->Chi2)());
  else   (((const ::RPReconstructedProtonPair*)o)->Chi2)();
}

static  void method_5523( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->Chi2Norm)(*(double*)arg[0]);
}

static  void method_5524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProtonPair*)o)->Chi2Norm)());
  else   (((const ::RPReconstructedProtonPair*)o)->Chi2Norm)();
}

static  void method_5525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::RPReconstructedProtonPair*)o)->FreeParametersNumber)());
  else   (((const ::RPReconstructedProtonPair*)o)->FreeParametersNumber)();
}

static  void method_5526( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->DegreesOfFreedom)(*(int*)arg[0]);
}

static  void method_5527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::RPReconstructedProtonPair*)o)->DegreesOfFreedom)());
  else   (((const ::RPReconstructedProtonPair*)o)->DegreesOfFreedom)();
}

static  void method_5528( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->AddDebugHit)(*(::RPId*)arg[0],
    *(const ::RP2DHitDebug*)arg[1]);
}

static  void method_5529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RPReconstructedProtonPair*)o)->DebugHits)();
  else   (((const ::RPReconstructedProtonPair*)o)->DebugHits)();
}

static  void method_5530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPReconstructedProtonPair*)o)->Vertex3DTo2DLeft_X)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3]));
  else   (((::RPReconstructedProtonPair*)o)->Vertex3DTo2DLeft_X)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3]);
}

static  void method_5531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPReconstructedProtonPair*)o)->Vertex3DTo2DLeft_Y)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3]));
  else   (((::RPReconstructedProtonPair*)o)->Vertex3DTo2DLeft_Y)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3]);
}

static  void method_5532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPReconstructedProtonPair*)o)->Vertex3DTo2DRight_X)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3]));
  else   (((::RPReconstructedProtonPair*)o)->Vertex3DTo2DRight_X)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3]);
}

static  void method_5533( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPReconstructedProtonPair*)o)->Vertex3DTo2DRight_Y)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3]));
  else   (((::RPReconstructedProtonPair*)o)->Vertex3DTo2DRight_Y)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3]);
}

static  void method_5534( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->FillMADTransportNtupleLeft)((const double*)arg[0],
    (double*)arg[1]);
}

static  void method_5535( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->FillMADTransportNtupleRight)((const double*)arg[0],
    (double*)arg[1]);
}

static  void method_5536( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->FillMADTransportNtupleLeft)(*(const ::std::vector<double>*)arg[0],
    (double*)arg[1]);
}

static  void method_5537( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->FillMADTransportNtupleRight)(*(const ::std::vector<double>*)arg[0],
    (double*)arg[1]);
}

static  void method_5538( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::RPReconstructedProtonPair*)o)->FillMADTransportNtupleLeft)((double*)arg[0]);
}

static  void method_5539( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::RPReconstructedProtonPair*)o)->FillMADTransportNtupleRight)((double*)arg[0]);
}

static  void method_5540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (RPRecoProtMADXVariables)((((const ::RPReconstructedProtonPair*)o)->GetMADXVariablesRight)());
  else   (((const ::RPReconstructedProtonPair*)o)->GetMADXVariablesRight)();
}

static  void method_5541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (RPRecoProtMADXVariables)((((const ::RPReconstructedProtonPair*)o)->GetMADXVariablesLeft)());
  else   (((const ::RPReconstructedProtonPair*)o)->GetMADXVariablesLeft)();
}

static  void method_5542( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->Fill5DimReconstructionVectorLeft)(*(const ::std::vector<double>*)arg[0],
    *(::std::vector<double>*)arg[1]);
}

static  void method_5543( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProtonPair*)o)->Fill5DimReconstructionVectorRight)(*(const ::std::vector<double>*)arg[0],
    *(::std::vector<double>*)arg[1]);
}

static void method_newdel_1003( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonPair >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonPair >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonPair >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonPair >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonPair >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPReconstructedProtonPair -------------------------------
void __RPReconstructedProtonPair_db_datamem(Reflex::Class*);
void __RPReconstructedProtonPair_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPReconstructedProtonPair_datamem_bld(&__RPReconstructedProtonPair_db_datamem);
Reflex::GenreflexMemberBuilder __RPReconstructedProtonPair_funcmem_bld(&__RPReconstructedProtonPair_db_funcmem);
void __RPReconstructedProtonPair_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPReconstructedProtonPair"), typeid(::RPReconstructedProtonPair), sizeof(::RPReconstructedProtonPair), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_163"), Reflex::Literal("dimension=9"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_164"), Reflex::Literal("cov_dimension=81"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_165"), Reflex::Literal("nx=0;ny=1;nz=2;ntheta_x0=3;ntheta_y0=4;nksi0=5;ntheta_x1=6;ntheta_y1=7;nksi1=8"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_2975, Reflex::Literal("RPReconstructedProtonPair::debug_hits_map_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12106, type_5606), Reflex::Literal("operator="), operator_5479, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5606), Reflex::Literal("RPReconstructedProtonPair"), constructor_5480, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPReconstructedProtonPair"), constructor_5481, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPReconstructedProtonPair"), destructor_5482, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1003, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPReconstructedProtonPair_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPReconstructedProtonPair_funcmem_bld);
}

//------Delayed data member builder for class RPReconstructedProtonPair -------------------
void __RPReconstructedProtonPair_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("valid_"), OffsetOf(__shadow__::__RPReconstructedProtonPair, valid_), ::Reflex::PRIVATE)
  .AddDataMember(type_19328, Reflex::Literal("variables_"), OffsetOf(__shadow__::__RPReconstructedProtonPair, variables_), ::Reflex::PRIVATE)
  .AddDataMember(type_19329, Reflex::Literal("covariance_"), OffsetOf(__shadow__::__RPReconstructedProtonPair, covariance_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("Chi_2_"), OffsetOf(__shadow__::__RPReconstructedProtonPair, Chi_2_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("Chi_2_over_n_"), OffsetOf(__shadow__::__RPReconstructedProtonPair, Chi_2_over_n_), ::Reflex::PRIVATE)
  .AddDataMember(type_65, Reflex::Literal("degrees_of_freedom_"), OffsetOf(__shadow__::__RPReconstructedProtonPair, degrees_of_freedom_), ::Reflex::PRIVATE)
  .AddDataMember(type_2975, Reflex::Literal("debug_hits_"), OffsetOf(__shadow__::__RPReconstructedProtonPair, debug_hits_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPReconstructedProtonPair -------------------
void __RPReconstructedProtonPair_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("X3D"), method_5483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Y3D"), method_5484, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Z3D"), method_5485, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("X0Left"), method_5486, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Y0Left"), method_5487, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("X0Right"), method_5488, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Y0Right"), method_5489, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaXLeft"), method_5490, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaYLeft"), method_5491, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaXRight"), method_5492, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaYRight"), method_5493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaXAngleLeft"), method_5494, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaYAngleLeft"), method_5495, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaXAngleRight"), method_5496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaYAngleRight"), method_5497, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("KsiLeft"), method_5498, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("KsiRight"), method_5499, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("X3D"), method_5500, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Y3D"), method_5501, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Z3D"), method_5502, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("ThetaXLeft"), method_5503, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("ThetaYLeft"), method_5504, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("KsiLeft"), method_5505, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("ThetaXRight"), method_5506, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("ThetaYRight"), method_5507, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("KsiRight"), method_5508, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaXLeft"), method_5509, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaYLeft"), method_5510, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("KsiLeft"), method_5511, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaXRight"), method_5512, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ThetaYRight"), method_5513, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("KsiRight"), method_5514, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97, type_65), Reflex::Literal("Parameter"), method_5515, 0, "n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_65, type_97), Reflex::Literal("Parameter"), method_5516, 0, "n;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_65, type_65, type_97), Reflex::Literal("CovarianceMartixElement"), method_5517, 0, "n;m;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97, type_65, type_65), Reflex::Literal("CovarianceMartixElement"), method_5518, 0, "n;m", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1482), Reflex::Literal("Valid"), method_5519, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("Valid"), method_5520, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Chi2"), method_5521, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Chi2"), method_5522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Chi2Norm"), method_5523, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Chi2Norm"), method_5524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65), Reflex::Literal("FreeParametersNumber"), method_5525, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_65), Reflex::Literal("DegreesOfFreedom"), method_5526, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65), Reflex::Literal("DegreesOfFreedom"), method_5527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1803, type_19330), Reflex::Literal("AddDebugHit"), method_5528, 0, "rp_id;deb_hit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19331), Reflex::Literal("DebugHits"), method_5529, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97, type_97, type_97, type_97, type_97), Reflex::Literal("Vertex3DTo2DLeft_X"), method_5530, 0, "mad_thetax;ksi;vx;vz", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97, type_97, type_97, type_97, type_97), Reflex::Literal("Vertex3DTo2DLeft_Y"), method_5531, 0, "mad_thetay;ksi;vy;vz", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97, type_97, type_97, type_97, type_97), Reflex::Literal("Vertex3DTo2DRight_X"), method_5532, 0, "mad_thetax;ksi;vx;vz", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97, type_97, type_97, type_97, type_97), Reflex::Literal("Vertex3DTo2DRight_Y"), method_5533, 0, "mad_thetay;ksi;vy;vz", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12684, type_3816), Reflex::Literal("FillMADTransportNtupleLeft"), method_5534, 0, "vect;par", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12684, type_3816), Reflex::Literal("FillMADTransportNtupleRight"), method_5535, 0, "vect;par", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_19332, type_3816), Reflex::Literal("FillMADTransportNtupleLeft"), method_5536, 0, "vect;par", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_19332, type_3816), Reflex::Literal("FillMADTransportNtupleRight"), method_5537, 0, "vect;par", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3816), Reflex::Literal("FillMADTransportNtupleLeft"), method_5538, 0, "par", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3816), Reflex::Literal("FillMADTransportNtupleRight"), method_5539, 0, "par", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1115), Reflex::Literal("GetMADXVariablesRight"), method_5540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1115), Reflex::Literal("GetMADXVariablesLeft"), method_5541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_19332, type_19333), Reflex::Literal("Fill5DimReconstructionVectorLeft"), method_5542, 0, "vect;par", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_19332, type_19333), Reflex::Literal("Fill5DimReconstructionVectorRight"), method_5543, 0, "vect;par", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class CentralMassInfo -------------------------------
static void destructor_5802(void*, void * o, const std::vector<void*>&, void *) {
(((::CentralMassInfo*)o)->::CentralMassInfo::~CentralMassInfo)();
}
static  void operator_5803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CentralMassInfo*)o)->operator=)(*(const ::CentralMassInfo*)arg[0]);
  else   (((::CentralMassInfo*)o)->operator=)(*(const ::CentralMassInfo*)arg[0]);
}

static void constructor_5804( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CentralMassInfo(*(const ::CentralMassInfo*)arg[0]);
  else ::new(mem) ::CentralMassInfo(*(const ::CentralMassInfo*)arg[0]);
}

static void constructor_5805( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CentralMassInfo();
  else ::new(mem) ::CentralMassInfo();
}

static  void method_5806( void*, void* o, const std::vector<void*>&, void*)
{
  (((::CentralMassInfo*)o)->clear)();
}

static  void method_5807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CentralMassInfo*)o)->AddParticle)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3]);
}

static void method_newdel_1181( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CentralMassInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CentralMassInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CentralMassInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CentralMassInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CentralMassInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CentralMassInfo -------------------------------
void __CentralMassInfo_db_datamem(Reflex::Class*);
void __CentralMassInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CentralMassInfo_datamem_bld(&__CentralMassInfo_db_datamem);
Reflex::GenreflexMemberBuilder __CentralMassInfo_funcmem_bld(&__CentralMassInfo_db_funcmem);
void __CentralMassInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CentralMassInfo"), typeid(::CentralMassInfo), sizeof(::CentralMassInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CentralMassInfo"), destructor_5802, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19381, type_19382), Reflex::Literal("operator="), operator_5803, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19382), Reflex::Literal("CentralMassInfo"), constructor_5804, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CentralMassInfo"), constructor_5805, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1181, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CentralMassInfo_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__CentralMassInfo_funcmem_bld);
}

//------Delayed data member builder for class CentralMassInfo -------------------
void __CentralMassInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_97, Reflex::Literal("px"), OffsetOf(__shadow__::__CentralMassInfo, px), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("py"), OffsetOf(__shadow__::__CentralMassInfo, py), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("pz"), OffsetOf(__shadow__::__CentralMassInfo, pz), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("pt"), OffsetOf(__shadow__::__CentralMassInfo, pt), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("e"), OffsetOf(__shadow__::__CentralMassInfo, e), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("m"), OffsetOf(__shadow__::__CentralMassInfo, m), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("min_rap"), OffsetOf(__shadow__::__CentralMassInfo, min_rap), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("max_rap"), OffsetOf(__shadow__::__CentralMassInfo, max_rap), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("rap"), OffsetOf(__shadow__::__CentralMassInfo, rap), ::Reflex::PUBLIC)
  .AddDataMember(type_1482, Reflex::Literal("empty"), OffsetOf(__shadow__::__CentralMassInfo, empty), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class CentralMassInfo -------------------
void __CentralMassInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_5806, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97, type_97, type_97, type_97), Reflex::Literal("AddParticle"), method_5807, 0, "pxr;pyr;pzr;er", ::Reflex::PUBLIC);
}
//------Stub functions for class RPReconstructedProton -------------------------------
static  void operator_6003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPReconstructedProton*)o)->operator=)(*(const ::RPReconstructedProton*)arg[0]);
  else   (((::RPReconstructedProton*)o)->operator=)(*(const ::RPReconstructedProton*)arg[0]);
}

static void constructor_6004( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPReconstructedProton(*(const ::RPReconstructedProton*)arg[0]);
  else ::new(mem) ::RPReconstructedProton(*(const ::RPReconstructedProton*)arg[0]);
}

static void constructor_6005( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPReconstructedProton();
  else ::new(mem) ::RPReconstructedProton();
}

static void destructor_6006(void*, void * o, const std::vector<void*>&, void *) {
(((::RPReconstructedProton*)o)->::RPReconstructedProton::~RPReconstructedProton)();
}
static  void method_6007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->X)());
  else   (((const ::RPReconstructedProton*)o)->X)();
}

static  void method_6008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->Y)());
  else   (((const ::RPReconstructedProton*)o)->Y)();
}

static  void method_6009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->Theta_x)());
  else   (((const ::RPReconstructedProton*)o)->Theta_x)();
}

static  void method_6010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->Theta_y)());
  else   (((const ::RPReconstructedProton*)o)->Theta_y)();
}

static  void method_6011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->Theta_x_angle)());
  else   (((const ::RPReconstructedProton*)o)->Theta_x_angle)();
}

static  void method_6012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->Theta_y_angle)());
  else   (((const ::RPReconstructedProton*)o)->Theta_y_angle)();
}

static  void method_6013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->Ksi)());
  else   (((const ::RPReconstructedProton*)o)->Ksi)();
}

static  void method_6014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->ZDirection)());
  else   (((const ::RPReconstructedProton*)o)->ZDirection)();
}

static  void method_6015( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->X)(*(double*)arg[0]);
}

static  void method_6016( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->Y)(*(double*)arg[0]);
}

static  void method_6017( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->Theta_x)(*(double*)arg[0]);
}

static  void method_6018( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->Theta_y)(*(double*)arg[0]);
}

static  void method_6019( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->Ksi)(*(double*)arg[0]);
}

static  void method_6020( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->ZDirection)(*(double*)arg[0]);
}

static  void method_6021( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->Parameter)(*(int*)arg[0]));
  else   (((const ::RPReconstructedProton*)o)->Parameter)(*(int*)arg[0]);
}

static  void method_6022( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->Parameter)(*(int*)arg[0],
    *(double*)arg[1]);
}

static  void method_6023( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->CovarianceMartixElement)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_6024( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->CovarianceMartixElement)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::RPReconstructedProton*)o)->CovarianceMartixElement)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_6025( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->Fitted)(*(int*)arg[0],
    *(bool*)arg[1]);
}

static  void method_6026( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::RPReconstructedProton*)o)->Fitted)(*(int*)arg[0]));
  else   (((const ::RPReconstructedProton*)o)->Fitted)(*(int*)arg[0]);
}

static  void method_6027( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->Valid)(*(bool*)arg[0]);
}

static  void method_6028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::RPReconstructedProton*)o)->Valid)());
  else   (((const ::RPReconstructedProton*)o)->Valid)();
}

static  void method_6029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->Chi2)(*(double*)arg[0]);
}

static  void method_6030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->Chi2)());
  else   (((const ::RPReconstructedProton*)o)->Chi2)();
}

static  void method_6031( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->Chi2Norm)(*(double*)arg[0]);
}

static  void method_6032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPReconstructedProton*)o)->Chi2Norm)());
  else   (((const ::RPReconstructedProton*)o)->Chi2Norm)();
}

static  void method_6033( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->DegreesOfFreedom)(*(int*)arg[0]);
}

static  void method_6034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::RPReconstructedProton*)o)->DegreesOfFreedom)());
  else   (((const ::RPReconstructedProton*)o)->DegreesOfFreedom)();
}

static  void method_6035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::RPReconstructedProton*)o)->FreeParametersNumber)());
  else   (((const ::RPReconstructedProton*)o)->FreeParametersNumber)();
}

static  void method_6036( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPReconstructedProton*)o)->AddDebugHit)(*(::RPId*)arg[0],
    *(const ::RP2DHitDebug*)arg[1]);
}

static  void method_6037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RPReconstructedProton*)o)->DebugHits)();
  else   (((const ::RPReconstructedProton*)o)->DebugHits)();
}

static  void method_6038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (RPRecoProtMADXVariables)((((const ::RPReconstructedProton*)o)->GetMADXVariables)());
  else   (((const ::RPReconstructedProton*)o)->GetMADXVariables)();
}

static void method_newdel_1565( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPReconstructedProton >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPReconstructedProton >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPReconstructedProton >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPReconstructedProton >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPReconstructedProton >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPReconstructedProton -------------------------------
void __RPReconstructedProton_db_datamem(Reflex::Class*);
void __RPReconstructedProton_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPReconstructedProton_datamem_bld(&__RPReconstructedProton_db_datamem);
Reflex::GenreflexMemberBuilder __RPReconstructedProton_funcmem_bld(&__RPReconstructedProton_db_funcmem);
void __RPReconstructedProton_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPReconstructedProton"), typeid(::RPReconstructedProton), sizeof(::RPReconstructedProton), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_160"), Reflex::Literal("dimension=5"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_161"), Reflex::Literal("cov_dimension=25"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_162"), Reflex::Literal("nx=0;ntheta_x=1;ny=2;ntheta_y=3;nksi=4"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_2975, Reflex::Literal("RPReconstructedProton::debug_hits_map_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12170, type_5607), Reflex::Literal("operator="), operator_6003, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5607), Reflex::Literal("RPReconstructedProton"), constructor_6004, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPReconstructedProton"), constructor_6005, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPReconstructedProton"), destructor_6006, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1565, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPReconstructedProton_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPReconstructedProton_funcmem_bld);
}

//------Delayed data member builder for class RPReconstructedProton -------------------
void __RPReconstructedProton_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("valid_"), OffsetOf(__shadow__::__RPReconstructedProton, valid_), ::Reflex::PRIVATE)
  .AddDataMember(type_19408, Reflex::Literal("variables_"), OffsetOf(__shadow__::__RPReconstructedProton, variables_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("z_direction_"), OffsetOf(__shadow__::__RPReconstructedProton, z_direction_), ::Reflex::PRIVATE)
  .AddDataMember(type_19312, Reflex::Literal("covariance_"), OffsetOf(__shadow__::__RPReconstructedProton, covariance_), ::Reflex::PRIVATE)
  .AddDataMember(type_19409, Reflex::Literal("fitted_"), OffsetOf(__shadow__::__RPReconstructedProton, fitted_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("Chi_2_"), OffsetOf(__shadow__::__RPReconstructedProton, Chi_2_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("Chi_2_over_n_"), OffsetOf(__shadow__::__RPReconstructedProton, Chi_2_over_n_), ::Reflex::PRIVATE)
  .AddDataMember(type_65, Reflex::Literal("degrees_of_freedom_"), OffsetOf(__shadow__::__RPReconstructedProton, degrees_of_freedom_), ::Reflex::PRIVATE)
  .AddDataMember(type_2975, Reflex::Literal("debug_hits_"), OffsetOf(__shadow__::__RPReconstructedProton, debug_hits_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPReconstructedProton -------------------
void __RPReconstructedProton_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("X"), method_6007, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Y"), method_6008, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Theta_x"), method_6009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Theta_y"), method_6010, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Theta_x_angle"), method_6011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Theta_y_angle"), method_6012, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Ksi"), method_6013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ZDirection"), method_6014, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("X"), method_6015, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Y"), method_6016, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Theta_x"), method_6017, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Theta_y"), method_6018, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Ksi"), method_6019, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("ZDirection"), method_6020, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97, type_65), Reflex::Literal("Parameter"), method_6021, 0, "n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_65, type_97), Reflex::Literal("Parameter"), method_6022, 0, "n;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_65, type_65, type_97), Reflex::Literal("CovarianceMartixElement"), method_6023, 0, "n;m;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97, type_65, type_65), Reflex::Literal("CovarianceMartixElement"), method_6024, 0, "n;m", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_65, type_1482), Reflex::Literal("Fitted"), method_6025, 0, "n;val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482, type_65), Reflex::Literal("Fitted"), method_6026, 0, "n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1482), Reflex::Literal("Valid"), method_6027, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("Valid"), method_6028, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Chi2"), method_6029, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Chi2"), method_6030, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Chi2Norm"), method_6031, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Chi2Norm"), method_6032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_65), Reflex::Literal("DegreesOfFreedom"), method_6033, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65), Reflex::Literal("DegreesOfFreedom"), method_6034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65), Reflex::Literal("FreeParametersNumber"), method_6035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1803, type_19330), Reflex::Literal("AddDebugHit"), method_6036, 0, "rp_id;deb_hit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19331), Reflex::Literal("DebugHits"), method_6037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1115), Reflex::Literal("GetMADXVariables"), method_6038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RPTrackCandidateCollection -------------------------------
static void destructor_6081(void*, void * o, const std::vector<void*>&, void *) {
(((::RPTrackCandidateCollection*)o)->::RPTrackCandidateCollection::~RPTrackCandidateCollection)();
}
static  void operator_6082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPTrackCandidateCollection*)o)->operator=)(*(const ::RPTrackCandidateCollection*)arg[0]);
  else   (((::RPTrackCandidateCollection*)o)->operator=)(*(const ::RPTrackCandidateCollection*)arg[0]);
}

static void constructor_6083( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPTrackCandidateCollection(*(const ::RPTrackCandidateCollection*)arg[0]);
  else ::new(mem) ::RPTrackCandidateCollection(*(const ::RPTrackCandidateCollection*)arg[0]);
}

static void constructor_6084( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPTrackCandidateCollection();
  else ::new(mem) ::RPTrackCandidateCollection();
}

static void method_newdel_1597( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPTrackCandidateCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPTrackCandidateCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPTrackCandidateCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPTrackCandidateCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPTrackCandidateCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPTrackCandidate>")), ::Reflex::BaseOffset< ::RPTrackCandidateCollection,::std::map<unsigned int,RPTrackCandidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RPTrackCandidateCollection -------------------------------
void __RPTrackCandidateCollection_db_datamem(Reflex::Class*);
void __RPTrackCandidateCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPTrackCandidateCollection_datamem_bld(&__RPTrackCandidateCollection_db_datamem);
Reflex::GenreflexMemberBuilder __RPTrackCandidateCollection_funcmem_bld(&__RPTrackCandidateCollection_db_funcmem);
void __RPTrackCandidateCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPTrackCandidateCollection"), typeid(::RPTrackCandidateCollection), sizeof(::RPTrackCandidateCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2981, ::Reflex::BaseOffset< ::RPTrackCandidateCollection, ::std::map<unsigned int,RPTrackCandidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPTrackCandidateCollection"), destructor_6081, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19414, type_19415), Reflex::Literal("operator="), operator_6082, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19415), Reflex::Literal("RPTrackCandidateCollection"), constructor_6083, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPTrackCandidateCollection"), constructor_6084, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1597, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RPTrackCandidateCollection -------------------
void __RPTrackCandidateCollection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RPTrackCandidateCollection -------------------
void __RPTrackCandidateCollection_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPTrackCandidate -------------------------------
static  void operator_6191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPTrackCandidate*)o)->operator=)(*(const ::RPTrackCandidate*)arg[0]);
  else   (((::RPTrackCandidate*)o)->operator=)(*(const ::RPTrackCandidate*)arg[0]);
}

static void constructor_6192( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPTrackCandidate(*(const ::RPTrackCandidate*)arg[0]);
  else ::new(mem) ::RPTrackCandidate(*(const ::RPTrackCandidate*)arg[0]);
}

static void constructor_6193( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPTrackCandidate(*(const ::std::vector<RPRecoHit>*)arg[0]);
  else ::new(mem) ::RPTrackCandidate(*(const ::std::vector<RPRecoHit>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPTrackCandidate(*(const ::std::vector<RPRecoHit>*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::RPTrackCandidate(*(const ::std::vector<RPRecoHit>*)arg[0],
      *(bool*)arg[1]);
  }
}

static void constructor_6194( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPTrackCandidate();
  else ::new(mem) ::RPTrackCandidate();
}

static  void method_6195( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPTrackCandidate*)o)->InsertHits)(*(const ::std::vector<RPRecoHit>*)arg[0],
    *(double*)arg[1]);
}

static  void method_6196( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPTrackCandidate*)o)->InsertHits)(*(const ::std::vector<const RPRecoHit*>*)arg[0],
    *(double*)arg[1]);
}

static  void method_6197( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPTrackCandidate*)o)->InsertHits)(*(const ::std::set<const RPRecoHit*>*)arg[0],
    *(double*)arg[1]);
}

static void destructor_6198(void*, void * o, const std::vector<void*>&, void *) {
(((::RPTrackCandidate*)o)->::RPTrackCandidate::~RPTrackCandidate)();
}
static  void method_6199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::RPTrackCandidate*)o)->Fittable)());
  else   (((const ::RPTrackCandidate*)o)->Fittable)();
}

static  void method_6200( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPTrackCandidate*)o)->Fittable)(*(bool*)arg[0]);
}

static  void method_6201( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPTrackCandidate*)o)->Weight)(*(double*)arg[0]);
}

static  void method_6202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPTrackCandidate*)o)->Weight)());
  else   (((const ::RPTrackCandidate*)o)->Weight)();
}

static  void method_6203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::RPTrackCandidate*)o)->Size)());
  else   (((const ::RPTrackCandidate*)o)->Size)();
}

static  void method_6204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >)((((const ::RPTrackCandidate*)o)->recHits)());
  else   (((const ::RPTrackCandidate*)o)->recHits)();
}

static  void method_6205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RPTrackCandidate*)o)->TrackRecoHits)();
  else   (((const ::RPTrackCandidate*)o)->TrackRecoHits)();
}

static  void method_6206( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPTrackCandidate*)o)->SetUVid)(*(unsigned int*)arg[0],
    *(unsigned int*)arg[1]);
}

static  void method_6207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::RPTrackCandidate*)o)->GetUid)());
  else   (((const ::RPTrackCandidate*)o)->GetUid)();
}

static  void method_6208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::RPTrackCandidate*)o)->GetVid)());
  else   (((const ::RPTrackCandidate*)o)->GetVid)();
}

static void method_newdel_1658( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPTrackCandidate >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPTrackCandidate >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPTrackCandidate >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPTrackCandidate >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPTrackCandidate >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPTrackCandidate -------------------------------
void __RPTrackCandidate_db_datamem(Reflex::Class*);
void __RPTrackCandidate_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPTrackCandidate_datamem_bld(&__RPTrackCandidate_db_datamem);
Reflex::GenreflexMemberBuilder __RPTrackCandidate_funcmem_bld(&__RPTrackCandidate_db_funcmem);
void __RPTrackCandidate_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPTrackCandidate"), typeid(::RPTrackCandidate), sizeof(::RPTrackCandidate), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddTypedef(type_2853, Reflex::Literal("RPTrackCandidate::RecHitContainer"))
  .AddTypedef(type_6188, Reflex::Literal("RPTrackCandidate::const_iterator"))
  .AddTypedef(type_2819, Reflex::Literal("RPTrackCandidate::range"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12429, type_12431), Reflex::Literal("operator="), operator_6191, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12431), Reflex::Literal("RPTrackCandidate"), constructor_6192, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19530, type_1482), Reflex::Literal("RPTrackCandidate"), constructor_6193, 0, "rh;_f=true", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPTrackCandidate"), constructor_6194, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPTrackCandidate"), destructor_6198, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1658, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPTrackCandidate_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPTrackCandidate_funcmem_bld);
}

//------Delayed data member builder for class RPTrackCandidate -------------------
void __RPTrackCandidate_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2853, Reflex::Literal("rh_"), OffsetOf(__shadow__::__RPTrackCandidate, rh_), ::Reflex::PRIVATE)
  .AddDataMember(type_1482, Reflex::Literal("fittable_"), OffsetOf(__shadow__::__RPTrackCandidate, fittable_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("weight_"), OffsetOf(__shadow__::__RPTrackCandidate, weight_), ::Reflex::PRIVATE)
  .AddDataMember(type_296, Reflex::Literal("u_id_"), OffsetOf(__shadow__::__RPTrackCandidate, u_id_), ::Reflex::PRIVATE)
  .AddDataMember(type_296, Reflex::Literal("v_id_"), OffsetOf(__shadow__::__RPTrackCandidate, v_id_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPTrackCandidate -------------------
void __RPTrackCandidate_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_19530, type_97), Reflex::Literal("InsertHits"), method_6195, 0, "vect;weight", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_19531, type_97), Reflex::Literal("InsertHits"), method_6196, 0, "vect;weight", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_19532, type_97), Reflex::Literal("InsertHits"), method_6197, 0, "data;weight", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("Fittable"), method_6199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1482), Reflex::Literal("Fittable"), method_6200, 0, "fittable", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Weight"), method_6201, 0, "weight", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Weight"), method_6202, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296), Reflex::Literal("Size"), method_6203, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819), Reflex::Literal("recHits"), method_6204, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19530), Reflex::Literal("TrackRecoHits"), method_6205, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_296, type_296), Reflex::Literal("SetUVid"), method_6206, 0, "u;v", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296), Reflex::Literal("GetUid"), method_6207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_296), Reflex::Literal("GetVid"), method_6208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TObject -------------------------------
static void constructor_6219( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TObject();
  else ::new(mem) ::TObject();
}

static void constructor_6220( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TObject(*(const ::TObject*)arg[0]);
  else ::new(mem) ::TObject(*(const ::TObject*)arg[0]);
}

static  void operator_6221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TObject*)o)->operator=)(*(const ::TObject*)arg[0]);
  else   (((::TObject*)o)->operator=)(*(const ::TObject*)arg[0]);
}

static void destructor_6222(void*, void * o, const std::vector<void*>&, void *) {
(((::TObject*)o)->::TObject::~TObject)();
}
static  void method_6223( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TObject*)o)->AppendPad)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TObject*)o)->AppendPad)((::Option_t*)arg[0]);
  }
}

static  void method_6224( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->Browse)((::TBrowser*)arg[0]);
}

static  void method_6225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->ClassName)());
  else   (((const ::TObject*)o)->ClassName)();
}

static  void method_6226( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TObject*)o)->Clear)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TObject*)o)->Clear)((::Option_t*)arg[0]);
  }
}

static  void method_6227( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->Clone)());
    else     (((const ::TObject*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->Clone)((const char*)arg[0]));
    else     (((const ::TObject*)o)->Clone)((const char*)arg[0]);
  }
}

static  void method_6228( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::TObject*)o)->Compare)((const ::TObject*)arg[0]));
  else   (((const ::TObject*)o)->Compare)((const ::TObject*)arg[0]);
}

static  void method_6229( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TObject*)o)->Copy)(*(::TObject*)arg[0]);
}

static  void method_6230( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TObject*)o)->Delete)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TObject*)o)->Delete)((::Option_t*)arg[0]);
  }
}

static  void method_6231( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((::TObject*)o)->DistancetoPrimitive)(*(::Int_t*)arg[0],
    *(::Int_t*)arg[1]));
  else   (((::TObject*)o)->DistancetoPrimitive)(*(::Int_t*)arg[0],
    *(::Int_t*)arg[1]);
}

static  void method_6232( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TObject*)o)->Draw)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TObject*)o)->Draw)((::Option_t*)arg[0]);
  }
}

static  void method_6233( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TObject*)o)->DrawClass)();
}

static  void method_6234( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->DrawClone)());
    else     (((const ::TObject*)o)->DrawClone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->DrawClone)((::Option_t*)arg[0]));
    else     (((const ::TObject*)o)->DrawClone)((::Option_t*)arg[0]);
  }
}

static  void method_6235( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TObject*)o)->Dump)();
}

static  void method_6236( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::TObject*)o)->Execute)((const char*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::TObject*)o)->Execute)((const char*)arg[0],
      (const char*)arg[1],
      (::Int_t*)arg[2]);
  }
}

static  void method_6237( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::TObject*)o)->Execute)((::TMethod*)arg[0],
      (::TObjArray*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::TObject*)o)->Execute)((::TMethod*)arg[0],
      (::TObjArray*)arg[1],
      (::Int_t*)arg[2]);
  }
}

static  void method_6238( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->ExecuteEvent)(*(::Int_t*)arg[0],
    *(::Int_t*)arg[1],
    *(::Int_t*)arg[2]);
}

static  void method_6239( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->FindObject)((const char*)arg[0]));
  else   (((const ::TObject*)o)->FindObject)((const char*)arg[0]);
}

static  void method_6240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->FindObject)((const ::TObject*)arg[0]));
  else   (((const ::TObject*)o)->FindObject)((const ::TObject*)arg[0]);
}

static  void method_6241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->GetDrawOption)());
  else   (((const ::TObject*)o)->GetDrawOption)();
}

static  void method_6242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (UInt_t)((((const ::TObject*)o)->GetUniqueID)());
  else   (((const ::TObject*)o)->GetUniqueID)();
}

static  void method_6243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->GetName)());
  else   (((const ::TObject*)o)->GetName)();
}

static  void method_6244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->GetIconName)());
  else   (((const ::TObject*)o)->GetIconName)();
}

static  void method_6245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->GetOption)());
  else   (((const ::TObject*)o)->GetOption)();
}

static  void method_6246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->GetObjectInfo)(*(::Int_t*)arg[0],
    *(::Int_t*)arg[1]));
  else   (((const ::TObject*)o)->GetObjectInfo)(*(::Int_t*)arg[0],
    *(::Int_t*)arg[1]);
}

static  void method_6247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->GetTitle)());
  else   (((const ::TObject*)o)->GetTitle)();
}

static  void method_6248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TObject*)o)->HandleTimer)((::TTimer*)arg[0]));
  else   (((::TObject*)o)->HandleTimer)((::TTimer*)arg[0]);
}

static  void method_6249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (ULong_t)((((const ::TObject*)o)->Hash)());
  else   (((const ::TObject*)o)->Hash)();
}

static  void method_6250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::TObject*)o)->InheritsFrom)((const char*)arg[0]));
  else   (((const ::TObject*)o)->InheritsFrom)((const char*)arg[0]);
}

static  void method_6251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::TObject*)o)->InheritsFrom)((const ::TClass*)arg[0]));
  else   (((const ::TObject*)o)->InheritsFrom)((const ::TClass*)arg[0]);
}

static  void method_6252( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TObject*)o)->Inspect)();
}

static  void method_6253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::TObject*)o)->IsFolder)());
  else   (((const ::TObject*)o)->IsFolder)();
}

static  void method_6254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::TObject*)o)->IsEqual)((const ::TObject*)arg[0]));
  else   (((const ::TObject*)o)->IsEqual)((const ::TObject*)arg[0]);
}

static  void method_6255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::TObject*)o)->IsSortable)());
  else   (((const ::TObject*)o)->IsSortable)();
}

static  void method_6256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::TObject*)o)->IsOnHeap)());
  else   (((const ::TObject*)o)->IsOnHeap)();
}

static  void method_6257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::TObject*)o)->IsZombie)());
  else   (((const ::TObject*)o)->IsZombie)();
}

static  void method_6258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TObject*)o)->Notify)());
  else   (((::TObject*)o)->Notify)();
}

static  void method_6259( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TObject*)o)->ls)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TObject*)o)->ls)((::Option_t*)arg[0]);
  }
}

static  void method_6260( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TObject*)o)->Paint)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TObject*)o)->Paint)((::Option_t*)arg[0]);
  }
}

static  void method_6261( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TObject*)o)->Pop)();
}

static  void method_6262( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TObject*)o)->Print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TObject*)o)->Print)((::Option_t*)arg[0]);
  }
}

static  void method_6263( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((::TObject*)o)->Read)((const char*)arg[0]));
  else   (((::TObject*)o)->Read)((const char*)arg[0]);
}

static  void method_6264( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->RecursiveRemove)((::TObject*)arg[0]);
}

static  void method_6265( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TObject*)o)->SaveAs)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TObject*)o)->SaveAs)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::TObject*)o)->SaveAs)((const char*)arg[0],
      (::Option_t*)arg[1]);
  }
}

static  void method_6266( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::TObject*)o)->SavePrimitive)(*(::std::ostream*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::TObject*)o)->SavePrimitive)(*(::std::ostream*)arg[0],
      (::Option_t*)arg[1]);
  }
}

static  void method_6267( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::TObject*)o)->SetDrawOption)();
  }
  else if ( arg.size() == 1 ) { 
    (((::TObject*)o)->SetDrawOption)((::Option_t*)arg[0]);
  }
}

static  void method_6268( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->SetUniqueID)(*(::UInt_t*)arg[0]);
}

static  void method_6269( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TObject*)o)->UseCurrentStyle)();
}

static  void method_6270( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (Int_t)((((::TObject*)o)->Write)());
    else     (((::TObject*)o)->Write)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (Int_t)((((::TObject*)o)->Write)((const char*)arg[0]));
    else     (((::TObject*)o)->Write)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Int_t)((((::TObject*)o)->Write)((const char*)arg[0],
      *(::Int_t*)arg[1]));
    else     (((::TObject*)o)->Write)((const char*)arg[0],
      *(::Int_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((::TObject*)o)->Write)((const char*)arg[0],
      *(::Int_t*)arg[1],
      *(::Int_t*)arg[2]));
    else     (((::TObject*)o)->Write)((const char*)arg[0],
      *(::Int_t*)arg[1],
      *(::Int_t*)arg[2]);
  }
}

static  void method_6271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::TObject*)o)->Write)());
    else     (((const ::TObject*)o)->Write)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::TObject*)o)->Write)((const char*)arg[0]));
    else     (((const ::TObject*)o)->Write)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::TObject*)o)->Write)((const char*)arg[0],
      *(::Int_t*)arg[1]));
    else     (((const ::TObject*)o)->Write)((const char*)arg[0],
      *(::Int_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::TObject*)o)->Write)((const char*)arg[0],
      *(::Int_t*)arg[1],
      *(::Int_t*)arg[2]));
    else     (((const ::TObject*)o)->Write)((const char*)arg[0],
      *(::Int_t*)arg[1],
      *(::Int_t*)arg[2]);
  }
}

static  void operator_6272( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TObject*)o)->operator new)(*(::size_t*)arg[0]));
  else   (((::TObject*)o)->operator new)(*(::size_t*)arg[0]);
}

static  void operator_6273( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TObject*)o)->operator new [])(*(::size_t*)arg[0]));
  else   (((::TObject*)o)->operator new [])(*(::size_t*)arg[0]);
}

static  void operator_6274( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TObject*)o)->operator new)(*(::size_t*)arg[0],
    (void*)arg[1]));
  else   (((::TObject*)o)->operator new)(*(::size_t*)arg[0],
    (void*)arg[1]);
}

static  void operator_6275( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TObject*)o)->operator new [])(*(::size_t*)arg[0],
    (void*)arg[1]));
  else   (((::TObject*)o)->operator new [])(*(::size_t*)arg[0],
    (void*)arg[1]);
}

static  void operator_6276( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->operator delete)((void*)arg[0]);
}

static  void operator_6277( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->operator delete [])((void*)arg[0]);
}

static  void operator_6278( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->operator delete)((void*)arg[0],
    (void*)arg[1]);
}

static  void operator_6279( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->operator delete [])((void*)arg[0],
    (void*)arg[1]);
}

static  void method_6280( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->SetBit)(*(::UInt_t*)arg[0],
    *(::Bool_t*)arg[1]);
}

static  void method_6281( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->SetBit)(*(::UInt_t*)arg[0]);
}

static  void method_6282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->ResetBit)(*(::UInt_t*)arg[0]);
}

static  void method_6283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::TObject*)o)->TestBit)(*(::UInt_t*)arg[0]));
  else   (((const ::TObject*)o)->TestBit)(*(::UInt_t*)arg[0]);
}

static  void method_6284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::TObject*)o)->TestBits)(*(::UInt_t*)arg[0]));
  else   (((const ::TObject*)o)->TestBits)(*(::UInt_t*)arg[0]);
}

static  void method_6285( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->InvertBit)(*(::UInt_t*)arg[0]);
}

static  void method_6286( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TObject*)o)->Info)((const char*)arg[0],
    (const char*)arg[1]);
}

static  void method_6287( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TObject*)o)->Warning)((const char*)arg[0],
    (const char*)arg[1]);
}

static  void method_6288( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TObject*)o)->Error)((const char*)arg[0],
    (const char*)arg[1]);
}

static  void method_6289( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TObject*)o)->SysError)((const char*)arg[0],
    (const char*)arg[1]);
}

static  void method_6290( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TObject*)o)->Fatal)((const char*)arg[0],
    (const char*)arg[1]);
}

static  void method_6291( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TObject*)o)->AbstractMethod)((const char*)arg[0]);
}

static  void method_6292( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TObject*)o)->MayNotUse)((const char*)arg[0]);
}

static  void method_6293( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TObject*)o)->Obsolete)((const char*)arg[0],
    (const char*)arg[1],
    (const char*)arg[2]);
}

static  void method_6294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Long_t)((((::TObject*)o)->GetDtorOnly)());
  else   (((::TObject*)o)->GetDtorOnly)();
}

static  void method_6295( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->SetDtorOnly)((void*)arg[0]);
}

static  void method_6296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::TObject*)o)->GetObjectStat)());
  else   (((::TObject*)o)->GetObjectStat)();
}

static  void method_6297( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->SetObjectStat)(*(::Bool_t*)arg[0]);
}

static  void method_6298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TObject*)o)->Class)());
  else   (((::TObject*)o)->Class)();
}

static  void method_6299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TObject*)o)->Class_Name)());
  else   (((::TObject*)o)->Class_Name)();
}

static  void method_6300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TObject*)o)->Class_Version)());
  else   (((::TObject*)o)->Class_Version)();
}

static  void method_6301( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TObject*)o)->Dictionary)();
}

static  void method_6302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TObject*)o)->IsA)());
  else   (((const ::TObject*)o)->IsA)();
}

static  void method_6303( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6304( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6305( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TObject*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TObject*)o)->DeclFileName)());
  else   (((::TObject*)o)->DeclFileName)();
}

static  void method_6307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TObject*)o)->ImplFileLine)());
  else   (((::TObject*)o)->ImplFileLine)();
}

static  void method_6308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TObject*)o)->ImplFileName)());
  else   (((::TObject*)o)->ImplFileName)();
}

static  void method_6309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TObject*)o)->DeclFileLine)());
  else   (((::TObject*)o)->DeclFileLine)();
}

static void method_newdel_1672( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TObject >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TObject >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TObject >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TObject >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TObject >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TObject -------------------------------
void __TObject_db_datamem(Reflex::Class*);
void __TObject_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TObject_datamem_bld(&__TObject_db_datamem);
Reflex::GenreflexMemberBuilder __TObject_funcmem_bld(&__TObject_db_funcmem);
void __TObject_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TObject"), typeid(::TObject), sizeof(::TObject), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TObject::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 0)
  .AddEnum(Reflex::Literal("TObject::EStatusBits"), Reflex::Literal("kCanDelete=1;kMustCleanup=8;kObjInCanvas=8;kIsReferenced=16;kHasUUID=32;kCannotPick=64;kNoContextMenu=256;kInvalidObject=8192"), &typeid(TObject::EStatusBits), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_87"), Reflex::Literal("kIsOnHeap=16777216;kNotDeleted=33554432;kZombie=67108864;kBitMask=16777215"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_88"), Reflex::Literal("kSingleKey=1;kOverwrite=2;kWriteDelete=4"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TObject"), constructor_6219, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19533), Reflex::Literal("TObject"), constructor_6220, 0, "object", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TObject"), destructor_6222, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1672, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TObject_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TObject_funcmem_bld);
}

//------Delayed data member builder for class TObject -------------------
void __TObject_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1166, Reflex::Literal("fUniqueID"), OffsetOf(__shadow__::__TObject, fUniqueID), ::Reflex::PRIVATE)
  .AddDataMember(type_1166, Reflex::Literal("fBits"), OffsetOf(__shadow__::__TObject, fBits), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TObject -------------------
void __TObject_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19378, type_19533), Reflex::Literal("operator="), operator_6221, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16705), Reflex::Literal("AppendPad"), method_6223, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_19249), Reflex::Literal("Browse"), method_6224, 0, "b", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3338), Reflex::Literal("ClassName"), method_6225, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16705), Reflex::Literal("Clear"), method_6226, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11323, type_3338), Reflex::Literal("Clone"), method_6227, 0, "newname=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_353, type_5611), Reflex::Literal("Compare"), method_6228, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_19378), Reflex::Literal("Copy"), method_6229, 0, "object", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16705), Reflex::Literal("Delete"), method_6230, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_353, type_353, type_353), Reflex::Literal("DistancetoPrimitive"), method_6231, 0, "px;py", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16705), Reflex::Literal("Draw"), method_6232, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("DrawClass"), method_6233, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11323, type_16705), Reflex::Literal("DrawClone"), method_6234, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("Dump"), method_6235, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3338, type_3338, type_16711), Reflex::Literal("Execute"), method_6236, 0, "method;params;error=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_19534, type_16816, type_16711), Reflex::Literal("Execute"), method_6237, 0, "method;params;error=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_353, type_353, type_353), Reflex::Literal("ExecuteEvent"), method_6238, 0, "event;px;py", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11323, type_3338), Reflex::Literal("FindObject"), method_6239, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11323, type_5611), Reflex::Literal("FindObject"), method_6240, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16705), Reflex::Literal("GetDrawOption"), method_6241, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("GetUniqueID"), method_6242, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3338), Reflex::Literal("GetName"), method_6243, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3338), Reflex::Literal("GetIconName"), method_6244, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16705), Reflex::Literal("GetOption"), method_6245, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1227, type_353, type_353), Reflex::Literal("GetObjectInfo"), method_6246, 0, "px;py", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3338), Reflex::Literal("GetTitle"), method_6247, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483, type_19535), Reflex::Literal("HandleTimer"), method_6248, 0, "timer", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2318), Reflex::Literal("Hash"), method_6249, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483, type_3338), Reflex::Literal("InheritsFrom"), method_6250, 0, "classname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483, type_19142), Reflex::Literal("InheritsFrom"), method_6251, 0, "cl", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("Inspect"), method_6252, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483), Reflex::Literal("IsFolder"), method_6253, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483, type_5611), Reflex::Literal("IsEqual"), method_6254, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483), Reflex::Literal("IsSortable"), method_6255, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483), Reflex::Literal("IsOnHeap"), method_6256, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483), Reflex::Literal("IsZombie"), method_6257, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483), Reflex::Literal("Notify"), method_6258, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16705), Reflex::Literal("ls"), method_6259, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16705), Reflex::Literal("Paint"), method_6260, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("Pop"), method_6261, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16705), Reflex::Literal("Print"), method_6262, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_353, type_3338), Reflex::Literal("Read"), method_6263, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_11323), Reflex::Literal("RecursiveRemove"), method_6264, 0, "obj", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3338, type_16705), Reflex::Literal("SaveAs"), method_6265, 0, "filename=\"\";option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_5604, type_16705), Reflex::Literal("SavePrimitive"), method_6266, 0, "out;option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16705), Reflex::Literal("SetDrawOption"), method_6267, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1166), Reflex::Literal("SetUniqueID"), method_6268, 0, "uid", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("UseCurrentStyle"), method_6269, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_353, type_3338, type_353, type_353), Reflex::Literal("Write"), method_6270, 0, "name=0;option=0;bufsize=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_353, type_3338, type_353, type_353), Reflex::Literal("Write"), method_6271, 0, "name=0;option=0;bufsize=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_594, type_1975), Reflex::Literal("operator new"), operator_6272, 0, "sz", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_594, type_1975), Reflex::Literal("operator new []"), operator_6273, 0, "sz", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_594, type_1975, type_594), Reflex::Literal("operator new"), operator_6274, 0, "sz;vp", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_594, type_1975, type_594), Reflex::Literal("operator new []"), operator_6275, 0, "sz;vp", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_594), Reflex::Literal("operator delete"), operator_6276, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_594), Reflex::Literal("operator delete []"), operator_6277, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_594, type_594), Reflex::Literal("operator delete"), operator_6278, 0, "ptr;vp", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_594, type_594), Reflex::Literal("operator delete []"), operator_6279, 0, "ptr;vp", ::Reflex::PUBLIC | ::Reflex::STATIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1166, type_1483), Reflex::Literal("SetBit"), method_6280, 0, "f;set", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1166), Reflex::Literal("SetBit"), method_6281, 0, "f", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1166), Reflex::Literal("ResetBit"), method_6282, 0, "f", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483, type_1166), Reflex::Literal("TestBit"), method_6283, 0, "f", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_353, type_1166), Reflex::Literal("TestBits"), method_6284, 0, "f", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1166), Reflex::Literal("InvertBit"), method_6285, 0, "f", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3338, type_3338), Reflex::Literal("Info"), method_6286, 0, "method;msgfmt", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3338, type_3338), Reflex::Literal("Warning"), method_6287, 0, "method;msgfmt", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3338, type_3338), Reflex::Literal("Error"), method_6288, 0, "method;msgfmt", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3338, type_3338), Reflex::Literal("SysError"), method_6289, 0, "method;msgfmt", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3338, type_3338), Reflex::Literal("Fatal"), method_6290, 0, "method;msgfmt", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3338), Reflex::Literal("AbstractMethod"), method_6291, 0, "method", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3338), Reflex::Literal("MayNotUse"), method_6292, 0, "method", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3338, type_3338, type_3338), Reflex::Literal("Obsolete"), method_6293, 0, "method;asOfVers;removedFromVers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_979), Reflex::Literal("GetDtorOnly"), method_6294, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_594), Reflex::Literal("SetDtorOnly"), method_6295, 0, "obj", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483), Reflex::Literal("GetObjectStat"), method_6296, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_1483), Reflex::Literal("SetObjectStat"), method_6297, 0, "stat", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16702), Reflex::Literal("Class"), method_6298, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3338), Reflex::Literal("Class_Name"), method_6299, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2224), Reflex::Literal("Class_Version"), method_6300, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("Dictionary"), method_6301, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16702), Reflex::Literal("IsA"), method_6302, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16723), Reflex::Literal("ShowMembers"), method_6303, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_5609), Reflex::Literal("Streamer"), method_6304, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_5609), Reflex::Literal("StreamerNVirtual"), method_6305, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3338), Reflex::Literal("DeclFileName"), method_6306, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65), Reflex::Literal("ImplFileLine"), method_6307, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3338), Reflex::Literal("ImplFileName"), method_6308, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65), Reflex::Literal("DeclFileLine"), method_6309, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RP2DHit -------------------------------
static void destructor_6400(void*, void * o, const std::vector<void*>&, void *) {
(((::RP2DHit*)o)->::RP2DHit::~RP2DHit)();
}
static  void operator_6401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RP2DHit*)o)->operator=)(*(const ::RP2DHit*)arg[0]);
  else   (((::RP2DHit*)o)->operator=)(*(const ::RP2DHit*)arg[0]);
}

static void constructor_6402( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RP2DHit(*(const ::RP2DHit*)arg[0]);
  else ::new(mem) ::RP2DHit(*(const ::RP2DHit*)arg[0]);
}

static void constructor_6403( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RP2DHit();
  else ::new(mem) ::RP2DHit();
}

static void constructor_6404( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RP2DHit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  else ::new(mem) ::RP2DHit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RP2DHit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
  else ::new(mem) ::RP2DHit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
  }
}

static  void method_6405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RP2DHit*)o)->X)());
  else   (((const ::RP2DHit*)o)->X)();
}

static  void method_6406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RP2DHit*)o)->Y)());
  else   (((const ::RP2DHit*)o)->Y)();
}

static  void method_6407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RP2DHit*)o)->Vx)());
  else   (((const ::RP2DHit*)o)->Vx)();
}

static  void method_6408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RP2DHit*)o)->Vy)());
  else   (((const ::RP2DHit*)o)->Vy)();
}

static  void method_6409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RP2DHit*)o)->Z)());
  else   (((const ::RP2DHit*)o)->Z)();
}

static  void method_6410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RP2DHit*)o)->Sx)());
  else   (((const ::RP2DHit*)o)->Sx)();
}

static  void method_6411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RP2DHit*)o)->Sy)());
  else   (((const ::RP2DHit*)o)->Sy)();
}

static  void method_6412( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RP2DHit*)o)->X)(*(double*)arg[0]);
}

static  void method_6413( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RP2DHit*)o)->Y)(*(double*)arg[0]);
}

static  void method_6414( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RP2DHit*)o)->Vx)(*(double*)arg[0]);
}

static  void method_6415( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RP2DHit*)o)->Vy)(*(double*)arg[0]);
}

static  void method_6416( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RP2DHit*)o)->Z)(*(double*)arg[0]);
}

static void method_newdel_1741( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RP2DHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RP2DHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RP2DHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RP2DHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RP2DHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RP2DHit -------------------------------
void __RP2DHit_db_datamem(Reflex::Class*);
void __RP2DHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RP2DHit_datamem_bld(&__RP2DHit_db_datamem);
Reflex::GenreflexMemberBuilder __RP2DHit_funcmem_bld(&__RP2DHit_db_funcmem);
void __RP2DHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RP2DHit"), typeid(::RP2DHit), sizeof(::RP2DHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RP2DHit"), destructor_6400, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19543, type_5608), Reflex::Literal("operator="), operator_6401, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5608), Reflex::Literal("RP2DHit"), constructor_6402, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RP2DHit"), constructor_6403, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_97, type_97, type_97, type_97, type_97), Reflex::Literal("RP2DHit"), constructor_6404, 0, "x;y;vx;vy;z=0.0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1741, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RP2DHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RP2DHit_funcmem_bld);
}

//------Delayed data member builder for class RP2DHit -------------------
void __RP2DHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_97, Reflex::Literal("x_"), OffsetOf(__shadow__::__RP2DHit, x_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("y_"), OffsetOf(__shadow__::__RP2DHit, y_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("z_"), OffsetOf(__shadow__::__RP2DHit, z_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("vx_"), OffsetOf(__shadow__::__RP2DHit, vx_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("vy_"), OffsetOf(__shadow__::__RP2DHit, vy_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RP2DHit -------------------
void __RP2DHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("X"), method_6405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Y"), method_6406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Vx"), method_6407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Vy"), method_6408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Z"), method_6409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Sx"), method_6410, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Sy"), method_6411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("X"), method_6412, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Y"), method_6413, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Vx"), method_6414, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Vy"), method_6415, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("Z"), method_6416, 0, "val", ::Reflex::PUBLIC);
}
//------Stub functions for class RP2DHitDebug -------------------------------
static void destructor_6782(void*, void * o, const std::vector<void*>&, void *) {
(((::RP2DHitDebug*)o)->::RP2DHitDebug::~RP2DHitDebug)();
}
static  void operator_6783( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RP2DHitDebug*)o)->operator=)(*(const ::RP2DHitDebug*)arg[0]);
  else   (((::RP2DHitDebug*)o)->operator=)(*(const ::RP2DHitDebug*)arg[0]);
}

static void constructor_6784( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RP2DHitDebug(*(const ::RP2DHitDebug*)arg[0]);
  else ::new(mem) ::RP2DHitDebug(*(const ::RP2DHitDebug*)arg[0]);
}

static void constructor_6785( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RP2DHitDebug();
  else ::new(mem) ::RP2DHitDebug();
}

static void constructor_6786( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RP2DHitDebug(*(const ::RP2DHit*)arg[0]);
  else ::new(mem) ::RP2DHitDebug(*(const ::RP2DHit*)arg[0]);
}

static  void method_6787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RP2DHitDebug*)o)->DeltaX)());
  else   (((::RP2DHitDebug*)o)->DeltaX)();
}

static  void method_6788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RP2DHitDebug*)o)->DeltaY)());
  else   (((::RP2DHitDebug*)o)->DeltaY)();
}

static  void method_6789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RP2DHitDebug*)o)->PullX)());
  else   (((::RP2DHitDebug*)o)->PullX)();
}

static  void method_6790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RP2DHitDebug*)o)->PullY)());
  else   (((::RP2DHitDebug*)o)->PullY)();
}

static  void method_6791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RP2DHitDebug*)o)->DeltaX)(*(double*)arg[0]);
}

static  void method_6792( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RP2DHitDebug*)o)->DeltaY)(*(double*)arg[0]);
}

static  void method_6793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RP2DHitDebug*)o)->PullX)(*(double*)arg[0]);
}

static  void method_6794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RP2DHitDebug*)o)->PullY)(*(double*)arg[0]);
}

static void method_newdel_1929( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RP2DHitDebug >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RP2DHitDebug >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RP2DHitDebug >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RP2DHitDebug >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RP2DHitDebug >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RP2DHit")), ::Reflex::BaseOffset< ::RP2DHitDebug,::RP2DHit >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RP2DHitDebug -------------------------------
void __RP2DHitDebug_db_datamem(Reflex::Class*);
void __RP2DHitDebug_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RP2DHitDebug_datamem_bld(&__RP2DHitDebug_db_datamem);
Reflex::GenreflexMemberBuilder __RP2DHitDebug_funcmem_bld(&__RP2DHitDebug_db_funcmem);
void __RP2DHitDebug_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RP2DHitDebug"), typeid(::RP2DHitDebug), sizeof(::RP2DHitDebug), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1741, ::Reflex::BaseOffset< ::RP2DHitDebug, ::RP2DHit >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RP2DHitDebug"), destructor_6782, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21916, type_19330), Reflex::Literal("operator="), operator_6783, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19330), Reflex::Literal("RP2DHitDebug"), constructor_6784, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RP2DHitDebug"), constructor_6785, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5608), Reflex::Literal("RP2DHitDebug"), constructor_6786, 0, "hit", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1929, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RP2DHitDebug_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RP2DHitDebug_funcmem_bld);
}

//------Delayed data member builder for class RP2DHitDebug -------------------
void __RP2DHitDebug_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_97, Reflex::Literal("d_x_"), OffsetOf(__shadow__::__RP2DHitDebug, d_x_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("d_y_"), OffsetOf(__shadow__::__RP2DHitDebug, d_y_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("pull_x_"), OffsetOf(__shadow__::__RP2DHitDebug, pull_x_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("pull_y_"), OffsetOf(__shadow__::__RP2DHitDebug, pull_y_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RP2DHitDebug -------------------
void __RP2DHitDebug_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("DeltaX"), method_6787, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("DeltaY"), method_6788, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("PullX"), method_6789, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("PullY"), method_6790, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("DeltaX"), method_6791, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("DeltaY"), method_6792, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("PullX"), method_6793, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_97), Reflex::Literal("PullY"), method_6794, 0, "val", ::Reflex::PUBLIC);
}
//------Stub functions for class RPStationTrackFit -------------------------------
static void destructor_6826(void*, void * o, const std::vector<void*>&, void *) {
(((::RPStationTrackFit*)o)->::RPStationTrackFit::~RPStationTrackFit)();
}
static  void operator_6827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPStationTrackFit*)o)->operator=)(*(const ::RPStationTrackFit*)arg[0]);
  else   (((::RPStationTrackFit*)o)->operator=)(*(const ::RPStationTrackFit*)arg[0]);
}

static void constructor_6828( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPStationTrackFit(*(const ::RPStationTrackFit*)arg[0]);
  else ::new(mem) ::RPStationTrackFit(*(const ::RPStationTrackFit*)arg[0]);
}

static  void method_6829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPStationTrackFit*)o)->ax_unc)());
  else   (((::RPStationTrackFit*)o)->ax_unc)();
}

static  void method_6830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPStationTrackFit*)o)->ay_unc)());
  else   (((::RPStationTrackFit*)o)->ay_unc)();
}

static  void method_6831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPStationTrackFit*)o)->bx_unc)());
  else   (((::RPStationTrackFit*)o)->bx_unc)();
}

static  void method_6832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((::RPStationTrackFit*)o)->by_unc)());
  else   (((::RPStationTrackFit*)o)->by_unc)();
}

static void constructor_6833( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPStationTrackFit();
  else ::new(mem) ::RPStationTrackFit();
}

static void method_newdel_1969( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPStationTrackFit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPStationTrackFit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPStationTrackFit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPStationTrackFit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPStationTrackFit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPStationTrackFit -------------------------------
void __RPStationTrackFit_db_datamem(Reflex::Class*);
void __RPStationTrackFit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPStationTrackFit_datamem_bld(&__RPStationTrackFit_db_datamem);
Reflex::GenreflexMemberBuilder __RPStationTrackFit_funcmem_bld(&__RPStationTrackFit_db_funcmem);
void __RPStationTrackFit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPStationTrackFit"), typeid(::RPStationTrackFit), sizeof(::RPStationTrackFit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPStationTrackFit"), destructor_6826, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11846, type_11848), Reflex::Literal("operator="), operator_6827, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11848), Reflex::Literal("RPStationTrackFit"), constructor_6828, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPStationTrackFit"), constructor_6833, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1969, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPStationTrackFit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPStationTrackFit_funcmem_bld);
}

//------Delayed data member builder for class RPStationTrackFit -------------------
void __RPStationTrackFit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_97, Reflex::Literal("ax"), OffsetOf(__shadow__::__RPStationTrackFit, ax), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("ay"), OffsetOf(__shadow__::__RPStationTrackFit, ay), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("bx"), OffsetOf(__shadow__::__RPStationTrackFit, bx), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("by"), OffsetOf(__shadow__::__RPStationTrackFit, by), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("z0"), OffsetOf(__shadow__::__RPStationTrackFit, z0), ::Reflex::PUBLIC)
  .AddDataMember(type_995, Reflex::Literal("covarianceMatrix"), OffsetOf(__shadow__::__RPStationTrackFit, covarianceMatrix), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("chiSq"), OffsetOf(__shadow__::__RPStationTrackFit, chiSq), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("ndf"), OffsetOf(__shadow__::__RPStationTrackFit, ndf), ::Reflex::PUBLIC)
  .AddDataMember(type_1482, Reflex::Literal("valid"), OffsetOf(__shadow__::__RPStationTrackFit, valid), ::Reflex::PUBLIC)
  .AddDataMember(type_2853, Reflex::Literal("hits"), OffsetOf(__shadow__::__RPStationTrackFit, hits), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPStationTrackFit -------------------
void __RPStationTrackFit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ax_unc"), method_6829, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("ay_unc"), method_6830, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("bx_unc"), method_6831, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("by_unc"), method_6832, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class TVector3 -------------------------------
static void constructor_7153( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TVector3();
  else ::new(mem) ::TVector3();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TVector3(*(::Double_t*)arg[0]);
  else ::new(mem) ::TVector3(*(::Double_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TVector3(*(::Double_t*)arg[0],
      *(::Double_t*)arg[1]);
  else ::new(mem) ::TVector3(*(::Double_t*)arg[0],
      *(::Double_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TVector3(*(::Double_t*)arg[0],
      *(::Double_t*)arg[1],
      *(::Double_t*)arg[2]);
  else ::new(mem) ::TVector3(*(::Double_t*)arg[0],
      *(::Double_t*)arg[1],
      *(::Double_t*)arg[2]);
  }
}

static void constructor_7154( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TVector3((const ::Double_t*)arg[0]);
  else ::new(mem) ::TVector3((const ::Double_t*)arg[0]);
}

static void constructor_7155( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TVector3((const ::Float_t*)arg[0]);
  else ::new(mem) ::TVector3((const ::Float_t*)arg[0]);
}

static void constructor_7156( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TVector3(*(const ::TVector3*)arg[0]);
  else ::new(mem) ::TVector3(*(const ::TVector3*)arg[0]);
}

static void destructor_7157(void*, void * o, const std::vector<void*>&, void *) {
(((::TVector3*)o)->::TVector3::~TVector3)();
}
static  void operator_7158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->operator())(*(int*)arg[0]));
  else   (((const ::TVector3*)o)->operator())(*(int*)arg[0]);
}

static  void operator_7159( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->operator[])(*(int*)arg[0]));
  else   (((const ::TVector3*)o)->operator[])(*(int*)arg[0]);
}

static  void operator_7160( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TVector3*)o)->operator())(*(int*)arg[0]);
  else   (((::TVector3*)o)->operator())(*(int*)arg[0]);
}

static  void operator_7161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TVector3*)o)->operator[])(*(int*)arg[0]);
  else   (((::TVector3*)o)->operator[])(*(int*)arg[0]);
}

static  void method_7162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->x)());
  else   (((const ::TVector3*)o)->x)();
}

static  void method_7163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->y)());
  else   (((const ::TVector3*)o)->y)();
}

static  void method_7164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->z)());
  else   (((const ::TVector3*)o)->z)();
}

static  void method_7165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->X)());
  else   (((const ::TVector3*)o)->X)();
}

static  void method_7166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Y)());
  else   (((const ::TVector3*)o)->Y)();
}

static  void method_7167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Z)());
  else   (((const ::TVector3*)o)->Z)();
}

static  void method_7168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Px)());
  else   (((const ::TVector3*)o)->Px)();
}

static  void method_7169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Py)());
  else   (((const ::TVector3*)o)->Py)();
}

static  void method_7170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Pz)());
  else   (((const ::TVector3*)o)->Pz)();
}

static  void method_7171( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->SetX)(*(::Double_t*)arg[0]);
}

static  void method_7172( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->SetY)(*(::Double_t*)arg[0]);
}

static  void method_7173( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->SetZ)(*(::Double_t*)arg[0]);
}

static  void method_7174( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->SetXYZ)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_7175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->SetPtEtaPhi)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_7176( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->SetPtThetaPhi)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_7177( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TVector3*)o)->GetXYZ)((::Double_t*)arg[0]);
}

static  void method_7178( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TVector3*)o)->GetXYZ)((::Float_t*)arg[0]);
}

static  void method_7179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Phi)());
  else   (((const ::TVector3*)o)->Phi)();
}

static  void method_7180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Theta)());
  else   (((const ::TVector3*)o)->Theta)();
}

static  void method_7181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->CosTheta)());
  else   (((const ::TVector3*)o)->CosTheta)();
}

static  void method_7182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Mag2)());
  else   (((const ::TVector3*)o)->Mag2)();
}

static  void method_7183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Mag)());
  else   (((const ::TVector3*)o)->Mag)();
}

static  void method_7184( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->SetPhi)(*(::Double_t*)arg[0]);
}

static  void method_7185( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->SetTheta)(*(::Double_t*)arg[0]);
}

static  void method_7186( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->SetMag)(*(::Double_t*)arg[0]);
}

static  void method_7187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Perp2)());
  else   (((const ::TVector3*)o)->Perp2)();
}

static  void method_7188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Pt)());
  else   (((const ::TVector3*)o)->Pt)();
}

static  void method_7189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Perp)());
  else   (((const ::TVector3*)o)->Perp)();
}

static  void method_7190( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->SetPerp)(*(::Double_t*)arg[0]);
}

static  void method_7191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Perp2)(*(const ::TVector3*)arg[0]));
  else   (((const ::TVector3*)o)->Perp2)(*(const ::TVector3*)arg[0]);
}

static  void method_7192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Pt)(*(const ::TVector3*)arg[0]));
  else   (((const ::TVector3*)o)->Pt)(*(const ::TVector3*)arg[0]);
}

static  void method_7193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Perp)(*(const ::TVector3*)arg[0]));
  else   (((const ::TVector3*)o)->Perp)(*(const ::TVector3*)arg[0]);
}

static  void method_7194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->DeltaPhi)(*(const ::TVector3*)arg[0]));
  else   (((const ::TVector3*)o)->DeltaPhi)(*(const ::TVector3*)arg[0]);
}

static  void method_7195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->DeltaR)(*(const ::TVector3*)arg[0]));
  else   (((const ::TVector3*)o)->DeltaR)(*(const ::TVector3*)arg[0]);
}

static  void method_7196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->DrEtaPhi)(*(const ::TVector3*)arg[0]));
  else   (((const ::TVector3*)o)->DrEtaPhi)(*(const ::TVector3*)arg[0]);
}

static  void method_7197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TVector2)((((const ::TVector3*)o)->EtaPhiVector)());
  else   (((const ::TVector3*)o)->EtaPhiVector)();
}

static  void method_7198( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->SetMagThetaPhi)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void operator_7199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TVector3*)o)->operator=)(*(const ::TVector3*)arg[0]);
  else   (((::TVector3*)o)->operator=)(*(const ::TVector3*)arg[0]);
}

static  void operator_7200( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::TVector3*)o)->operator==)(*(const ::TVector3*)arg[0]));
  else   (((const ::TVector3*)o)->operator==)(*(const ::TVector3*)arg[0]);
}

static  void operator_7201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::TVector3*)o)->operator!=)(*(const ::TVector3*)arg[0]));
  else   (((const ::TVector3*)o)->operator!=)(*(const ::TVector3*)arg[0]);
}

static  void operator_7202( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TVector3*)o)->operator+=)(*(const ::TVector3*)arg[0]);
  else   (((::TVector3*)o)->operator+=)(*(const ::TVector3*)arg[0]);
}

static  void operator_7203( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TVector3*)o)->operator-=)(*(const ::TVector3*)arg[0]);
  else   (((::TVector3*)o)->operator-=)(*(const ::TVector3*)arg[0]);
}

static  void operator_7204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TVector3*)o)->operator-)());
  else   (((const ::TVector3*)o)->operator-)();
}

static  void operator_7205( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TVector3*)o)->operator*=)(*(::Double_t*)arg[0]);
  else   (((::TVector3*)o)->operator*=)(*(::Double_t*)arg[0]);
}

static  void method_7206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TVector3*)o)->Unit)());
  else   (((const ::TVector3*)o)->Unit)();
}

static  void method_7207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TVector3*)o)->Orthogonal)());
  else   (((const ::TVector3*)o)->Orthogonal)();
}

static  void method_7208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Dot)(*(const ::TVector3*)arg[0]));
  else   (((const ::TVector3*)o)->Dot)(*(const ::TVector3*)arg[0]);
}

static  void method_7209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::TVector3*)o)->Cross)(*(const ::TVector3*)arg[0]));
  else   (((const ::TVector3*)o)->Cross)(*(const ::TVector3*)arg[0]);
}

static  void method_7210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Angle)(*(const ::TVector3*)arg[0]));
  else   (((const ::TVector3*)o)->Angle)(*(const ::TVector3*)arg[0]);
}

static  void method_7211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->PseudoRapidity)());
  else   (((const ::TVector3*)o)->PseudoRapidity)();
}

static  void method_7212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::TVector3*)o)->Eta)());
  else   (((const ::TVector3*)o)->Eta)();
}

static  void method_7213( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->RotateX)(*(::Double_t*)arg[0]);
}

static  void method_7214( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->RotateY)(*(::Double_t*)arg[0]);
}

static  void method_7215( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->RotateZ)(*(::Double_t*)arg[0]);
}

static  void method_7216( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->RotateUz)(*(const ::TVector3*)arg[0]);
}

static  void method_7217( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->Rotate)(*(::Double_t*)arg[0],
    *(const ::TVector3*)arg[1]);
}

static  void operator_7218( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TVector3*)o)->operator*=)(*(const ::TRotation*)arg[0]);
  else   (((::TVector3*)o)->operator*=)(*(const ::TRotation*)arg[0]);
}

static  void method_7219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TVector3*)o)->Transform)(*(const ::TRotation*)arg[0]);
  else   (((::TVector3*)o)->Transform)(*(const ::TRotation*)arg[0]);
}

static  void method_7220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TVector2)((((const ::TVector3*)o)->XYvector)());
  else   (((const ::TVector3*)o)->XYvector)();
}

static  void method_7221( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TVector3*)o)->Print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TVector3*)o)->Print)((::Option_t*)arg[0]);
  }
}

static  void method_7222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TVector3*)o)->Class)());
  else   (((::TVector3*)o)->Class)();
}

static  void method_7223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TVector3*)o)->Class_Name)());
  else   (((::TVector3*)o)->Class_Name)();
}

static  void method_7224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TVector3*)o)->Class_Version)());
  else   (((::TVector3*)o)->Class_Version)();
}

static  void method_7225( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TVector3*)o)->Dictionary)();
}

static  void method_7226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TVector3*)o)->IsA)());
  else   (((const ::TVector3*)o)->IsA)();
}

static  void method_7227( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7228( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7229( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TVector3*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TVector3*)o)->DeclFileName)());
  else   (((::TVector3*)o)->DeclFileName)();
}

static  void method_7231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TVector3*)o)->ImplFileLine)());
  else   (((::TVector3*)o)->ImplFileLine)();
}

static  void method_7232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TVector3*)o)->ImplFileName)());
  else   (((::TVector3*)o)->ImplFileName)();
}

static  void method_7233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TVector3*)o)->DeclFileLine)());
  else   (((::TVector3*)o)->DeclFileLine)();
}

static void constructor_x28( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TVector3();
  else ::new(mem) ::TVector3();
}

static void method_newdel_2017( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TVector3 >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TVector3 >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TVector3 >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TVector3 >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TVector3 >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TVector3,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TVector3 -------------------------------
void __TVector3_db_datamem(Reflex::Class*);
void __TVector3_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TVector3_datamem_bld(&__TVector3_db_datamem);
Reflex::GenreflexMemberBuilder __TVector3_funcmem_bld(&__TVector3_db_funcmem);
void __TVector3_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TVector3"), typeid(::TVector3), sizeof(::TVector3), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TVector3::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1672, ::Reflex::BaseOffset< ::TVector3, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_941, type_941, type_941), Reflex::Literal("TVector3"), constructor_7153, 0, "x=0.0;y=0.0;z=0.0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16725), Reflex::Literal("TVector3"), constructor_7154, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21948), Reflex::Literal("TVector3"), constructor_7155, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7363), Reflex::Literal("TVector3"), constructor_7156, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TVector3"), destructor_7157, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TVector3"), constructor_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2017, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TVector3_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TVector3_funcmem_bld);
}

//------Delayed data member builder for class TVector3 -------------------
void __TVector3_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_941, Reflex::Literal("fX"), OffsetOf(__shadow__::__TVector3, fX), ::Reflex::PRIVATE)
  .AddDataMember(type_941, Reflex::Literal("fY"), OffsetOf(__shadow__::__TVector3, fY), ::Reflex::PRIVATE)
  .AddDataMember(type_941, Reflex::Literal("fZ"), OffsetOf(__shadow__::__TVector3, fZ), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TVector3 -------------------
void __TVector3_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941, type_65), Reflex::Literal("operator()"), operator_7158, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941, type_65), Reflex::Literal("operator[]"), operator_7159, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5622, type_65), Reflex::Literal("operator()"), operator_7160, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5622, type_65), Reflex::Literal("operator[]"), operator_7161, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("x"), method_7162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("y"), method_7163, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("z"), method_7164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("X"), method_7165, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Y"), method_7166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Z"), method_7167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Px"), method_7168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Py"), method_7169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Pz"), method_7170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941), Reflex::Literal("SetX"), method_7171, 0, "xx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941), Reflex::Literal("SetY"), method_7172, 0, "yy", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941), Reflex::Literal("SetZ"), method_7173, 0, "zz", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941, type_941, type_941), Reflex::Literal("SetXYZ"), method_7174, 0, "xx;yy;zz", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941, type_941, type_941), Reflex::Literal("SetPtEtaPhi"), method_7175, 0, "pt;eta;phi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941, type_941, type_941), Reflex::Literal("SetPtThetaPhi"), method_7176, 0, "pt;theta;phi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16715), Reflex::Literal("GetXYZ"), method_7177, 0, "carray", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16724), Reflex::Literal("GetXYZ"), method_7178, 0, "carray", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Phi"), method_7179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Theta"), method_7180, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("CosTheta"), method_7181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Mag2"), method_7182, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Mag"), method_7183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941), Reflex::Literal("SetPhi"), method_7184, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941), Reflex::Literal("SetTheta"), method_7185, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941), Reflex::Literal("SetMag"), method_7186, 0, "ma", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Perp2"), method_7187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Pt"), method_7188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Perp"), method_7189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941), Reflex::Literal("SetPerp"), method_7190, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941, type_7363), Reflex::Literal("Perp2"), method_7191, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941, type_7363), Reflex::Literal("Pt"), method_7192, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941, type_7363), Reflex::Literal("Perp"), method_7193, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941, type_7363), Reflex::Literal("DeltaPhi"), method_7194, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941, type_7363), Reflex::Literal("DeltaR"), method_7195, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941, type_7363), Reflex::Literal("DrEtaPhi"), method_7196, 0, "v", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2016), Reflex::Literal("EtaPhiVector"), method_7197, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941, type_941, type_941), Reflex::Literal("SetMagThetaPhi"), method_7198, 0, "mag;theta;phi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21949, type_7363), Reflex::Literal("operator="), operator_7199, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483, type_7363), Reflex::Literal("operator=="), operator_7200, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1483, type_7363), Reflex::Literal("operator!="), operator_7201, 0, "v", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21949, type_7363), Reflex::Literal("operator+="), operator_7202, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21949, type_7363), Reflex::Literal("operator-="), operator_7203, 0, "p", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2017), Reflex::Literal("operator-"), operator_7204, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21949, type_941), Reflex::Literal("operator*="), operator_7205, 0, "a", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2017), Reflex::Literal("Unit"), method_7206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2017), Reflex::Literal("Orthogonal"), method_7207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941, type_7363), Reflex::Literal("Dot"), method_7208, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2017, type_7363), Reflex::Literal("Cross"), method_7209, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941, type_7363), Reflex::Literal("Angle"), method_7210, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("PseudoRapidity"), method_7211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941), Reflex::Literal("Eta"), method_7212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941), Reflex::Literal("RotateX"), method_7213, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941), Reflex::Literal("RotateY"), method_7214, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941), Reflex::Literal("RotateZ"), method_7215, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_7363), Reflex::Literal("RotateUz"), method_7216, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_941, type_7363), Reflex::Literal("Rotate"), method_7217, 0, ";", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21949, type_21950), Reflex::Literal("operator*="), operator_7218, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21949, type_21950), Reflex::Literal("Transform"), method_7219, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2016), Reflex::Literal("XYvector"), method_7220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16705), Reflex::Literal("Print"), method_7221, 0, "option=\"\"", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16702), Reflex::Literal("Class"), method_7222, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3338), Reflex::Literal("Class_Name"), method_7223, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2224), Reflex::Literal("Class_Version"), method_7224, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("Dictionary"), method_7225, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16702), Reflex::Literal("IsA"), method_7226, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16723), Reflex::Literal("ShowMembers"), method_7227, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_5609), Reflex::Literal("Streamer"), method_7228, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_5609), Reflex::Literal("StreamerNVirtual"), method_7229, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3338), Reflex::Literal("DeclFileName"), method_7230, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65), Reflex::Literal("ImplFileLine"), method_7231, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3338), Reflex::Literal("ImplFileName"), method_7232, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65), Reflex::Literal("DeclFileLine"), method_7233, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RPRecoElasticEvent -------------------------------
static  void operator_7347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRecoElasticEvent*)o)->operator=)(*(const ::RPRecoElasticEvent*)arg[0]);
  else   (((::RPRecoElasticEvent*)o)->operator=)(*(const ::RPRecoElasticEvent*)arg[0]);
}

static void constructor_7348( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecoElasticEvent(*(const ::RPRecoElasticEvent*)arg[0]);
  else ::new(mem) ::RPRecoElasticEvent(*(const ::RPRecoElasticEvent*)arg[0]);
}

static  void method_7349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::RPRecoElasticEvent*)o)->isValid)());
  else   (((const ::RPRecoElasticEvent*)o)->isValid)();
}

static void constructor_7350( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecoElasticEvent();
  else ::new(mem) ::RPRecoElasticEvent();
}

static void destructor_7351(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRecoElasticEvent*)o)->::RPRecoElasticEvent::~RPRecoElasticEvent)();
}
static void method_newdel_2052( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRecoElasticEvent -------------------------------
void __RPRecoElasticEvent_db_datamem(Reflex::Class*);
void __RPRecoElasticEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRecoElasticEvent_datamem_bld(&__RPRecoElasticEvent_db_datamem);
Reflex::GenreflexMemberBuilder __RPRecoElasticEvent_funcmem_bld(&__RPRecoElasticEvent_db_funcmem);
void __RPRecoElasticEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRecoElasticEvent"), typeid(::RPRecoElasticEvent), sizeof(::RPRecoElasticEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("RPRecoElasticEvent::status_type"), Reflex::Literal("sDefault=0;sOK=1;sNoRoad=2;sNoGoodRoad=3;sRejected=4"), &typeid(RPRecoElasticEvent::status_type), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("RPRecoElasticEvent::reject_type"), Reflex::Literal("rNone=0;rVertexX=1;rVertexY=2;rAngleX=4;rAngleY=8"), &typeid(RPRecoElasticEvent::reject_type), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23119, type_5605), Reflex::Literal("operator="), operator_7347, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5605), Reflex::Literal("RPRecoElasticEvent"), constructor_7348, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRecoElasticEvent"), constructor_7350, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRecoElasticEvent"), destructor_7351, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2052, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRecoElasticEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPRecoElasticEvent_funcmem_bld);
}

//------Delayed data member builder for class RPRecoElasticEvent -------------------
void __RPRecoElasticEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2845, Reflex::Literal("roads"), OffsetOf(__shadow__::__RPRecoElasticEvent, roads), ::Reflex::PUBLIC)
  .AddDataMember(type_65, Reflex::Literal("preferredRoad"), OffsetOf(__shadow__::__RPRecoElasticEvent, preferredRoad), ::Reflex::PUBLIC)
  .AddDataMember(type_7344, Reflex::Literal("leftFit"), OffsetOf(__shadow__::__RPRecoElasticEvent, leftFit), ::Reflex::PUBLIC)
  .AddDataMember(type_7344, Reflex::Literal("rightFit"), OffsetOf(__shadow__::__RPRecoElasticEvent, rightFit), ::Reflex::PUBLIC)
  .AddDataMember(type_7344, Reflex::Literal("globalFit"), OffsetOf(__shadow__::__RPRecoElasticEvent, globalFit), ::Reflex::PUBLIC)
  .AddDataMember(type_7344, Reflex::Literal("result"), OffsetOf(__shadow__::__RPRecoElasticEvent, result), ::Reflex::PUBLIC)
  .AddDataMember(type_7345, Reflex::Literal("status"), OffsetOf(__shadow__::__RPRecoElasticEvent, status), ::Reflex::PUBLIC)
  .AddDataMember(type_296, Reflex::Literal("rejectReason"), OffsetOf(__shadow__::__RPRecoElasticEvent, rejectReason), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRecoElasticEvent -------------------
void __RPRecoElasticEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isValid"), method_7349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RPRecognizedPatternsCollection -------------------------------
static void destructor_7352(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRecognizedPatternsCollection*)o)->::RPRecognizedPatternsCollection::~RPRecognizedPatternsCollection)();
}
static  void operator_7353( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRecognizedPatternsCollection*)o)->operator=)(*(const ::RPRecognizedPatternsCollection*)arg[0]);
  else   (((::RPRecognizedPatternsCollection*)o)->operator=)(*(const ::RPRecognizedPatternsCollection*)arg[0]);
}

static void constructor_7354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecognizedPatternsCollection(*(const ::RPRecognizedPatternsCollection*)arg[0]);
  else ::new(mem) ::RPRecognizedPatternsCollection(*(const ::RPRecognizedPatternsCollection*)arg[0]);
}

static void constructor_7355( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecognizedPatternsCollection();
  else ::new(mem) ::RPRecognizedPatternsCollection();
}

static void method_newdel_2062( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatternsCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatternsCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatternsCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatternsCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatternsCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>")), ::Reflex::BaseOffset< ::RPRecognizedPatternsCollection,::std::map<unsigned int,RPRecognizedPatterns> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RPRecognizedPatternsCollection -------------------------------
void __RPRecognizedPatternsCollection_db_datamem(Reflex::Class*);
void __RPRecognizedPatternsCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRecognizedPatternsCollection_datamem_bld(&__RPRecognizedPatternsCollection_db_datamem);
Reflex::GenreflexMemberBuilder __RPRecognizedPatternsCollection_funcmem_bld(&__RPRecognizedPatternsCollection_db_funcmem);
void __RPRecognizedPatternsCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRecognizedPatternsCollection"), typeid(::RPRecognizedPatternsCollection), sizeof(::RPRecognizedPatternsCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2974, ::Reflex::BaseOffset< ::RPRecognizedPatternsCollection, ::std::map<unsigned int,RPRecognizedPatterns> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRecognizedPatternsCollection"), destructor_7352, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23120, type_23121), Reflex::Literal("operator="), operator_7353, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23121), Reflex::Literal("RPRecognizedPatternsCollection"), constructor_7354, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRecognizedPatternsCollection"), constructor_7355, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2062, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RPRecognizedPatternsCollection -------------------
void __RPRecognizedPatternsCollection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RPRecognizedPatternsCollection -------------------
void __RPRecognizedPatternsCollection_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPRecognizedPatterns -------------------------------
static void destructor_7384(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRecognizedPatterns*)o)->::RPRecognizedPatterns::~RPRecognizedPatterns)();
}
static  void operator_7385( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRecognizedPatterns*)o)->operator=)(*(const ::RPRecognizedPatterns*)arg[0]);
  else   (((::RPRecognizedPatterns*)o)->operator=)(*(const ::RPRecognizedPatterns*)arg[0]);
}

static void constructor_7386( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecognizedPatterns(*(const ::RPRecognizedPatterns*)arg[0]);
  else ::new(mem) ::RPRecognizedPatterns(*(const ::RPRecognizedPatterns*)arg[0]);
}

static void constructor_7387( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecognizedPatterns();
  else ::new(mem) ::RPRecognizedPatterns();
}

static  void method_7388( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RPRecognizedPatterns*)o)->Clear)();
}

static void method_newdel_2172( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatterns >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatterns >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatterns >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatterns >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatterns >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRecognizedPatterns -------------------------------
void __RPRecognizedPatterns_db_datamem(Reflex::Class*);
void __RPRecognizedPatterns_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRecognizedPatterns_datamem_bld(&__RPRecognizedPatterns_db_datamem);
Reflex::GenreflexMemberBuilder __RPRecognizedPatterns_funcmem_bld(&__RPRecognizedPatterns_db_funcmem);
void __RPRecognizedPatterns_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRecognizedPatterns"), typeid(::RPRecognizedPatterns), sizeof(::RPRecognizedPatterns), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("RPRecognizedPatterns::SourceType"), Reflex::Literal("sParallel=0;sNonParallel=1"), &typeid(RPRecognizedPatterns::SourceType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRecognizedPatterns"), destructor_7384, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23135, type_23136), Reflex::Literal("operator="), operator_7385, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23136), Reflex::Literal("RPRecognizedPatterns"), constructor_7386, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRecognizedPatterns"), constructor_7387, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2172, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRecognizedPatterns_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPRecognizedPatterns_funcmem_bld);
}

//------Delayed data member builder for class RPRecognizedPatterns -------------------
void __RPRecognizedPatterns_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7383, Reflex::Literal("source"), OffsetOf(__shadow__::__RPRecognizedPatterns, source), ::Reflex::PUBLIC)
  .AddDataMember(type_2843, Reflex::Literal("uLines"), OffsetOf(__shadow__::__RPRecognizedPatterns, uLines), ::Reflex::PUBLIC)
  .AddDataMember(type_2843, Reflex::Literal("vLines"), OffsetOf(__shadow__::__RPRecognizedPatterns, vLines), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRecognizedPatterns -------------------
void __RPRecognizedPatterns_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("Clear"), method_7388, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class RPReconstructedProtonCollection -------------------------------
static void destructor_7687(void*, void * o, const std::vector<void*>&, void *) {
(((::RPReconstructedProtonCollection*)o)->::RPReconstructedProtonCollection::~RPReconstructedProtonCollection)();
}
static  void operator_7688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPReconstructedProtonCollection*)o)->operator=)(*(const ::RPReconstructedProtonCollection*)arg[0]);
  else   (((::RPReconstructedProtonCollection*)o)->operator=)(*(const ::RPReconstructedProtonCollection*)arg[0]);
}

static void constructor_7689( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPReconstructedProtonCollection(*(const ::RPReconstructedProtonCollection*)arg[0]);
  else ::new(mem) ::RPReconstructedProtonCollection(*(const ::RPReconstructedProtonCollection*)arg[0]);
}

static void constructor_7690( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPReconstructedProtonCollection();
  else ::new(mem) ::RPReconstructedProtonCollection();
}

static void method_newdel_2293( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPReconstructedProtonCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPReconstructedProton>")), ::Reflex::BaseOffset< ::RPReconstructedProtonCollection,::std::vector<RPReconstructedProton> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPReconstructedProton,std::allocator<RPReconstructedProton> >")), ::Reflex::BaseOffset< ::RPReconstructedProtonCollection,::std::_Vector_base<RPReconstructedProton,std::allocator<RPReconstructedProton> > >::Get(),::Reflex::PROTECTED), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RPReconstructedProtonCollection -------------------------------
void __RPReconstructedProtonCollection_db_datamem(Reflex::Class*);
void __RPReconstructedProtonCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPReconstructedProtonCollection_datamem_bld(&__RPReconstructedProtonCollection_db_datamem);
Reflex::GenreflexMemberBuilder __RPReconstructedProtonCollection_funcmem_bld(&__RPReconstructedProtonCollection_db_funcmem);
void __RPReconstructedProtonCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPReconstructedProtonCollection"), typeid(::RPReconstructedProtonCollection), sizeof(::RPReconstructedProtonCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2847, ::Reflex::BaseOffset< ::RPReconstructedProtonCollection, ::std::vector<RPReconstructedProton> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPReconstructedProtonCollection"), destructor_7687, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23340, type_23341), Reflex::Literal("operator="), operator_7688, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23341), Reflex::Literal("RPReconstructedProtonCollection"), constructor_7689, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPReconstructedProtonCollection"), constructor_7690, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2293, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class RPReconstructedProtonCollection -------------------
void __RPReconstructedProtonCollection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RPReconstructedProtonCollection -------------------
void __RPReconstructedProtonCollection_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class less<unsigned int> -------------------------------
static void destructor_9534(void*, void * o, const std::vector<void*>&, void *) {
(((::std::less<unsigned int>*)o)->::std::less<unsigned int>::~less)();
}
static  void operator_9535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::less<unsigned int>*)o)->operator=)(*(const ::std::less<unsigned int>*)arg[0]);
  else   (((::std::less<unsigned int>*)o)->operator=)(*(const ::std::less<unsigned int>*)arg[0]);
}

static void constructor_9536( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::less<unsigned int>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::less<unsigned int>(*(const ::std::less<unsigned int>*)arg[0]);
}

static void constructor_9537( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::less<unsigned int>();
  else ::new(mem) ::std::less<unsigned int>();
}

static  void operator_9538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::less<unsigned int>*)o)->operator())(*(const unsigned int*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::std::less<unsigned int>*)o)->operator())(*(const unsigned int*)arg[0],
    *(const unsigned int*)arg[1]);
}

static void method_newdel_2510( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::less<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::less<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::less<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::less<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::less<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x38( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::binary_function<unsigned int,unsigned int,bool>")), ::Reflex::BaseOffset< ::std::less<unsigned int>,::std::binary_function<unsigned int,unsigned int,bool> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class less<unsigned int> -------------------------------
void __std__less_unsignedsint__db_datamem(Reflex::Class*);
void __std__less_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__less_unsignedsint__datamem_bld(&__std__less_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__less_unsignedsint__funcmem_bld(&__std__less_unsignedsint__db_funcmem);
void __std__less_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::less<unsigned int>"), typeid(::std::less<unsigned int>), sizeof(::std::less<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddBase(type_2990, ::Reflex::BaseOffset< ::std::less<unsigned int>, ::std::binary_function<unsigned int,unsigned int,bool> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~less"), destructor_9534, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23995, type_23996), Reflex::Literal("operator="), operator_9535, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23996), Reflex::Literal("less"), constructor_9536, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("less"), constructor_9537, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2510, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x38, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__less_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class less<unsigned int> -------------------
void __std__less_unsignedsint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class less<unsigned int> -------------------
void __std__less_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482, type_23997, type_23997), Reflex::Literal("operator()"), operator_9538, 0, "__x;__y", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class pair<unsigned int,RP2DHitDebug> -------------------------------
static void destructor_11590(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,RP2DHitDebug>*)o)->::std::pair<unsigned int,RP2DHitDebug>::~pair)();
}
static  void operator_11591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,RP2DHitDebug>*)o)->operator=)(*(const ::std::pair<unsigned int,RP2DHitDebug>*)arg[0]);
  else   (((::std::pair<unsigned int,RP2DHitDebug>*)o)->operator=)(*(const ::std::pair<unsigned int,RP2DHitDebug>*)arg[0]);
}

static void constructor_11592( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,RP2DHitDebug>(*(const ::std::pair<unsigned int,RP2DHitDebug>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,RP2DHitDebug>(*(const ::std::pair<unsigned int,RP2DHitDebug>*)arg[0]);
}

static void constructor_11593( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,RP2DHitDebug>();
  else ::new(mem) ::std::pair<unsigned int,RP2DHitDebug>();
}

static void constructor_11594( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,RP2DHitDebug>(*(const unsigned int*)arg[0],
      *(const ::RP2DHitDebug*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,RP2DHitDebug>(*(const unsigned int*)arg[0],
      *(const ::RP2DHitDebug*)arg[1]);
}

static void method_newdel_2774( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RP2DHitDebug> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RP2DHitDebug> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RP2DHitDebug> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RP2DHitDebug> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RP2DHitDebug> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,RP2DHitDebug> -------------------------------
void __std__pair_unsignedsint_RP2DHitDebug__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_RP2DHitDebug__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_RP2DHitDebug__datamem_bld(&__std__pair_unsignedsint_RP2DHitDebug__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_RP2DHitDebug__funcmem_bld(&__std__pair_unsignedsint_RP2DHitDebug__db_funcmem);
void __std__pair_unsignedsint_RP2DHitDebug__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,RP2DHitDebug>"), typeid(::std::pair<unsigned int,RP2DHitDebug>), sizeof(::std::pair<unsigned int,RP2DHitDebug>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_296, Reflex::Literal("std::pair<unsigned int,RP2DHitDebug>::first_type"))
  .AddTypedef(type_1929, Reflex::Literal("std::pair<unsigned int,RP2DHitDebug>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_11590, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24301, type_24302), Reflex::Literal("operator="), operator_11591, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24302), Reflex::Literal("pair"), constructor_11592, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_11593, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23997, type_19330), Reflex::Literal("pair"), constructor_11594, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2774, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_RP2DHitDebug__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,RP2DHitDebug> -------------------
void __std__pair_unsignedsint_RP2DHitDebug__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_296, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_RP2DHitDebug_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1929, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_RP2DHitDebug_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,RP2DHitDebug> -------------------
void __std__pair_unsignedsint_RP2DHitDebug__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<RPStationTrackFit,std::allocator<RPStationTrackFit> > -------------------------------
static void constructor_11857( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStationTrackFit>();
  else ::new(mem) ::std::vector<RPStationTrackFit>();
}

static void constructor_11858( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStationTrackFit>(*(const ::std::allocator<RPStationTrackFit>*)arg[0]);
  else ::new(mem) ::std::vector<RPStationTrackFit>(*(const ::std::allocator<RPStationTrackFit>*)arg[0]);
}

static void constructor_11859( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStationTrackFit>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPStationTrackFit>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStationTrackFit>(*(::std::size_t*)arg[0],
      *(const ::RPStationTrackFit*)arg[1]);
  else ::new(mem) ::std::vector<RPStationTrackFit>(*(::std::size_t*)arg[0],
      *(const ::RPStationTrackFit*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStationTrackFit>(*(::std::size_t*)arg[0],
      *(const ::RPStationTrackFit*)arg[1],
      *(const ::std::allocator<RPStationTrackFit>*)arg[2]);
  else ::new(mem) ::std::vector<RPStationTrackFit>(*(::std::size_t*)arg[0],
      *(const ::RPStationTrackFit*)arg[1],
      *(const ::std::allocator<RPStationTrackFit>*)arg[2]);
  }
}

static void constructor_11860( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStationTrackFit>(*(const ::std::vector<RPStationTrackFit>*)arg[0]);
  else ::new(mem) ::std::vector<RPStationTrackFit>(*(const ::std::vector<RPStationTrackFit>*)arg[0]);
}

static void destructor_11861(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPStationTrackFit>*)o)->::std::vector<RPStationTrackFit>::~vector)();
}
static  void operator_11862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPStationTrackFit>*)o)->operator=)(*(const ::std::vector<RPStationTrackFit>*)arg[0]);
  else   (((::std::vector<RPStationTrackFit>*)o)->operator=)(*(const ::std::vector<RPStationTrackFit>*)arg[0]);
}

static  void method_11863( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPStationTrackFit>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPStationTrackFit*)arg[1]);
}

static  void method_11864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >)((((::std::vector<RPStationTrackFit>*)o)->begin)());
  else   (((::std::vector<RPStationTrackFit>*)o)->begin)();
}

static  void method_11865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPStationTrackFit*,std::vector<RPStationTrackFit> >)((((const ::std::vector<RPStationTrackFit>*)o)->begin)());
  else   (((const ::std::vector<RPStationTrackFit>*)o)->begin)();
}

static  void method_11866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >)((((::std::vector<RPStationTrackFit>*)o)->end)());
  else   (((::std::vector<RPStationTrackFit>*)o)->end)();
}

static  void method_11867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPStationTrackFit*,std::vector<RPStationTrackFit> >)((((const ::std::vector<RPStationTrackFit>*)o)->end)());
  else   (((const ::std::vector<RPStationTrackFit>*)o)->end)();
}

static  void method_11872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPStationTrackFit>*)o)->size)());
  else   (((const ::std::vector<RPStationTrackFit>*)o)->size)();
}

static  void method_11873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPStationTrackFit>*)o)->max_size)());
  else   (((const ::std::vector<RPStationTrackFit>*)o)->max_size)();
}

static  void method_11874( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPStationTrackFit>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPStationTrackFit>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPStationTrackFit*)arg[1]);
  }
}

static  void method_11875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPStationTrackFit>*)o)->capacity)());
  else   (((const ::std::vector<RPStationTrackFit>*)o)->capacity)();
}

static  void method_11876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPStationTrackFit>*)o)->empty)());
  else   (((const ::std::vector<RPStationTrackFit>*)o)->empty)();
}

static  void method_11877( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPStationTrackFit>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPStationTrackFit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPStationTrackFit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPStationTrackFit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPStationTrackFit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPStationTrackFit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPStationTrackFit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPStationTrackFit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPStationTrackFit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPStationTrackFit>*)o)->front)();
  else   (((::std::vector<RPStationTrackFit>*)o)->front)();
}

static  void method_11884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPStationTrackFit>*)o)->front)();
  else   (((const ::std::vector<RPStationTrackFit>*)o)->front)();
}

static  void method_11885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPStationTrackFit>*)o)->back)();
  else   (((::std::vector<RPStationTrackFit>*)o)->back)();
}

static  void method_11886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPStationTrackFit>*)o)->back)();
  else   (((const ::std::vector<RPStationTrackFit>*)o)->back)();
}

static  void method_11887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPStationTrackFit>*)o)->data)());
  else   (((::std::vector<RPStationTrackFit>*)o)->data)();
}

static  void method_11888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPStationTrackFit>*)o)->data)());
  else   (((const ::std::vector<RPStationTrackFit>*)o)->data)();
}

static  void method_11889( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPStationTrackFit>*)o)->push_back)(*(const ::RPStationTrackFit*)arg[0]);
}

static  void method_11890( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPStationTrackFit>*)o)->pop_back)();
}

static  void method_11891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >)((((::std::vector<RPStationTrackFit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >*)arg[0],
    *(const ::RPStationTrackFit*)arg[1]));
  else   (((::std::vector<RPStationTrackFit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >*)arg[0],
    *(const ::RPStationTrackFit*)arg[1]);
}

static  void method_11892( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPStationTrackFit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPStationTrackFit*)arg[2]);
}

static  void method_11893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >)((((::std::vector<RPStationTrackFit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >*)arg[0]));
  else   (((::std::vector<RPStationTrackFit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >*)arg[0]);
}

static  void method_11894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >)((((::std::vector<RPStationTrackFit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >*)arg[1]));
  else   (((::std::vector<RPStationTrackFit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPStationTrackFit*,std::vector<RPStationTrackFit> >*)arg[1]);
}

static  void method_11895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPStationTrackFit>*)o)->swap)(*(::std::vector<RPStationTrackFit>*)arg[0]);
}

static  void method_11896( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPStationTrackFit>*)o)->clear)();
}

static void method_newdel_2842( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPStationTrackFit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPStationTrackFit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPStationTrackFit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPStationTrackFit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPStationTrackFit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x41( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPStationTrackFit,std::allocator<RPStationTrackFit> >")), ::Reflex::BaseOffset< ::std::vector<RPStationTrackFit>,::std::_Vector_base<RPStationTrackFit,std::allocator<RPStationTrackFit> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPStationTrackFit> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPStationTrackFit> >::Generate();
}

//------Dictionary for class vector<RPStationTrackFit,std::allocator<RPStationTrackFit> > -------------------------------
void __std__vector_RPStationTrackFit__db_datamem(Reflex::Class*);
void __std__vector_RPStationTrackFit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPStationTrackFit__datamem_bld(&__std__vector_RPStationTrackFit__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPStationTrackFit__funcmem_bld(&__std__vector_RPStationTrackFit__db_funcmem);
void __std__vector_RPStationTrackFit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPStationTrackFit>"), typeid(::std::vector<RPStationTrackFit>), sizeof(::std::vector<RPStationTrackFit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2352, ::Reflex::BaseOffset< ::std::vector<RPStationTrackFit>, ::std::_Vector_base<RPStationTrackFit,std::allocator<RPStationTrackFit> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1969, Reflex::Literal("std::vector<RPStationTrackFit>::_Alloc_value_type"))
  .AddTypedef(type_2352, Reflex::Literal("std::vector<RPStationTrackFit>::_Base"))
  .AddTypedef(type_3052, Reflex::Literal("std::vector<RPStationTrackFit>::_Tp_alloc_type"))
  .AddTypedef(type_6681, Reflex::Literal("std::vector<RPStationTrackFit>::_Alloc_traits"))
  .AddTypedef(type_1969, Reflex::Literal("std::vector<RPStationTrackFit>::value_type"))
  .AddTypedef(type_8066, Reflex::Literal("std::vector<RPStationTrackFit>::pointer"))
  .AddTypedef(type_11844, Reflex::Literal("std::vector<RPStationTrackFit>::const_pointer"))
  .AddTypedef(type_11846, Reflex::Literal("std::vector<RPStationTrackFit>::reference"))
  .AddTypedef(type_11848, Reflex::Literal("std::vector<RPStationTrackFit>::const_reference"))
  .AddTypedef(type_6587, Reflex::Literal("std::vector<RPStationTrackFit>::iterator"))
  .AddTypedef(type_6588, Reflex::Literal("std::vector<RPStationTrackFit>::const_iterator"))
  .AddTypedef(type_3198, Reflex::Literal("std::vector<RPStationTrackFit>::const_reverse_iterator"))
  .AddTypedef(type_3199, Reflex::Literal("std::vector<RPStationTrackFit>::reverse_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<RPStationTrackFit>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<RPStationTrackFit>::difference_type"))
  .AddTypedef(type_3052, Reflex::Literal("std::vector<RPStationTrackFit>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11857, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23407), Reflex::Literal("vector"), constructor_11858, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3037, type_11848, type_23407), Reflex::Literal("vector"), constructor_11859, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24328), Reflex::Literal("vector"), constructor_11860, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11861, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2842, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x41, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPStationTrackFit__funcmem_bld);
}

//------Delayed data member builder for class vector<RPStationTrackFit,std::allocator<RPStationTrackFit> > -------------------
void __std__vector_RPStationTrackFit__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPStationTrackFit,std::allocator<RPStationTrackFit> > -------------------
void __std__vector_RPStationTrackFit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24329, type_24328), Reflex::Literal("operator="), operator_11862, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_11848), Reflex::Literal("assign"), method_11863, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6587), Reflex::Literal("begin"), method_11864, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6588), Reflex::Literal("begin"), method_11865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6587), Reflex::Literal("end"), method_11866, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6588), Reflex::Literal("end"), method_11867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_11872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_11873, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_1969), Reflex::Literal("resize"), method_11874, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("capacity"), method_11875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_11876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037), Reflex::Literal("reserve"), method_11877, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11846, type_3037), Reflex::Literal("operator[]"), operator_11878, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11848, type_3037), Reflex::Literal("operator[]"), operator_11879, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11846, type_3037), Reflex::Literal("at"), method_11881, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11848, type_3037), Reflex::Literal("at"), method_11882, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11846), Reflex::Literal("front"), method_11883, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11848), Reflex::Literal("front"), method_11884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11846), Reflex::Literal("back"), method_11885, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11848), Reflex::Literal("back"), method_11886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8066), Reflex::Literal("data"), method_11887, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11844), Reflex::Literal("data"), method_11888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_11848), Reflex::Literal("push_back"), method_11889, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("pop_back"), method_11890, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6587, type_6587, type_11848), Reflex::Literal("insert"), method_11891, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_6587, type_3037, type_11848), Reflex::Literal("insert"), method_11892, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6587, type_6587), Reflex::Literal("erase"), method_11893, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6587, type_6587, type_6587), Reflex::Literal("erase"), method_11894, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24329), Reflex::Literal("swap"), method_11895, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_11896, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Line -------------------------------
static void destructor_23131(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRecognizedPatterns::Line*)o)->::RPRecognizedPatterns::Line::~Line)();
}
static  void operator_23132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRecognizedPatterns::Line*)o)->operator=)(*(const ::RPRecognizedPatterns::Line*)arg[0]);
  else   (((::RPRecognizedPatterns::Line*)o)->operator=)(*(const ::RPRecognizedPatterns::Line*)arg[0]);
}

static void constructor_23133( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecognizedPatterns::Line(*(const ::RPRecognizedPatterns::Line*)arg[0]);
  else ::new(mem) ::RPRecognizedPatterns::Line(*(const ::RPRecognizedPatterns::Line*)arg[0]);
}

static void constructor_23134( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecognizedPatterns::Line();
  else ::new(mem) ::RPRecognizedPatterns::Line();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecognizedPatterns::Line(*(double*)arg[0]);
  else ::new(mem) ::RPRecognizedPatterns::Line(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecognizedPatterns::Line(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::RPRecognizedPatterns::Line(*(double*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecognizedPatterns::Line(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::RPRecognizedPatterns::Line(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
}

static void constructor_x43( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecognizedPatterns::Line();
  else ::new(mem) ::RPRecognizedPatterns::Line();
}

static void method_newdel_7382( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatterns::Line >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatterns::Line >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatterns::Line >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatterns::Line >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRecognizedPatterns::Line >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Line -------------------------------
void __RPRecognizedPatterns__Line_db_datamem(Reflex::Class*);
void __RPRecognizedPatterns__Line_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRecognizedPatterns__Line_datamem_bld(&__RPRecognizedPatterns__Line_db_datamem);
Reflex::GenreflexMemberBuilder __RPRecognizedPatterns__Line_funcmem_bld(&__RPRecognizedPatterns__Line_db_funcmem);
void __RPRecognizedPatterns__Line_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRecognizedPatterns::Line"), typeid(::RPRecognizedPatterns::Line), sizeof(::RPRecognizedPatterns::Line), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2853, Reflex::Literal("RPRecognizedPatterns::Line::HitCollection"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Line"), destructor_23131, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11911, type_11913), Reflex::Literal("operator="), operator_23132, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11913), Reflex::Literal("Line"), constructor_23133, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_97, type_97, type_97), Reflex::Literal("Line"), constructor_23134, 0, "_a=0.0;_b=0.0;_w=1.0e+0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Line"), constructor_x43, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7382, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRecognizedPatterns__Line_datamem_bld);
}

//------Delayed data member builder for class Line -------------------
void __RPRecognizedPatterns__Line_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_97, Reflex::Literal("a"), OffsetOf(__shadow__::__RPRecognizedPatterns__Line, a), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("b"), OffsetOf(__shadow__::__RPRecognizedPatterns__Line, b), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("w"), OffsetOf(__shadow__::__RPRecognizedPatterns__Line, w), ::Reflex::PUBLIC)
  .AddDataMember(type_2853, Reflex::Literal("hits"), OffsetOf(__shadow__::__RPRecognizedPatterns__Line, hits), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class Line -------------------
void __RPRecognizedPatterns__Line_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<RPRecognizedPatterns::Line,std::allocator<RPRecognizedPatterns::Line> > -------------------------------
static void constructor_11922( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecognizedPatterns::Line>();
  else ::new(mem) ::std::vector<RPRecognizedPatterns::Line>();
}

static void constructor_11923( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecognizedPatterns::Line>(*(const ::std::allocator<RPRecognizedPatterns::Line>*)arg[0]);
  else ::new(mem) ::std::vector<RPRecognizedPatterns::Line>(*(const ::std::allocator<RPRecognizedPatterns::Line>*)arg[0]);
}

static void constructor_11924( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecognizedPatterns::Line>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRecognizedPatterns::Line>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecognizedPatterns::Line>(*(::std::size_t*)arg[0],
      *(const ::RPRecognizedPatterns::Line*)arg[1]);
  else ::new(mem) ::std::vector<RPRecognizedPatterns::Line>(*(::std::size_t*)arg[0],
      *(const ::RPRecognizedPatterns::Line*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecognizedPatterns::Line>(*(::std::size_t*)arg[0],
      *(const ::RPRecognizedPatterns::Line*)arg[1],
      *(const ::std::allocator<RPRecognizedPatterns::Line>*)arg[2]);
  else ::new(mem) ::std::vector<RPRecognizedPatterns::Line>(*(::std::size_t*)arg[0],
      *(const ::RPRecognizedPatterns::Line*)arg[1],
      *(const ::std::allocator<RPRecognizedPatterns::Line>*)arg[2]);
  }
}

static void constructor_11925( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecognizedPatterns::Line>(*(const ::std::vector<RPRecognizedPatterns::Line>*)arg[0]);
  else ::new(mem) ::std::vector<RPRecognizedPatterns::Line>(*(const ::std::vector<RPRecognizedPatterns::Line>*)arg[0]);
}

static void destructor_11926(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRecognizedPatterns::Line>*)o)->::std::vector<RPRecognizedPatterns::Line>::~vector)();
}
static  void operator_11927( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecognizedPatterns::Line>*)o)->operator=)(*(const ::std::vector<RPRecognizedPatterns::Line>*)arg[0]);
  else   (((::std::vector<RPRecognizedPatterns::Line>*)o)->operator=)(*(const ::std::vector<RPRecognizedPatterns::Line>*)arg[0]);
}

static  void method_11928( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecognizedPatterns::Line>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRecognizedPatterns::Line*)arg[1]);
}

static  void method_11929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >)((((::std::vector<RPRecognizedPatterns::Line>*)o)->begin)());
  else   (((::std::vector<RPRecognizedPatterns::Line>*)o)->begin)();
}

static  void method_11930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >)((((const ::std::vector<RPRecognizedPatterns::Line>*)o)->begin)());
  else   (((const ::std::vector<RPRecognizedPatterns::Line>*)o)->begin)();
}

static  void method_11931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >)((((::std::vector<RPRecognizedPatterns::Line>*)o)->end)());
  else   (((::std::vector<RPRecognizedPatterns::Line>*)o)->end)();
}

static  void method_11932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >)((((const ::std::vector<RPRecognizedPatterns::Line>*)o)->end)());
  else   (((const ::std::vector<RPRecognizedPatterns::Line>*)o)->end)();
}

static  void method_11937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecognizedPatterns::Line>*)o)->size)());
  else   (((const ::std::vector<RPRecognizedPatterns::Line>*)o)->size)();
}

static  void method_11938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecognizedPatterns::Line>*)o)->max_size)());
  else   (((const ::std::vector<RPRecognizedPatterns::Line>*)o)->max_size)();
}

static  void method_11939( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRecognizedPatterns::Line>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRecognizedPatterns::Line>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRecognizedPatterns::Line*)arg[1]);
  }
}

static  void method_11940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecognizedPatterns::Line>*)o)->capacity)());
  else   (((const ::std::vector<RPRecognizedPatterns::Line>*)o)->capacity)();
}

static  void method_11941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRecognizedPatterns::Line>*)o)->empty)());
  else   (((const ::std::vector<RPRecognizedPatterns::Line>*)o)->empty)();
}

static  void method_11942( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecognizedPatterns::Line>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11943( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecognizedPatterns::Line>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRecognizedPatterns::Line>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecognizedPatterns::Line>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRecognizedPatterns::Line>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecognizedPatterns::Line>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRecognizedPatterns::Line>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecognizedPatterns::Line>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRecognizedPatterns::Line>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecognizedPatterns::Line>*)o)->front)();
  else   (((::std::vector<RPRecognizedPatterns::Line>*)o)->front)();
}

static  void method_11949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecognizedPatterns::Line>*)o)->front)();
  else   (((const ::std::vector<RPRecognizedPatterns::Line>*)o)->front)();
}

static  void method_11950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecognizedPatterns::Line>*)o)->back)();
  else   (((::std::vector<RPRecognizedPatterns::Line>*)o)->back)();
}

static  void method_11951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecognizedPatterns::Line>*)o)->back)();
  else   (((const ::std::vector<RPRecognizedPatterns::Line>*)o)->back)();
}

static  void method_11952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRecognizedPatterns::Line>*)o)->data)());
  else   (((::std::vector<RPRecognizedPatterns::Line>*)o)->data)();
}

static  void method_11953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRecognizedPatterns::Line>*)o)->data)());
  else   (((const ::std::vector<RPRecognizedPatterns::Line>*)o)->data)();
}

static  void method_11954( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecognizedPatterns::Line>*)o)->push_back)(*(const ::RPRecognizedPatterns::Line*)arg[0]);
}

static  void method_11955( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRecognizedPatterns::Line>*)o)->pop_back)();
}

static  void method_11956( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >)((((::std::vector<RPRecognizedPatterns::Line>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >*)arg[0],
    *(const ::RPRecognizedPatterns::Line*)arg[1]));
  else   (((::std::vector<RPRecognizedPatterns::Line>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >*)arg[0],
    *(const ::RPRecognizedPatterns::Line*)arg[1]);
}

static  void method_11957( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecognizedPatterns::Line>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRecognizedPatterns::Line*)arg[2]);
}

static  void method_11958( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >)((((::std::vector<RPRecognizedPatterns::Line>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >*)arg[0]));
  else   (((::std::vector<RPRecognizedPatterns::Line>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >*)arg[0]);
}

static  void method_11959( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >)((((::std::vector<RPRecognizedPatterns::Line>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >*)arg[1]));
  else   (((::std::vector<RPRecognizedPatterns::Line>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRecognizedPatterns::Line*,std::vector<RPRecognizedPatterns::Line> >*)arg[1]);
}

static  void method_11960( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecognizedPatterns::Line>*)o)->swap)(*(::std::vector<RPRecognizedPatterns::Line>*)arg[0]);
}

static  void method_11961( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRecognizedPatterns::Line>*)o)->clear)();
}

static void method_newdel_2843( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecognizedPatterns::Line> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecognizedPatterns::Line> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecognizedPatterns::Line> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecognizedPatterns::Line> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecognizedPatterns::Line> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRecognizedPatterns::Line,std::allocator<RPRecognizedPatterns::Line> >")), ::Reflex::BaseOffset< ::std::vector<RPRecognizedPatterns::Line>,::std::_Vector_base<RPRecognizedPatterns::Line,std::allocator<RPRecognizedPatterns::Line> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x47( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRecognizedPatterns::Line> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRecognizedPatterns::Line> >::Generate();
}

//------Dictionary for class vector<RPRecognizedPatterns::Line,std::allocator<RPRecognizedPatterns::Line> > -------------------------------
void __std__vector_RPRecognizedPatterns__Line__db_datamem(Reflex::Class*);
void __std__vector_RPRecognizedPatterns__Line__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRecognizedPatterns__Line__datamem_bld(&__std__vector_RPRecognizedPatterns__Line__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRecognizedPatterns__Line__funcmem_bld(&__std__vector_RPRecognizedPatterns__Line__db_funcmem);
void __std__vector_RPRecognizedPatterns__Line__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRecognizedPatterns::Line>"), typeid(::std::vector<RPRecognizedPatterns::Line>), sizeof(::std::vector<RPRecognizedPatterns::Line>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2358, ::Reflex::BaseOffset< ::std::vector<RPRecognizedPatterns::Line>, ::std::_Vector_base<RPRecognizedPatterns::Line,std::allocator<RPRecognizedPatterns::Line> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7382, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::_Alloc_value_type"))
  .AddTypedef(type_2358, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::_Base"))
  .AddTypedef(type_3055, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::_Tp_alloc_type"))
  .AddTypedef(type_6687, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::_Alloc_traits"))
  .AddTypedef(type_7382, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::value_type"))
  .AddTypedef(type_8180, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::pointer"))
  .AddTypedef(type_11909, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::const_pointer"))
  .AddTypedef(type_11911, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::reference"))
  .AddTypedef(type_11913, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::const_reference"))
  .AddTypedef(type_6599, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::iterator"))
  .AddTypedef(type_6600, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::const_iterator"))
  .AddTypedef(type_3214, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::const_reverse_iterator"))
  .AddTypedef(type_3215, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::reverse_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::difference_type"))
  .AddTypedef(type_3055, Reflex::Literal("std::vector<RPRecognizedPatterns::Line>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11922, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23485), Reflex::Literal("vector"), constructor_11923, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3037, type_11913, type_23485), Reflex::Literal("vector"), constructor_11924, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24331), Reflex::Literal("vector"), constructor_11925, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11926, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2843, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x47, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRecognizedPatterns__Line__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRecognizedPatterns::Line,std::allocator<RPRecognizedPatterns::Line> > -------------------
void __std__vector_RPRecognizedPatterns__Line__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRecognizedPatterns::Line,std::allocator<RPRecognizedPatterns::Line> > -------------------
void __std__vector_RPRecognizedPatterns__Line__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24332, type_24331), Reflex::Literal("operator="), operator_11927, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_11913), Reflex::Literal("assign"), method_11928, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6599), Reflex::Literal("begin"), method_11929, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6600), Reflex::Literal("begin"), method_11930, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6599), Reflex::Literal("end"), method_11931, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6600), Reflex::Literal("end"), method_11932, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_11937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_11938, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_7382), Reflex::Literal("resize"), method_11939, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("capacity"), method_11940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_11941, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037), Reflex::Literal("reserve"), method_11942, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11911, type_3037), Reflex::Literal("operator[]"), operator_11943, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11913, type_3037), Reflex::Literal("operator[]"), operator_11944, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11911, type_3037), Reflex::Literal("at"), method_11946, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11913, type_3037), Reflex::Literal("at"), method_11947, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11911), Reflex::Literal("front"), method_11948, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11913), Reflex::Literal("front"), method_11949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11911), Reflex::Literal("back"), method_11950, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11913), Reflex::Literal("back"), method_11951, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8180), Reflex::Literal("data"), method_11952, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11909), Reflex::Literal("data"), method_11953, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_11913), Reflex::Literal("push_back"), method_11954, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("pop_back"), method_11955, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6599, type_6599, type_11913), Reflex::Literal("insert"), method_11956, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_6599, type_3037, type_11913), Reflex::Literal("insert"), method_11957, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6599, type_6599), Reflex::Literal("erase"), method_11958, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6599, type_6599, type_6599), Reflex::Literal("erase"), method_11959, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24332), Reflex::Literal("swap"), method_11960, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_11961, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class fit_type -------------------------------
static void destructor_23113(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRecoElasticEvent::fit_type*)o)->::RPRecoElasticEvent::fit_type::~fit_type)();
}
static  void operator_23114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRecoElasticEvent::fit_type*)o)->operator=)(*(const ::RPRecoElasticEvent::fit_type*)arg[0]);
  else   (((::RPRecoElasticEvent::fit_type*)o)->operator=)(*(const ::RPRecoElasticEvent::fit_type*)arg[0]);
}

static void constructor_23115( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecoElasticEvent::fit_type(*(const ::RPRecoElasticEvent::fit_type*)arg[0]);
  else ::new(mem) ::RPRecoElasticEvent::fit_type(*(const ::RPRecoElasticEvent::fit_type*)arg[0]);
}

static  void method_23116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPRecoElasticEvent::fit_type*)o)->s2minPerDf_x)());
  else   (((const ::RPRecoElasticEvent::fit_type*)o)->s2minPerDf_x)();
}

static  void method_23117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPRecoElasticEvent::fit_type*)o)->s2minPerDf_y)());
  else   (((const ::RPRecoElasticEvent::fit_type*)o)->s2minPerDf_y)();
}

static void constructor_23118( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecoElasticEvent::fit_type();
  else ::new(mem) ::RPRecoElasticEvent::fit_type();
}

static void method_newdel_7344( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent::fit_type >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent::fit_type >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent::fit_type >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent::fit_type >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent::fit_type >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class fit_type -------------------------------
void __RPRecoElasticEvent__fit_type_db_datamem(Reflex::Class*);
void __RPRecoElasticEvent__fit_type_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRecoElasticEvent__fit_type_datamem_bld(&__RPRecoElasticEvent__fit_type_db_datamem);
Reflex::GenreflexMemberBuilder __RPRecoElasticEvent__fit_type_funcmem_bld(&__RPRecoElasticEvent__fit_type_db_funcmem);
void __RPRecoElasticEvent__fit_type_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRecoElasticEvent::fit_type"), typeid(::RPRecoElasticEvent::fit_type), sizeof(::RPRecoElasticEvent::fit_type), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~fit_type"), destructor_23113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11976, type_11978), Reflex::Literal("operator="), operator_23114, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11978), Reflex::Literal("fit_type"), constructor_23115, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("fit_type"), constructor_23118, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7344, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRecoElasticEvent__fit_type_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPRecoElasticEvent__fit_type_funcmem_bld);
}

//------Delayed data member builder for class fit_type -------------------
void __RPRecoElasticEvent__fit_type_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_97, Reflex::Literal("th_x"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, th_x), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("th_y"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, th_y), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("x"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, x), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("y"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, y), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("si_th_x"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, si_th_x), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("si_th_y"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, si_th_y), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("si_x"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, si_x), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("si_y"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, si_y), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("s2min_x"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, s2min_x), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("s2min_y"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, s2min_y), ::Reflex::PUBLIC)
  .AddDataMember(type_401, Reflex::Literal("ndf_x"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, ndf_x), ::Reflex::PUBLIC)
  .AddDataMember(type_401, Reflex::Literal("ndf_y"), OffsetOf(__shadow__::__RPRecoElasticEvent__fit_type, ndf_y), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class fit_type -------------------
void __RPRecoElasticEvent__fit_type_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("s2minPerDf_x"), method_23116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("s2minPerDf_y"), method_23117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<RPRecoElasticEvent::fit_type,std::allocator<RPRecoElasticEvent::fit_type> > -------------------------------
static void constructor_11987( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>();
  else ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>();
}

static void constructor_11988( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>(*(const ::std::allocator<RPRecoElasticEvent::fit_type>*)arg[0]);
  else ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>(*(const ::std::allocator<RPRecoElasticEvent::fit_type>*)arg[0]);
}

static void constructor_11989( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>(*(::std::size_t*)arg[0],
      *(const ::RPRecoElasticEvent::fit_type*)arg[1]);
  else ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>(*(::std::size_t*)arg[0],
      *(const ::RPRecoElasticEvent::fit_type*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>(*(::std::size_t*)arg[0],
      *(const ::RPRecoElasticEvent::fit_type*)arg[1],
      *(const ::std::allocator<RPRecoElasticEvent::fit_type>*)arg[2]);
  else ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>(*(::std::size_t*)arg[0],
      *(const ::RPRecoElasticEvent::fit_type*)arg[1],
      *(const ::std::allocator<RPRecoElasticEvent::fit_type>*)arg[2]);
  }
}

static void constructor_11990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>(*(const ::std::vector<RPRecoElasticEvent::fit_type>*)arg[0]);
  else ::new(mem) ::std::vector<RPRecoElasticEvent::fit_type>(*(const ::std::vector<RPRecoElasticEvent::fit_type>*)arg[0]);
}

static void destructor_11991(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRecoElasticEvent::fit_type>*)o)->::std::vector<RPRecoElasticEvent::fit_type>::~vector)();
}
static  void operator_11992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoElasticEvent::fit_type>*)o)->operator=)(*(const ::std::vector<RPRecoElasticEvent::fit_type>*)arg[0]);
  else   (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->operator=)(*(const ::std::vector<RPRecoElasticEvent::fit_type>*)arg[0]);
}

static  void method_11993( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRecoElasticEvent::fit_type*)arg[1]);
}

static  void method_11994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >)((((::std::vector<RPRecoElasticEvent::fit_type>*)o)->begin)());
  else   (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->begin)();
}

static  void method_11995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >)((((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->begin)());
  else   (((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->begin)();
}

static  void method_11996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >)((((::std::vector<RPRecoElasticEvent::fit_type>*)o)->end)());
  else   (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->end)();
}

static  void method_11997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >)((((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->end)());
  else   (((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->end)();
}

static  void method_12002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->size)());
  else   (((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->size)();
}

static  void method_12003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->max_size)());
  else   (((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->max_size)();
}

static  void method_12004( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRecoElasticEvent::fit_type*)arg[1]);
  }
}

static  void method_12005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->capacity)());
  else   (((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->capacity)();
}

static  void method_12006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->empty)());
  else   (((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->empty)();
}

static  void method_12007( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoElasticEvent::fit_type>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12011( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoElasticEvent::fit_type>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12012( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoElasticEvent::fit_type>*)o)->front)();
  else   (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->front)();
}

static  void method_12014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->front)();
  else   (((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->front)();
}

static  void method_12015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoElasticEvent::fit_type>*)o)->back)();
  else   (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->back)();
}

static  void method_12016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->back)();
  else   (((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->back)();
}

static  void method_12017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRecoElasticEvent::fit_type>*)o)->data)());
  else   (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->data)();
}

static  void method_12018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->data)());
  else   (((const ::std::vector<RPRecoElasticEvent::fit_type>*)o)->data)();
}

static  void method_12019( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->push_back)(*(const ::RPRecoElasticEvent::fit_type*)arg[0]);
}

static  void method_12020( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->pop_back)();
}

static  void method_12021( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >)((((::std::vector<RPRecoElasticEvent::fit_type>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >*)arg[0],
    *(const ::RPRecoElasticEvent::fit_type*)arg[1]));
  else   (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >*)arg[0],
    *(const ::RPRecoElasticEvent::fit_type*)arg[1]);
}

static  void method_12022( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRecoElasticEvent::fit_type*)arg[2]);
}

static  void method_12023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >)((((::std::vector<RPRecoElasticEvent::fit_type>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >*)arg[0]));
  else   (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >*)arg[0]);
}

static  void method_12024( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >)((((::std::vector<RPRecoElasticEvent::fit_type>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >*)arg[1]));
  else   (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::fit_type*,std::vector<RPRecoElasticEvent::fit_type> >*)arg[1]);
}

static  void method_12025( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->swap)(*(::std::vector<RPRecoElasticEvent::fit_type>*)arg[0]);
}

static  void method_12026( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRecoElasticEvent::fit_type>*)o)->clear)();
}

static void method_newdel_2844( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoElasticEvent::fit_type> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoElasticEvent::fit_type> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoElasticEvent::fit_type> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoElasticEvent::fit_type> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoElasticEvent::fit_type> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRecoElasticEvent::fit_type,std::allocator<RPRecoElasticEvent::fit_type> >")), ::Reflex::BaseOffset< ::std::vector<RPRecoElasticEvent::fit_type>,::std::_Vector_base<RPRecoElasticEvent::fit_type,std::allocator<RPRecoElasticEvent::fit_type> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x51( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRecoElasticEvent::fit_type> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRecoElasticEvent::fit_type> >::Generate();
}

//------Dictionary for class vector<RPRecoElasticEvent::fit_type,std::allocator<RPRecoElasticEvent::fit_type> > -------------------------------
void __std__vector_RPRecoElasticEvent__fit_type__db_datamem(Reflex::Class*);
void __std__vector_RPRecoElasticEvent__fit_type__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRecoElasticEvent__fit_type__datamem_bld(&__std__vector_RPRecoElasticEvent__fit_type__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRecoElasticEvent__fit_type__funcmem_bld(&__std__vector_RPRecoElasticEvent__fit_type__db_funcmem);
void __std__vector_RPRecoElasticEvent__fit_type__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>"), typeid(::std::vector<RPRecoElasticEvent::fit_type>), sizeof(::std::vector<RPRecoElasticEvent::fit_type>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2353, ::Reflex::BaseOffset< ::std::vector<RPRecoElasticEvent::fit_type>, ::std::_Vector_base<RPRecoElasticEvent::fit_type,std::allocator<RPRecoElasticEvent::fit_type> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7344, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::_Alloc_value_type"))
  .AddTypedef(type_2353, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::_Base"))
  .AddTypedef(type_3056, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::_Tp_alloc_type"))
  .AddTypedef(type_6682, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::_Alloc_traits"))
  .AddTypedef(type_7344, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::value_type"))
  .AddTypedef(type_8085, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::pointer"))
  .AddTypedef(type_11974, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::const_pointer"))
  .AddTypedef(type_11976, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::reference"))
  .AddTypedef(type_11978, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::const_reference"))
  .AddTypedef(type_6589, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::iterator"))
  .AddTypedef(type_6590, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::const_iterator"))
  .AddTypedef(type_3200, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::const_reverse_iterator"))
  .AddTypedef(type_3201, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::reverse_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::difference_type"))
  .AddTypedef(type_3056, Reflex::Literal("std::vector<RPRecoElasticEvent::fit_type>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11987, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23420), Reflex::Literal("vector"), constructor_11988, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3037, type_11978, type_23420), Reflex::Literal("vector"), constructor_11989, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24334), Reflex::Literal("vector"), constructor_11990, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11991, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2844, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x51, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRecoElasticEvent__fit_type__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRecoElasticEvent::fit_type,std::allocator<RPRecoElasticEvent::fit_type> > -------------------
void __std__vector_RPRecoElasticEvent__fit_type__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRecoElasticEvent::fit_type,std::allocator<RPRecoElasticEvent::fit_type> > -------------------
void __std__vector_RPRecoElasticEvent__fit_type__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24335, type_24334), Reflex::Literal("operator="), operator_11992, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_11978), Reflex::Literal("assign"), method_11993, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6589), Reflex::Literal("begin"), method_11994, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6590), Reflex::Literal("begin"), method_11995, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6589), Reflex::Literal("end"), method_11996, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6590), Reflex::Literal("end"), method_11997, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_12002, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_12003, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_7344), Reflex::Literal("resize"), method_12004, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("capacity"), method_12005, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_12006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037), Reflex::Literal("reserve"), method_12007, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11976, type_3037), Reflex::Literal("operator[]"), operator_12008, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11978, type_3037), Reflex::Literal("operator[]"), operator_12009, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11976, type_3037), Reflex::Literal("at"), method_12011, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11978, type_3037), Reflex::Literal("at"), method_12012, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11976), Reflex::Literal("front"), method_12013, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11978), Reflex::Literal("front"), method_12014, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11976), Reflex::Literal("back"), method_12015, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11978), Reflex::Literal("back"), method_12016, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8085), Reflex::Literal("data"), method_12017, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11974), Reflex::Literal("data"), method_12018, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_11978), Reflex::Literal("push_back"), method_12019, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("pop_back"), method_12020, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6589, type_6589, type_11978), Reflex::Literal("insert"), method_12021, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_6589, type_3037, type_11978), Reflex::Literal("insert"), method_12022, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6589, type_6589), Reflex::Literal("erase"), method_12023, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6589, type_6589, type_6589), Reflex::Literal("erase"), method_12024, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24335), Reflex::Literal("swap"), method_12025, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_12026, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class road_type -------------------------------
static void destructor_23093(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRecoElasticEvent::road_type*)o)->::RPRecoElasticEvent::road_type::~road_type)();
}
static  void operator_23094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRecoElasticEvent::road_type*)o)->operator=)(*(const ::RPRecoElasticEvent::road_type*)arg[0]);
  else   (((::RPRecoElasticEvent::road_type*)o)->operator=)(*(const ::RPRecoElasticEvent::road_type*)arg[0]);
}

static void constructor_23095( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecoElasticEvent::road_type(*(const ::RPRecoElasticEvent::road_type*)arg[0]);
  else ::new(mem) ::RPRecoElasticEvent::road_type(*(const ::RPRecoElasticEvent::road_type*)arg[0]);
}

static void constructor_23096( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecoElasticEvent::road_type();
  else ::new(mem) ::RPRecoElasticEvent::road_type();
}

static  void method_23097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPRecoElasticEvent::road_type*)o)->centerX)());
  else   (((const ::RPRecoElasticEvent::road_type*)o)->centerX)();
}

static  void method_23098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPRecoElasticEvent::road_type*)o)->centerY)());
  else   (((const ::RPRecoElasticEvent::road_type*)o)->centerY)();
}

static  void method_23099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPRecoElasticEvent::road_type*)o)->SizeX)());
  else   (((const ::RPRecoElasticEvent::road_type*)o)->SizeX)();
}

static  void method_23100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPRecoElasticEvent::road_type*)o)->SizeY)());
  else   (((const ::RPRecoElasticEvent::road_type*)o)->SizeY)();
}

static void method_newdel_7343( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent::road_type >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent::road_type >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent::road_type >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent::road_type >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRecoElasticEvent::road_type >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class road_type -------------------------------
void __RPRecoElasticEvent__road_type_db_datamem(Reflex::Class*);
void __RPRecoElasticEvent__road_type_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRecoElasticEvent__road_type_datamem_bld(&__RPRecoElasticEvent__road_type_db_datamem);
Reflex::GenreflexMemberBuilder __RPRecoElasticEvent__road_type_funcmem_bld(&__RPRecoElasticEvent__road_type_db_funcmem);
void __RPRecoElasticEvent__road_type_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRecoElasticEvent::road_type"), typeid(::RPRecoElasticEvent::road_type), sizeof(::RPRecoElasticEvent::road_type), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~road_type"), destructor_23093, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12041, type_12043), Reflex::Literal("operator="), operator_23094, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12043), Reflex::Literal("road_type"), constructor_23095, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("road_type"), constructor_23096, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7343, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRecoElasticEvent__road_type_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPRecoElasticEvent__road_type_funcmem_bld);
}

//------Delayed data member builder for class road_type -------------------
void __RPRecoElasticEvent__road_type_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_97, Reflex::Literal("sumx"), OffsetOf(__shadow__::__RPRecoElasticEvent__road_type, sumx), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("sumy"), OffsetOf(__shadow__::__RPRecoElasticEvent__road_type, sumy), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("minx"), OffsetOf(__shadow__::__RPRecoElasticEvent__road_type, minx), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("maxx"), OffsetOf(__shadow__::__RPRecoElasticEvent__road_type, maxx), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("miny"), OffsetOf(__shadow__::__RPRecoElasticEvent__road_type, miny), ::Reflex::PUBLIC)
  .AddDataMember(type_97, Reflex::Literal("maxy"), OffsetOf(__shadow__::__RPRecoElasticEvent__road_type, maxy), ::Reflex::PUBLIC)
  .AddDataMember(type_2854, Reflex::Literal("members"), OffsetOf(__shadow__::__RPRecoElasticEvent__road_type, members), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class road_type -------------------
void __RPRecoElasticEvent__road_type_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("centerX"), method_23097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("centerY"), method_23098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("SizeX"), method_23099, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("SizeY"), method_23100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<RPRecoElasticEvent::road_type,std::allocator<RPRecoElasticEvent::road_type> > -------------------------------
static void constructor_12052( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>();
  else ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>();
}

static void constructor_12053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>(*(const ::std::allocator<RPRecoElasticEvent::road_type>*)arg[0]);
  else ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>(*(const ::std::allocator<RPRecoElasticEvent::road_type>*)arg[0]);
}

static void constructor_12054( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>(*(::std::size_t*)arg[0],
      *(const ::RPRecoElasticEvent::road_type*)arg[1]);
  else ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>(*(::std::size_t*)arg[0],
      *(const ::RPRecoElasticEvent::road_type*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>(*(::std::size_t*)arg[0],
      *(const ::RPRecoElasticEvent::road_type*)arg[1],
      *(const ::std::allocator<RPRecoElasticEvent::road_type>*)arg[2]);
  else ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>(*(::std::size_t*)arg[0],
      *(const ::RPRecoElasticEvent::road_type*)arg[1],
      *(const ::std::allocator<RPRecoElasticEvent::road_type>*)arg[2]);
  }
}

static void constructor_12055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>(*(const ::std::vector<RPRecoElasticEvent::road_type>*)arg[0]);
  else ::new(mem) ::std::vector<RPRecoElasticEvent::road_type>(*(const ::std::vector<RPRecoElasticEvent::road_type>*)arg[0]);
}

static void destructor_12056(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRecoElasticEvent::road_type>*)o)->::std::vector<RPRecoElasticEvent::road_type>::~vector)();
}
static  void operator_12057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoElasticEvent::road_type>*)o)->operator=)(*(const ::std::vector<RPRecoElasticEvent::road_type>*)arg[0]);
  else   (((::std::vector<RPRecoElasticEvent::road_type>*)o)->operator=)(*(const ::std::vector<RPRecoElasticEvent::road_type>*)arg[0]);
}

static  void method_12058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoElasticEvent::road_type>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRecoElasticEvent::road_type*)arg[1]);
}

static  void method_12059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >)((((::std::vector<RPRecoElasticEvent::road_type>*)o)->begin)());
  else   (((::std::vector<RPRecoElasticEvent::road_type>*)o)->begin)();
}

static  void method_12060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >)((((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->begin)());
  else   (((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->begin)();
}

static  void method_12061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >)((((::std::vector<RPRecoElasticEvent::road_type>*)o)->end)());
  else   (((::std::vector<RPRecoElasticEvent::road_type>*)o)->end)();
}

static  void method_12062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >)((((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->end)());
  else   (((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->end)();
}

static  void method_12067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->size)());
  else   (((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->size)();
}

static  void method_12068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->max_size)());
  else   (((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->max_size)();
}

static  void method_12069( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRecoElasticEvent::road_type>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRecoElasticEvent::road_type>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRecoElasticEvent::road_type*)arg[1]);
  }
}

static  void method_12070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->capacity)());
  else   (((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->capacity)();
}

static  void method_12071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->empty)());
  else   (((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->empty)();
}

static  void method_12072( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoElasticEvent::road_type>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoElasticEvent::road_type>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRecoElasticEvent::road_type>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoElasticEvent::road_type>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRecoElasticEvent::road_type>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoElasticEvent::road_type>*)o)->front)();
  else   (((::std::vector<RPRecoElasticEvent::road_type>*)o)->front)();
}

static  void method_12079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->front)();
  else   (((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->front)();
}

static  void method_12080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoElasticEvent::road_type>*)o)->back)();
  else   (((::std::vector<RPRecoElasticEvent::road_type>*)o)->back)();
}

static  void method_12081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->back)();
  else   (((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->back)();
}

static  void method_12082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRecoElasticEvent::road_type>*)o)->data)());
  else   (((::std::vector<RPRecoElasticEvent::road_type>*)o)->data)();
}

static  void method_12083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->data)());
  else   (((const ::std::vector<RPRecoElasticEvent::road_type>*)o)->data)();
}

static  void method_12084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoElasticEvent::road_type>*)o)->push_back)(*(const ::RPRecoElasticEvent::road_type*)arg[0]);
}

static  void method_12085( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRecoElasticEvent::road_type>*)o)->pop_back)();
}

static  void method_12086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >)((((::std::vector<RPRecoElasticEvent::road_type>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >*)arg[0],
    *(const ::RPRecoElasticEvent::road_type*)arg[1]));
  else   (((::std::vector<RPRecoElasticEvent::road_type>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >*)arg[0],
    *(const ::RPRecoElasticEvent::road_type*)arg[1]);
}

static  void method_12087( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoElasticEvent::road_type>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRecoElasticEvent::road_type*)arg[2]);
}

static  void method_12088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >)((((::std::vector<RPRecoElasticEvent::road_type>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >*)arg[0]));
  else   (((::std::vector<RPRecoElasticEvent::road_type>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >*)arg[0]);
}

static  void method_12089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >)((((::std::vector<RPRecoElasticEvent::road_type>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >*)arg[1]));
  else   (((::std::vector<RPRecoElasticEvent::road_type>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRecoElasticEvent::road_type*,std::vector<RPRecoElasticEvent::road_type> >*)arg[1]);
}

static  void method_12090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoElasticEvent::road_type>*)o)->swap)(*(::std::vector<RPRecoElasticEvent::road_type>*)arg[0]);
}

static  void method_12091( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRecoElasticEvent::road_type>*)o)->clear)();
}

static void method_newdel_2845( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoElasticEvent::road_type> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoElasticEvent::road_type> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoElasticEvent::road_type> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoElasticEvent::road_type> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoElasticEvent::road_type> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x54( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRecoElasticEvent::road_type,std::allocator<RPRecoElasticEvent::road_type> >")), ::Reflex::BaseOffset< ::std::vector<RPRecoElasticEvent::road_type>,::std::_Vector_base<RPRecoElasticEvent::road_type,std::allocator<RPRecoElasticEvent::road_type> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x55( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRecoElasticEvent::road_type> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRecoElasticEvent::road_type> >::Generate();
}

//------Dictionary for class vector<RPRecoElasticEvent::road_type,std::allocator<RPRecoElasticEvent::road_type> > -------------------------------
void __std__vector_RPRecoElasticEvent__road_type__db_datamem(Reflex::Class*);
void __std__vector_RPRecoElasticEvent__road_type__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRecoElasticEvent__road_type__datamem_bld(&__std__vector_RPRecoElasticEvent__road_type__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRecoElasticEvent__road_type__funcmem_bld(&__std__vector_RPRecoElasticEvent__road_type__db_funcmem);
void __std__vector_RPRecoElasticEvent__road_type__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>"), typeid(::std::vector<RPRecoElasticEvent::road_type>), sizeof(::std::vector<RPRecoElasticEvent::road_type>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2359, ::Reflex::BaseOffset< ::std::vector<RPRecoElasticEvent::road_type>, ::std::_Vector_base<RPRecoElasticEvent::road_type,std::allocator<RPRecoElasticEvent::road_type> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7343, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::_Alloc_value_type"))
  .AddTypedef(type_2359, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::_Base"))
  .AddTypedef(type_3057, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::_Tp_alloc_type"))
  .AddTypedef(type_6688, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::_Alloc_traits"))
  .AddTypedef(type_7343, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::value_type"))
  .AddTypedef(type_8199, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::pointer"))
  .AddTypedef(type_12039, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::const_pointer"))
  .AddTypedef(type_12041, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::reference"))
  .AddTypedef(type_12043, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::const_reference"))
  .AddTypedef(type_6601, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::iterator"))
  .AddTypedef(type_6602, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::const_iterator"))
  .AddTypedef(type_3216, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::const_reverse_iterator"))
  .AddTypedef(type_3217, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::reverse_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::difference_type"))
  .AddTypedef(type_3057, Reflex::Literal("std::vector<RPRecoElasticEvent::road_type>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12052, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23498), Reflex::Literal("vector"), constructor_12053, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3037, type_12043, type_23498), Reflex::Literal("vector"), constructor_12054, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24337), Reflex::Literal("vector"), constructor_12055, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12056, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2845, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x54, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x55, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRecoElasticEvent__road_type__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRecoElasticEvent::road_type,std::allocator<RPRecoElasticEvent::road_type> > -------------------
void __std__vector_RPRecoElasticEvent__road_type__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRecoElasticEvent::road_type,std::allocator<RPRecoElasticEvent::road_type> > -------------------
void __std__vector_RPRecoElasticEvent__road_type__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24338, type_24337), Reflex::Literal("operator="), operator_12057, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_12043), Reflex::Literal("assign"), method_12058, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6601), Reflex::Literal("begin"), method_12059, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6602), Reflex::Literal("begin"), method_12060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6601), Reflex::Literal("end"), method_12061, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6602), Reflex::Literal("end"), method_12062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_12067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_12068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_7343), Reflex::Literal("resize"), method_12069, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("capacity"), method_12070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_12071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037), Reflex::Literal("reserve"), method_12072, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12041, type_3037), Reflex::Literal("operator[]"), operator_12073, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12043, type_3037), Reflex::Literal("operator[]"), operator_12074, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12041, type_3037), Reflex::Literal("at"), method_12076, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12043, type_3037), Reflex::Literal("at"), method_12077, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12041), Reflex::Literal("front"), method_12078, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12043), Reflex::Literal("front"), method_12079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12041), Reflex::Literal("back"), method_12080, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12043), Reflex::Literal("back"), method_12081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8199), Reflex::Literal("data"), method_12082, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12039), Reflex::Literal("data"), method_12083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12043), Reflex::Literal("push_back"), method_12084, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("pop_back"), method_12085, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6601, type_6601, type_12043), Reflex::Literal("insert"), method_12086, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_6601, type_3037, type_12043), Reflex::Literal("insert"), method_12087, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6601, type_6601), Reflex::Literal("erase"), method_12088, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6601, type_6601, type_6601), Reflex::Literal("erase"), method_12089, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24338), Reflex::Literal("swap"), method_12090, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_12091, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPReconstructedProtonPair,std::allocator<RPReconstructedProtonPair> > -------------------------------
static void constructor_12116( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProtonPair>();
  else ::new(mem) ::std::vector<RPReconstructedProtonPair>();
}

static void constructor_12117( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProtonPair>(*(const ::std::allocator<RPReconstructedProtonPair>*)arg[0]);
  else ::new(mem) ::std::vector<RPReconstructedProtonPair>(*(const ::std::allocator<RPReconstructedProtonPair>*)arg[0]);
}

static void constructor_12118( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProtonPair>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPReconstructedProtonPair>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProtonPair>(*(::std::size_t*)arg[0],
      *(const ::RPReconstructedProtonPair*)arg[1]);
  else ::new(mem) ::std::vector<RPReconstructedProtonPair>(*(::std::size_t*)arg[0],
      *(const ::RPReconstructedProtonPair*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProtonPair>(*(::std::size_t*)arg[0],
      *(const ::RPReconstructedProtonPair*)arg[1],
      *(const ::std::allocator<RPReconstructedProtonPair>*)arg[2]);
  else ::new(mem) ::std::vector<RPReconstructedProtonPair>(*(::std::size_t*)arg[0],
      *(const ::RPReconstructedProtonPair*)arg[1],
      *(const ::std::allocator<RPReconstructedProtonPair>*)arg[2]);
  }
}

static void constructor_12119( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProtonPair>(*(const ::std::vector<RPReconstructedProtonPair>*)arg[0]);
  else ::new(mem) ::std::vector<RPReconstructedProtonPair>(*(const ::std::vector<RPReconstructedProtonPair>*)arg[0]);
}

static void destructor_12120(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPReconstructedProtonPair>*)o)->::std::vector<RPReconstructedProtonPair>::~vector)();
}
static  void operator_12121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPReconstructedProtonPair>*)o)->operator=)(*(const ::std::vector<RPReconstructedProtonPair>*)arg[0]);
  else   (((::std::vector<RPReconstructedProtonPair>*)o)->operator=)(*(const ::std::vector<RPReconstructedProtonPair>*)arg[0]);
}

static  void method_12122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPReconstructedProtonPair>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPReconstructedProtonPair*)arg[1]);
}

static  void method_12123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >)((((::std::vector<RPReconstructedProtonPair>*)o)->begin)());
  else   (((::std::vector<RPReconstructedProtonPair>*)o)->begin)();
}

static  void method_12124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >)((((const ::std::vector<RPReconstructedProtonPair>*)o)->begin)());
  else   (((const ::std::vector<RPReconstructedProtonPair>*)o)->begin)();
}

static  void method_12125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >)((((::std::vector<RPReconstructedProtonPair>*)o)->end)());
  else   (((::std::vector<RPReconstructedProtonPair>*)o)->end)();
}

static  void method_12126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >)((((const ::std::vector<RPReconstructedProtonPair>*)o)->end)());
  else   (((const ::std::vector<RPReconstructedProtonPair>*)o)->end)();
}

static  void method_12131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPReconstructedProtonPair>*)o)->size)());
  else   (((const ::std::vector<RPReconstructedProtonPair>*)o)->size)();
}

static  void method_12132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPReconstructedProtonPair>*)o)->max_size)());
  else   (((const ::std::vector<RPReconstructedProtonPair>*)o)->max_size)();
}

static  void method_12133( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPReconstructedProtonPair>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPReconstructedProtonPair>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPReconstructedProtonPair*)arg[1]);
  }
}

static  void method_12134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPReconstructedProtonPair>*)o)->capacity)());
  else   (((const ::std::vector<RPReconstructedProtonPair>*)o)->capacity)();
}

static  void method_12135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPReconstructedProtonPair>*)o)->empty)());
  else   (((const ::std::vector<RPReconstructedProtonPair>*)o)->empty)();
}

static  void method_12136( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPReconstructedProtonPair>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPReconstructedProtonPair>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPReconstructedProtonPair>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPReconstructedProtonPair>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPReconstructedProtonPair>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPReconstructedProtonPair>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPReconstructedProtonPair>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPReconstructedProtonPair>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPReconstructedProtonPair>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPReconstructedProtonPair>*)o)->front)();
  else   (((::std::vector<RPReconstructedProtonPair>*)o)->front)();
}

static  void method_12143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPReconstructedProtonPair>*)o)->front)();
  else   (((const ::std::vector<RPReconstructedProtonPair>*)o)->front)();
}

static  void method_12144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPReconstructedProtonPair>*)o)->back)();
  else   (((::std::vector<RPReconstructedProtonPair>*)o)->back)();
}

static  void method_12145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPReconstructedProtonPair>*)o)->back)();
  else   (((const ::std::vector<RPReconstructedProtonPair>*)o)->back)();
}

static  void method_12146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPReconstructedProtonPair>*)o)->data)());
  else   (((::std::vector<RPReconstructedProtonPair>*)o)->data)();
}

static  void method_12147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPReconstructedProtonPair>*)o)->data)());
  else   (((const ::std::vector<RPReconstructedProtonPair>*)o)->data)();
}

static  void method_12148( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPReconstructedProtonPair>*)o)->push_back)(*(const ::RPReconstructedProtonPair*)arg[0]);
}

static  void method_12149( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPReconstructedProtonPair>*)o)->pop_back)();
}

static  void method_12150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >)((((::std::vector<RPReconstructedProtonPair>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >*)arg[0],
    *(const ::RPReconstructedProtonPair*)arg[1]));
  else   (((::std::vector<RPReconstructedProtonPair>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >*)arg[0],
    *(const ::RPReconstructedProtonPair*)arg[1]);
}

static  void method_12151( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPReconstructedProtonPair>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPReconstructedProtonPair*)arg[2]);
}

static  void method_12152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >)((((::std::vector<RPReconstructedProtonPair>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >*)arg[0]));
  else   (((::std::vector<RPReconstructedProtonPair>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >*)arg[0]);
}

static  void method_12153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >)((((::std::vector<RPReconstructedProtonPair>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >*)arg[1]));
  else   (((::std::vector<RPReconstructedProtonPair>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPReconstructedProtonPair*,std::vector<RPReconstructedProtonPair> >*)arg[1]);
}

static  void method_12154( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPReconstructedProtonPair>*)o)->swap)(*(::std::vector<RPReconstructedProtonPair>*)arg[0]);
}

static  void method_12155( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPReconstructedProtonPair>*)o)->clear)();
}

static void method_newdel_2846( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPReconstructedProtonPair> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPReconstructedProtonPair> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPReconstructedProtonPair> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPReconstructedProtonPair> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPReconstructedProtonPair> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x57( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPReconstructedProtonPair,std::allocator<RPReconstructedProtonPair> >")), ::Reflex::BaseOffset< ::std::vector<RPReconstructedProtonPair>,::std::_Vector_base<RPReconstructedProtonPair,std::allocator<RPReconstructedProtonPair> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x58( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPReconstructedProtonPair> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPReconstructedProtonPair> >::Generate();
}

//------Dictionary for class vector<RPReconstructedProtonPair,std::allocator<RPReconstructedProtonPair> > -------------------------------
void __std__vector_RPReconstructedProtonPair__db_datamem(Reflex::Class*);
void __std__vector_RPReconstructedProtonPair__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPReconstructedProtonPair__datamem_bld(&__std__vector_RPReconstructedProtonPair__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPReconstructedProtonPair__funcmem_bld(&__std__vector_RPReconstructedProtonPair__db_funcmem);
void __std__vector_RPReconstructedProtonPair__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPReconstructedProtonPair>"), typeid(::std::vector<RPReconstructedProtonPair>), sizeof(::std::vector<RPReconstructedProtonPair>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2361, ::Reflex::BaseOffset< ::std::vector<RPReconstructedProtonPair>, ::std::_Vector_base<RPReconstructedProtonPair,std::allocator<RPReconstructedProtonPair> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1003, Reflex::Literal("std::vector<RPReconstructedProtonPair>::_Alloc_value_type"))
  .AddTypedef(type_2361, Reflex::Literal("std::vector<RPReconstructedProtonPair>::_Base"))
  .AddTypedef(type_3058, Reflex::Literal("std::vector<RPReconstructedProtonPair>::_Tp_alloc_type"))
  .AddTypedef(type_6690, Reflex::Literal("std::vector<RPReconstructedProtonPair>::_Alloc_traits"))
  .AddTypedef(type_1003, Reflex::Literal("std::vector<RPReconstructedProtonPair>::value_type"))
  .AddTypedef(type_8236, Reflex::Literal("std::vector<RPReconstructedProtonPair>::pointer"))
  .AddTypedef(type_12104, Reflex::Literal("std::vector<RPReconstructedProtonPair>::const_pointer"))
  .AddTypedef(type_12106, Reflex::Literal("std::vector<RPReconstructedProtonPair>::reference"))
  .AddTypedef(type_5606, Reflex::Literal("std::vector<RPReconstructedProtonPair>::const_reference"))
  .AddTypedef(type_6605, Reflex::Literal("std::vector<RPReconstructedProtonPair>::iterator"))
  .AddTypedef(type_6606, Reflex::Literal("std::vector<RPReconstructedProtonPair>::const_iterator"))
  .AddTypedef(type_3220, Reflex::Literal("std::vector<RPReconstructedProtonPair>::const_reverse_iterator"))
  .AddTypedef(type_3221, Reflex::Literal("std::vector<RPReconstructedProtonPair>::reverse_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<RPReconstructedProtonPair>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<RPReconstructedProtonPair>::difference_type"))
  .AddTypedef(type_3058, Reflex::Literal("std::vector<RPReconstructedProtonPair>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12116, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23524), Reflex::Literal("vector"), constructor_12117, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3037, type_5606, type_23524), Reflex::Literal("vector"), constructor_12118, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24339), Reflex::Literal("vector"), constructor_12119, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12120, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2846, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x57, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x58, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPReconstructedProtonPair__funcmem_bld);
}

//------Delayed data member builder for class vector<RPReconstructedProtonPair,std::allocator<RPReconstructedProtonPair> > -------------------
void __std__vector_RPReconstructedProtonPair__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPReconstructedProtonPair,std::allocator<RPReconstructedProtonPair> > -------------------
void __std__vector_RPReconstructedProtonPair__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24340, type_24339), Reflex::Literal("operator="), operator_12121, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_5606), Reflex::Literal("assign"), method_12122, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6605), Reflex::Literal("begin"), method_12123, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6606), Reflex::Literal("begin"), method_12124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6605), Reflex::Literal("end"), method_12125, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6606), Reflex::Literal("end"), method_12126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_12131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_12132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_1003), Reflex::Literal("resize"), method_12133, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("capacity"), method_12134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_12135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037), Reflex::Literal("reserve"), method_12136, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12106, type_3037), Reflex::Literal("operator[]"), operator_12137, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5606, type_3037), Reflex::Literal("operator[]"), operator_12138, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12106, type_3037), Reflex::Literal("at"), method_12140, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5606, type_3037), Reflex::Literal("at"), method_12141, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12106), Reflex::Literal("front"), method_12142, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5606), Reflex::Literal("front"), method_12143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12106), Reflex::Literal("back"), method_12144, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5606), Reflex::Literal("back"), method_12145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8236), Reflex::Literal("data"), method_12146, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12104), Reflex::Literal("data"), method_12147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_5606), Reflex::Literal("push_back"), method_12148, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("pop_back"), method_12149, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6605, type_6605, type_5606), Reflex::Literal("insert"), method_12150, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_6605, type_3037, type_5606), Reflex::Literal("insert"), method_12151, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6605, type_6605), Reflex::Literal("erase"), method_12152, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6605, type_6605, type_6605), Reflex::Literal("erase"), method_12153, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24340), Reflex::Literal("swap"), method_12154, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_12155, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPReconstructedProton,std::allocator<RPReconstructedProton> > -------------------------------
static void constructor_12180( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProton>();
  else ::new(mem) ::std::vector<RPReconstructedProton>();
}

static void constructor_12181( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProton>(*(const ::std::allocator<RPReconstructedProton>*)arg[0]);
  else ::new(mem) ::std::vector<RPReconstructedProton>(*(const ::std::allocator<RPReconstructedProton>*)arg[0]);
}

static void constructor_12182( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProton>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPReconstructedProton>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPReconstructedProton*)arg[1]);
  else ::new(mem) ::std::vector<RPReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPReconstructedProton*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPReconstructedProton*)arg[1],
      *(const ::std::allocator<RPReconstructedProton>*)arg[2]);
  else ::new(mem) ::std::vector<RPReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPReconstructedProton*)arg[1],
      *(const ::std::allocator<RPReconstructedProton>*)arg[2]);
  }
}

static void constructor_12183( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPReconstructedProton>(*(const ::std::vector<RPReconstructedProton>*)arg[0]);
  else ::new(mem) ::std::vector<RPReconstructedProton>(*(const ::std::vector<RPReconstructedProton>*)arg[0]);
}

static void destructor_12184(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPReconstructedProton>*)o)->::std::vector<RPReconstructedProton>::~vector)();
}
static  void operator_12185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPReconstructedProton>*)o)->operator=)(*(const ::std::vector<RPReconstructedProton>*)arg[0]);
  else   (((::std::vector<RPReconstructedProton>*)o)->operator=)(*(const ::std::vector<RPReconstructedProton>*)arg[0]);
}

static  void method_12186( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPReconstructedProton>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPReconstructedProton*)arg[1]);
}

static  void method_12187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >)((((::std::vector<RPReconstructedProton>*)o)->begin)());
  else   (((::std::vector<RPReconstructedProton>*)o)->begin)();
}

static  void method_12188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPReconstructedProton*,std::vector<RPReconstructedProton> >)((((const ::std::vector<RPReconstructedProton>*)o)->begin)());
  else   (((const ::std::vector<RPReconstructedProton>*)o)->begin)();
}

static  void method_12189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >)((((::std::vector<RPReconstructedProton>*)o)->end)());
  else   (((::std::vector<RPReconstructedProton>*)o)->end)();
}

static  void method_12190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPReconstructedProton*,std::vector<RPReconstructedProton> >)((((const ::std::vector<RPReconstructedProton>*)o)->end)());
  else   (((const ::std::vector<RPReconstructedProton>*)o)->end)();
}

static  void method_12195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPReconstructedProton>*)o)->size)());
  else   (((const ::std::vector<RPReconstructedProton>*)o)->size)();
}

static  void method_12196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPReconstructedProton>*)o)->max_size)());
  else   (((const ::std::vector<RPReconstructedProton>*)o)->max_size)();
}

static  void method_12197( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPReconstructedProton>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPReconstructedProton>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPReconstructedProton*)arg[1]);
  }
}

static  void method_12198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPReconstructedProton>*)o)->capacity)());
  else   (((const ::std::vector<RPReconstructedProton>*)o)->capacity)();
}

static  void method_12199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPReconstructedProton>*)o)->empty)());
  else   (((const ::std::vector<RPReconstructedProton>*)o)->empty)();
}

static  void method_12200( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPReconstructedProton>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12202( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12205( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPReconstructedProton>*)o)->front)();
  else   (((::std::vector<RPReconstructedProton>*)o)->front)();
}

static  void method_12207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPReconstructedProton>*)o)->front)();
  else   (((const ::std::vector<RPReconstructedProton>*)o)->front)();
}

static  void method_12208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPReconstructedProton>*)o)->back)();
  else   (((::std::vector<RPReconstructedProton>*)o)->back)();
}

static  void method_12209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPReconstructedProton>*)o)->back)();
  else   (((const ::std::vector<RPReconstructedProton>*)o)->back)();
}

static  void method_12210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPReconstructedProton>*)o)->data)());
  else   (((::std::vector<RPReconstructedProton>*)o)->data)();
}

static  void method_12211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPReconstructedProton>*)o)->data)());
  else   (((const ::std::vector<RPReconstructedProton>*)o)->data)();
}

static  void method_12212( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPReconstructedProton>*)o)->push_back)(*(const ::RPReconstructedProton*)arg[0]);
}

static  void method_12213( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPReconstructedProton>*)o)->pop_back)();
}

static  void method_12214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >)((((::std::vector<RPReconstructedProton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >*)arg[0],
    *(const ::RPReconstructedProton*)arg[1]));
  else   (((::std::vector<RPReconstructedProton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >*)arg[0],
    *(const ::RPReconstructedProton*)arg[1]);
}

static  void method_12215( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPReconstructedProton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPReconstructedProton*)arg[2]);
}

static  void method_12216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >)((((::std::vector<RPReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >*)arg[0]));
  else   (((::std::vector<RPReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >*)arg[0]);
}

static  void method_12217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >)((((::std::vector<RPReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >*)arg[1]));
  else   (((::std::vector<RPReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPReconstructedProton*,std::vector<RPReconstructedProton> >*)arg[1]);
}

static  void method_12218( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPReconstructedProton>*)o)->swap)(*(::std::vector<RPReconstructedProton>*)arg[0]);
}

static  void method_12219( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPReconstructedProton>*)o)->clear)();
}

static void method_newdel_2847( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPReconstructedProton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPReconstructedProton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPReconstructedProton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPReconstructedProton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPReconstructedProton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x60( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPReconstructedProton,std::allocator<RPReconstructedProton> >")), ::Reflex::BaseOffset< ::std::vector<RPReconstructedProton>,::std::_Vector_base<RPReconstructedProton,std::allocator<RPReconstructedProton> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x61( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPReconstructedProton> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPReconstructedProton> >::Generate();
}

//------Dictionary for class vector<RPReconstructedProton,std::allocator<RPReconstructedProton> > -------------------------------
void __std__vector_RPReconstructedProton__db_datamem(Reflex::Class*);
void __std__vector_RPReconstructedProton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPReconstructedProton__datamem_bld(&__std__vector_RPReconstructedProton__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPReconstructedProton__funcmem_bld(&__std__vector_RPReconstructedProton__db_funcmem);
void __std__vector_RPReconstructedProton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPReconstructedProton>"), typeid(::std::vector<RPReconstructedProton>), sizeof(::std::vector<RPReconstructedProton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2363, ::Reflex::BaseOffset< ::std::vector<RPReconstructedProton>, ::std::_Vector_base<RPReconstructedProton,std::allocator<RPReconstructedProton> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1565, Reflex::Literal("std::vector<RPReconstructedProton>::_Alloc_value_type"))
  .AddTypedef(type_2363, Reflex::Literal("std::vector<RPReconstructedProton>::_Base"))
  .AddTypedef(type_3060, Reflex::Literal("std::vector<RPReconstructedProton>::_Tp_alloc_type"))
  .AddTypedef(type_6692, Reflex::Literal("std::vector<RPReconstructedProton>::_Alloc_traits"))
  .AddTypedef(type_1565, Reflex::Literal("std::vector<RPReconstructedProton>::value_type"))
  .AddTypedef(type_8273, Reflex::Literal("std::vector<RPReconstructedProton>::pointer"))
  .AddTypedef(type_12168, Reflex::Literal("std::vector<RPReconstructedProton>::const_pointer"))
  .AddTypedef(type_12170, Reflex::Literal("std::vector<RPReconstructedProton>::reference"))
  .AddTypedef(type_5607, Reflex::Literal("std::vector<RPReconstructedProton>::const_reference"))
  .AddTypedef(type_6609, Reflex::Literal("std::vector<RPReconstructedProton>::iterator"))
  .AddTypedef(type_6610, Reflex::Literal("std::vector<RPReconstructedProton>::const_iterator"))
  .AddTypedef(type_3224, Reflex::Literal("std::vector<RPReconstructedProton>::const_reverse_iterator"))
  .AddTypedef(type_3225, Reflex::Literal("std::vector<RPReconstructedProton>::reverse_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<RPReconstructedProton>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<RPReconstructedProton>::difference_type"))
  .AddTypedef(type_3060, Reflex::Literal("std::vector<RPReconstructedProton>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12180, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23550), Reflex::Literal("vector"), constructor_12181, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3037, type_5607, type_23550), Reflex::Literal("vector"), constructor_12182, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24341), Reflex::Literal("vector"), constructor_12183, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12184, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2847, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x60, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x61, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPReconstructedProton__funcmem_bld);
}

//------Delayed data member builder for class vector<RPReconstructedProton,std::allocator<RPReconstructedProton> > -------------------
void __std__vector_RPReconstructedProton__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPReconstructedProton,std::allocator<RPReconstructedProton> > -------------------
void __std__vector_RPReconstructedProton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24342, type_24341), Reflex::Literal("operator="), operator_12185, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_5607), Reflex::Literal("assign"), method_12186, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6609), Reflex::Literal("begin"), method_12187, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6610), Reflex::Literal("begin"), method_12188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6609), Reflex::Literal("end"), method_12189, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6610), Reflex::Literal("end"), method_12190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_12195, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_12196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_1565), Reflex::Literal("resize"), method_12197, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("capacity"), method_12198, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_12199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037), Reflex::Literal("reserve"), method_12200, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12170, type_3037), Reflex::Literal("operator[]"), operator_12201, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5607, type_3037), Reflex::Literal("operator[]"), operator_12202, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12170, type_3037), Reflex::Literal("at"), method_12204, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5607, type_3037), Reflex::Literal("at"), method_12205, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12170), Reflex::Literal("front"), method_12206, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5607), Reflex::Literal("front"), method_12207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12170), Reflex::Literal("back"), method_12208, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5607), Reflex::Literal("back"), method_12209, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8273), Reflex::Literal("data"), method_12210, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12168), Reflex::Literal("data"), method_12211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_5607), Reflex::Literal("push_back"), method_12212, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("pop_back"), method_12213, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6609, type_6609, type_5607), Reflex::Literal("insert"), method_12214, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_6609, type_3037, type_5607), Reflex::Literal("insert"), method_12215, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6609, type_6609), Reflex::Literal("erase"), method_12216, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6609, type_6609, type_6609), Reflex::Literal("erase"), method_12217, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24342), Reflex::Literal("swap"), method_12218, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_12219, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPDetHitPoint,std::allocator<RPDetHitPoint> > -------------------------------
static void constructor_12245( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetHitPoint>();
  else ::new(mem) ::std::vector<RPDetHitPoint>();
}

static void constructor_12246( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetHitPoint>(*(const ::std::allocator<RPDetHitPoint>*)arg[0]);
  else ::new(mem) ::std::vector<RPDetHitPoint>(*(const ::std::allocator<RPDetHitPoint>*)arg[0]);
}

static void constructor_12247( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetHitPoint>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPDetHitPoint>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetHitPoint>(*(::std::size_t*)arg[0],
      *(const ::RPDetHitPoint*)arg[1]);
  else ::new(mem) ::std::vector<RPDetHitPoint>(*(::std::size_t*)arg[0],
      *(const ::RPDetHitPoint*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetHitPoint>(*(::std::size_t*)arg[0],
      *(const ::RPDetHitPoint*)arg[1],
      *(const ::std::allocator<RPDetHitPoint>*)arg[2]);
  else ::new(mem) ::std::vector<RPDetHitPoint>(*(::std::size_t*)arg[0],
      *(const ::RPDetHitPoint*)arg[1],
      *(const ::std::allocator<RPDetHitPoint>*)arg[2]);
  }
}

static void constructor_12248( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetHitPoint>(*(const ::std::vector<RPDetHitPoint>*)arg[0]);
  else ::new(mem) ::std::vector<RPDetHitPoint>(*(const ::std::vector<RPDetHitPoint>*)arg[0]);
}

static void destructor_12249(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPDetHitPoint>*)o)->::std::vector<RPDetHitPoint>::~vector)();
}
static  void operator_12250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDetHitPoint>*)o)->operator=)(*(const ::std::vector<RPDetHitPoint>*)arg[0]);
  else   (((::std::vector<RPDetHitPoint>*)o)->operator=)(*(const ::std::vector<RPDetHitPoint>*)arg[0]);
}

static  void method_12251( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDetHitPoint>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPDetHitPoint*)arg[1]);
}

static  void method_12252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >)((((::std::vector<RPDetHitPoint>*)o)->begin)());
  else   (((::std::vector<RPDetHitPoint>*)o)->begin)();
}

static  void method_12253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPDetHitPoint*,std::vector<RPDetHitPoint> >)((((const ::std::vector<RPDetHitPoint>*)o)->begin)());
  else   (((const ::std::vector<RPDetHitPoint>*)o)->begin)();
}

static  void method_12254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >)((((::std::vector<RPDetHitPoint>*)o)->end)());
  else   (((::std::vector<RPDetHitPoint>*)o)->end)();
}

static  void method_12255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPDetHitPoint*,std::vector<RPDetHitPoint> >)((((const ::std::vector<RPDetHitPoint>*)o)->end)());
  else   (((const ::std::vector<RPDetHitPoint>*)o)->end)();
}

static  void method_12260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPDetHitPoint>*)o)->size)());
  else   (((const ::std::vector<RPDetHitPoint>*)o)->size)();
}

static  void method_12261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPDetHitPoint>*)o)->max_size)());
  else   (((const ::std::vector<RPDetHitPoint>*)o)->max_size)();
}

static  void method_12262( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPDetHitPoint>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPDetHitPoint>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPDetHitPoint*)arg[1]);
  }
}

static  void method_12263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPDetHitPoint>*)o)->capacity)());
  else   (((const ::std::vector<RPDetHitPoint>*)o)->capacity)();
}

static  void method_12264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPDetHitPoint>*)o)->empty)());
  else   (((const ::std::vector<RPDetHitPoint>*)o)->empty)();
}

static  void method_12265( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDetHitPoint>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDetHitPoint>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPDetHitPoint>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDetHitPoint>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPDetHitPoint>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDetHitPoint>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPDetHitPoint>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12270( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDetHitPoint>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPDetHitPoint>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDetHitPoint>*)o)->front)();
  else   (((::std::vector<RPDetHitPoint>*)o)->front)();
}

static  void method_12272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDetHitPoint>*)o)->front)();
  else   (((const ::std::vector<RPDetHitPoint>*)o)->front)();
}

static  void method_12273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDetHitPoint>*)o)->back)();
  else   (((::std::vector<RPDetHitPoint>*)o)->back)();
}

static  void method_12274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDetHitPoint>*)o)->back)();
  else   (((const ::std::vector<RPDetHitPoint>*)o)->back)();
}

static  void method_12275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPDetHitPoint>*)o)->data)());
  else   (((::std::vector<RPDetHitPoint>*)o)->data)();
}

static  void method_12276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPDetHitPoint>*)o)->data)());
  else   (((const ::std::vector<RPDetHitPoint>*)o)->data)();
}

static  void method_12277( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDetHitPoint>*)o)->push_back)(*(const ::RPDetHitPoint*)arg[0]);
}

static  void method_12278( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPDetHitPoint>*)o)->pop_back)();
}

static  void method_12279( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >)((((::std::vector<RPDetHitPoint>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >*)arg[0],
    *(const ::RPDetHitPoint*)arg[1]));
  else   (((::std::vector<RPDetHitPoint>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >*)arg[0],
    *(const ::RPDetHitPoint*)arg[1]);
}

static  void method_12280( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDetHitPoint>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPDetHitPoint*)arg[2]);
}

static  void method_12281( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >)((((::std::vector<RPDetHitPoint>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >*)arg[0]));
  else   (((::std::vector<RPDetHitPoint>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >*)arg[0]);
}

static  void method_12282( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >)((((::std::vector<RPDetHitPoint>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >*)arg[1]));
  else   (((::std::vector<RPDetHitPoint>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPDetHitPoint*,std::vector<RPDetHitPoint> >*)arg[1]);
}

static  void method_12283( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDetHitPoint>*)o)->swap)(*(::std::vector<RPDetHitPoint>*)arg[0]);
}

static  void method_12284( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPDetHitPoint>*)o)->clear)();
}

static void method_newdel_2848( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPDetHitPoint> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPDetHitPoint> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPDetHitPoint> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPDetHitPoint> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPDetHitPoint> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x63( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPDetHitPoint,std::allocator<RPDetHitPoint> >")), ::Reflex::BaseOffset< ::std::vector<RPDetHitPoint>,::std::_Vector_base<RPDetHitPoint,std::allocator<RPDetHitPoint> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x64( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPDetHitPoint> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPDetHitPoint> >::Generate();
}

//------Dictionary for class vector<RPDetHitPoint,std::allocator<RPDetHitPoint> > -------------------------------
void __std__vector_RPDetHitPoint__db_datamem(Reflex::Class*);
void __std__vector_RPDetHitPoint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPDetHitPoint__datamem_bld(&__std__vector_RPDetHitPoint__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPDetHitPoint__funcmem_bld(&__std__vector_RPDetHitPoint__db_funcmem);
void __std__vector_RPDetHitPoint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPDetHitPoint>"), typeid(::std::vector<RPDetHitPoint>), sizeof(::std::vector<RPDetHitPoint>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2364, ::Reflex::BaseOffset< ::std::vector<RPDetHitPoint>, ::std::_Vector_base<RPDetHitPoint,std::allocator<RPDetHitPoint> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_221, Reflex::Literal("std::vector<RPDetHitPoint>::_Alloc_value_type"))
  .AddTypedef(type_2364, Reflex::Literal("std::vector<RPDetHitPoint>::_Base"))
  .AddTypedef(type_3061, Reflex::Literal("std::vector<RPDetHitPoint>::_Tp_alloc_type"))
  .AddTypedef(type_6693, Reflex::Literal("std::vector<RPDetHitPoint>::_Alloc_traits"))
  .AddTypedef(type_221, Reflex::Literal("std::vector<RPDetHitPoint>::value_type"))
  .AddTypedef(type_8292, Reflex::Literal("std::vector<RPDetHitPoint>::pointer"))
  .AddTypedef(type_12232, Reflex::Literal("std::vector<RPDetHitPoint>::const_pointer"))
  .AddTypedef(type_12234, Reflex::Literal("std::vector<RPDetHitPoint>::reference"))
  .AddTypedef(type_12236, Reflex::Literal("std::vector<RPDetHitPoint>::const_reference"))
  .AddTypedef(type_6611, Reflex::Literal("std::vector<RPDetHitPoint>::iterator"))
  .AddTypedef(type_6612, Reflex::Literal("std::vector<RPDetHitPoint>::const_iterator"))
  .AddTypedef(type_3234, Reflex::Literal("std::vector<RPDetHitPoint>::const_reverse_iterator"))
  .AddTypedef(type_3235, Reflex::Literal("std::vector<RPDetHitPoint>::reverse_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<RPDetHitPoint>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<RPDetHitPoint>::difference_type"))
  .AddTypedef(type_3061, Reflex::Literal("std::vector<RPDetHitPoint>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12245, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23563), Reflex::Literal("vector"), constructor_12246, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3037, type_12236, type_23563), Reflex::Literal("vector"), constructor_12247, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24344), Reflex::Literal("vector"), constructor_12248, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12249, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2848, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x63, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x64, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPDetHitPoint__funcmem_bld);
}

//------Delayed data member builder for class vector<RPDetHitPoint,std::allocator<RPDetHitPoint> > -------------------
void __std__vector_RPDetHitPoint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPDetHitPoint,std::allocator<RPDetHitPoint> > -------------------
void __std__vector_RPDetHitPoint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24345, type_24344), Reflex::Literal("operator="), operator_12250, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_12236), Reflex::Literal("assign"), method_12251, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6611), Reflex::Literal("begin"), method_12252, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6612), Reflex::Literal("begin"), method_12253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6611), Reflex::Literal("end"), method_12254, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6612), Reflex::Literal("end"), method_12255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_12260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_12261, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_221), Reflex::Literal("resize"), method_12262, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("capacity"), method_12263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_12264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037), Reflex::Literal("reserve"), method_12265, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12234, type_3037), Reflex::Literal("operator[]"), operator_12266, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12236, type_3037), Reflex::Literal("operator[]"), operator_12267, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12234, type_3037), Reflex::Literal("at"), method_12269, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12236, type_3037), Reflex::Literal("at"), method_12270, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12234), Reflex::Literal("front"), method_12271, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12236), Reflex::Literal("front"), method_12272, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12234), Reflex::Literal("back"), method_12273, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12236), Reflex::Literal("back"), method_12274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8292), Reflex::Literal("data"), method_12275, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12232), Reflex::Literal("data"), method_12276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12236), Reflex::Literal("push_back"), method_12277, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("pop_back"), method_12278, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6611, type_6611, type_12236), Reflex::Literal("insert"), method_12279, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_6611, type_3037, type_12236), Reflex::Literal("insert"), method_12280, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6611, type_6611), Reflex::Literal("erase"), method_12281, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6611, type_6611, type_6611), Reflex::Literal("erase"), method_12282, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24345), Reflex::Literal("swap"), method_12283, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_12284, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPFittedTrack,std::allocator<RPFittedTrack> > -------------------------------
static void constructor_12310( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFittedTrack>();
  else ::new(mem) ::std::vector<RPFittedTrack>();
}

static void constructor_12311( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFittedTrack>(*(const ::std::allocator<RPFittedTrack>*)arg[0]);
  else ::new(mem) ::std::vector<RPFittedTrack>(*(const ::std::allocator<RPFittedTrack>*)arg[0]);
}

static void constructor_12312( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFittedTrack>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPFittedTrack>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFittedTrack>(*(::std::size_t*)arg[0],
      *(const ::RPFittedTrack*)arg[1]);
  else ::new(mem) ::std::vector<RPFittedTrack>(*(::std::size_t*)arg[0],
      *(const ::RPFittedTrack*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFittedTrack>(*(::std::size_t*)arg[0],
      *(const ::RPFittedTrack*)arg[1],
      *(const ::std::allocator<RPFittedTrack>*)arg[2]);
  else ::new(mem) ::std::vector<RPFittedTrack>(*(::std::size_t*)arg[0],
      *(const ::RPFittedTrack*)arg[1],
      *(const ::std::allocator<RPFittedTrack>*)arg[2]);
  }
}

static void constructor_12313( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPFittedTrack>(*(const ::std::vector<RPFittedTrack>*)arg[0]);
  else ::new(mem) ::std::vector<RPFittedTrack>(*(const ::std::vector<RPFittedTrack>*)arg[0]);
}

static void destructor_12314(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPFittedTrack>*)o)->::std::vector<RPFittedTrack>::~vector)();
}
static  void operator_12315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPFittedTrack>*)o)->operator=)(*(const ::std::vector<RPFittedTrack>*)arg[0]);
  else   (((::std::vector<RPFittedTrack>*)o)->operator=)(*(const ::std::vector<RPFittedTrack>*)arg[0]);
}

static  void method_12316( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPFittedTrack>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPFittedTrack*)arg[1]);
}

static  void method_12317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >)((((::std::vector<RPFittedTrack>*)o)->begin)());
  else   (((::std::vector<RPFittedTrack>*)o)->begin)();
}

static  void method_12318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPFittedTrack*,std::vector<RPFittedTrack> >)((((const ::std::vector<RPFittedTrack>*)o)->begin)());
  else   (((const ::std::vector<RPFittedTrack>*)o)->begin)();
}

static  void method_12319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >)((((::std::vector<RPFittedTrack>*)o)->end)());
  else   (((::std::vector<RPFittedTrack>*)o)->end)();
}

static  void method_12320( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPFittedTrack*,std::vector<RPFittedTrack> >)((((const ::std::vector<RPFittedTrack>*)o)->end)());
  else   (((const ::std::vector<RPFittedTrack>*)o)->end)();
}

static  void method_12325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPFittedTrack>*)o)->size)());
  else   (((const ::std::vector<RPFittedTrack>*)o)->size)();
}

static  void method_12326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPFittedTrack>*)o)->max_size)());
  else   (((const ::std::vector<RPFittedTrack>*)o)->max_size)();
}

static  void method_12327( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPFittedTrack>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPFittedTrack>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPFittedTrack*)arg[1]);
  }
}

static  void method_12328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPFittedTrack>*)o)->capacity)());
  else   (((const ::std::vector<RPFittedTrack>*)o)->capacity)();
}

static  void method_12329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPFittedTrack>*)o)->empty)());
  else   (((const ::std::vector<RPFittedTrack>*)o)->empty)();
}

static  void method_12330( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPFittedTrack>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12331( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPFittedTrack>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPFittedTrack>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12332( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPFittedTrack>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPFittedTrack>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12334( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPFittedTrack>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPFittedTrack>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPFittedTrack>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPFittedTrack>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPFittedTrack>*)o)->front)();
  else   (((::std::vector<RPFittedTrack>*)o)->front)();
}

static  void method_12337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPFittedTrack>*)o)->front)();
  else   (((const ::std::vector<RPFittedTrack>*)o)->front)();
}

static  void method_12338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPFittedTrack>*)o)->back)();
  else   (((::std::vector<RPFittedTrack>*)o)->back)();
}

static  void method_12339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPFittedTrack>*)o)->back)();
  else   (((const ::std::vector<RPFittedTrack>*)o)->back)();
}

static  void method_12340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPFittedTrack>*)o)->data)());
  else   (((::std::vector<RPFittedTrack>*)o)->data)();
}

static  void method_12341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPFittedTrack>*)o)->data)());
  else   (((const ::std::vector<RPFittedTrack>*)o)->data)();
}

static  void method_12342( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPFittedTrack>*)o)->push_back)(*(const ::RPFittedTrack*)arg[0]);
}

static  void method_12343( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPFittedTrack>*)o)->pop_back)();
}

static  void method_12344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >)((((::std::vector<RPFittedTrack>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >*)arg[0],
    *(const ::RPFittedTrack*)arg[1]));
  else   (((::std::vector<RPFittedTrack>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >*)arg[0],
    *(const ::RPFittedTrack*)arg[1]);
}

static  void method_12345( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPFittedTrack>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPFittedTrack*)arg[2]);
}

static  void method_12346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >)((((::std::vector<RPFittedTrack>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >*)arg[0]));
  else   (((::std::vector<RPFittedTrack>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >*)arg[0]);
}

static  void method_12347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >)((((::std::vector<RPFittedTrack>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >*)arg[1]));
  else   (((::std::vector<RPFittedTrack>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPFittedTrack*,std::vector<RPFittedTrack> >*)arg[1]);
}

static  void method_12348( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPFittedTrack>*)o)->swap)(*(::std::vector<RPFittedTrack>*)arg[0]);
}

static  void method_12349( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPFittedTrack>*)o)->clear)();
}

static void method_newdel_2849( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPFittedTrack> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPFittedTrack> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPFittedTrack> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPFittedTrack> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPFittedTrack> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x66( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPFittedTrack,std::allocator<RPFittedTrack> >")), ::Reflex::BaseOffset< ::std::vector<RPFittedTrack>,::std::_Vector_base<RPFittedTrack,std::allocator<RPFittedTrack> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x67( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPFittedTrack> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPFittedTrack> >::Generate();
}

//------Dictionary for class vector<RPFittedTrack,std::allocator<RPFittedTrack> > -------------------------------
void __std__vector_RPFittedTrack__db_datamem(Reflex::Class*);
void __std__vector_RPFittedTrack__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPFittedTrack__datamem_bld(&__std__vector_RPFittedTrack__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPFittedTrack__funcmem_bld(&__std__vector_RPFittedTrack__db_funcmem);
void __std__vector_RPFittedTrack__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPFittedTrack>"), typeid(::std::vector<RPFittedTrack>), sizeof(::std::vector<RPFittedTrack>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2354, ::Reflex::BaseOffset< ::std::vector<RPFittedTrack>, ::std::_Vector_base<RPFittedTrack,std::allocator<RPFittedTrack> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_156, Reflex::Literal("std::vector<RPFittedTrack>::_Alloc_value_type"))
  .AddTypedef(type_2354, Reflex::Literal("std::vector<RPFittedTrack>::_Base"))
  .AddTypedef(type_3063, Reflex::Literal("std::vector<RPFittedTrack>::_Tp_alloc_type"))
  .AddTypedef(type_6683, Reflex::Literal("std::vector<RPFittedTrack>::_Alloc_traits"))
  .AddTypedef(type_156, Reflex::Literal("std::vector<RPFittedTrack>::value_type"))
  .AddTypedef(type_8104, Reflex::Literal("std::vector<RPFittedTrack>::pointer"))
  .AddTypedef(type_12297, Reflex::Literal("std::vector<RPFittedTrack>::const_pointer"))
  .AddTypedef(type_12299, Reflex::Literal("std::vector<RPFittedTrack>::reference"))
  .AddTypedef(type_12301, Reflex::Literal("std::vector<RPFittedTrack>::const_reference"))
  .AddTypedef(type_6591, Reflex::Literal("std::vector<RPFittedTrack>::iterator"))
  .AddTypedef(type_6592, Reflex::Literal("std::vector<RPFittedTrack>::const_iterator"))
  .AddTypedef(type_3202, Reflex::Literal("std::vector<RPFittedTrack>::const_reverse_iterator"))
  .AddTypedef(type_3203, Reflex::Literal("std::vector<RPFittedTrack>::reverse_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<RPFittedTrack>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<RPFittedTrack>::difference_type"))
  .AddTypedef(type_3063, Reflex::Literal("std::vector<RPFittedTrack>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12310, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23433), Reflex::Literal("vector"), constructor_12311, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3037, type_12301, type_23433), Reflex::Literal("vector"), constructor_12312, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12496), Reflex::Literal("vector"), constructor_12313, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12314, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2849, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x66, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x67, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPFittedTrack__funcmem_bld);
}

//------Delayed data member builder for class vector<RPFittedTrack,std::allocator<RPFittedTrack> > -------------------
void __std__vector_RPFittedTrack__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPFittedTrack,std::allocator<RPFittedTrack> > -------------------
void __std__vector_RPFittedTrack__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12494, type_12496), Reflex::Literal("operator="), operator_12315, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_12301), Reflex::Literal("assign"), method_12316, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6591), Reflex::Literal("begin"), method_12317, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("begin"), method_12318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6591), Reflex::Literal("end"), method_12319, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("end"), method_12320, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_12325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_12326, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_156), Reflex::Literal("resize"), method_12327, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("capacity"), method_12328, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_12329, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037), Reflex::Literal("reserve"), method_12330, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12299, type_3037), Reflex::Literal("operator[]"), operator_12331, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12301, type_3037), Reflex::Literal("operator[]"), operator_12332, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12299, type_3037), Reflex::Literal("at"), method_12334, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12301, type_3037), Reflex::Literal("at"), method_12335, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12299), Reflex::Literal("front"), method_12336, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12301), Reflex::Literal("front"), method_12337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12299), Reflex::Literal("back"), method_12338, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12301), Reflex::Literal("back"), method_12339, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8104), Reflex::Literal("data"), method_12340, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12297), Reflex::Literal("data"), method_12341, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12301), Reflex::Literal("push_back"), method_12342, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("pop_back"), method_12343, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6591, type_6591, type_12301), Reflex::Literal("insert"), method_12344, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_6591, type_3037, type_12301), Reflex::Literal("insert"), method_12345, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6591, type_6591), Reflex::Literal("erase"), method_12346, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6591, type_6591, type_6591), Reflex::Literal("erase"), method_12347, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12494), Reflex::Literal("swap"), method_12348, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_12349, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPTrackCandidate,std::allocator<RPTrackCandidate> > -------------------------------
static void constructor_12440( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTrackCandidate>();
  else ::new(mem) ::std::vector<RPTrackCandidate>();
}

static void constructor_12441( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTrackCandidate>(*(const ::std::allocator<RPTrackCandidate>*)arg[0]);
  else ::new(mem) ::std::vector<RPTrackCandidate>(*(const ::std::allocator<RPTrackCandidate>*)arg[0]);
}

static void constructor_12442( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTrackCandidate>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPTrackCandidate>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTrackCandidate>(*(::std::size_t*)arg[0],
      *(const ::RPTrackCandidate*)arg[1]);
  else ::new(mem) ::std::vector<RPTrackCandidate>(*(::std::size_t*)arg[0],
      *(const ::RPTrackCandidate*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTrackCandidate>(*(::std::size_t*)arg[0],
      *(const ::RPTrackCandidate*)arg[1],
      *(const ::std::allocator<RPTrackCandidate>*)arg[2]);
  else ::new(mem) ::std::vector<RPTrackCandidate>(*(::std::size_t*)arg[0],
      *(const ::RPTrackCandidate*)arg[1],
      *(const ::std::allocator<RPTrackCandidate>*)arg[2]);
  }
}

static void constructor_12443( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTrackCandidate>(*(const ::std::vector<RPTrackCandidate>*)arg[0]);
  else ::new(mem) ::std::vector<RPTrackCandidate>(*(const ::std::vector<RPTrackCandidate>*)arg[0]);
}

static void destructor_12444(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPTrackCandidate>*)o)->::std::vector<RPTrackCandidate>::~vector)();
}
static  void operator_12445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPTrackCandidate>*)o)->operator=)(*(const ::std::vector<RPTrackCandidate>*)arg[0]);
  else   (((::std::vector<RPTrackCandidate>*)o)->operator=)(*(const ::std::vector<RPTrackCandidate>*)arg[0]);
}

static  void method_12446( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPTrackCandidate>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPTrackCandidate*)arg[1]);
}

static  void method_12447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >)((((::std::vector<RPTrackCandidate>*)o)->begin)());
  else   (((::std::vector<RPTrackCandidate>*)o)->begin)();
}

static  void method_12448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPTrackCandidate*,std::vector<RPTrackCandidate> >)((((const ::std::vector<RPTrackCandidate>*)o)->begin)());
  else   (((const ::std::vector<RPTrackCandidate>*)o)->begin)();
}

static  void method_12449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >)((((::std::vector<RPTrackCandidate>*)o)->end)());
  else   (((::std::vector<RPTrackCandidate>*)o)->end)();
}

static  void method_12450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPTrackCandidate*,std::vector<RPTrackCandidate> >)((((const ::std::vector<RPTrackCandidate>*)o)->end)());
  else   (((const ::std::vector<RPTrackCandidate>*)o)->end)();
}

static  void method_12455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPTrackCandidate>*)o)->size)());
  else   (((const ::std::vector<RPTrackCandidate>*)o)->size)();
}

static  void method_12456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPTrackCandidate>*)o)->max_size)());
  else   (((const ::std::vector<RPTrackCandidate>*)o)->max_size)();
}

static  void method_12457( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPTrackCandidate>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPTrackCandidate>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPTrackCandidate*)arg[1]);
  }
}

static  void method_12458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPTrackCandidate>*)o)->capacity)());
  else   (((const ::std::vector<RPTrackCandidate>*)o)->capacity)();
}

static  void method_12459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPTrackCandidate>*)o)->empty)());
  else   (((const ::std::vector<RPTrackCandidate>*)o)->empty)();
}

static  void method_12460( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPTrackCandidate>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12461( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPTrackCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPTrackCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPTrackCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPTrackCandidate>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12464( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPTrackCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPTrackCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12465( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPTrackCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPTrackCandidate>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPTrackCandidate>*)o)->front)();
  else   (((::std::vector<RPTrackCandidate>*)o)->front)();
}

static  void method_12467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPTrackCandidate>*)o)->front)();
  else   (((const ::std::vector<RPTrackCandidate>*)o)->front)();
}

static  void method_12468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPTrackCandidate>*)o)->back)();
  else   (((::std::vector<RPTrackCandidate>*)o)->back)();
}

static  void method_12469( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPTrackCandidate>*)o)->back)();
  else   (((const ::std::vector<RPTrackCandidate>*)o)->back)();
}

static  void method_12470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPTrackCandidate>*)o)->data)());
  else   (((::std::vector<RPTrackCandidate>*)o)->data)();
}

static  void method_12471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPTrackCandidate>*)o)->data)());
  else   (((const ::std::vector<RPTrackCandidate>*)o)->data)();
}

static  void method_12472( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPTrackCandidate>*)o)->push_back)(*(const ::RPTrackCandidate*)arg[0]);
}

static  void method_12473( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPTrackCandidate>*)o)->pop_back)();
}

static  void method_12474( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >)((((::std::vector<RPTrackCandidate>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >*)arg[0],
    *(const ::RPTrackCandidate*)arg[1]));
  else   (((::std::vector<RPTrackCandidate>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >*)arg[0],
    *(const ::RPTrackCandidate*)arg[1]);
}

static  void method_12475( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPTrackCandidate>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPTrackCandidate*)arg[2]);
}

static  void method_12476( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >)((((::std::vector<RPTrackCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >*)arg[0]));
  else   (((::std::vector<RPTrackCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >*)arg[0]);
}

static  void method_12477( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >)((((::std::vector<RPTrackCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >*)arg[1]));
  else   (((::std::vector<RPTrackCandidate>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPTrackCandidate*,std::vector<RPTrackCandidate> >*)arg[1]);
}

static  void method_12478( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPTrackCandidate>*)o)->swap)(*(::std::vector<RPTrackCandidate>*)arg[0]);
}

static  void method_12479( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPTrackCandidate>*)o)->clear)();
}

static void method_newdel_2851( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPTrackCandidate> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPTrackCandidate> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPTrackCandidate> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPTrackCandidate> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPTrackCandidate> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x69( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPTrackCandidate,std::allocator<RPTrackCandidate> >")), ::Reflex::BaseOffset< ::std::vector<RPTrackCandidate>,::std::_Vector_base<RPTrackCandidate,std::allocator<RPTrackCandidate> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x70( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPTrackCandidate> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPTrackCandidate> >::Generate();
}

//------Dictionary for class vector<RPTrackCandidate,std::allocator<RPTrackCandidate> > -------------------------------
void __std__vector_RPTrackCandidate__db_datamem(Reflex::Class*);
void __std__vector_RPTrackCandidate__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPTrackCandidate__datamem_bld(&__std__vector_RPTrackCandidate__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPTrackCandidate__funcmem_bld(&__std__vector_RPTrackCandidate__db_funcmem);
void __std__vector_RPTrackCandidate__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPTrackCandidate>"), typeid(::std::vector<RPTrackCandidate>), sizeof(::std::vector<RPTrackCandidate>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2357, ::Reflex::BaseOffset< ::std::vector<RPTrackCandidate>, ::std::_Vector_base<RPTrackCandidate,std::allocator<RPTrackCandidate> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1658, Reflex::Literal("std::vector<RPTrackCandidate>::_Alloc_value_type"))
  .AddTypedef(type_2357, Reflex::Literal("std::vector<RPTrackCandidate>::_Base"))
  .AddTypedef(type_3067, Reflex::Literal("std::vector<RPTrackCandidate>::_Tp_alloc_type"))
  .AddTypedef(type_6686, Reflex::Literal("std::vector<RPTrackCandidate>::_Alloc_traits"))
  .AddTypedef(type_1658, Reflex::Literal("std::vector<RPTrackCandidate>::value_type"))
  .AddTypedef(type_8161, Reflex::Literal("std::vector<RPTrackCandidate>::pointer"))
  .AddTypedef(type_12427, Reflex::Literal("std::vector<RPTrackCandidate>::const_pointer"))
  .AddTypedef(type_12429, Reflex::Literal("std::vector<RPTrackCandidate>::reference"))
  .AddTypedef(type_12431, Reflex::Literal("std::vector<RPTrackCandidate>::const_reference"))
  .AddTypedef(type_6597, Reflex::Literal("std::vector<RPTrackCandidate>::iterator"))
  .AddTypedef(type_6598, Reflex::Literal("std::vector<RPTrackCandidate>::const_iterator"))
  .AddTypedef(type_3208, Reflex::Literal("std::vector<RPTrackCandidate>::const_reverse_iterator"))
  .AddTypedef(type_3209, Reflex::Literal("std::vector<RPTrackCandidate>::reverse_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<RPTrackCandidate>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<RPTrackCandidate>::difference_type"))
  .AddTypedef(type_3067, Reflex::Literal("std::vector<RPTrackCandidate>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12440, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23472), Reflex::Literal("vector"), constructor_12441, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3037, type_12431, type_23472), Reflex::Literal("vector"), constructor_12442, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12366), Reflex::Literal("vector"), constructor_12443, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12444, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2851, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x69, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x70, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPTrackCandidate__funcmem_bld);
}

//------Delayed data member builder for class vector<RPTrackCandidate,std::allocator<RPTrackCandidate> > -------------------
void __std__vector_RPTrackCandidate__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPTrackCandidate,std::allocator<RPTrackCandidate> > -------------------
void __std__vector_RPTrackCandidate__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12364, type_12366), Reflex::Literal("operator="), operator_12445, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_12431), Reflex::Literal("assign"), method_12446, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6597), Reflex::Literal("begin"), method_12447, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6598), Reflex::Literal("begin"), method_12448, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6597), Reflex::Literal("end"), method_12449, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6598), Reflex::Literal("end"), method_12450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_12455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_12456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_1658), Reflex::Literal("resize"), method_12457, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("capacity"), method_12458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_12459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037), Reflex::Literal("reserve"), method_12460, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12429, type_3037), Reflex::Literal("operator[]"), operator_12461, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12431, type_3037), Reflex::Literal("operator[]"), operator_12462, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12429, type_3037), Reflex::Literal("at"), method_12464, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12431, type_3037), Reflex::Literal("at"), method_12465, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12429), Reflex::Literal("front"), method_12466, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12431), Reflex::Literal("front"), method_12467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12429), Reflex::Literal("back"), method_12468, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12431), Reflex::Literal("back"), method_12469, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8161), Reflex::Literal("data"), method_12470, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12427), Reflex::Literal("data"), method_12471, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12431), Reflex::Literal("push_back"), method_12472, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("pop_back"), method_12473, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6597, type_6597, type_12431), Reflex::Literal("insert"), method_12474, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_6597, type_3037, type_12431), Reflex::Literal("insert"), method_12475, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6597, type_6597), Reflex::Literal("erase"), method_12476, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6597, type_6597, type_6597), Reflex::Literal("erase"), method_12477, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12364), Reflex::Literal("swap"), method_12478, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_12479, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >,std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > -------------------------------
static void constructor_12375( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >();
  else ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >();
}

static void constructor_12376( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >(*(const ::std::allocator<std::vector<RPTrackCandidate> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >(*(const ::std::allocator<std::vector<RPTrackCandidate> >*)arg[0]);
}

static void constructor_12377( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<RPTrackCandidate>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<RPTrackCandidate>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<RPTrackCandidate>*)arg[1],
      *(const ::std::allocator<std::vector<RPTrackCandidate> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<RPTrackCandidate>*)arg[1],
      *(const ::std::allocator<std::vector<RPTrackCandidate> >*)arg[2]);
  }
}

static void constructor_12378( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >(*(const ::std::vector<std::vector<RPTrackCandidate> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<RPTrackCandidate> >(*(const ::std::vector<std::vector<RPTrackCandidate> >*)arg[0]);
}

static void destructor_12379(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<RPTrackCandidate> >*)o)->::std::vector<std::vector<RPTrackCandidate> >::~vector)();
}
static  void operator_12380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<RPTrackCandidate> >*)o)->operator=)(*(const ::std::vector<std::vector<RPTrackCandidate> >*)arg[0]);
  else   (((::std::vector<std::vector<RPTrackCandidate> >*)o)->operator=)(*(const ::std::vector<std::vector<RPTrackCandidate> >*)arg[0]);
}

static  void method_12381( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<RPTrackCandidate> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<RPTrackCandidate>*)arg[1]);
}

static  void method_12382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >)((((::std::vector<std::vector<RPTrackCandidate> >*)o)->begin)());
  else   (((::std::vector<std::vector<RPTrackCandidate> >*)o)->begin)();
}

static  void method_12383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >)((((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->begin)();
}

static  void method_12384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >)((((::std::vector<std::vector<RPTrackCandidate> >*)o)->end)());
  else   (((::std::vector<std::vector<RPTrackCandidate> >*)o)->end)();
}

static  void method_12385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >)((((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->end)());
  else   (((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->end)();
}

static  void method_12390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->size)());
  else   (((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->size)();
}

static  void method_12391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->max_size)();
}

static  void method_12392( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<RPTrackCandidate> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<RPTrackCandidate> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<RPTrackCandidate>*)arg[1]);
  }
}

static  void method_12393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->capacity)();
}

static  void method_12394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->empty)();
}

static  void method_12395( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<RPTrackCandidate> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<RPTrackCandidate> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<RPTrackCandidate> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12397( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12399( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<RPTrackCandidate> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<RPTrackCandidate> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12400( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<RPTrackCandidate> >*)o)->front)();
  else   (((::std::vector<std::vector<RPTrackCandidate> >*)o)->front)();
}

static  void method_12402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->front)();
  else   (((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->front)();
}

static  void method_12403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<RPTrackCandidate> >*)o)->back)();
  else   (((::std::vector<std::vector<RPTrackCandidate> >*)o)->back)();
}

static  void method_12404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->back)();
  else   (((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->back)();
}

static  void method_12405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<RPTrackCandidate> >*)o)->data)());
  else   (((::std::vector<std::vector<RPTrackCandidate> >*)o)->data)();
}

static  void method_12406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->data)());
  else   (((const ::std::vector<std::vector<RPTrackCandidate> >*)o)->data)();
}

static  void method_12407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<RPTrackCandidate> >*)o)->push_back)(*(const ::std::vector<RPTrackCandidate>*)arg[0]);
}

static  void method_12408( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<RPTrackCandidate> >*)o)->pop_back)();
}

static  void method_12409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >)((((::std::vector<std::vector<RPTrackCandidate> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >*)arg[0],
    *(const ::std::vector<RPTrackCandidate>*)arg[1]));
  else   (((::std::vector<std::vector<RPTrackCandidate> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >*)arg[0],
    *(const ::std::vector<RPTrackCandidate>*)arg[1]);
}

static  void method_12410( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<RPTrackCandidate> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<RPTrackCandidate>*)arg[2]);
}

static  void method_12411( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >)((((::std::vector<std::vector<RPTrackCandidate> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >*)arg[0]));
  else   (((::std::vector<std::vector<RPTrackCandidate> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >*)arg[0]);
}

static  void method_12412( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >)((((::std::vector<std::vector<RPTrackCandidate> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >*)arg[1]));
  else   (((::std::vector<std::vector<RPTrackCandidate> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<RPTrackCandidate>*,std::vector<std::vector<RPTrackCandidate> > >*)arg[1]);
}

static  void method_12413( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<RPTrackCandidate> >*)o)->swap)(*(::std::vector<std::vector<RPTrackCandidate> >*)arg[0]);
}

static  void method_12414( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<RPTrackCandidate> >*)o)->clear)();
}

static void method_newdel_2850( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<RPTrackCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<RPTrackCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<RPTrackCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<RPTrackCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<RPTrackCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x72( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<RPTrackCandidate>,std::allocator<std::vector<RPTrackCandidate> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<RPTrackCandidate> >,::std::_Vector_base<std::vector<RPTrackCandidate>,std::allocator<std::vector<RPTrackCandidate> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x73( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<RPTrackCandidate> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<RPTrackCandidate> > >::Generate();
}

//------Dictionary for class vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >,std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > -------------------------------
void __std__vector_std__vector_RPTrackCandidate_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_RPTrackCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_RPTrackCandidate_s__datamem_bld(&__std__vector_std__vector_RPTrackCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_RPTrackCandidate_s__funcmem_bld(&__std__vector_std__vector_RPTrackCandidate_s__db_funcmem);
void __std__vector_std__vector_RPTrackCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >"), typeid(::std::vector<std::vector<RPTrackCandidate> >), sizeof(::std::vector<std::vector<RPTrackCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2355, ::Reflex::BaseOffset< ::std::vector<std::vector<RPTrackCandidate> >, ::std::_Vector_base<std::vector<RPTrackCandidate>,std::allocator<std::vector<RPTrackCandidate> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2851, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::_Alloc_value_type"))
  .AddTypedef(type_2355, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::_Base"))
  .AddTypedef(type_3066, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::_Tp_alloc_type"))
  .AddTypedef(type_6684, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::_Alloc_traits"))
  .AddTypedef(type_2851, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::value_type"))
  .AddTypedef(type_8123, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::pointer"))
  .AddTypedef(type_12362, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::const_pointer"))
  .AddTypedef(type_12364, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::reference"))
  .AddTypedef(type_12366, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::const_reference"))
  .AddTypedef(type_6593, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::iterator"))
  .AddTypedef(type_6594, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::const_iterator"))
  .AddTypedef(type_3204, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::const_reverse_iterator"))
  .AddTypedef(type_3205, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::reverse_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::difference_type"))
  .AddTypedef(type_3066, Reflex::Literal("std::vector<std::vector<RPTrackCandidate> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12375, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23446), Reflex::Literal("vector"), constructor_12376, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3037, type_12366, type_23446), Reflex::Literal("vector"), constructor_12377, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24348), Reflex::Literal("vector"), constructor_12378, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12379, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2850, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x72, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x73, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_RPTrackCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >,std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > -------------------
void __std__vector_std__vector_RPTrackCandidate_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >,std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > -------------------
void __std__vector_std__vector_RPTrackCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24349, type_24348), Reflex::Literal("operator="), operator_12380, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_12366), Reflex::Literal("assign"), method_12381, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6593), Reflex::Literal("begin"), method_12382, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6594), Reflex::Literal("begin"), method_12383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6593), Reflex::Literal("end"), method_12384, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6594), Reflex::Literal("end"), method_12385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_12390, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_12391, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_2851), Reflex::Literal("resize"), method_12392, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("capacity"), method_12393, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_12394, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037), Reflex::Literal("reserve"), method_12395, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12364, type_3037), Reflex::Literal("operator[]"), operator_12396, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12366, type_3037), Reflex::Literal("operator[]"), operator_12397, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12364, type_3037), Reflex::Literal("at"), method_12399, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12366, type_3037), Reflex::Literal("at"), method_12400, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12364), Reflex::Literal("front"), method_12401, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12366), Reflex::Literal("front"), method_12402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12364), Reflex::Literal("back"), method_12403, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12366), Reflex::Literal("back"), method_12404, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8123), Reflex::Literal("data"), method_12405, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12362), Reflex::Literal("data"), method_12406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12366), Reflex::Literal("push_back"), method_12407, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("pop_back"), method_12408, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6593, type_6593, type_12366), Reflex::Literal("insert"), method_12409, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_6593, type_3037, type_12366), Reflex::Literal("insert"), method_12410, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6593, type_6593), Reflex::Literal("erase"), method_12411, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6593, type_6593, type_6593), Reflex::Literal("erase"), method_12412, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24349), Reflex::Literal("swap"), method_12413, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_12414, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >,std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > -------------------------------
static void constructor_12505( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPFittedTrack> >();
  else ::new(mem) ::std::vector<std::vector<RPFittedTrack> >();
}

static void constructor_12506( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPFittedTrack> >(*(const ::std::allocator<std::vector<RPFittedTrack> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<RPFittedTrack> >(*(const ::std::allocator<std::vector<RPFittedTrack> >*)arg[0]);
}

static void constructor_12507( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPFittedTrack> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<RPFittedTrack> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPFittedTrack> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<RPFittedTrack>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<RPFittedTrack> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<RPFittedTrack>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPFittedTrack> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<RPFittedTrack>*)arg[1],
      *(const ::std::allocator<std::vector<RPFittedTrack> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<RPFittedTrack> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<RPFittedTrack>*)arg[1],
      *(const ::std::allocator<std::vector<RPFittedTrack> >*)arg[2]);
  }
}

static void constructor_12508( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<RPFittedTrack> >(*(const ::std::vector<std::vector<RPFittedTrack> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<RPFittedTrack> >(*(const ::std::vector<std::vector<RPFittedTrack> >*)arg[0]);
}

static void destructor_12509(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<RPFittedTrack> >*)o)->::std::vector<std::vector<RPFittedTrack> >::~vector)();
}
static  void operator_12510( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<RPFittedTrack> >*)o)->operator=)(*(const ::std::vector<std::vector<RPFittedTrack> >*)arg[0]);
  else   (((::std::vector<std::vector<RPFittedTrack> >*)o)->operator=)(*(const ::std::vector<std::vector<RPFittedTrack> >*)arg[0]);
}

static  void method_12511( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<RPFittedTrack> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<RPFittedTrack>*)arg[1]);
}

static  void method_12512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >)((((::std::vector<std::vector<RPFittedTrack> >*)o)->begin)());
  else   (((::std::vector<std::vector<RPFittedTrack> >*)o)->begin)();
}

static  void method_12513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >)((((const ::std::vector<std::vector<RPFittedTrack> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<RPFittedTrack> >*)o)->begin)();
}

static  void method_12514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >)((((::std::vector<std::vector<RPFittedTrack> >*)o)->end)());
  else   (((::std::vector<std::vector<RPFittedTrack> >*)o)->end)();
}

static  void method_12515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >)((((const ::std::vector<std::vector<RPFittedTrack> >*)o)->end)());
  else   (((const ::std::vector<std::vector<RPFittedTrack> >*)o)->end)();
}

static  void method_12520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<RPFittedTrack> >*)o)->size)());
  else   (((const ::std::vector<std::vector<RPFittedTrack> >*)o)->size)();
}

static  void method_12521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<RPFittedTrack> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<RPFittedTrack> >*)o)->max_size)();
}

static  void method_12522( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<RPFittedTrack> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<RPFittedTrack> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<RPFittedTrack>*)arg[1]);
  }
}

static  void method_12523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<RPFittedTrack> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<RPFittedTrack> >*)o)->capacity)();
}

static  void method_12524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<RPFittedTrack> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<RPFittedTrack> >*)o)->empty)();
}

static  void method_12525( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<RPFittedTrack> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12526( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<RPFittedTrack> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<RPFittedTrack> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<RPFittedTrack> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<RPFittedTrack> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<RPFittedTrack> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<RPFittedTrack> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<RPFittedTrack> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<RPFittedTrack> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<RPFittedTrack> >*)o)->front)();
  else   (((::std::vector<std::vector<RPFittedTrack> >*)o)->front)();
}

static  void method_12532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<RPFittedTrack> >*)o)->front)();
  else   (((const ::std::vector<std::vector<RPFittedTrack> >*)o)->front)();
}

static  void method_12533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<RPFittedTrack> >*)o)->back)();
  else   (((::std::vector<std::vector<RPFittedTrack> >*)o)->back)();
}

static  void method_12534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<RPFittedTrack> >*)o)->back)();
  else   (((const ::std::vector<std::vector<RPFittedTrack> >*)o)->back)();
}

static  void method_12535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<RPFittedTrack> >*)o)->data)());
  else   (((::std::vector<std::vector<RPFittedTrack> >*)o)->data)();
}

static  void method_12536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<RPFittedTrack> >*)o)->data)());
  else   (((const ::std::vector<std::vector<RPFittedTrack> >*)o)->data)();
}

static  void method_12537( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<RPFittedTrack> >*)o)->push_back)(*(const ::std::vector<RPFittedTrack>*)arg[0]);
}

static  void method_12538( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<RPFittedTrack> >*)o)->pop_back)();
}

static  void method_12539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >)((((::std::vector<std::vector<RPFittedTrack> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >*)arg[0],
    *(const ::std::vector<RPFittedTrack>*)arg[1]));
  else   (((::std::vector<std::vector<RPFittedTrack> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >*)arg[0],
    *(const ::std::vector<RPFittedTrack>*)arg[1]);
}

static  void method_12540( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<RPFittedTrack> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<RPFittedTrack>*)arg[2]);
}

static  void method_12541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >)((((::std::vector<std::vector<RPFittedTrack> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >*)arg[0]));
  else   (((::std::vector<std::vector<RPFittedTrack> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >*)arg[0]);
}

static  void method_12542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >)((((::std::vector<std::vector<RPFittedTrack> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >*)arg[1]));
  else   (((::std::vector<std::vector<RPFittedTrack> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<RPFittedTrack>*,std::vector<std::vector<RPFittedTrack> > >*)arg[1]);
}

static  void method_12543( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<RPFittedTrack> >*)o)->swap)(*(::std::vector<std::vector<RPFittedTrack> >*)arg[0]);
}

static  void method_12544( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<RPFittedTrack> >*)o)->clear)();
}

static void method_newdel_2852( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<RPFittedTrack> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<RPFittedTrack> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<RPFittedTrack> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<RPFittedTrack> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<RPFittedTrack> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x75( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<RPFittedTrack>,std::allocator<std::vector<RPFittedTrack> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<RPFittedTrack> >,::std::_Vector_base<std::vector<RPFittedTrack>,std::allocator<std::vector<RPFittedTrack> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x76( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<RPFittedTrack> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<RPFittedTrack> > >::Generate();
}

//------Dictionary for class vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >,std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > -------------------------------
void __std__vector_std__vector_RPFittedTrack_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_RPFittedTrack_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_RPFittedTrack_s__datamem_bld(&__std__vector_std__vector_RPFittedTrack_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_RPFittedTrack_s__funcmem_bld(&__std__vector_std__vector_RPFittedTrack_s__db_funcmem);
void __std__vector_std__vector_RPFittedTrack_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<RPFittedTrack> >"), typeid(::std::vector<std::vector<RPFittedTrack> >), sizeof(::std::vector<std::vector<RPFittedTrack> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2356, ::Reflex::BaseOffset< ::std::vector<std::vector<RPFittedTrack> >, ::std::_Vector_base<std::vector<RPFittedTrack>,std::allocator<std::vector<RPFittedTrack> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2849, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::_Alloc_value_type"))
  .AddTypedef(type_2356, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::_Base"))
  .AddTypedef(type_3069, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::_Tp_alloc_type"))
  .AddTypedef(type_6685, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::_Alloc_traits"))
  .AddTypedef(type_2849, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::value_type"))
  .AddTypedef(type_8142, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::pointer"))
  .AddTypedef(type_12492, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::const_pointer"))
  .AddTypedef(type_12494, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::reference"))
  .AddTypedef(type_12496, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::const_reference"))
  .AddTypedef(type_6595, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::iterator"))
  .AddTypedef(type_6596, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::const_iterator"))
  .AddTypedef(type_3206, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::const_reverse_iterator"))
  .AddTypedef(type_3207, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::reverse_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::difference_type"))
  .AddTypedef(type_3069, Reflex::Literal("std::vector<std::vector<RPFittedTrack> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12505, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23459), Reflex::Literal("vector"), constructor_12506, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3037, type_12496, type_23459), Reflex::Literal("vector"), constructor_12507, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24352), Reflex::Literal("vector"), constructor_12508, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12509, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2852, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x75, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x76, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_RPFittedTrack_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >,std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > -------------------
void __std__vector_std__vector_RPFittedTrack_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >,std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > -------------------
void __std__vector_std__vector_RPFittedTrack_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24353, type_24352), Reflex::Literal("operator="), operator_12510, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_12496), Reflex::Literal("assign"), method_12511, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6595), Reflex::Literal("begin"), method_12512, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6596), Reflex::Literal("begin"), method_12513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6595), Reflex::Literal("end"), method_12514, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6596), Reflex::Literal("end"), method_12515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_12520, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_12521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037, type_2849), Reflex::Literal("resize"), method_12522, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("capacity"), method_12523, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_12524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_3037), Reflex::Literal("reserve"), method_12525, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12494, type_3037), Reflex::Literal("operator[]"), operator_12526, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12496, type_3037), Reflex::Literal("operator[]"), operator_12527, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12494, type_3037), Reflex::Literal("at"), method_12529, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12496, type_3037), Reflex::Literal("at"), method_12530, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12494), Reflex::Literal("front"), method_12531, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12496), Reflex::Literal("front"), method_12532, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12494), Reflex::Literal("back"), method_12533, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12496), Reflex::Literal("back"), method_12534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8142), Reflex::Literal("data"), method_12535, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12492), Reflex::Literal("data"), method_12536, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_12496), Reflex::Literal("push_back"), method_12537, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("pop_back"), method_12538, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6595, type_6595, type_12496), Reflex::Literal("insert"), method_12539, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_6595, type_3037, type_12496), Reflex::Literal("insert"), method_12540, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6595, type_6595), Reflex::Literal("erase"), method_12541, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6595, type_6595, type_6595), Reflex::Literal("erase"), method_12542, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24353), Reflex::Literal("swap"), method_12543, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_12544, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<unsigned int,std::vector<RPStationTrackFit, std::allocator<RPStationTrackFit> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPStationTrackFit, std::allocator<RPStationTrackFit> > > > > -------------------------------
static void destructor_14058(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->::std::map<unsigned int,std::vector<RPStationTrackFit> >::~map)();
}
static void constructor_14059( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPStationTrackFit> >();
  else ::new(mem) ::std::map<unsigned int,std::vector<RPStationTrackFit> >();
}

static void constructor_14060( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPStationTrackFit> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPStationTrackFit> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPStationTrackFit> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPStationTrackFit> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >*)arg[1]);
  }
}

static void constructor_14061( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPStationTrackFit> >(*(const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPStationTrackFit> >(*(const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)arg[0]);
}

static  void operator_14062( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)arg[0]);
}

static  void method_14063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->get_allocator)();
}

static  void method_14064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->begin)();
}

static  void method_14065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->begin)();
}

static  void method_14066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->end)();
}

static  void method_14067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->end)();
}

static  void method_14072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->empty)();
}

static  void method_14073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->size)();
}

static  void method_14074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->max_size)();
}

static  void operator_14075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >,bool>)((((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPStationTrackFit> >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPStationTrackFit> >*)arg[0]);
}

static  void method_14079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPStationTrackFit> >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPStationTrackFit> >*)arg[1]);
}

static  void method_14080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >*)arg[0]);
}

static  void method_14081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >*)arg[1]);
}

static  void method_14083( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->swap)(*(::std::map<unsigned int,std::vector<RPStationTrackFit> >*)arg[0]);
}

static  void method_14084( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->clear)();
}

static  void method_14085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->key_comp)();
}

static  void method_14087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14090( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14093( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > > >)((((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPStationTrackFit> > > >)((((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPStationTrackFit> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2973( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPStationTrackFit> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPStationTrackFit> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPStationTrackFit> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPStationTrackFit> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPStationTrackFit> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x78( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPStationTrackFit> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPStationTrackFit> > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<RPStationTrackFit, std::allocator<RPStationTrackFit> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPStationTrackFit, std::allocator<RPStationTrackFit> > > > > -------------------------------
void __std__map_unsignedsint_std__vector_RPStationTrackFit_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_RPStationTrackFit_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPStationTrackFit_s__datamem_bld(&__std__map_unsignedsint_std__vector_RPStationTrackFit_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPStationTrackFit_s__funcmem_bld(&__std__map_unsignedsint_std__vector_RPStationTrackFit_s__db_funcmem);
void __std__map_unsignedsint_std__vector_RPStationTrackFit_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >"), typeid(::std::map<unsigned int,std::vector<RPStationTrackFit> >), sizeof(::std::map<unsigned int,std::vector<RPStationTrackFit> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_296, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::key_type"))
  .AddTypedef(type_2842, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::mapped_type"))
  .AddTypedef(type_2771, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::value_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::key_compare"))
  .AddTypedef(type_3051, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::allocator_type"))
  .AddTypedef(type_2771, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::_Alloc_value_type"))
  .AddTypedef(type_3051, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::_Pair_alloc_type"))
  .AddTypedef(type_2556, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::_Rep_type"))
  .AddTypedef(type_9662, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::pointer"))
  .AddTypedef(type_9664, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::const_pointer"))
  .AddTypedef(type_9666, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::reference"))
  .AddTypedef(type_9668, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::const_reference"))
  .AddTypedef(type_2908, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::iterator"))
  .AddTypedef(type_2660, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::const_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::difference_type"))
  .AddTypedef(type_3211, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::reverse_iterator"))
  .AddTypedef(type_3210, Reflex::Literal("std::map<unsigned int,std::vector<RPStationTrackFit> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14058, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14059, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23996, type_24074), Reflex::Literal("map"), constructor_14060, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24481), Reflex::Literal("map"), constructor_14061, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2973, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x78, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_RPStationTrackFit_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_RPStationTrackFit_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<RPStationTrackFit, std::allocator<RPStationTrackFit> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPStationTrackFit, std::allocator<RPStationTrackFit> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPStationTrackFit_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2556, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_RPStationTrackFit_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<RPStationTrackFit, std::allocator<RPStationTrackFit> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPStationTrackFit, std::allocator<RPStationTrackFit> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPStationTrackFit_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24482, type_24481), Reflex::Literal("operator="), operator_14062, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3051), Reflex::Literal("get_allocator"), method_14063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2908), Reflex::Literal("begin"), method_14064, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660), Reflex::Literal("begin"), method_14065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2908), Reflex::Literal("end"), method_14066, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660), Reflex::Literal("end"), method_14067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_14072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_14073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_14074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24329, type_23997), Reflex::Literal("operator[]"), operator_14075, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24329, type_23997), Reflex::Literal("at"), method_14076, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24328, type_23997), Reflex::Literal("at"), method_14077, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2787, type_9668), Reflex::Literal("insert"), method_14078, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2908, type_2908, type_9668), Reflex::Literal("insert"), method_14079, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2908), Reflex::Literal("erase"), method_14080, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("erase"), method_14081, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2908, type_2908), Reflex::Literal("erase"), method_14082, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24482), Reflex::Literal("swap"), method_14083, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_14084, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510), Reflex::Literal("key_comp"), method_14085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2908, type_23997), Reflex::Literal("find"), method_14087, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660, type_23997), Reflex::Literal("find"), method_14088, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("count"), method_14089, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2908, type_23997), Reflex::Literal("lower_bound"), method_14090, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660, type_23997), Reflex::Literal("lower_bound"), method_14091, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2908, type_23997), Reflex::Literal("upper_bound"), method_14092, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660, type_23997), Reflex::Literal("upper_bound"), method_14093, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2786, type_23997), Reflex::Literal("equal_range"), method_14094, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2785, type_23997), Reflex::Literal("equal_range"), method_14095, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,RPRecognizedPatterns,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRecognizedPatterns> > > -------------------------------
static void destructor_14116(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RPRecognizedPatterns>*)o)->::std::map<unsigned int,RPRecognizedPatterns>::~map)();
}
static void constructor_14117( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRecognizedPatterns>();
  else ::new(mem) ::std::map<unsigned int,RPRecognizedPatterns>();
}

static void constructor_14118( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRecognizedPatterns>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRecognizedPatterns>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRecognizedPatterns>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRecognizedPatterns> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RPRecognizedPatterns>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRecognizedPatterns> >*)arg[1]);
  }
}

static void constructor_14119( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRecognizedPatterns>(*(const ::std::map<unsigned int,RPRecognizedPatterns>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRecognizedPatterns>(*(const ::std::map<unsigned int,RPRecognizedPatterns>*)arg[0]);
}

static  void operator_14120( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRecognizedPatterns>*)o)->operator=)(*(const ::std::map<unsigned int,RPRecognizedPatterns>*)arg[0]);
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->operator=)(*(const ::std::map<unsigned int,RPRecognizedPatterns>*)arg[0]);
}

static  void method_14121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->get_allocator)();
}

static  void method_14122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((::std::map<unsigned int,RPRecognizedPatterns>*)o)->begin)());
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->begin)();
}

static  void method_14123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->begin)();
}

static  void method_14124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((::std::map<unsigned int,RPRecognizedPatterns>*)o)->end)());
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->end)();
}

static  void method_14125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->end)());
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->end)();
}

static  void method_14130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->empty)();
}

static  void method_14131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->size)());
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->size)();
}

static  void method_14132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->max_size)();
}

static  void operator_14133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRecognizedPatterns>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRecognizedPatterns>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >,bool>)((((::std::map<unsigned int,RPRecognizedPatterns>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRecognizedPatterns>*)arg[0]));
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRecognizedPatterns>*)arg[0]);
}

static  void method_14137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((::std::map<unsigned int,RPRecognizedPatterns>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRecognizedPatterns>*)arg[1]));
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRecognizedPatterns>*)arg[1]);
}

static  void method_14138( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >*)arg[0]);
}

static  void method_14139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RPRecognizedPatterns>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14140( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >*)arg[1]);
}

static  void method_14141( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->swap)(*(::std::map<unsigned int,RPRecognizedPatterns>*)arg[0]);
}

static  void method_14142( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->clear)();
}

static  void method_14143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->key_comp)();
}

static  void method_14145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((::std::map<unsigned int,RPRecognizedPatterns>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14147( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((::std::map<unsigned int,RPRecognizedPatterns>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((::std::map<unsigned int,RPRecognizedPatterns>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRecognizedPatterns> > >)((((::std::map<unsigned int,RPRecognizedPatterns>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRecognizedPatterns>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRecognizedPatterns> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRecognizedPatterns> > >)((((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRecognizedPatterns>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2974( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRecognizedPatterns> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRecognizedPatterns> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRecognizedPatterns> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRecognizedPatterns> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRecognizedPatterns> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x80( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RPRecognizedPatterns> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RPRecognizedPatterns> >::Generate();
}

//------Dictionary for class map<unsigned int,RPRecognizedPatterns,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRecognizedPatterns> > > -------------------------------
void __std__map_unsignedsint_RPRecognizedPatterns__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RPRecognizedPatterns__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRecognizedPatterns__datamem_bld(&__std__map_unsignedsint_RPRecognizedPatterns__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRecognizedPatterns__funcmem_bld(&__std__map_unsignedsint_RPRecognizedPatterns__db_funcmem);
void __std__map_unsignedsint_RPRecognizedPatterns__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>"), typeid(::std::map<unsigned int,RPRecognizedPatterns>), sizeof(::std::map<unsigned int,RPRecognizedPatterns>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_296, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::key_type"))
  .AddTypedef(type_2172, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::mapped_type"))
  .AddTypedef(type_2773, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::value_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::key_compare"))
  .AddTypedef(type_3054, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::allocator_type"))
  .AddTypedef(type_2773, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::_Alloc_value_type"))
  .AddTypedef(type_3054, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::_Pair_alloc_type"))
  .AddTypedef(type_2557, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::_Rep_type"))
  .AddTypedef(type_9771, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::pointer"))
  .AddTypedef(type_9773, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::const_pointer"))
  .AddTypedef(type_9775, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::reference"))
  .AddTypedef(type_9777, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::const_reference"))
  .AddTypedef(type_2909, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::iterator"))
  .AddTypedef(type_2661, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::const_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::difference_type"))
  .AddTypedef(type_3213, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::reverse_iterator"))
  .AddTypedef(type_3212, Reflex::Literal("std::map<unsigned int,RPRecognizedPatterns>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14117, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23996, type_24082), Reflex::Literal("map"), constructor_14118, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24483), Reflex::Literal("map"), constructor_14119, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2974, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x80, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RPRecognizedPatterns__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RPRecognizedPatterns__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RPRecognizedPatterns,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRecognizedPatterns> > > -------------------
void __std__map_unsignedsint_RPRecognizedPatterns__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2557, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RPRecognizedPatterns_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RPRecognizedPatterns,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRecognizedPatterns> > > -------------------
void __std__map_unsignedsint_RPRecognizedPatterns__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24484, type_24483), Reflex::Literal("operator="), operator_14120, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054), Reflex::Literal("get_allocator"), method_14121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2909), Reflex::Literal("begin"), method_14122, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2661), Reflex::Literal("begin"), method_14123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2909), Reflex::Literal("end"), method_14124, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2661), Reflex::Literal("end"), method_14125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_14130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_14131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_14132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23135, type_23997), Reflex::Literal("operator[]"), operator_14133, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23135, type_23997), Reflex::Literal("at"), method_14134, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23136, type_23997), Reflex::Literal("at"), method_14135, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2791, type_9777), Reflex::Literal("insert"), method_14136, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2909, type_2909, type_9777), Reflex::Literal("insert"), method_14137, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2909), Reflex::Literal("erase"), method_14138, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("erase"), method_14139, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2909, type_2909), Reflex::Literal("erase"), method_14140, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24484), Reflex::Literal("swap"), method_14141, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_14142, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510), Reflex::Literal("key_comp"), method_14143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2909, type_23997), Reflex::Literal("find"), method_14145, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2661, type_23997), Reflex::Literal("find"), method_14146, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("count"), method_14147, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2909, type_23997), Reflex::Literal("lower_bound"), method_14148, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2661, type_23997), Reflex::Literal("lower_bound"), method_14149, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2909, type_23997), Reflex::Literal("upper_bound"), method_14150, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2661, type_23997), Reflex::Literal("upper_bound"), method_14151, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2790, type_23997), Reflex::Literal("equal_range"), method_14152, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2789, type_23997), Reflex::Literal("equal_range"), method_14153, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class binary_function<unsigned int,unsigned int,bool> -------------------------------
static void destructor_14621(void*, void * o, const std::vector<void*>&, void *) {
(((::std::binary_function<unsigned int,unsigned int,bool>*)o)->::std::binary_function<unsigned int,unsigned int,bool>::~binary_function)();
}
static  void operator_14622( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::binary_function<unsigned int,unsigned int,bool>*)o)->operator=)(*(const ::std::binary_function<unsigned int,unsigned int,bool>*)arg[0]);
  else   (((::std::binary_function<unsigned int,unsigned int,bool>*)o)->operator=)(*(const ::std::binary_function<unsigned int,unsigned int,bool>*)arg[0]);
}

static void constructor_14623( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::binary_function<unsigned int,unsigned int,bool>(*(const ::std::binary_function<unsigned int,unsigned int,bool>*)arg[0]);
  else ::new(mem) ::std::binary_function<unsigned int,unsigned int,bool>(*(const ::std::binary_function<unsigned int,unsigned int,bool>*)arg[0]);
}

static void constructor_14624( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::binary_function<unsigned int,unsigned int,bool>();
  else ::new(mem) ::std::binary_function<unsigned int,unsigned int,bool>();
}

static void method_newdel_2990( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::binary_function<unsigned int,unsigned int,bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::binary_function<unsigned int,unsigned int,bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::binary_function<unsigned int,unsigned int,bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::binary_function<unsigned int,unsigned int,bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::binary_function<unsigned int,unsigned int,bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class binary_function<unsigned int,unsigned int,bool> -------------------------------
void __std__binary_function_unsignedsint_unsignedsint_bool__db_datamem(Reflex::Class*);
void __std__binary_function_unsignedsint_unsignedsint_bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__binary_function_unsignedsint_unsignedsint_bool__datamem_bld(&__std__binary_function_unsignedsint_unsignedsint_bool__db_datamem);
Reflex::GenreflexMemberBuilder __std__binary_function_unsignedsint_unsignedsint_bool__funcmem_bld(&__std__binary_function_unsignedsint_unsignedsint_bool__db_funcmem);
void __std__binary_function_unsignedsint_unsignedsint_bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::binary_function<unsigned int,unsigned int,bool>"), typeid(::std::binary_function<unsigned int,unsigned int,bool>), sizeof(::std::binary_function<unsigned int,unsigned int,bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_296, Reflex::Literal("std::binary_function<unsigned int,unsigned int,bool>::first_argument_type"))
  .AddTypedef(type_296, Reflex::Literal("std::binary_function<unsigned int,unsigned int,bool>::second_argument_type"))
  .AddTypedef(type_1482, Reflex::Literal("std::binary_function<unsigned int,unsigned int,bool>::result_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~binary_function"), destructor_14621, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24502, type_24503), Reflex::Literal("operator="), operator_14622, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24503), Reflex::Literal("binary_function"), constructor_14623, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("binary_function"), constructor_14624, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2990, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class binary_function<unsigned int,unsigned int,bool> -------------------
void __std__binary_function_unsignedsint_unsignedsint_bool__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class binary_function<unsigned int,unsigned int,bool> -------------------
void __std__binary_function_unsignedsint_unsignedsint_bool__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<std::pair<const unsigned int, RPFittedTrack> > -------------------------------
static  void operator_14997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<std::pair<const unsigned int,RPFittedTrack> >*)o)->operator=)(*(const ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >*)arg[0]);
  else   (((::std::allocator<std::pair<const unsigned int,RPFittedTrack> >*)o)->operator=)(*(const ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >*)arg[0]);
}

static void constructor_14998( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >();
  else ::new(mem) ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >();
}

static void constructor_14999( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >(*(const ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >*)arg[0]);
  else ::new(mem) ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >(*(const ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >*)arg[0]);
}

static void destructor_15000(void*, void * o, const std::vector<void*>&, void *) {
(((::std::allocator<std::pair<const unsigned int,RPFittedTrack> >*)o)->::std::allocator<std::pair<const unsigned int,RPFittedTrack> >::~allocator)();
}
static void method_newdel_3053( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<std::pair<const unsigned int,RPFittedTrack> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<std::pair<const unsigned int,RPFittedTrack> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<std::pair<const unsigned int,RPFittedTrack> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<std::pair<const unsigned int,RPFittedTrack> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<std::pair<const unsigned int,RPFittedTrack> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x83( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<std::pair<const unsigned int,RPFittedTrack> >")), ::Reflex::BaseOffset< ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >,::__gnu_cxx::new_allocator<std::pair<const unsigned int,RPFittedTrack> > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<std::pair<const unsigned int, RPFittedTrack> > -------------------------------
void __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s__db_datamem(Reflex::Class*);
void __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s__datamem_bld(&__std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s__funcmem_bld(&__std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s__db_funcmem);
void __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPFittedTrack> >"), typeid(::std::allocator<std::pair<const unsigned int,RPFittedTrack> >), sizeof(::std::allocator<std::pair<const unsigned int,RPFittedTrack> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_6525, ::Reflex::BaseOffset< ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >, ::__gnu_cxx::new_allocator<std::pair<const unsigned int,RPFittedTrack> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3037, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPFittedTrack> >::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPFittedTrack> >::difference_type"))
  .AddTypedef(type_10207, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPFittedTrack> >::pointer"))
  .AddTypedef(type_10209, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPFittedTrack> >::const_pointer"))
  .AddTypedef(type_10211, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPFittedTrack> >::reference"))
  .AddTypedef(type_10213, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPFittedTrack> >::const_reference"))
  .AddTypedef(type_2772, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPFittedTrack> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24532, type_24110), Reflex::Literal("operator="), operator_14997, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_14998, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24110), Reflex::Literal("allocator"), constructor_14999, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_15000, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3053, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x83, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<std::pair<const unsigned int, RPFittedTrack> > -------------------
void __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<std::pair<const unsigned int, RPFittedTrack> > -------------------
void __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<std::pair<const unsigned int, RPTrackCandidate> > -------------------------------
static  void operator_15118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >*)o)->operator=)(*(const ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >*)arg[0]);
  else   (((::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >*)o)->operator=)(*(const ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >*)arg[0]);
}

static void constructor_15119( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >();
  else ::new(mem) ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >();
}

static void constructor_15120( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >(*(const ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >*)arg[0]);
  else ::new(mem) ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >(*(const ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >*)arg[0]);
}

static void destructor_15121(void*, void * o, const std::vector<void*>&, void *) {
(((::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >*)o)->::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >::~allocator)();
}
static void method_newdel_3064( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x85( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<std::pair<const unsigned int,RPTrackCandidate> >")), ::Reflex::BaseOffset< ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >,::__gnu_cxx::new_allocator<std::pair<const unsigned int,RPTrackCandidate> > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<std::pair<const unsigned int, RPTrackCandidate> > -------------------------------
void __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s__db_datamem(Reflex::Class*);
void __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s__datamem_bld(&__std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s__funcmem_bld(&__std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s__db_funcmem);
void __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPTrackCandidate> >"), typeid(::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >), sizeof(::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_6551, ::Reflex::BaseOffset< ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >, ::__gnu_cxx::new_allocator<std::pair<const unsigned int,RPTrackCandidate> > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3037, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPTrackCandidate> >::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPTrackCandidate> >::difference_type"))
  .AddTypedef(type_10643, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPTrackCandidate> >::pointer"))
  .AddTypedef(type_10645, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPTrackCandidate> >::const_pointer"))
  .AddTypedef(type_10647, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPTrackCandidate> >::reference"))
  .AddTypedef(type_10649, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPTrackCandidate> >::const_reference"))
  .AddTypedef(type_2779, Reflex::Literal("std::allocator<std::pair<const unsigned int,RPTrackCandidate> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24536, type_24138), Reflex::Literal("operator="), operator_15118, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_15119, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24138), Reflex::Literal("allocator"), constructor_15120, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_15121, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3064, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x85, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<std::pair<const unsigned int, RPTrackCandidate> > -------------------
void __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<std::pair<const unsigned int, RPTrackCandidate> > -------------------
void __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Wrapper<RPStationTrackFitCollection> -------------------------------
static void constructor_18131( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPStationTrackFitCollection>();
  else ::new(mem) ::edm::Wrapper<RPStationTrackFitCollection>();
}

static void constructor_18132( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPStationTrackFitCollection>(*(::std::auto_ptr<RPStationTrackFitCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPStationTrackFitCollection>(*(::std::auto_ptr<RPStationTrackFitCollection>*)arg[0]);
}

static void destructor_18133(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPStationTrackFitCollection>*)o)->::edm::Wrapper<RPStationTrackFitCollection>::~Wrapper)();
}
static  void method_18134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->product)();
}

static  void operator_18135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->operator->)();
}

static  void method_18136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPStationTrackFitCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPStationTrackFitCollection>*)o)->productTypeInfo)();
}

static  void method_18137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPStationTrackFitCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPStationTrackFitCollection>*)o)->typeInfo)();
}

static void constructor_18138( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPStationTrackFitCollection>((::RPStationTrackFitCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPStationTrackFitCollection>((::RPStationTrackFitCollection*)arg[0]);
}

static  void method_18139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPStationTrackFitCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPStationTrackFitCollection>*)o)->getInterface)();
}

static  void method_18140( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18141( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18142( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->dynamicTypeInfo)();
}

static  void method_18144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->isPresent)();
}

static  void method_18145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPStationTrackFitCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4200( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPStationTrackFitCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPStationTrackFitCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPStationTrackFitCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPStationTrackFitCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPStationTrackFitCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPStationTrackFitCollection> -------------------------------
void __edm__Wrapper_RPStationTrackFitCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPStationTrackFitCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPStationTrackFitCollection__datamem_bld(&__edm__Wrapper_RPStationTrackFitCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPStationTrackFitCollection__funcmem_bld(&__edm__Wrapper_RPStationTrackFitCollection__db_funcmem);
void __edm__Wrapper_RPStationTrackFitCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPStationTrackFitCollection>"), typeid(::edm::Wrapper<RPStationTrackFitCollection>), sizeof(::edm::Wrapper<RPStationTrackFitCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_252, Reflex::Literal("edm::Wrapper<RPStationTrackFitCollection>::value_type"))
  .AddTypedef(type_252, Reflex::Literal("edm::Wrapper<RPStationTrackFitCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18131, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2610), Reflex::Literal("Wrapper"), constructor_18132, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18133, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26430), Reflex::Literal("Wrapper"), constructor_18138, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4200, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPStationTrackFitCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPStationTrackFitCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPStationTrackFitCollection> -------------------
void __edm__Wrapper_RPStationTrackFitCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPStationTrackFitCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_252, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPStationTrackFitCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPStationTrackFitCollection> -------------------
void __edm__Wrapper_RPStationTrackFitCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26429), Reflex::Literal("product"), method_18134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26429), Reflex::Literal("operator->"), operator_18135, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18136, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18137, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26431), Reflex::Literal("getInterface"), method_18139, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18140, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18141, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18142, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18144, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRecognizedPatternsCollection> -------------------------------
static void constructor_18152( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRecognizedPatternsCollection>();
  else ::new(mem) ::edm::Wrapper<RPRecognizedPatternsCollection>();
}

static void constructor_18153( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRecognizedPatternsCollection>(*(::std::auto_ptr<RPRecognizedPatternsCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRecognizedPatternsCollection>(*(::std::auto_ptr<RPRecognizedPatternsCollection>*)arg[0]);
}

static void destructor_18154(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->::edm::Wrapper<RPRecognizedPatternsCollection>::~Wrapper)();
}
static  void method_18155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->product)();
}

static  void operator_18156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->operator->)();
}

static  void method_18157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->productTypeInfo)();
}

static  void method_18158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->typeInfo)();
}

static void constructor_18159( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRecognizedPatternsCollection>((::RPRecognizedPatternsCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRecognizedPatternsCollection>((::RPRecognizedPatternsCollection*)arg[0]);
}

static  void method_18160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->getInterface)();
}

static  void method_18161( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18162( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18163( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->dynamicTypeInfo)();
}

static  void method_18165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->isPresent)();
}

static  void method_18166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRecognizedPatternsCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4201( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecognizedPatternsCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecognizedPatternsCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecognizedPatternsCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecognizedPatternsCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecognizedPatternsCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRecognizedPatternsCollection> -------------------------------
void __edm__Wrapper_RPRecognizedPatternsCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRecognizedPatternsCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRecognizedPatternsCollection__datamem_bld(&__edm__Wrapper_RPRecognizedPatternsCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRecognizedPatternsCollection__funcmem_bld(&__edm__Wrapper_RPRecognizedPatternsCollection__db_funcmem);
void __edm__Wrapper_RPRecognizedPatternsCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRecognizedPatternsCollection>"), typeid(::edm::Wrapper<RPRecognizedPatternsCollection>), sizeof(::edm::Wrapper<RPRecognizedPatternsCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2062, Reflex::Literal("edm::Wrapper<RPRecognizedPatternsCollection>::value_type"))
  .AddTypedef(type_2062, Reflex::Literal("edm::Wrapper<RPRecognizedPatternsCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18152, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2611), Reflex::Literal("Wrapper"), constructor_18153, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18154, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26435), Reflex::Literal("Wrapper"), constructor_18159, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4201, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRecognizedPatternsCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRecognizedPatternsCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRecognizedPatternsCollection> -------------------
void __edm__Wrapper_RPRecognizedPatternsCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRecognizedPatternsCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2062, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRecognizedPatternsCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRecognizedPatternsCollection> -------------------
void __edm__Wrapper_RPRecognizedPatternsCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26434), Reflex::Literal("product"), method_18155, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26434), Reflex::Literal("operator->"), operator_18156, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18157, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18158, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26436), Reflex::Literal("getInterface"), method_18160, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18161, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18162, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18163, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18165, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRecognizedPatterns> -------------------------------
static void constructor_18173( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRecognizedPatterns>();
  else ::new(mem) ::edm::Wrapper<RPRecognizedPatterns>();
}

static void constructor_18174( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRecognizedPatterns>(*(::std::auto_ptr<RPRecognizedPatterns>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRecognizedPatterns>(*(::std::auto_ptr<RPRecognizedPatterns>*)arg[0]);
}

static void destructor_18175(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRecognizedPatterns>*)o)->::edm::Wrapper<RPRecognizedPatterns>::~Wrapper)();
}
static  void method_18176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->product)();
}

static  void operator_18177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->operator->)();
}

static  void method_18178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRecognizedPatterns>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRecognizedPatterns>*)o)->productTypeInfo)();
}

static  void method_18179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRecognizedPatterns>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRecognizedPatterns>*)o)->typeInfo)();
}

static void constructor_18180( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRecognizedPatterns>((::RPRecognizedPatterns*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRecognizedPatterns>((::RPRecognizedPatterns*)arg[0]);
}

static  void method_18181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRecognizedPatterns>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRecognizedPatterns>*)o)->getInterface)();
}

static  void method_18182( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18183( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18184( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->dynamicTypeInfo)();
}

static  void method_18186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->isPresent)();
}

static  void method_18187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRecognizedPatterns>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4202( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecognizedPatterns> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecognizedPatterns> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecognizedPatterns> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecognizedPatterns> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecognizedPatterns> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRecognizedPatterns> -------------------------------
void __edm__Wrapper_RPRecognizedPatterns__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRecognizedPatterns__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRecognizedPatterns__datamem_bld(&__edm__Wrapper_RPRecognizedPatterns__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRecognizedPatterns__funcmem_bld(&__edm__Wrapper_RPRecognizedPatterns__db_funcmem);
void __edm__Wrapper_RPRecognizedPatterns__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRecognizedPatterns>"), typeid(::edm::Wrapper<RPRecognizedPatterns>), sizeof(::edm::Wrapper<RPRecognizedPatterns>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2172, Reflex::Literal("edm::Wrapper<RPRecognizedPatterns>::value_type"))
  .AddTypedef(type_2172, Reflex::Literal("edm::Wrapper<RPRecognizedPatterns>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18173, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2612), Reflex::Literal("Wrapper"), constructor_18174, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18175, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26440), Reflex::Literal("Wrapper"), constructor_18180, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4202, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRecognizedPatterns__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRecognizedPatterns__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRecognizedPatterns> -------------------
void __edm__Wrapper_RPRecognizedPatterns__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRecognizedPatterns_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2172, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRecognizedPatterns_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRecognizedPatterns> -------------------
void __edm__Wrapper_RPRecognizedPatterns__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26439), Reflex::Literal("product"), method_18176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26439), Reflex::Literal("operator->"), operator_18177, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18178, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18179, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26441), Reflex::Literal("getInterface"), method_18181, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18182, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18183, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18184, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRecoElasticEvent> -------------------------------
static void constructor_18194( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRecoElasticEvent>();
  else ::new(mem) ::edm::Wrapper<RPRecoElasticEvent>();
}

static void constructor_18195( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRecoElasticEvent>(*(::std::auto_ptr<RPRecoElasticEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRecoElasticEvent>(*(::std::auto_ptr<RPRecoElasticEvent>*)arg[0]);
}

static void destructor_18196(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRecoElasticEvent>*)o)->::edm::Wrapper<RPRecoElasticEvent>::~Wrapper)();
}
static  void method_18197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->product)();
}

static  void operator_18198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->operator->)();
}

static  void method_18199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRecoElasticEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRecoElasticEvent>*)o)->productTypeInfo)();
}

static  void method_18200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRecoElasticEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRecoElasticEvent>*)o)->typeInfo)();
}

static void constructor_18201( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRecoElasticEvent>((::RPRecoElasticEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRecoElasticEvent>((::RPRecoElasticEvent*)arg[0]);
}

static  void method_18202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRecoElasticEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRecoElasticEvent>*)o)->getInterface)();
}

static  void method_18203( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18204( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18205( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->dynamicTypeInfo)();
}

static  void method_18207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->isPresent)();
}

static  void method_18208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRecoElasticEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4203( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecoElasticEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecoElasticEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecoElasticEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecoElasticEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRecoElasticEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRecoElasticEvent> -------------------------------
void __edm__Wrapper_RPRecoElasticEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRecoElasticEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRecoElasticEvent__datamem_bld(&__edm__Wrapper_RPRecoElasticEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRecoElasticEvent__funcmem_bld(&__edm__Wrapper_RPRecoElasticEvent__db_funcmem);
void __edm__Wrapper_RPRecoElasticEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRecoElasticEvent>"), typeid(::edm::Wrapper<RPRecoElasticEvent>), sizeof(::edm::Wrapper<RPRecoElasticEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2052, Reflex::Literal("edm::Wrapper<RPRecoElasticEvent>::value_type"))
  .AddTypedef(type_2052, Reflex::Literal("edm::Wrapper<RPRecoElasticEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18194, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2613), Reflex::Literal("Wrapper"), constructor_18195, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18196, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26445), Reflex::Literal("Wrapper"), constructor_18201, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4203, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRecoElasticEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRecoElasticEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRecoElasticEvent> -------------------
void __edm__Wrapper_RPRecoElasticEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRecoElasticEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2052, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRecoElasticEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRecoElasticEvent> -------------------
void __edm__Wrapper_RPRecoElasticEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26444), Reflex::Literal("product"), method_18197, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26444), Reflex::Literal("operator->"), operator_18198, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18199, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18200, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26446), Reflex::Literal("getInterface"), method_18202, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18203, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18204, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18205, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPReconstructedProtonPairCollection> -------------------------------
static void constructor_18215( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProtonPairCollection>();
  else ::new(mem) ::edm::Wrapper<RPReconstructedProtonPairCollection>();
}

static void constructor_18216( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProtonPairCollection>(*(::std::auto_ptr<RPReconstructedProtonPairCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPReconstructedProtonPairCollection>(*(::std::auto_ptr<RPReconstructedProtonPairCollection>*)arg[0]);
}

static void destructor_18217(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->::edm::Wrapper<RPReconstructedProtonPairCollection>::~Wrapper)();
}
static  void method_18218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->product)();
}

static  void operator_18219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->operator->)();
}

static  void method_18220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->productTypeInfo)();
}

static  void method_18221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->typeInfo)();
}

static void constructor_18222( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProtonPairCollection>((::RPReconstructedProtonPairCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPReconstructedProtonPairCollection>((::RPReconstructedProtonPairCollection*)arg[0]);
}

static  void method_18223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->getInterface)();
}

static  void method_18224( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18225( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18226( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->dynamicTypeInfo)();
}

static  void method_18228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->isPresent)();
}

static  void method_18229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPReconstructedProtonPairCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4204( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonPairCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonPairCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonPairCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonPairCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonPairCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPReconstructedProtonPairCollection> -------------------------------
void __edm__Wrapper_RPReconstructedProtonPairCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPReconstructedProtonPairCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPReconstructedProtonPairCollection__datamem_bld(&__edm__Wrapper_RPReconstructedProtonPairCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPReconstructedProtonPairCollection__funcmem_bld(&__edm__Wrapper_RPReconstructedProtonPairCollection__db_funcmem);
void __edm__Wrapper_RPReconstructedProtonPairCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPReconstructedProtonPairCollection>"), typeid(::edm::Wrapper<RPReconstructedProtonPairCollection>), sizeof(::edm::Wrapper<RPReconstructedProtonPairCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_925, Reflex::Literal("edm::Wrapper<RPReconstructedProtonPairCollection>::value_type"))
  .AddTypedef(type_925, Reflex::Literal("edm::Wrapper<RPReconstructedProtonPairCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18215, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2614), Reflex::Literal("Wrapper"), constructor_18216, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18217, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26450), Reflex::Literal("Wrapper"), constructor_18222, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4204, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPReconstructedProtonPairCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPReconstructedProtonPairCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPReconstructedProtonPairCollection> -------------------
void __edm__Wrapper_RPReconstructedProtonPairCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPReconstructedProtonPairCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_925, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPReconstructedProtonPairCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPReconstructedProtonPairCollection> -------------------
void __edm__Wrapper_RPReconstructedProtonPairCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26449), Reflex::Literal("product"), method_18218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26449), Reflex::Literal("operator->"), operator_18219, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18220, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18221, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26451), Reflex::Literal("getInterface"), method_18223, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18224, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18225, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18226, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPReconstructedProtonPair> -------------------------------
static void constructor_18236( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProtonPair>();
  else ::new(mem) ::edm::Wrapper<RPReconstructedProtonPair>();
}

static void constructor_18237( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProtonPair>(*(::std::auto_ptr<RPReconstructedProtonPair>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPReconstructedProtonPair>(*(::std::auto_ptr<RPReconstructedProtonPair>*)arg[0]);
}

static void destructor_18238(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPReconstructedProtonPair>*)o)->::edm::Wrapper<RPReconstructedProtonPair>::~Wrapper)();
}
static  void method_18239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->product)());
  else   (((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->product)();
}

static  void operator_18240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->operator->)();
}

static  void method_18241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPReconstructedProtonPair>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPReconstructedProtonPair>*)o)->productTypeInfo)();
}

static  void method_18242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPReconstructedProtonPair>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPReconstructedProtonPair>*)o)->typeInfo)();
}

static void constructor_18243( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProtonPair>((::RPReconstructedProtonPair*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPReconstructedProtonPair>((::RPReconstructedProtonPair*)arg[0]);
}

static  void method_18244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPReconstructedProtonPair>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPReconstructedProtonPair>*)o)->getInterface)();
}

static  void method_18245( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18246( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18247( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->dynamicTypeInfo)();
}

static  void method_18249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->isPresent)();
}

static  void method_18250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPReconstructedProtonPair>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4205( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonPair> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonPair> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonPair> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonPair> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonPair> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPReconstructedProtonPair> -------------------------------
void __edm__Wrapper_RPReconstructedProtonPair__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPReconstructedProtonPair__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPReconstructedProtonPair__datamem_bld(&__edm__Wrapper_RPReconstructedProtonPair__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPReconstructedProtonPair__funcmem_bld(&__edm__Wrapper_RPReconstructedProtonPair__db_funcmem);
void __edm__Wrapper_RPReconstructedProtonPair__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPReconstructedProtonPair>"), typeid(::edm::Wrapper<RPReconstructedProtonPair>), sizeof(::edm::Wrapper<RPReconstructedProtonPair>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1003, Reflex::Literal("edm::Wrapper<RPReconstructedProtonPair>::value_type"))
  .AddTypedef(type_1003, Reflex::Literal("edm::Wrapper<RPReconstructedProtonPair>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18236, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2615), Reflex::Literal("Wrapper"), constructor_18237, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18238, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8236), Reflex::Literal("Wrapper"), constructor_18243, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4205, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPReconstructedProtonPair__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPReconstructedProtonPair__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPReconstructedProtonPair> -------------------
void __edm__Wrapper_RPReconstructedProtonPair__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPReconstructedProtonPair_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1003, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPReconstructedProtonPair_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPReconstructedProtonPair> -------------------
void __edm__Wrapper_RPReconstructedProtonPair__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12104), Reflex::Literal("product"), method_18239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12104), Reflex::Literal("operator->"), operator_18240, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18241, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18242, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26454), Reflex::Literal("getInterface"), method_18244, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18245, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18246, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18247, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18248, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18249, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RP2DHitDebug> -------------------------------
static void constructor_18278( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RP2DHitDebug>();
  else ::new(mem) ::edm::Wrapper<RP2DHitDebug>();
}

static void constructor_18279( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RP2DHitDebug>(*(::std::auto_ptr<RP2DHitDebug>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RP2DHitDebug>(*(::std::auto_ptr<RP2DHitDebug>*)arg[0]);
}

static void destructor_18280(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RP2DHitDebug>*)o)->::edm::Wrapper<RP2DHitDebug>::~Wrapper)();
}
static  void method_18281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RP2DHitDebug>*)o)->product)());
  else   (((const ::edm::Wrapper<RP2DHitDebug>*)o)->product)();
}

static  void operator_18282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RP2DHitDebug>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RP2DHitDebug>*)o)->operator->)();
}

static  void method_18283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RP2DHitDebug>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RP2DHitDebug>*)o)->productTypeInfo)();
}

static  void method_18284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RP2DHitDebug>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RP2DHitDebug>*)o)->typeInfo)();
}

static void constructor_18285( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RP2DHitDebug>((::RP2DHitDebug*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RP2DHitDebug>((::RP2DHitDebug*)arg[0]);
}

static  void method_18286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RP2DHitDebug>*)o)->getInterface)());
  else   (((::edm::Wrapper<RP2DHitDebug>*)o)->getInterface)();
}

static  void method_18287( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RP2DHitDebug>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18288( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RP2DHitDebug>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18289( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RP2DHitDebug>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RP2DHitDebug>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RP2DHitDebug>*)o)->dynamicTypeInfo)();
}

static  void method_18291( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RP2DHitDebug>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RP2DHitDebug>*)o)->isPresent)();
}

static  void method_18292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RP2DHitDebug>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RP2DHitDebug>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4207( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RP2DHitDebug> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RP2DHitDebug> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RP2DHitDebug> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RP2DHitDebug> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RP2DHitDebug> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RP2DHitDebug> -------------------------------
void __edm__Wrapper_RP2DHitDebug__db_datamem(Reflex::Class*);
void __edm__Wrapper_RP2DHitDebug__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RP2DHitDebug__datamem_bld(&__edm__Wrapper_RP2DHitDebug__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RP2DHitDebug__funcmem_bld(&__edm__Wrapper_RP2DHitDebug__db_funcmem);
void __edm__Wrapper_RP2DHitDebug__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RP2DHitDebug>"), typeid(::edm::Wrapper<RP2DHitDebug>), sizeof(::edm::Wrapper<RP2DHitDebug>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1929, Reflex::Literal("edm::Wrapper<RP2DHitDebug>::value_type"))
  .AddTypedef(type_1929, Reflex::Literal("edm::Wrapper<RP2DHitDebug>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18278, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2617), Reflex::Literal("Wrapper"), constructor_18279, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18280, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26463), Reflex::Literal("Wrapper"), constructor_18285, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4207, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RP2DHitDebug__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RP2DHitDebug__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RP2DHitDebug> -------------------
void __edm__Wrapper_RP2DHitDebug__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RP2DHitDebug_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1929, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RP2DHitDebug_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RP2DHitDebug> -------------------
void __edm__Wrapper_RP2DHitDebug__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26462), Reflex::Literal("product"), method_18281, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26462), Reflex::Literal("operator->"), operator_18282, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18283, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18284, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26464), Reflex::Literal("getInterface"), method_18286, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18287, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18288, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18289, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18290, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18291, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RP2DHit> -------------------------------
static void constructor_18299( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RP2DHit>();
  else ::new(mem) ::edm::Wrapper<RP2DHit>();
}

static void constructor_18300( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RP2DHit>(*(::std::auto_ptr<RP2DHit>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RP2DHit>(*(::std::auto_ptr<RP2DHit>*)arg[0]);
}

static void destructor_18301(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RP2DHit>*)o)->::edm::Wrapper<RP2DHit>::~Wrapper)();
}
static  void method_18302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RP2DHit>*)o)->product)());
  else   (((const ::edm::Wrapper<RP2DHit>*)o)->product)();
}

static  void operator_18303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RP2DHit>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RP2DHit>*)o)->operator->)();
}

static  void method_18304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RP2DHit>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RP2DHit>*)o)->productTypeInfo)();
}

static  void method_18305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RP2DHit>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RP2DHit>*)o)->typeInfo)();
}

static void constructor_18306( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RP2DHit>((::RP2DHit*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RP2DHit>((::RP2DHit*)arg[0]);
}

static  void method_18307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RP2DHit>*)o)->getInterface)());
  else   (((::edm::Wrapper<RP2DHit>*)o)->getInterface)();
}

static  void method_18308( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RP2DHit>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18309( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RP2DHit>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18310( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RP2DHit>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RP2DHit>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RP2DHit>*)o)->dynamicTypeInfo)();
}

static  void method_18312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RP2DHit>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RP2DHit>*)o)->isPresent)();
}

static  void method_18313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RP2DHit>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RP2DHit>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4208( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RP2DHit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RP2DHit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RP2DHit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RP2DHit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RP2DHit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RP2DHit> -------------------------------
void __edm__Wrapper_RP2DHit__db_datamem(Reflex::Class*);
void __edm__Wrapper_RP2DHit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RP2DHit__datamem_bld(&__edm__Wrapper_RP2DHit__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RP2DHit__funcmem_bld(&__edm__Wrapper_RP2DHit__db_funcmem);
void __edm__Wrapper_RP2DHit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RP2DHit>"), typeid(::edm::Wrapper<RP2DHit>), sizeof(::edm::Wrapper<RP2DHit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1741, Reflex::Literal("edm::Wrapper<RP2DHit>::value_type"))
  .AddTypedef(type_1741, Reflex::Literal("edm::Wrapper<RP2DHit>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18299, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2618), Reflex::Literal("Wrapper"), constructor_18300, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18301, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26468), Reflex::Literal("Wrapper"), constructor_18306, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4208, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RP2DHit__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RP2DHit__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RP2DHit> -------------------
void __edm__Wrapper_RP2DHit__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RP2DHit_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1741, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RP2DHit_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RP2DHit> -------------------
void __edm__Wrapper_RP2DHit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26467), Reflex::Literal("product"), method_18302, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26467), Reflex::Literal("operator->"), operator_18303, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18304, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18305, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26469), Reflex::Literal("getInterface"), method_18307, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18308, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18309, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18310, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPReconstructedProtonCollection> -------------------------------
static void constructor_18320( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProtonCollection>();
  else ::new(mem) ::edm::Wrapper<RPReconstructedProtonCollection>();
}

static void constructor_18321( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProtonCollection>(*(::std::auto_ptr<RPReconstructedProtonCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPReconstructedProtonCollection>(*(::std::auto_ptr<RPReconstructedProtonCollection>*)arg[0]);
}

static void destructor_18322(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPReconstructedProtonCollection>*)o)->::edm::Wrapper<RPReconstructedProtonCollection>::~Wrapper)();
}
static  void method_18323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->product)();
}

static  void operator_18324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->operator->)();
}

static  void method_18325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPReconstructedProtonCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPReconstructedProtonCollection>*)o)->productTypeInfo)();
}

static  void method_18326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPReconstructedProtonCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPReconstructedProtonCollection>*)o)->typeInfo)();
}

static void constructor_18327( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProtonCollection>((::RPReconstructedProtonCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPReconstructedProtonCollection>((::RPReconstructedProtonCollection*)arg[0]);
}

static  void method_18328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPReconstructedProtonCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPReconstructedProtonCollection>*)o)->getInterface)();
}

static  void method_18329( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18330( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18331( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->dynamicTypeInfo)();
}

static  void method_18333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->isPresent)();
}

static  void method_18334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPReconstructedProtonCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4209( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProtonCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPReconstructedProtonCollection> -------------------------------
void __edm__Wrapper_RPReconstructedProtonCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPReconstructedProtonCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPReconstructedProtonCollection__datamem_bld(&__edm__Wrapper_RPReconstructedProtonCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPReconstructedProtonCollection__funcmem_bld(&__edm__Wrapper_RPReconstructedProtonCollection__db_funcmem);
void __edm__Wrapper_RPReconstructedProtonCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPReconstructedProtonCollection>"), typeid(::edm::Wrapper<RPReconstructedProtonCollection>), sizeof(::edm::Wrapper<RPReconstructedProtonCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2293, Reflex::Literal("edm::Wrapper<RPReconstructedProtonCollection>::value_type"))
  .AddTypedef(type_2293, Reflex::Literal("edm::Wrapper<RPReconstructedProtonCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18320, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2619), Reflex::Literal("Wrapper"), constructor_18321, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18322, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26473), Reflex::Literal("Wrapper"), constructor_18327, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4209, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPReconstructedProtonCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPReconstructedProtonCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPReconstructedProtonCollection> -------------------
void __edm__Wrapper_RPReconstructedProtonCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPReconstructedProtonCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2293, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPReconstructedProtonCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPReconstructedProtonCollection> -------------------
void __edm__Wrapper_RPReconstructedProtonCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26472), Reflex::Literal("product"), method_18323, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26472), Reflex::Literal("operator->"), operator_18324, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18325, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18326, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26474), Reflex::Literal("getInterface"), method_18328, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18329, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18330, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18331, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPReconstructedProton> -------------------------------
static void constructor_18341( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProton>();
  else ::new(mem) ::edm::Wrapper<RPReconstructedProton>();
}

static void constructor_18342( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProton>(*(::std::auto_ptr<RPReconstructedProton>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPReconstructedProton>(*(::std::auto_ptr<RPReconstructedProton>*)arg[0]);
}

static void destructor_18343(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPReconstructedProton>*)o)->::edm::Wrapper<RPReconstructedProton>::~Wrapper)();
}
static  void method_18344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPReconstructedProton>*)o)->product)());
  else   (((const ::edm::Wrapper<RPReconstructedProton>*)o)->product)();
}

static  void operator_18345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPReconstructedProton>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPReconstructedProton>*)o)->operator->)();
}

static  void method_18346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPReconstructedProton>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPReconstructedProton>*)o)->productTypeInfo)();
}

static  void method_18347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPReconstructedProton>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPReconstructedProton>*)o)->typeInfo)();
}

static void constructor_18348( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPReconstructedProton>((::RPReconstructedProton*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPReconstructedProton>((::RPReconstructedProton*)arg[0]);
}

static  void method_18349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPReconstructedProton>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPReconstructedProton>*)o)->getInterface)();
}

static  void method_18350( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProton>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18351( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProton>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18352( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPReconstructedProton>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPReconstructedProton>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPReconstructedProton>*)o)->dynamicTypeInfo)();
}

static  void method_18354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPReconstructedProton>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPReconstructedProton>*)o)->isPresent)();
}

static  void method_18355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPReconstructedProton>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPReconstructedProton>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4210( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPReconstructedProton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPReconstructedProton> -------------------------------
void __edm__Wrapper_RPReconstructedProton__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPReconstructedProton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPReconstructedProton__datamem_bld(&__edm__Wrapper_RPReconstructedProton__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPReconstructedProton__funcmem_bld(&__edm__Wrapper_RPReconstructedProton__db_funcmem);
void __edm__Wrapper_RPReconstructedProton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPReconstructedProton>"), typeid(::edm::Wrapper<RPReconstructedProton>), sizeof(::edm::Wrapper<RPReconstructedProton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1565, Reflex::Literal("edm::Wrapper<RPReconstructedProton>::value_type"))
  .AddTypedef(type_1565, Reflex::Literal("edm::Wrapper<RPReconstructedProton>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18341, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2620), Reflex::Literal("Wrapper"), constructor_18342, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18343, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8273), Reflex::Literal("Wrapper"), constructor_18348, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4210, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPReconstructedProton__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPReconstructedProton__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPReconstructedProton> -------------------
void __edm__Wrapper_RPReconstructedProton__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPReconstructedProton_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1565, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPReconstructedProton_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPReconstructedProton> -------------------
void __edm__Wrapper_RPReconstructedProton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12168), Reflex::Literal("product"), method_18344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12168), Reflex::Literal("operator->"), operator_18345, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18346, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18347, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26477), Reflex::Literal("getInterface"), method_18349, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18350, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18351, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18352, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TObject> -------------------------------
static void constructor_18362( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TObject>();
  else ::new(mem) ::edm::Wrapper<TObject>();
}

static void constructor_18363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TObject>(*(::std::auto_ptr<TObject>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TObject>(*(::std::auto_ptr<TObject>*)arg[0]);
}

static void destructor_18364(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TObject>*)o)->::edm::Wrapper<TObject>::~Wrapper)();
}
static  void method_18365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TObject>*)o)->product)());
  else   (((const ::edm::Wrapper<TObject>*)o)->product)();
}

static  void operator_18366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TObject>*)o)->operator->)());
  else   (((const ::edm::Wrapper<TObject>*)o)->operator->)();
}

static  void method_18367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TObject>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TObject>*)o)->productTypeInfo)();
}

static  void method_18368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TObject>*)o)->typeInfo)();
  else   (((::edm::Wrapper<TObject>*)o)->typeInfo)();
}

static void constructor_18369( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TObject>((::TObject*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TObject>((::TObject*)arg[0]);
}

static  void method_18370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TObject>*)o)->getInterface)());
  else   (((::edm::Wrapper<TObject>*)o)->getInterface)();
}

static  void method_18371( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TObject>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TObject>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18373( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TObject>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TObject>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TObject>*)o)->dynamicTypeInfo)();
}

static  void method_18375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TObject>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TObject>*)o)->isPresent)();
}

static  void method_18376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TObject>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TObject>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4211( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TObject> -------------------------------
void __edm__Wrapper_TObject__db_datamem(Reflex::Class*);
void __edm__Wrapper_TObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TObject__datamem_bld(&__edm__Wrapper_TObject__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TObject__funcmem_bld(&__edm__Wrapper_TObject__db_funcmem);
void __edm__Wrapper_TObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TObject>"), typeid(::edm::Wrapper<TObject>), sizeof(::edm::Wrapper<TObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1672, Reflex::Literal("edm::Wrapper<TObject>::value_type"))
  .AddTypedef(type_1672, Reflex::Literal("edm::Wrapper<TObject>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18362, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2621), Reflex::Literal("Wrapper"), constructor_18363, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18364, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11323), Reflex::Literal("Wrapper"), constructor_18369, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4211, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TObject__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TObject__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TObject> -------------------
void __edm__Wrapper_TObject__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TObject_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1672, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TObject_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TObject> -------------------
void __edm__Wrapper_TObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5611), Reflex::Literal("product"), method_18365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5611), Reflex::Literal("operator->"), operator_18366, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18367, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18368, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26480), Reflex::Literal("getInterface"), method_18370, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18371, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18372, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18373, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18374, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<RPDetHitPoint, std::allocator<RPDetHitPoint> > > -------------------------------
static void constructor_18383( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPDetHitPoint> >();
  else ::new(mem) ::edm::Wrapper<std::vector<RPDetHitPoint> >();
}

static void constructor_18384( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPDetHitPoint> >(*(::std::auto_ptr<std::vector<RPDetHitPoint> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPDetHitPoint> >(*(::std::auto_ptr<std::vector<RPDetHitPoint> >*)arg[0]);
}

static void destructor_18385(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->::edm::Wrapper<std::vector<RPDetHitPoint> >::~Wrapper)();
}
static  void method_18386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->product)();
}

static  void operator_18387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->operator->)();
}

static  void method_18388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->productTypeInfo)();
}

static  void method_18389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->typeInfo)();
}

static void constructor_18390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPDetHitPoint> >((::std::vector<RPDetHitPoint>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPDetHitPoint> >((::std::vector<RPDetHitPoint>*)arg[0]);
}

static  void method_18391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->getInterface)();
}

static  void method_18392( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18393( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18394( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->dynamicTypeInfo)();
}

static  void method_18396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->isPresent)();
}

static  void method_18397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<RPDetHitPoint> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4212( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPDetHitPoint> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPDetHitPoint> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPDetHitPoint> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPDetHitPoint> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPDetHitPoint> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<RPDetHitPoint, std::allocator<RPDetHitPoint> > > -------------------------------
void __edm__Wrapper_std__vector_RPDetHitPoint_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_RPDetHitPoint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPDetHitPoint_s__datamem_bld(&__edm__Wrapper_std__vector_RPDetHitPoint_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPDetHitPoint_s__funcmem_bld(&__edm__Wrapper_std__vector_RPDetHitPoint_s__db_funcmem);
void __edm__Wrapper_std__vector_RPDetHitPoint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPDetHitPoint> >"), typeid(::edm::Wrapper<std::vector<RPDetHitPoint> >), sizeof(::edm::Wrapper<std::vector<RPDetHitPoint> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2848, Reflex::Literal("edm::Wrapper<std::vector<RPDetHitPoint> >::value_type"))
  .AddTypedef(type_2848, Reflex::Literal("edm::Wrapper<std::vector<RPDetHitPoint> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18383, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2622), Reflex::Literal("Wrapper"), constructor_18384, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18385, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26484), Reflex::Literal("Wrapper"), constructor_18390, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4212, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_RPDetHitPoint_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_RPDetHitPoint_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<RPDetHitPoint, std::allocator<RPDetHitPoint> > > -------------------
void __edm__Wrapper_std__vector_RPDetHitPoint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPDetHitPoint_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2848, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPDetHitPoint_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<RPDetHitPoint, std::allocator<RPDetHitPoint> > > -------------------
void __edm__Wrapper_std__vector_RPDetHitPoint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26483), Reflex::Literal("product"), method_18386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26483), Reflex::Literal("operator->"), operator_18387, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18388, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18389, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26485), Reflex::Literal("getInterface"), method_18391, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18392, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18393, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18394, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18396, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TVector3> -------------------------------
static void constructor_18404( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TVector3>();
  else ::new(mem) ::edm::Wrapper<TVector3>();
}

static void constructor_18405( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TVector3>(*(::std::auto_ptr<TVector3>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TVector3>(*(::std::auto_ptr<TVector3>*)arg[0]);
}

static void destructor_18406(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TVector3>*)o)->::edm::Wrapper<TVector3>::~Wrapper)();
}
static  void method_18407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TVector3>*)o)->product)());
  else   (((const ::edm::Wrapper<TVector3>*)o)->product)();
}

static  void operator_18408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TVector3>*)o)->operator->)());
  else   (((const ::edm::Wrapper<TVector3>*)o)->operator->)();
}

static  void method_18409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TVector3>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TVector3>*)o)->productTypeInfo)();
}

static  void method_18410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TVector3>*)o)->typeInfo)();
  else   (((::edm::Wrapper<TVector3>*)o)->typeInfo)();
}

static void constructor_18411( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TVector3>((::TVector3*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TVector3>((::TVector3*)arg[0]);
}

static  void method_18412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TVector3>*)o)->getInterface)());
  else   (((::edm::Wrapper<TVector3>*)o)->getInterface)();
}

static  void method_18413( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TVector3>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18414( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TVector3>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18415( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TVector3>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TVector3>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TVector3>*)o)->dynamicTypeInfo)();
}

static  void method_18417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TVector3>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TVector3>*)o)->isPresent)();
}

static  void method_18418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TVector3>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TVector3>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4213( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TVector3> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TVector3> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TVector3> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TVector3> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TVector3> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TVector3> -------------------------------
void __edm__Wrapper_TVector3__db_datamem(Reflex::Class*);
void __edm__Wrapper_TVector3__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TVector3__datamem_bld(&__edm__Wrapper_TVector3__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TVector3__funcmem_bld(&__edm__Wrapper_TVector3__db_funcmem);
void __edm__Wrapper_TVector3__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TVector3>"), typeid(::edm::Wrapper<TVector3>), sizeof(::edm::Wrapper<TVector3>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2017, Reflex::Literal("edm::Wrapper<TVector3>::value_type"))
  .AddTypedef(type_2017, Reflex::Literal("edm::Wrapper<TVector3>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18404, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2623), Reflex::Literal("Wrapper"), constructor_18405, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18406, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26489), Reflex::Literal("Wrapper"), constructor_18411, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4213, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TVector3__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TVector3__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TVector3> -------------------
void __edm__Wrapper_TVector3__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TVector3_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2017, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TVector3_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TVector3> -------------------
void __edm__Wrapper_TVector3__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26488), Reflex::Literal("product"), method_18407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26488), Reflex::Literal("operator->"), operator_18408, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18409, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18410, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26490), Reflex::Literal("getInterface"), method_18412, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18413, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18414, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18415, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18416, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18417, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18418, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPDetHitPoint> -------------------------------
static void constructor_18425( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPDetHitPoint>();
  else ::new(mem) ::edm::Wrapper<RPDetHitPoint>();
}

static void constructor_18426( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPDetHitPoint>(*(::std::auto_ptr<RPDetHitPoint>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPDetHitPoint>(*(::std::auto_ptr<RPDetHitPoint>*)arg[0]);
}

static void destructor_18427(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPDetHitPoint>*)o)->::edm::Wrapper<RPDetHitPoint>::~Wrapper)();
}
static  void method_18428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPDetHitPoint>*)o)->product)());
  else   (((const ::edm::Wrapper<RPDetHitPoint>*)o)->product)();
}

static  void operator_18429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPDetHitPoint>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPDetHitPoint>*)o)->operator->)();
}

static  void method_18430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPDetHitPoint>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPDetHitPoint>*)o)->productTypeInfo)();
}

static  void method_18431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPDetHitPoint>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPDetHitPoint>*)o)->typeInfo)();
}

static void constructor_18432( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPDetHitPoint>((::RPDetHitPoint*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPDetHitPoint>((::RPDetHitPoint*)arg[0]);
}

static  void method_18433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPDetHitPoint>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPDetHitPoint>*)o)->getInterface)();
}

static  void method_18434( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPDetHitPoint>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18435( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPDetHitPoint>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18436( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPDetHitPoint>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPDetHitPoint>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPDetHitPoint>*)o)->dynamicTypeInfo)();
}

static  void method_18438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPDetHitPoint>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPDetHitPoint>*)o)->isPresent)();
}

static  void method_18439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPDetHitPoint>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPDetHitPoint>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4214( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPDetHitPoint> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPDetHitPoint> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPDetHitPoint> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPDetHitPoint> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPDetHitPoint> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPDetHitPoint> -------------------------------
void __edm__Wrapper_RPDetHitPoint__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPDetHitPoint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPDetHitPoint__datamem_bld(&__edm__Wrapper_RPDetHitPoint__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPDetHitPoint__funcmem_bld(&__edm__Wrapper_RPDetHitPoint__db_funcmem);
void __edm__Wrapper_RPDetHitPoint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPDetHitPoint>"), typeid(::edm::Wrapper<RPDetHitPoint>), sizeof(::edm::Wrapper<RPDetHitPoint>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_221, Reflex::Literal("edm::Wrapper<RPDetHitPoint>::value_type"))
  .AddTypedef(type_221, Reflex::Literal("edm::Wrapper<RPDetHitPoint>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18425, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2624), Reflex::Literal("Wrapper"), constructor_18426, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18427, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8292), Reflex::Literal("Wrapper"), constructor_18432, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4214, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPDetHitPoint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPDetHitPoint__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPDetHitPoint> -------------------
void __edm__Wrapper_RPDetHitPoint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPDetHitPoint_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_221, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPDetHitPoint_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPDetHitPoint> -------------------
void __edm__Wrapper_RPDetHitPoint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12232), Reflex::Literal("product"), method_18428, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12232), Reflex::Literal("operator->"), operator_18429, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18430, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18431, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26493), Reflex::Literal("getInterface"), method_18433, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18434, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18435, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18436, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18437, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18438, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18439, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPMulFittedTrackCollection> -------------------------------
static void constructor_18488( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulFittedTrackCollection>();
  else ::new(mem) ::edm::Wrapper<RPMulFittedTrackCollection>();
}

static void constructor_18489( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulFittedTrackCollection>(*(::std::auto_ptr<RPMulFittedTrackCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPMulFittedTrackCollection>(*(::std::auto_ptr<RPMulFittedTrackCollection>*)arg[0]);
}

static void destructor_18490(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPMulFittedTrackCollection>*)o)->::edm::Wrapper<RPMulFittedTrackCollection>::~Wrapper)();
}
static  void method_18491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->product)();
}

static  void operator_18492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->operator->)();
}

static  void method_18493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPMulFittedTrackCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPMulFittedTrackCollection>*)o)->productTypeInfo)();
}

static  void method_18494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPMulFittedTrackCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPMulFittedTrackCollection>*)o)->typeInfo)();
}

static void constructor_18495( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulFittedTrackCollection>((::RPMulFittedTrackCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPMulFittedTrackCollection>((::RPMulFittedTrackCollection*)arg[0]);
}

static  void method_18496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPMulFittedTrackCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPMulFittedTrackCollection>*)o)->getInterface)();
}

static  void method_18497( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18498( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18499( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->dynamicTypeInfo)();
}

static  void method_18501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->isPresent)();
}

static  void method_18502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPMulFittedTrackCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4217( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulFittedTrackCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulFittedTrackCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulFittedTrackCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulFittedTrackCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulFittedTrackCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPMulFittedTrackCollection> -------------------------------
void __edm__Wrapper_RPMulFittedTrackCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPMulFittedTrackCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPMulFittedTrackCollection__datamem_bld(&__edm__Wrapper_RPMulFittedTrackCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPMulFittedTrackCollection__funcmem_bld(&__edm__Wrapper_RPMulFittedTrackCollection__db_funcmem);
void __edm__Wrapper_RPMulFittedTrackCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPMulFittedTrackCollection>"), typeid(::edm::Wrapper<RPMulFittedTrackCollection>), sizeof(::edm::Wrapper<RPMulFittedTrackCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_225, Reflex::Literal("edm::Wrapper<RPMulFittedTrackCollection>::value_type"))
  .AddTypedef(type_225, Reflex::Literal("edm::Wrapper<RPMulFittedTrackCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18488, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2627), Reflex::Literal("Wrapper"), constructor_18489, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18490, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26507), Reflex::Literal("Wrapper"), constructor_18495, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4217, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPMulFittedTrackCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPMulFittedTrackCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPMulFittedTrackCollection> -------------------
void __edm__Wrapper_RPMulFittedTrackCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPMulFittedTrackCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_225, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPMulFittedTrackCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPMulFittedTrackCollection> -------------------
void __edm__Wrapper_RPMulFittedTrackCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26506), Reflex::Literal("product"), method_18491, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26506), Reflex::Literal("operator->"), operator_18492, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18493, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18494, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26508), Reflex::Literal("getInterface"), method_18496, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18497, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18498, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18499, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18500, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18501, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18502, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPFittedTrackCollection> -------------------------------
static void constructor_18509( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPFittedTrackCollection>();
  else ::new(mem) ::edm::Wrapper<RPFittedTrackCollection>();
}

static void constructor_18510( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPFittedTrackCollection>(*(::std::auto_ptr<RPFittedTrackCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPFittedTrackCollection>(*(::std::auto_ptr<RPFittedTrackCollection>*)arg[0]);
}

static void destructor_18511(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPFittedTrackCollection>*)o)->::edm::Wrapper<RPFittedTrackCollection>::~Wrapper)();
}
static  void method_18512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->product)();
}

static  void operator_18513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->operator->)();
}

static  void method_18514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPFittedTrackCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPFittedTrackCollection>*)o)->productTypeInfo)();
}

static  void method_18515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPFittedTrackCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPFittedTrackCollection>*)o)->typeInfo)();
}

static void constructor_18516( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPFittedTrackCollection>((::RPFittedTrackCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPFittedTrackCollection>((::RPFittedTrackCollection*)arg[0]);
}

static  void method_18517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPFittedTrackCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPFittedTrackCollection>*)o)->getInterface)();
}

static  void method_18518( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18519( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18520( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->dynamicTypeInfo)();
}

static  void method_18522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->isPresent)();
}

static  void method_18523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPFittedTrackCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4218( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPFittedTrackCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPFittedTrackCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPFittedTrackCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPFittedTrackCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPFittedTrackCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPFittedTrackCollection> -------------------------------
void __edm__Wrapper_RPFittedTrackCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPFittedTrackCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPFittedTrackCollection__datamem_bld(&__edm__Wrapper_RPFittedTrackCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPFittedTrackCollection__funcmem_bld(&__edm__Wrapper_RPFittedTrackCollection__db_funcmem);
void __edm__Wrapper_RPFittedTrackCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPFittedTrackCollection>"), typeid(::edm::Wrapper<RPFittedTrackCollection>), sizeof(::edm::Wrapper<RPFittedTrackCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_215, Reflex::Literal("edm::Wrapper<RPFittedTrackCollection>::value_type"))
  .AddTypedef(type_215, Reflex::Literal("edm::Wrapper<RPFittedTrackCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18509, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2628), Reflex::Literal("Wrapper"), constructor_18510, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18511, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26512), Reflex::Literal("Wrapper"), constructor_18516, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4218, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPFittedTrackCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPFittedTrackCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPFittedTrackCollection> -------------------
void __edm__Wrapper_RPFittedTrackCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPFittedTrackCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_215, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPFittedTrackCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPFittedTrackCollection> -------------------
void __edm__Wrapper_RPFittedTrackCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26511), Reflex::Literal("product"), method_18512, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26511), Reflex::Literal("operator->"), operator_18513, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18514, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18515, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26513), Reflex::Literal("getInterface"), method_18517, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18518, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18519, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18520, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18523, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPFittedTrack> -------------------------------
static void constructor_18530( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPFittedTrack>();
  else ::new(mem) ::edm::Wrapper<RPFittedTrack>();
}

static void constructor_18531( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPFittedTrack>(*(::std::auto_ptr<RPFittedTrack>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPFittedTrack>(*(::std::auto_ptr<RPFittedTrack>*)arg[0]);
}

static void destructor_18532(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPFittedTrack>*)o)->::edm::Wrapper<RPFittedTrack>::~Wrapper)();
}
static  void method_18533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPFittedTrack>*)o)->product)());
  else   (((const ::edm::Wrapper<RPFittedTrack>*)o)->product)();
}

static  void operator_18534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPFittedTrack>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPFittedTrack>*)o)->operator->)();
}

static  void method_18535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPFittedTrack>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPFittedTrack>*)o)->productTypeInfo)();
}

static  void method_18536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPFittedTrack>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPFittedTrack>*)o)->typeInfo)();
}

static void constructor_18537( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPFittedTrack>((::RPFittedTrack*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPFittedTrack>((::RPFittedTrack*)arg[0]);
}

static  void method_18538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPFittedTrack>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPFittedTrack>*)o)->getInterface)();
}

static  void method_18539( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPFittedTrack>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18540( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPFittedTrack>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18541( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPFittedTrack>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPFittedTrack>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPFittedTrack>*)o)->dynamicTypeInfo)();
}

static  void method_18543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPFittedTrack>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPFittedTrack>*)o)->isPresent)();
}

static  void method_18544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPFittedTrack>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPFittedTrack>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4219( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPFittedTrack> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPFittedTrack> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPFittedTrack> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPFittedTrack> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPFittedTrack> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPFittedTrack> -------------------------------
void __edm__Wrapper_RPFittedTrack__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPFittedTrack__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPFittedTrack__datamem_bld(&__edm__Wrapper_RPFittedTrack__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPFittedTrack__funcmem_bld(&__edm__Wrapper_RPFittedTrack__db_funcmem);
void __edm__Wrapper_RPFittedTrack__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPFittedTrack>"), typeid(::edm::Wrapper<RPFittedTrack>), sizeof(::edm::Wrapper<RPFittedTrack>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_156, Reflex::Literal("edm::Wrapper<RPFittedTrack>::value_type"))
  .AddTypedef(type_156, Reflex::Literal("edm::Wrapper<RPFittedTrack>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18530, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2629), Reflex::Literal("Wrapper"), constructor_18531, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18532, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8104), Reflex::Literal("Wrapper"), constructor_18537, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4219, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPFittedTrack__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPFittedTrack__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPFittedTrack> -------------------
void __edm__Wrapper_RPFittedTrack__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPFittedTrack_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_156, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPFittedTrack_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPFittedTrack> -------------------
void __edm__Wrapper_RPFittedTrack__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12297), Reflex::Literal("product"), method_18533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12297), Reflex::Literal("operator->"), operator_18534, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18535, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18536, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26516), Reflex::Literal("getInterface"), method_18538, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18539, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18540, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18541, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18544, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPMulTrackCandidateSetsCollection> -------------------------------
static void constructor_18551( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulTrackCandidateSetsCollection>();
  else ::new(mem) ::edm::Wrapper<RPMulTrackCandidateSetsCollection>();
}

static void constructor_18552( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulTrackCandidateSetsCollection>(*(::std::auto_ptr<RPMulTrackCandidateSetsCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPMulTrackCandidateSetsCollection>(*(::std::auto_ptr<RPMulTrackCandidateSetsCollection>*)arg[0]);
}

static void destructor_18553(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->::edm::Wrapper<RPMulTrackCandidateSetsCollection>::~Wrapper)();
}
static  void method_18554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->product)();
}

static  void operator_18555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->operator->)();
}

static  void method_18556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->productTypeInfo)();
}

static  void method_18557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->typeInfo)();
}

static void constructor_18558( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulTrackCandidateSetsCollection>((::RPMulTrackCandidateSetsCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPMulTrackCandidateSetsCollection>((::RPMulTrackCandidateSetsCollection*)arg[0]);
}

static  void method_18559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->getInterface)();
}

static  void method_18560( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18561( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18562( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->dynamicTypeInfo)();
}

static  void method_18564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->isPresent)();
}

static  void method_18565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPMulTrackCandidateSetsCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4220( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulTrackCandidateSetsCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulTrackCandidateSetsCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulTrackCandidateSetsCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulTrackCandidateSetsCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulTrackCandidateSetsCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPMulTrackCandidateSetsCollection> -------------------------------
void __edm__Wrapper_RPMulTrackCandidateSetsCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPMulTrackCandidateSetsCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPMulTrackCandidateSetsCollection__datamem_bld(&__edm__Wrapper_RPMulTrackCandidateSetsCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPMulTrackCandidateSetsCollection__funcmem_bld(&__edm__Wrapper_RPMulTrackCandidateSetsCollection__db_funcmem);
void __edm__Wrapper_RPMulTrackCandidateSetsCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPMulTrackCandidateSetsCollection>"), typeid(::edm::Wrapper<RPMulTrackCandidateSetsCollection>), sizeof(::edm::Wrapper<RPMulTrackCandidateSetsCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_586, Reflex::Literal("edm::Wrapper<RPMulTrackCandidateSetsCollection>::value_type"))
  .AddTypedef(type_586, Reflex::Literal("edm::Wrapper<RPMulTrackCandidateSetsCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18551, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2630), Reflex::Literal("Wrapper"), constructor_18552, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18553, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26520), Reflex::Literal("Wrapper"), constructor_18558, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4220, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPMulTrackCandidateSetsCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPMulTrackCandidateSetsCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPMulTrackCandidateSetsCollection> -------------------
void __edm__Wrapper_RPMulTrackCandidateSetsCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPMulTrackCandidateSetsCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_586, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPMulTrackCandidateSetsCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPMulTrackCandidateSetsCollection> -------------------
void __edm__Wrapper_RPMulTrackCandidateSetsCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26519), Reflex::Literal("product"), method_18554, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26519), Reflex::Literal("operator->"), operator_18555, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18556, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18557, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26521), Reflex::Literal("getInterface"), method_18559, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18560, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18561, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18562, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > -------------------------------
static void constructor_18593( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >();
}

static void constructor_18594( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >(*(::std::auto_ptr<std::vector<std::vector<RPTrackCandidate> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >(*(::std::auto_ptr<std::vector<std::vector<RPTrackCandidate> > >*)arg[0]);
}

static void destructor_18595(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >::~Wrapper)();
}
static  void method_18596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->product)();
}

static  void operator_18597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->operator->)();
}

static  void method_18598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->productTypeInfo)();
}

static  void method_18599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->typeInfo)();
}

static void constructor_18600( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >((::std::vector<std::vector<RPTrackCandidate> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >((::std::vector<std::vector<RPTrackCandidate> >*)arg[0]);
}

static  void method_18601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->getInterface)();
}

static  void method_18602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18603( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18604( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->dynamicTypeInfo)();
}

static  void method_18606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->isPresent)();
}

static  void method_18607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4222( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > -------------------------------
void __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__datamem_bld(&__edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__funcmem_bld(&__edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__db_funcmem);
void __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >"), typeid(::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >), sizeof(::edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2850, Reflex::Literal("edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >::value_type"))
  .AddTypedef(type_2850, Reflex::Literal("edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18593, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2632), Reflex::Literal("Wrapper"), constructor_18594, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18595, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26530), Reflex::Literal("Wrapper"), constructor_18600, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4222, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > -------------------
void __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2850, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > -------------------
void __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26529), Reflex::Literal("product"), method_18596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26529), Reflex::Literal("operator->"), operator_18597, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18598, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18599, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26531), Reflex::Literal("getInterface"), method_18601, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18602, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18603, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18604, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPMulFittedTrackSetsCollection> -------------------------------
static void constructor_18614( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulFittedTrackSetsCollection>();
  else ::new(mem) ::edm::Wrapper<RPMulFittedTrackSetsCollection>();
}

static void constructor_18615( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulFittedTrackSetsCollection>(*(::std::auto_ptr<RPMulFittedTrackSetsCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPMulFittedTrackSetsCollection>(*(::std::auto_ptr<RPMulFittedTrackSetsCollection>*)arg[0]);
}

static void destructor_18616(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->::edm::Wrapper<RPMulFittedTrackSetsCollection>::~Wrapper)();
}
static  void method_18617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->product)();
}

static  void operator_18618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->operator->)();
}

static  void method_18619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->productTypeInfo)();
}

static  void method_18620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->typeInfo)();
}

static void constructor_18621( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulFittedTrackSetsCollection>((::RPMulFittedTrackSetsCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPMulFittedTrackSetsCollection>((::RPMulFittedTrackSetsCollection*)arg[0]);
}

static  void method_18622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->getInterface)();
}

static  void method_18623( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18624( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18625( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->dynamicTypeInfo)();
}

static  void method_18627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->isPresent)();
}

static  void method_18628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPMulFittedTrackSetsCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4223( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulFittedTrackSetsCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulFittedTrackSetsCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulFittedTrackSetsCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulFittedTrackSetsCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulFittedTrackSetsCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPMulFittedTrackSetsCollection> -------------------------------
void __edm__Wrapper_RPMulFittedTrackSetsCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPMulFittedTrackSetsCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPMulFittedTrackSetsCollection__datamem_bld(&__edm__Wrapper_RPMulFittedTrackSetsCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPMulFittedTrackSetsCollection__funcmem_bld(&__edm__Wrapper_RPMulFittedTrackSetsCollection__db_funcmem);
void __edm__Wrapper_RPMulFittedTrackSetsCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPMulFittedTrackSetsCollection>"), typeid(::edm::Wrapper<RPMulFittedTrackSetsCollection>), sizeof(::edm::Wrapper<RPMulFittedTrackSetsCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1944, Reflex::Literal("edm::Wrapper<RPMulFittedTrackSetsCollection>::value_type"))
  .AddTypedef(type_1944, Reflex::Literal("edm::Wrapper<RPMulFittedTrackSetsCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18614, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2633), Reflex::Literal("Wrapper"), constructor_18615, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18616, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26535), Reflex::Literal("Wrapper"), constructor_18621, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4223, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPMulFittedTrackSetsCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPMulFittedTrackSetsCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPMulFittedTrackSetsCollection> -------------------
void __edm__Wrapper_RPMulFittedTrackSetsCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPMulFittedTrackSetsCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1944, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPMulFittedTrackSetsCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPMulFittedTrackSetsCollection> -------------------
void __edm__Wrapper_RPMulFittedTrackSetsCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26534), Reflex::Literal("product"), method_18617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26534), Reflex::Literal("operator->"), operator_18618, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18619, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18620, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26536), Reflex::Literal("getInterface"), method_18622, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18623, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18624, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18625, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18627, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18628, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > -------------------------------
static void constructor_18656( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >();
}

static void constructor_18657( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >(*(::std::auto_ptr<std::vector<std::vector<RPFittedTrack> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >(*(::std::auto_ptr<std::vector<std::vector<RPFittedTrack> > >*)arg[0]);
}

static void destructor_18658(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >::~Wrapper)();
}
static  void method_18659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->product)();
}

static  void operator_18660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->operator->)();
}

static  void method_18661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->productTypeInfo)();
}

static  void method_18662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->typeInfo)();
}

static void constructor_18663( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >((::std::vector<std::vector<RPFittedTrack> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >((::std::vector<std::vector<RPFittedTrack> >*)arg[0]);
}

static  void method_18664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->getInterface)();
}

static  void method_18665( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->dynamicTypeInfo)();
}

static  void method_18669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->isPresent)();
}

static  void method_18670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4225( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > -------------------------------
void __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__datamem_bld(&__edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__funcmem_bld(&__edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__db_funcmem);
void __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >"), typeid(::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >), sizeof(::edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2852, Reflex::Literal("edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >::value_type"))
  .AddTypedef(type_2852, Reflex::Literal("edm::Wrapper<std::vector<std::vector<RPFittedTrack> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18656, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2635), Reflex::Literal("Wrapper"), constructor_18657, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18658, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26545), Reflex::Literal("Wrapper"), constructor_18663, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4225, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > -------------------
void __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2852, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > -------------------
void __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26544), Reflex::Literal("product"), method_18659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26544), Reflex::Literal("operator->"), operator_18660, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18661, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18662, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26546), Reflex::Literal("getInterface"), method_18664, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18665, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18666, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18667, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18668, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPTrackCandidateDistinctCollectionsSet> -------------------------------
static void constructor_18677( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>();
  else ::new(mem) ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>();
}

static void constructor_18678( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>(*(::std::auto_ptr<RPTrackCandidateDistinctCollectionsSet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>(*(::std::auto_ptr<RPTrackCandidateDistinctCollectionsSet>*)arg[0]);
}

static void destructor_18679(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>::~Wrapper)();
}
static  void method_18680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->product)());
  else   (((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->product)();
}

static  void operator_18681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->operator->)();
}

static  void method_18682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->productTypeInfo)();
}

static  void method_18683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->typeInfo)();
}

static void constructor_18684( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>((::RPTrackCandidateDistinctCollectionsSet*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>((::RPTrackCandidateDistinctCollectionsSet*)arg[0]);
}

static  void method_18685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->getInterface)();
}

static  void method_18686( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18687( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18688( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->dynamicTypeInfo)();
}

static  void method_18690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->isPresent)();
}

static  void method_18691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4226( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPTrackCandidateDistinctCollectionsSet> -------------------------------
void __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__datamem_bld(&__edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__funcmem_bld(&__edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__db_funcmem);
void __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>"), typeid(::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>), sizeof(::edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_157, Reflex::Literal("edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>::value_type"))
  .AddTypedef(type_157, Reflex::Literal("edm::Wrapper<RPTrackCandidateDistinctCollectionsSet>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18677, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2636), Reflex::Literal("Wrapper"), constructor_18678, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18679, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26550), Reflex::Literal("Wrapper"), constructor_18684, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4226, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPTrackCandidateDistinctCollectionsSet> -------------------
void __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPTrackCandidateDistinctCollectionsSet_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_157, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPTrackCandidateDistinctCollectionsSet_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPTrackCandidateDistinctCollectionsSet> -------------------
void __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26549), Reflex::Literal("product"), method_18680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26549), Reflex::Literal("operator->"), operator_18681, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18682, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18683, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26551), Reflex::Literal("getInterface"), method_18685, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18686, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18687, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18688, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPMulTrackCandidateCollection> -------------------------------
static void constructor_18698( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulTrackCandidateCollection>();
  else ::new(mem) ::edm::Wrapper<RPMulTrackCandidateCollection>();
}

static void constructor_18699( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulTrackCandidateCollection>(*(::std::auto_ptr<RPMulTrackCandidateCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPMulTrackCandidateCollection>(*(::std::auto_ptr<RPMulTrackCandidateCollection>*)arg[0]);
}

static void destructor_18700(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->::edm::Wrapper<RPMulTrackCandidateCollection>::~Wrapper)();
}
static  void method_18701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->product)();
}

static  void operator_18702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->operator->)();
}

static  void method_18703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->productTypeInfo)();
}

static  void method_18704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->typeInfo)();
}

static void constructor_18705( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPMulTrackCandidateCollection>((::RPMulTrackCandidateCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPMulTrackCandidateCollection>((::RPMulTrackCandidateCollection*)arg[0]);
}

static  void method_18706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->getInterface)();
}

static  void method_18707( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18708( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18709( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->dynamicTypeInfo)();
}

static  void method_18711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->isPresent)();
}

static  void method_18712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPMulTrackCandidateCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4227( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulTrackCandidateCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulTrackCandidateCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulTrackCandidateCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulTrackCandidateCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPMulTrackCandidateCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPMulTrackCandidateCollection> -------------------------------
void __edm__Wrapper_RPMulTrackCandidateCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPMulTrackCandidateCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPMulTrackCandidateCollection__datamem_bld(&__edm__Wrapper_RPMulTrackCandidateCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPMulTrackCandidateCollection__funcmem_bld(&__edm__Wrapper_RPMulTrackCandidateCollection__db_funcmem);
void __edm__Wrapper_RPMulTrackCandidateCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPMulTrackCandidateCollection>"), typeid(::edm::Wrapper<RPMulTrackCandidateCollection>), sizeof(::edm::Wrapper<RPMulTrackCandidateCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_370, Reflex::Literal("edm::Wrapper<RPMulTrackCandidateCollection>::value_type"))
  .AddTypedef(type_370, Reflex::Literal("edm::Wrapper<RPMulTrackCandidateCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18698, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2637), Reflex::Literal("Wrapper"), constructor_18699, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18700, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26555), Reflex::Literal("Wrapper"), constructor_18705, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4227, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPMulTrackCandidateCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPMulTrackCandidateCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPMulTrackCandidateCollection> -------------------
void __edm__Wrapper_RPMulTrackCandidateCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPMulTrackCandidateCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_370, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPMulTrackCandidateCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPMulTrackCandidateCollection> -------------------
void __edm__Wrapper_RPMulTrackCandidateCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26554), Reflex::Literal("product"), method_18701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26554), Reflex::Literal("operator->"), operator_18702, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18703, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18704, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26556), Reflex::Literal("getInterface"), method_18706, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18707, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18708, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18709, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPTrackCandidateCollection> -------------------------------
static void constructor_18719( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPTrackCandidateCollection>();
  else ::new(mem) ::edm::Wrapper<RPTrackCandidateCollection>();
}

static void constructor_18720( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPTrackCandidateCollection>(*(::std::auto_ptr<RPTrackCandidateCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPTrackCandidateCollection>(*(::std::auto_ptr<RPTrackCandidateCollection>*)arg[0]);
}

static void destructor_18721(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPTrackCandidateCollection>*)o)->::edm::Wrapper<RPTrackCandidateCollection>::~Wrapper)();
}
static  void method_18722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->product)();
}

static  void operator_18723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->operator->)();
}

static  void method_18724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPTrackCandidateCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPTrackCandidateCollection>*)o)->productTypeInfo)();
}

static  void method_18725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPTrackCandidateCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPTrackCandidateCollection>*)o)->typeInfo)();
}

static void constructor_18726( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPTrackCandidateCollection>((::RPTrackCandidateCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPTrackCandidateCollection>((::RPTrackCandidateCollection*)arg[0]);
}

static  void method_18727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPTrackCandidateCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPTrackCandidateCollection>*)o)->getInterface)();
}

static  void method_18728( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->dynamicTypeInfo)();
}

static  void method_18732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->isPresent)();
}

static  void method_18733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPTrackCandidateCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4228( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPTrackCandidateCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPTrackCandidateCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPTrackCandidateCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPTrackCandidateCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPTrackCandidateCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPTrackCandidateCollection> -------------------------------
void __edm__Wrapper_RPTrackCandidateCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPTrackCandidateCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPTrackCandidateCollection__datamem_bld(&__edm__Wrapper_RPTrackCandidateCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPTrackCandidateCollection__funcmem_bld(&__edm__Wrapper_RPTrackCandidateCollection__db_funcmem);
void __edm__Wrapper_RPTrackCandidateCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPTrackCandidateCollection>"), typeid(::edm::Wrapper<RPTrackCandidateCollection>), sizeof(::edm::Wrapper<RPTrackCandidateCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1597, Reflex::Literal("edm::Wrapper<RPTrackCandidateCollection>::value_type"))
  .AddTypedef(type_1597, Reflex::Literal("edm::Wrapper<RPTrackCandidateCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18719, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2638), Reflex::Literal("Wrapper"), constructor_18720, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18721, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26560), Reflex::Literal("Wrapper"), constructor_18726, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4228, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPTrackCandidateCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPTrackCandidateCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPTrackCandidateCollection> -------------------
void __edm__Wrapper_RPTrackCandidateCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPTrackCandidateCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1597, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPTrackCandidateCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPTrackCandidateCollection> -------------------
void __edm__Wrapper_RPTrackCandidateCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26559), Reflex::Literal("product"), method_18722, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26559), Reflex::Literal("operator->"), operator_18723, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18724, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18725, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26561), Reflex::Literal("getInterface"), method_18727, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18728, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18729, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18730, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<CentralMassInfo> -------------------------------
static void constructor_18740( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<CentralMassInfo>();
  else ::new(mem) ::edm::Wrapper<CentralMassInfo>();
}

static void constructor_18741( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<CentralMassInfo>(*(::std::auto_ptr<CentralMassInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<CentralMassInfo>(*(::std::auto_ptr<CentralMassInfo>*)arg[0]);
}

static void destructor_18742(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<CentralMassInfo>*)o)->::edm::Wrapper<CentralMassInfo>::~Wrapper)();
}
static  void method_18743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<CentralMassInfo>*)o)->product)());
  else   (((const ::edm::Wrapper<CentralMassInfo>*)o)->product)();
}

static  void operator_18744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<CentralMassInfo>*)o)->operator->)());
  else   (((const ::edm::Wrapper<CentralMassInfo>*)o)->operator->)();
}

static  void method_18745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<CentralMassInfo>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<CentralMassInfo>*)o)->productTypeInfo)();
}

static  void method_18746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<CentralMassInfo>*)o)->typeInfo)();
  else   (((::edm::Wrapper<CentralMassInfo>*)o)->typeInfo)();
}

static void constructor_18747( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<CentralMassInfo>((::CentralMassInfo*)arg[0]);
  else ::new(mem) ::edm::Wrapper<CentralMassInfo>((::CentralMassInfo*)arg[0]);
}

static  void method_18748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<CentralMassInfo>*)o)->getInterface)());
  else   (((::edm::Wrapper<CentralMassInfo>*)o)->getInterface)();
}

static  void method_18749( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<CentralMassInfo>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18750( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<CentralMassInfo>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18751( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<CentralMassInfo>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<CentralMassInfo>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<CentralMassInfo>*)o)->dynamicTypeInfo)();
}

static  void method_18753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<CentralMassInfo>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<CentralMassInfo>*)o)->isPresent)();
}

static  void method_18754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<CentralMassInfo>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<CentralMassInfo>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4229( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CentralMassInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CentralMassInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CentralMassInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CentralMassInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CentralMassInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<CentralMassInfo> -------------------------------
void __edm__Wrapper_CentralMassInfo__db_datamem(Reflex::Class*);
void __edm__Wrapper_CentralMassInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_CentralMassInfo__datamem_bld(&__edm__Wrapper_CentralMassInfo__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_CentralMassInfo__funcmem_bld(&__edm__Wrapper_CentralMassInfo__db_funcmem);
void __edm__Wrapper_CentralMassInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<CentralMassInfo>"), typeid(::edm::Wrapper<CentralMassInfo>), sizeof(::edm::Wrapper<CentralMassInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1181, Reflex::Literal("edm::Wrapper<CentralMassInfo>::value_type"))
  .AddTypedef(type_1181, Reflex::Literal("edm::Wrapper<CentralMassInfo>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18740, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2639), Reflex::Literal("Wrapper"), constructor_18741, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18742, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26565), Reflex::Literal("Wrapper"), constructor_18747, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4229, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_CentralMassInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_CentralMassInfo__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<CentralMassInfo> -------------------
void __edm__Wrapper_CentralMassInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_CentralMassInfo_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1181, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_CentralMassInfo_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<CentralMassInfo> -------------------
void __edm__Wrapper_CentralMassInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26564), Reflex::Literal("product"), method_18743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26564), Reflex::Literal("operator->"), operator_18744, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18745, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18746, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26566), Reflex::Literal("getInterface"), method_18748, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18749, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18750, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18751, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class pair<unsigned int,std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > -------------------------------
static void destructor_11599(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,std::vector<RPFittedTrack> >*)o)->::std::pair<unsigned int,std::vector<RPFittedTrack> >::~pair)();
}
static  void operator_11600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,std::vector<RPFittedTrack> >*)o)->operator=)(*(const ::std::pair<unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
  else   (((::std::pair<unsigned int,std::vector<RPFittedTrack> >*)o)->operator=)(*(const ::std::pair<unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
}

static void constructor_11601( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<RPFittedTrack> >(*(const ::std::pair<unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,std::vector<RPFittedTrack> >(*(const ::std::pair<unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
}

static void constructor_11602( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<RPFittedTrack> >();
  else ::new(mem) ::std::pair<unsigned int,std::vector<RPFittedTrack> >();
}

static void constructor_11603( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<RPFittedTrack> >(*(const unsigned int*)arg[0],
      *(const ::std::vector<RPFittedTrack>*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,std::vector<RPFittedTrack> >(*(const unsigned int*)arg[0],
      *(const ::std::vector<RPFittedTrack>*)arg[1]);
}

static void method_newdel_2777( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<RPFittedTrack> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<RPFittedTrack> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<RPFittedTrack> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<RPFittedTrack> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<RPFittedTrack> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > -------------------------------
void __std__pair_unsignedsint_std__vector_RPFittedTrack_s__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_std__vector_RPFittedTrack_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__vector_RPFittedTrack_s__datamem_bld(&__std__pair_unsignedsint_std__vector_RPFittedTrack_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__vector_RPFittedTrack_s__funcmem_bld(&__std__pair_unsignedsint_std__vector_RPFittedTrack_s__db_funcmem);
void __std__pair_unsignedsint_std__vector_RPFittedTrack_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,std::vector<RPFittedTrack> >"), typeid(::std::pair<unsigned int,std::vector<RPFittedTrack> >), sizeof(::std::pair<unsigned int,std::vector<RPFittedTrack> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("o_name"), "std::pair<RPId, std::vector<RPFittedTrack> >")
  .AddTypedef(type_296, Reflex::Literal("std::pair<unsigned int,std::vector<RPFittedTrack> >::first_type"))
  .AddTypedef(type_2849, Reflex::Literal("std::pair<unsigned int,std::vector<RPFittedTrack> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_11599, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24303, type_24304), Reflex::Literal("operator="), operator_11600, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24304), Reflex::Literal("pair"), constructor_11601, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_11602, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23997, type_12496), Reflex::Literal("pair"), constructor_11603, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2777, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_std__vector_RPFittedTrack_s__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > -------------------
void __std__pair_unsignedsint_std__vector_RPFittedTrack_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_296, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__vector_RPFittedTrack_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2849, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__vector_RPFittedTrack_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > -------------------
void __std__pair_unsignedsint_std__vector_RPFittedTrack_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,RPFittedTrack> -------------------------------
static void destructor_11608(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,RPFittedTrack>*)o)->::std::pair<unsigned int,RPFittedTrack>::~pair)();
}
static  void operator_11609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,RPFittedTrack>*)o)->operator=)(*(const ::std::pair<unsigned int,RPFittedTrack>*)arg[0]);
  else   (((::std::pair<unsigned int,RPFittedTrack>*)o)->operator=)(*(const ::std::pair<unsigned int,RPFittedTrack>*)arg[0]);
}

static void constructor_11610( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,RPFittedTrack>(*(const ::std::pair<unsigned int,RPFittedTrack>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,RPFittedTrack>(*(const ::std::pair<unsigned int,RPFittedTrack>*)arg[0]);
}

static void constructor_11611( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,RPFittedTrack>();
  else ::new(mem) ::std::pair<unsigned int,RPFittedTrack>();
}

static void constructor_11612( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,RPFittedTrack>(*(const unsigned int*)arg[0],
      *(const ::RPFittedTrack*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,RPFittedTrack>(*(const unsigned int*)arg[0],
      *(const ::RPFittedTrack*)arg[1]);
}

static void method_newdel_2778( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RPFittedTrack> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RPFittedTrack> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RPFittedTrack> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RPFittedTrack> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RPFittedTrack> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,RPFittedTrack> -------------------------------
void __std__pair_unsignedsint_RPFittedTrack__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_RPFittedTrack__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_RPFittedTrack__datamem_bld(&__std__pair_unsignedsint_RPFittedTrack__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_RPFittedTrack__funcmem_bld(&__std__pair_unsignedsint_RPFittedTrack__db_funcmem);
void __std__pair_unsignedsint_RPFittedTrack__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,RPFittedTrack>"), typeid(::std::pair<unsigned int,RPFittedTrack>), sizeof(::std::pair<unsigned int,RPFittedTrack>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("o_name"), "std::pair<RPId, RPFittedTrack>")
  .AddTypedef(type_296, Reflex::Literal("std::pair<unsigned int,RPFittedTrack>::first_type"))
  .AddTypedef(type_156, Reflex::Literal("std::pair<unsigned int,RPFittedTrack>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_11608, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24305, type_24306), Reflex::Literal("operator="), operator_11609, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24306), Reflex::Literal("pair"), constructor_11610, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_11611, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23997, type_12301), Reflex::Literal("pair"), constructor_11612, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2778, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_RPFittedTrack__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,RPFittedTrack> -------------------
void __std__pair_unsignedsint_RPFittedTrack__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_296, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_RPFittedTrack_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_156, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_RPFittedTrack_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,RPFittedTrack> -------------------
void __std__pair_unsignedsint_RPFittedTrack__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > -------------------------------
static void destructor_11617(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,std::vector<RPTrackCandidate> >*)o)->::std::pair<unsigned int,std::vector<RPTrackCandidate> >::~pair)();
}
static  void operator_11618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,std::vector<RPTrackCandidate> >*)o)->operator=)(*(const ::std::pair<unsigned int,std::vector<RPTrackCandidate> >*)arg[0]);
  else   (((::std::pair<unsigned int,std::vector<RPTrackCandidate> >*)o)->operator=)(*(const ::std::pair<unsigned int,std::vector<RPTrackCandidate> >*)arg[0]);
}

static void constructor_11619( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<RPTrackCandidate> >(*(const ::std::pair<unsigned int,std::vector<RPTrackCandidate> >*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,std::vector<RPTrackCandidate> >(*(const ::std::pair<unsigned int,std::vector<RPTrackCandidate> >*)arg[0]);
}

static void constructor_11620( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<RPTrackCandidate> >();
  else ::new(mem) ::std::pair<unsigned int,std::vector<RPTrackCandidate> >();
}

static void constructor_11621( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<RPTrackCandidate> >(*(const unsigned int*)arg[0],
      *(const ::std::vector<RPTrackCandidate>*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,std::vector<RPTrackCandidate> >(*(const unsigned int*)arg[0],
      *(const ::std::vector<RPTrackCandidate>*)arg[1]);
}

static void method_newdel_2783( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<RPTrackCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<RPTrackCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<RPTrackCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<RPTrackCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<RPTrackCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > -------------------------------
void __std__pair_unsignedsint_std__vector_RPTrackCandidate_s__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_std__vector_RPTrackCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__vector_RPTrackCandidate_s__datamem_bld(&__std__pair_unsignedsint_std__vector_RPTrackCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__vector_RPTrackCandidate_s__funcmem_bld(&__std__pair_unsignedsint_std__vector_RPTrackCandidate_s__db_funcmem);
void __std__pair_unsignedsint_std__vector_RPTrackCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,std::vector<RPTrackCandidate> >"), typeid(::std::pair<unsigned int,std::vector<RPTrackCandidate> >), sizeof(::std::pair<unsigned int,std::vector<RPTrackCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("o_name"), "std::pair<RPId, std::vector<RPTrackCandidate> >")
  .AddTypedef(type_296, Reflex::Literal("std::pair<unsigned int,std::vector<RPTrackCandidate> >::first_type"))
  .AddTypedef(type_2851, Reflex::Literal("std::pair<unsigned int,std::vector<RPTrackCandidate> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_11617, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24307, type_24308), Reflex::Literal("operator="), operator_11618, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24308), Reflex::Literal("pair"), constructor_11619, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_11620, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23997, type_12366), Reflex::Literal("pair"), constructor_11621, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2783, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_std__vector_RPTrackCandidate_s__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > -------------------
void __std__pair_unsignedsint_std__vector_RPTrackCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_296, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__vector_RPTrackCandidate_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2851, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__vector_RPTrackCandidate_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > -------------------
void __std__pair_unsignedsint_std__vector_RPTrackCandidate_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,RPTrackCandidate> -------------------------------
static void destructor_11626(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,RPTrackCandidate>*)o)->::std::pair<unsigned int,RPTrackCandidate>::~pair)();
}
static  void operator_11627( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,RPTrackCandidate>*)o)->operator=)(*(const ::std::pair<unsigned int,RPTrackCandidate>*)arg[0]);
  else   (((::std::pair<unsigned int,RPTrackCandidate>*)o)->operator=)(*(const ::std::pair<unsigned int,RPTrackCandidate>*)arg[0]);
}

static void constructor_11628( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,RPTrackCandidate>(*(const ::std::pair<unsigned int,RPTrackCandidate>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,RPTrackCandidate>(*(const ::std::pair<unsigned int,RPTrackCandidate>*)arg[0]);
}

static void constructor_11629( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,RPTrackCandidate>();
  else ::new(mem) ::std::pair<unsigned int,RPTrackCandidate>();
}

static void constructor_11630( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,RPTrackCandidate>(*(const unsigned int*)arg[0],
      *(const ::RPTrackCandidate*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,RPTrackCandidate>(*(const unsigned int*)arg[0],
      *(const ::RPTrackCandidate*)arg[1]);
}

static void method_newdel_2784( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RPTrackCandidate> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RPTrackCandidate> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RPTrackCandidate> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RPTrackCandidate> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,RPTrackCandidate> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,RPTrackCandidate> -------------------------------
void __std__pair_unsignedsint_RPTrackCandidate__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_RPTrackCandidate__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_RPTrackCandidate__datamem_bld(&__std__pair_unsignedsint_RPTrackCandidate__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_RPTrackCandidate__funcmem_bld(&__std__pair_unsignedsint_RPTrackCandidate__db_funcmem);
void __std__pair_unsignedsint_RPTrackCandidate__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,RPTrackCandidate>"), typeid(::std::pair<unsigned int,RPTrackCandidate>), sizeof(::std::pair<unsigned int,RPTrackCandidate>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("o_name"), "std::pair<RPId, RPTrackCandidate>")
  .AddTypedef(type_296, Reflex::Literal("std::pair<unsigned int,RPTrackCandidate>::first_type"))
  .AddTypedef(type_1658, Reflex::Literal("std::pair<unsigned int,RPTrackCandidate>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_11626, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24309, type_24310), Reflex::Literal("operator="), operator_11627, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24310), Reflex::Literal("pair"), constructor_11628, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_11629, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23997, type_12431), Reflex::Literal("pair"), constructor_11630, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2784, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_RPTrackCandidate__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,RPTrackCandidate> -------------------
void __std__pair_unsignedsint_RPTrackCandidate__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_296, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_RPTrackCandidate_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1658, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_RPTrackCandidate_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,RPTrackCandidate> -------------------
void __std__pair_unsignedsint_RPTrackCandidate__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class map<unsigned int,RP2DHitDebug,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RP2DHitDebug> > > -------------------------------
static void destructor_14174(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RP2DHitDebug>*)o)->::std::map<unsigned int,RP2DHitDebug>::~map)();
}
static void constructor_14175( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RP2DHitDebug>();
  else ::new(mem) ::std::map<unsigned int,RP2DHitDebug>();
}

static void constructor_14176( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RP2DHitDebug>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RP2DHitDebug>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RP2DHitDebug>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RP2DHitDebug> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RP2DHitDebug>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RP2DHitDebug> >*)arg[1]);
  }
}

static void constructor_14177( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RP2DHitDebug>(*(const ::std::map<unsigned int,RP2DHitDebug>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RP2DHitDebug>(*(const ::std::map<unsigned int,RP2DHitDebug>*)arg[0]);
}

static  void operator_14178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RP2DHitDebug>*)o)->operator=)(*(const ::std::map<unsigned int,RP2DHitDebug>*)arg[0]);
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->operator=)(*(const ::std::map<unsigned int,RP2DHitDebug>*)arg[0]);
}

static  void method_14179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RP2DHitDebug> >)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->get_allocator)();
}

static  void method_14180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >)((((::std::map<unsigned int,RP2DHitDebug>*)o)->begin)());
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->begin)();
}

static  void method_14181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RP2DHitDebug> >)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->begin)();
}

static  void method_14182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >)((((::std::map<unsigned int,RP2DHitDebug>*)o)->end)());
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->end)();
}

static  void method_14183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RP2DHitDebug> >)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->end)());
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->end)();
}

static  void method_14188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->empty)();
}

static  void method_14189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->size)());
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->size)();
}

static  void method_14190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->max_size)();
}

static  void operator_14191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RP2DHitDebug>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RP2DHitDebug>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RP2DHitDebug>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >,bool>)((((::std::map<unsigned int,RP2DHitDebug>*)o)->insert)(*(const ::std::pair<const unsigned int,RP2DHitDebug>*)arg[0]));
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->insert)(*(const ::std::pair<const unsigned int,RP2DHitDebug>*)arg[0]);
}

static  void method_14195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >)((((::std::map<unsigned int,RP2DHitDebug>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >*)arg[0],
    *(const ::std::pair<const unsigned int,RP2DHitDebug>*)arg[1]));
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >*)arg[0],
    *(const ::std::pair<const unsigned int,RP2DHitDebug>*)arg[1]);
}

static  void method_14196( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RP2DHitDebug>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >*)arg[0]);
}

static  void method_14197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RP2DHitDebug>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14198( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RP2DHitDebug>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >*)arg[1]);
}

static  void method_14199( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RP2DHitDebug>*)o)->swap)(*(::std::map<unsigned int,RP2DHitDebug>*)arg[0]);
}

static  void method_14200( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RP2DHitDebug>*)o)->clear)();
}

static  void method_14201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->key_comp)();
}

static  void method_14203( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >)((((::std::map<unsigned int,RP2DHitDebug>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RP2DHitDebug> >)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14205( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14206( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >)((((::std::map<unsigned int,RP2DHitDebug>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RP2DHitDebug> >)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >)((((::std::map<unsigned int,RP2DHitDebug>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RP2DHitDebug> >)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RP2DHitDebug> > >)((((::std::map<unsigned int,RP2DHitDebug>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RP2DHitDebug>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RP2DHitDebug> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RP2DHitDebug> > >)((((const ::std::map<unsigned int,RP2DHitDebug>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RP2DHitDebug>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2975( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RP2DHitDebug> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RP2DHitDebug> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RP2DHitDebug> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RP2DHitDebug> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RP2DHitDebug> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x116( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RP2DHitDebug> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RP2DHitDebug> >::Generate();
}

//------Dictionary for class map<unsigned int,RP2DHitDebug,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RP2DHitDebug> > > -------------------------------
void __std__map_unsignedsint_RP2DHitDebug__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RP2DHitDebug__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RP2DHitDebug__datamem_bld(&__std__map_unsignedsint_RP2DHitDebug__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RP2DHitDebug__funcmem_bld(&__std__map_unsignedsint_RP2DHitDebug__db_funcmem);
void __std__map_unsignedsint_RP2DHitDebug__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RP2DHitDebug>"), typeid(::std::map<unsigned int,RP2DHitDebug>), sizeof(::std::map<unsigned int,RP2DHitDebug>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::map<RPId, RP2DHitDebug>")
  .AddTypedef(type_296, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::key_type"))
  .AddTypedef(type_1929, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::mapped_type"))
  .AddTypedef(type_2775, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::value_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::key_compare"))
  .AddTypedef(type_3059, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::allocator_type"))
  .AddTypedef(type_2775, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::_Alloc_value_type"))
  .AddTypedef(type_3059, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::_Pair_alloc_type"))
  .AddTypedef(type_2558, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::_Rep_type"))
  .AddTypedef(type_9880, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::pointer"))
  .AddTypedef(type_9882, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::const_pointer"))
  .AddTypedef(type_9884, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::reference"))
  .AddTypedef(type_9886, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::const_reference"))
  .AddTypedef(type_2910, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::iterator"))
  .AddTypedef(type_2662, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::const_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::difference_type"))
  .AddTypedef(type_3227, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::reverse_iterator"))
  .AddTypedef(type_3226, Reflex::Literal("std::map<unsigned int,RP2DHitDebug>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14174, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14175, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23996, type_24089), Reflex::Literal("map"), constructor_14176, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19331), Reflex::Literal("map"), constructor_14177, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2975, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RP2DHitDebug__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RP2DHitDebug__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RP2DHitDebug,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RP2DHitDebug> > > -------------------
void __std__map_unsignedsint_RP2DHitDebug__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2558, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RP2DHitDebug_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RP2DHitDebug,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RP2DHitDebug> > > -------------------
void __std__map_unsignedsint_RP2DHitDebug__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24485, type_19331), Reflex::Literal("operator="), operator_14178, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3059), Reflex::Literal("get_allocator"), method_14179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2910), Reflex::Literal("begin"), method_14180, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("begin"), method_14181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2910), Reflex::Literal("end"), method_14182, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662), Reflex::Literal("end"), method_14183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_14188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_14189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_14190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21916, type_23997), Reflex::Literal("operator[]"), operator_14191, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21916, type_23997), Reflex::Literal("at"), method_14192, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19330, type_23997), Reflex::Literal("at"), method_14193, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2794, type_9886), Reflex::Literal("insert"), method_14194, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2910, type_2910, type_9886), Reflex::Literal("insert"), method_14195, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2910), Reflex::Literal("erase"), method_14196, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("erase"), method_14197, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2910, type_2910), Reflex::Literal("erase"), method_14198, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24485), Reflex::Literal("swap"), method_14199, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_14200, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510), Reflex::Literal("key_comp"), method_14201, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2910, type_23997), Reflex::Literal("find"), method_14203, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662, type_23997), Reflex::Literal("find"), method_14204, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("count"), method_14205, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2910, type_23997), Reflex::Literal("lower_bound"), method_14206, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662, type_23997), Reflex::Literal("lower_bound"), method_14207, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2910, type_23997), Reflex::Literal("upper_bound"), method_14208, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2662, type_23997), Reflex::Literal("upper_bound"), method_14209, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2793, type_23997), Reflex::Literal("equal_range"), method_14210, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2792, type_23997), Reflex::Literal("equal_range"), method_14211, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > -------------------------------
static void destructor_14232(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->::std::map<unsigned int,std::vector<RPFittedTrack> >::~map)();
}
static void constructor_14233( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPFittedTrack> >();
  else ::new(mem) ::std::map<unsigned int,std::vector<RPFittedTrack> >();
}

static void constructor_14234( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPFittedTrack> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPFittedTrack> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPFittedTrack> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPFittedTrack> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >*)arg[1]);
  }
}

static void constructor_14235( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPFittedTrack> >(*(const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPFittedTrack> >(*(const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
}

static  void operator_14236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
}

static  void method_14237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->get_allocator)();
}

static  void method_14238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->begin)();
}

static  void method_14239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->begin)();
}

static  void method_14240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->end)();
}

static  void method_14241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->end)();
}

static  void method_14246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->empty)();
}

static  void method_14247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->size)();
}

static  void method_14248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->max_size)();
}

static  void operator_14249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >,bool>)((((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPFittedTrack> >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
}

static  void method_14253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPFittedTrack> >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPFittedTrack> >*)arg[1]);
}

static  void method_14254( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >*)arg[0]);
}

static  void method_14255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14256( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >*)arg[1]);
}

static  void method_14257( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->swap)(*(::std::map<unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
}

static  void method_14258( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->clear)();
}

static  void method_14259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->key_comp)();
}

static  void method_14261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14263( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > > >)((((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPFittedTrack> > > >)((((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPFittedTrack> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2976( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPFittedTrack> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPFittedTrack> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPFittedTrack> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPFittedTrack> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPFittedTrack> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x118( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPFittedTrack> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPFittedTrack> > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > -------------------------------
void __std__map_unsignedsint_std__vector_RPFittedTrack_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_RPFittedTrack_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPFittedTrack_s__datamem_bld(&__std__map_unsignedsint_std__vector_RPFittedTrack_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPFittedTrack_s__funcmem_bld(&__std__map_unsignedsint_std__vector_RPFittedTrack_s__db_funcmem);
void __std__map_unsignedsint_std__vector_RPFittedTrack_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >"), typeid(::std::map<unsigned int,std::vector<RPFittedTrack> >), sizeof(::std::map<unsigned int,std::vector<RPFittedTrack> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::map<RPId, std::vector<RPFittedTrack> >")
  .AddTypedef(type_296, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::key_type"))
  .AddTypedef(type_2849, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::mapped_type"))
  .AddTypedef(type_2776, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::value_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::key_compare"))
  .AddTypedef(type_3062, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::allocator_type"))
  .AddTypedef(type_2776, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::_Alloc_value_type"))
  .AddTypedef(type_3062, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::_Pair_alloc_type"))
  .AddTypedef(type_2560, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::_Rep_type"))
  .AddTypedef(type_10098, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::pointer"))
  .AddTypedef(type_10100, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::const_pointer"))
  .AddTypedef(type_10102, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::reference"))
  .AddTypedef(type_10104, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::const_reference"))
  .AddTypedef(type_2912, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::iterator"))
  .AddTypedef(type_2664, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::const_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::difference_type"))
  .AddTypedef(type_3231, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::reverse_iterator"))
  .AddTypedef(type_3230, Reflex::Literal("std::map<unsigned int,std::vector<RPFittedTrack> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14232, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14233, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23996, type_24103), Reflex::Literal("map"), constructor_14234, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24486), Reflex::Literal("map"), constructor_14235, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2976, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_RPFittedTrack_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_RPFittedTrack_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPFittedTrack_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2560, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_RPFittedTrack_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPFittedTrack_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24487, type_24486), Reflex::Literal("operator="), operator_14236, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3062), Reflex::Literal("get_allocator"), method_14237, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2912), Reflex::Literal("begin"), method_14238, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("begin"), method_14239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2912), Reflex::Literal("end"), method_14240, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("end"), method_14241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_14246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_14247, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_14248, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12494, type_23997), Reflex::Literal("operator[]"), operator_14249, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12494, type_23997), Reflex::Literal("at"), method_14250, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12496, type_23997), Reflex::Literal("at"), method_14251, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2800, type_10104), Reflex::Literal("insert"), method_14252, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2912, type_2912, type_10104), Reflex::Literal("insert"), method_14253, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2912), Reflex::Literal("erase"), method_14254, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("erase"), method_14255, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2912, type_2912), Reflex::Literal("erase"), method_14256, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24487), Reflex::Literal("swap"), method_14257, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_14258, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510), Reflex::Literal("key_comp"), method_14259, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2912, type_23997), Reflex::Literal("find"), method_14261, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664, type_23997), Reflex::Literal("find"), method_14262, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("count"), method_14263, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2912, type_23997), Reflex::Literal("lower_bound"), method_14264, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664, type_23997), Reflex::Literal("lower_bound"), method_14265, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2912, type_23997), Reflex::Literal("upper_bound"), method_14266, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664, type_23997), Reflex::Literal("upper_bound"), method_14267, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2799, type_23997), Reflex::Literal("equal_range"), method_14268, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2798, type_23997), Reflex::Literal("equal_range"), method_14269, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,RPFittedTrack,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPFittedTrack> > > -------------------------------
static void destructor_14290(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RPFittedTrack>*)o)->::std::map<unsigned int,RPFittedTrack>::~map)();
}
static void constructor_14291( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPFittedTrack>();
  else ::new(mem) ::std::map<unsigned int,RPFittedTrack>();
}

static void constructor_14292( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPFittedTrack>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPFittedTrack>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPFittedTrack>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RPFittedTrack>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPFittedTrack> >*)arg[1]);
  }
}

static void constructor_14293( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPFittedTrack>(*(const ::std::map<unsigned int,RPFittedTrack>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPFittedTrack>(*(const ::std::map<unsigned int,RPFittedTrack>*)arg[0]);
}

static  void operator_14294( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPFittedTrack>*)o)->operator=)(*(const ::std::map<unsigned int,RPFittedTrack>*)arg[0]);
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->operator=)(*(const ::std::map<unsigned int,RPFittedTrack>*)arg[0]);
}

static  void method_14295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RPFittedTrack> >)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->get_allocator)();
}

static  void method_14296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >)((((::std::map<unsigned int,RPFittedTrack>*)o)->begin)());
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->begin)();
}

static  void method_14297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPFittedTrack> >)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->begin)();
}

static  void method_14298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >)((((::std::map<unsigned int,RPFittedTrack>*)o)->end)());
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->end)();
}

static  void method_14299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPFittedTrack> >)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->end)());
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->end)();
}

static  void method_14304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->empty)();
}

static  void method_14305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->size)());
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->size)();
}

static  void method_14306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->max_size)();
}

static  void operator_14307( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPFittedTrack>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14308( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPFittedTrack>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14309( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RPFittedTrack>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >,bool>)((((::std::map<unsigned int,RPFittedTrack>*)o)->insert)(*(const ::std::pair<const unsigned int,RPFittedTrack>*)arg[0]));
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->insert)(*(const ::std::pair<const unsigned int,RPFittedTrack>*)arg[0]);
}

static  void method_14311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >)((((::std::map<unsigned int,RPFittedTrack>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPFittedTrack>*)arg[1]));
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPFittedTrack>*)arg[1]);
}

static  void method_14312( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPFittedTrack>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >*)arg[0]);
}

static  void method_14313( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RPFittedTrack>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14314( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPFittedTrack>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >*)arg[1]);
}

static  void method_14315( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPFittedTrack>*)o)->swap)(*(::std::map<unsigned int,RPFittedTrack>*)arg[0]);
}

static  void method_14316( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RPFittedTrack>*)o)->clear)();
}

static  void method_14317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->key_comp)();
}

static  void method_14319( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >)((((::std::map<unsigned int,RPFittedTrack>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPFittedTrack> >)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >)((((::std::map<unsigned int,RPFittedTrack>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPFittedTrack> >)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >)((((::std::map<unsigned int,RPFittedTrack>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPFittedTrack> >)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPFittedTrack> > >)((((::std::map<unsigned int,RPFittedTrack>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPFittedTrack>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14327( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPFittedTrack> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPFittedTrack> > >)((((const ::std::map<unsigned int,RPFittedTrack>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPFittedTrack>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2977( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPFittedTrack> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPFittedTrack> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPFittedTrack> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPFittedTrack> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPFittedTrack> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x120( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RPFittedTrack> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RPFittedTrack> >::Generate();
}

//------Dictionary for class map<unsigned int,RPFittedTrack,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPFittedTrack> > > -------------------------------
void __std__map_unsignedsint_RPFittedTrack__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RPFittedTrack__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPFittedTrack__datamem_bld(&__std__map_unsignedsint_RPFittedTrack__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPFittedTrack__funcmem_bld(&__std__map_unsignedsint_RPFittedTrack__db_funcmem);
void __std__map_unsignedsint_RPFittedTrack__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RPFittedTrack>"), typeid(::std::map<unsigned int,RPFittedTrack>), sizeof(::std::map<unsigned int,RPFittedTrack>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::map<RPId, RPFittedTrack>")
  .AddTypedef(type_296, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::key_type"))
  .AddTypedef(type_156, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::mapped_type"))
  .AddTypedef(type_2772, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::value_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::key_compare"))
  .AddTypedef(type_3053, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::allocator_type"))
  .AddTypedef(type_2772, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::_Alloc_value_type"))
  .AddTypedef(type_3053, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::_Pair_alloc_type"))
  .AddTypedef(type_2561, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::_Rep_type"))
  .AddTypedef(type_10207, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::pointer"))
  .AddTypedef(type_10209, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::const_pointer"))
  .AddTypedef(type_10211, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::reference"))
  .AddTypedef(type_10213, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::const_reference"))
  .AddTypedef(type_2913, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::iterator"))
  .AddTypedef(type_2665, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::const_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::difference_type"))
  .AddTypedef(type_3233, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::reverse_iterator"))
  .AddTypedef(type_3232, Reflex::Literal("std::map<unsigned int,RPFittedTrack>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14290, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14291, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23996, type_24110), Reflex::Literal("map"), constructor_14292, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24488), Reflex::Literal("map"), constructor_14293, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2977, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RPFittedTrack__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RPFittedTrack__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RPFittedTrack,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPFittedTrack> > > -------------------
void __std__map_unsignedsint_RPFittedTrack__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2561, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RPFittedTrack_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RPFittedTrack,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPFittedTrack> > > -------------------
void __std__map_unsignedsint_RPFittedTrack__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24489, type_24488), Reflex::Literal("operator="), operator_14294, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3053), Reflex::Literal("get_allocator"), method_14295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2913), Reflex::Literal("begin"), method_14296, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2665), Reflex::Literal("begin"), method_14297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2913), Reflex::Literal("end"), method_14298, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2665), Reflex::Literal("end"), method_14299, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_14304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_14305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_14306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12299, type_23997), Reflex::Literal("operator[]"), operator_14307, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12299, type_23997), Reflex::Literal("at"), method_14308, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12301, type_23997), Reflex::Literal("at"), method_14309, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2803, type_10213), Reflex::Literal("insert"), method_14310, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2913, type_2913, type_10213), Reflex::Literal("insert"), method_14311, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2913), Reflex::Literal("erase"), method_14312, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("erase"), method_14313, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2913, type_2913), Reflex::Literal("erase"), method_14314, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24489), Reflex::Literal("swap"), method_14315, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_14316, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510), Reflex::Literal("key_comp"), method_14317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2913, type_23997), Reflex::Literal("find"), method_14319, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2665, type_23997), Reflex::Literal("find"), method_14320, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("count"), method_14321, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2913, type_23997), Reflex::Literal("lower_bound"), method_14322, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2665, type_23997), Reflex::Literal("lower_bound"), method_14323, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2913, type_23997), Reflex::Literal("upper_bound"), method_14324, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2665, type_23997), Reflex::Literal("upper_bound"), method_14325, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2802, type_23997), Reflex::Literal("equal_range"), method_14326, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2801, type_23997), Reflex::Literal("equal_range"), method_14327, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > > > -------------------------------
static void destructor_14348(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::~map)();
}
static void constructor_14349( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >();
  else ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >();
}

static void constructor_14350( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)arg[1]);
  }
}

static void constructor_14351( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >(*(const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >(*(const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)arg[0]);
}

static  void operator_14352( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)arg[0]);
}

static  void method_14353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->get_allocator)();
}

static  void method_14354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->begin)();
}

static  void method_14355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->begin)();
}

static  void method_14356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->end)();
}

static  void method_14357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->end)();
}

static  void method_14362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->empty)();
}

static  void method_14363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->size)();
}

static  void method_14364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->max_size)();
}

static  void operator_14365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14367( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >,bool>)((((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)arg[0]);
}

static  void method_14369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)arg[1]);
}

static  void method_14370( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)arg[0]);
}

static  void method_14371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)arg[1]);
}

static  void method_14373( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->swap)(*(::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)arg[0]);
}

static  void method_14374( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->clear)();
}

static  void method_14375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->key_comp)();
}

static  void method_14377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14382( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >)((((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14385( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2978( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > > > -------------------------------
void __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__datamem_bld(&__std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__funcmem_bld(&__std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__db_funcmem);
void __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >"), typeid(::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >), sizeof(::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::map<RPId, std::vector<std::vector<RPTrackCandidate> > >")
  .AddTypedef(type_296, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::key_type"))
  .AddTypedef(type_2850, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::mapped_type"))
  .AddTypedef(type_2780, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::value_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::key_compare"))
  .AddTypedef(type_3065, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::allocator_type"))
  .AddTypedef(type_2780, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::_Alloc_value_type"))
  .AddTypedef(type_3065, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::_Pair_alloc_type"))
  .AddTypedef(type_2563, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::_Rep_type"))
  .AddTypedef(type_10425, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::pointer"))
  .AddTypedef(type_10427, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::const_pointer"))
  .AddTypedef(type_10429, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::reference"))
  .AddTypedef(type_10431, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::const_reference"))
  .AddTypedef(type_2915, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::iterator"))
  .AddTypedef(type_2667, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::const_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::difference_type"))
  .AddTypedef(type_3277, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::reverse_iterator"))
  .AddTypedef(type_3276, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14348, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14349, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23996, type_24124), Reflex::Literal("map"), constructor_14350, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24490), Reflex::Literal("map"), constructor_14351, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2978, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > > > -------------------
void __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2563, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > > > -------------------
void __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24491, type_24490), Reflex::Literal("operator="), operator_14352, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3065), Reflex::Literal("get_allocator"), method_14353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2915), Reflex::Literal("begin"), method_14354, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2667), Reflex::Literal("begin"), method_14355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2915), Reflex::Literal("end"), method_14356, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2667), Reflex::Literal("end"), method_14357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_14362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_14363, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_14364, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24349, type_23997), Reflex::Literal("operator[]"), operator_14365, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24349, type_23997), Reflex::Literal("at"), method_14366, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24348, type_23997), Reflex::Literal("at"), method_14367, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2812, type_10431), Reflex::Literal("insert"), method_14368, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2915, type_2915, type_10431), Reflex::Literal("insert"), method_14369, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2915), Reflex::Literal("erase"), method_14370, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("erase"), method_14371, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2915, type_2915), Reflex::Literal("erase"), method_14372, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24491), Reflex::Literal("swap"), method_14373, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_14374, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510), Reflex::Literal("key_comp"), method_14375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2915, type_23997), Reflex::Literal("find"), method_14377, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2667, type_23997), Reflex::Literal("find"), method_14378, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("count"), method_14379, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2915, type_23997), Reflex::Literal("lower_bound"), method_14380, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2667, type_23997), Reflex::Literal("lower_bound"), method_14381, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2915, type_23997), Reflex::Literal("upper_bound"), method_14382, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2667, type_23997), Reflex::Literal("upper_bound"), method_14383, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_23997), Reflex::Literal("equal_range"), method_14384, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2810, type_23997), Reflex::Literal("equal_range"), method_14385, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > > -------------------------------
static void destructor_14406(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::~map)();
}
static void constructor_14407( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >();
  else ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >();
}

static void constructor_14408( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)arg[1]);
  }
}

static void constructor_14409( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >(*(const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >(*(const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)arg[0]);
}

static  void operator_14410( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)arg[0]);
}

static  void method_14411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->get_allocator)();
}

static  void method_14412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->begin)();
}

static  void method_14413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->begin)();
}

static  void method_14414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->end)();
}

static  void method_14415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->end)();
}

static  void method_14420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->empty)();
}

static  void method_14421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->size)();
}

static  void method_14422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->max_size)();
}

static  void operator_14423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14424( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >,bool>)((((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > >*)arg[0]);
}

static  void method_14427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > >*)arg[1]);
}

static  void method_14428( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)arg[0]);
}

static  void method_14429( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14430( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)arg[1]);
}

static  void method_14431( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->swap)(*(::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)arg[0]);
}

static  void method_14432( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->clear)();
}

static  void method_14433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->key_comp)();
}

static  void method_14435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14436( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14440( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > > >)((((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::vector<RPFittedTrack> > > > >)((((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2979( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > > -------------------------------
void __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__datamem_bld(&__std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__funcmem_bld(&__std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__db_funcmem);
void __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >"), typeid(::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >), sizeof(::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::map<RPId, std::vector<std::vector<RPFittedTrack> > >")
  .AddTypedef(type_296, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::key_type"))
  .AddTypedef(type_2852, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::mapped_type"))
  .AddTypedef(type_2781, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::value_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::key_compare"))
  .AddTypedef(type_3068, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::allocator_type"))
  .AddTypedef(type_2781, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::_Alloc_value_type"))
  .AddTypedef(type_3068, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::_Pair_alloc_type"))
  .AddTypedef(type_2559, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::_Rep_type"))
  .AddTypedef(type_9989, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::pointer"))
  .AddTypedef(type_9991, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::const_pointer"))
  .AddTypedef(type_9993, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::reference"))
  .AddTypedef(type_9995, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::const_reference"))
  .AddTypedef(type_2911, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::iterator"))
  .AddTypedef(type_2663, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::const_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::difference_type"))
  .AddTypedef(type_3229, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::reverse_iterator"))
  .AddTypedef(type_3228, Reflex::Literal("std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14406, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14407, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23996, type_24096), Reflex::Literal("map"), constructor_14408, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24492), Reflex::Literal("map"), constructor_14409, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2979, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > > -------------------
void __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2559, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > > -------------------
void __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24493, type_24492), Reflex::Literal("operator="), operator_14410, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3068), Reflex::Literal("get_allocator"), method_14411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2911), Reflex::Literal("begin"), method_14412, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2663), Reflex::Literal("begin"), method_14413, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2911), Reflex::Literal("end"), method_14414, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2663), Reflex::Literal("end"), method_14415, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_14420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_14421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_14422, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24353, type_23997), Reflex::Literal("operator[]"), operator_14423, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24353, type_23997), Reflex::Literal("at"), method_14424, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24352, type_23997), Reflex::Literal("at"), method_14425, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2797, type_9995), Reflex::Literal("insert"), method_14426, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2911, type_2911, type_9995), Reflex::Literal("insert"), method_14427, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2911), Reflex::Literal("erase"), method_14428, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("erase"), method_14429, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2911, type_2911), Reflex::Literal("erase"), method_14430, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24493), Reflex::Literal("swap"), method_14431, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_14432, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510), Reflex::Literal("key_comp"), method_14433, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2911, type_23997), Reflex::Literal("find"), method_14435, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2663, type_23997), Reflex::Literal("find"), method_14436, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("count"), method_14437, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2911, type_23997), Reflex::Literal("lower_bound"), method_14438, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2663, type_23997), Reflex::Literal("lower_bound"), method_14439, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2911, type_23997), Reflex::Literal("upper_bound"), method_14440, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2663, type_23997), Reflex::Literal("upper_bound"), method_14441, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2796, type_23997), Reflex::Literal("equal_range"), method_14442, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2795, type_23997), Reflex::Literal("equal_range"), method_14443, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > -------------------------------
static void destructor_14464(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->::std::map<unsigned int,std::vector<RPTrackCandidate> >::~map)();
}
static void constructor_14465( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidate> >();
  else ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidate> >();
}

static void constructor_14466( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidate> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidate> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidate> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidate> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >*)arg[1]);
  }
}

static void constructor_14467( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidate> >(*(const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidate> >(*(const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)arg[0]);
}

static  void operator_14468( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)arg[0]);
}

static  void method_14469( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->get_allocator)();
}

static  void method_14470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->begin)();
}

static  void method_14471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->begin)();
}

static  void method_14472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->end)();
}

static  void method_14473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->end)();
}

static  void method_14478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->empty)();
}

static  void method_14479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->size)();
}

static  void method_14480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->max_size)();
}

static  void operator_14481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14482( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14484( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >,bool>)((((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPTrackCandidate> >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPTrackCandidate> >*)arg[0]);
}

static  void method_14485( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPTrackCandidate> >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPTrackCandidate> >*)arg[1]);
}

static  void method_14486( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >*)arg[0]);
}

static  void method_14487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14488( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >*)arg[1]);
}

static  void method_14489( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->swap)(*(::std::map<unsigned int,std::vector<RPTrackCandidate> >*)arg[0]);
}

static  void method_14490( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->clear)();
}

static  void method_14491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->key_comp)();
}

static  void method_14493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14494( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14495( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14496( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14497( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14498( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14499( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > > >)((((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidate> > > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidate> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2980( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPTrackCandidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPTrackCandidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPTrackCandidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPTrackCandidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPTrackCandidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x126( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPTrackCandidate> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPTrackCandidate> > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > -------------------------------
void __std__map_unsignedsint_std__vector_RPTrackCandidate_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_RPTrackCandidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPTrackCandidate_s__datamem_bld(&__std__map_unsignedsint_std__vector_RPTrackCandidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPTrackCandidate_s__funcmem_bld(&__std__map_unsignedsint_std__vector_RPTrackCandidate_s__db_funcmem);
void __std__map_unsignedsint_std__vector_RPTrackCandidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >"), typeid(::std::map<unsigned int,std::vector<RPTrackCandidate> >), sizeof(::std::map<unsigned int,std::vector<RPTrackCandidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::map<RPId, std::vector<RPTrackCandidate> >")
  .AddTypedef(type_296, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::key_type"))
  .AddTypedef(type_2851, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::mapped_type"))
  .AddTypedef(type_2782, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::value_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::key_compare"))
  .AddTypedef(type_3070, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::allocator_type"))
  .AddTypedef(type_2782, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::_Alloc_value_type"))
  .AddTypedef(type_3070, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::_Pair_alloc_type"))
  .AddTypedef(type_2564, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::_Rep_type"))
  .AddTypedef(type_10534, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::pointer"))
  .AddTypedef(type_10536, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::const_pointer"))
  .AddTypedef(type_10538, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::reference"))
  .AddTypedef(type_10540, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::const_reference"))
  .AddTypedef(type_2916, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::iterator"))
  .AddTypedef(type_2668, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::const_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::difference_type"))
  .AddTypedef(type_3279, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::reverse_iterator"))
  .AddTypedef(type_3278, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidate> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14464, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14465, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23996, type_24131), Reflex::Literal("map"), constructor_14466, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24494), Reflex::Literal("map"), constructor_14467, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2980, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_RPTrackCandidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_RPTrackCandidate_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPTrackCandidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2564, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_RPTrackCandidate_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPTrackCandidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24495, type_24494), Reflex::Literal("operator="), operator_14468, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3070), Reflex::Literal("get_allocator"), method_14469, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2916), Reflex::Literal("begin"), method_14470, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("begin"), method_14471, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2916), Reflex::Literal("end"), method_14472, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("end"), method_14473, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_14478, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_14479, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_14480, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12364, type_23997), Reflex::Literal("operator[]"), operator_14481, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12364, type_23997), Reflex::Literal("at"), method_14482, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12366, type_23997), Reflex::Literal("at"), method_14483, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2815, type_10540), Reflex::Literal("insert"), method_14484, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2916, type_2916, type_10540), Reflex::Literal("insert"), method_14485, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2916), Reflex::Literal("erase"), method_14486, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("erase"), method_14487, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2916, type_2916), Reflex::Literal("erase"), method_14488, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24495), Reflex::Literal("swap"), method_14489, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_14490, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510), Reflex::Literal("key_comp"), method_14491, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2916, type_23997), Reflex::Literal("find"), method_14493, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668, type_23997), Reflex::Literal("find"), method_14494, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("count"), method_14495, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2916, type_23997), Reflex::Literal("lower_bound"), method_14496, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668, type_23997), Reflex::Literal("lower_bound"), method_14497, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2916, type_23997), Reflex::Literal("upper_bound"), method_14498, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668, type_23997), Reflex::Literal("upper_bound"), method_14499, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2814, type_23997), Reflex::Literal("equal_range"), method_14500, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2813, type_23997), Reflex::Literal("equal_range"), method_14501, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,RPTrackCandidate,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPTrackCandidate> > > -------------------------------
static void destructor_14522(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RPTrackCandidate>*)o)->::std::map<unsigned int,RPTrackCandidate>::~map)();
}
static void constructor_14523( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPTrackCandidate>();
  else ::new(mem) ::std::map<unsigned int,RPTrackCandidate>();
}

static void constructor_14524( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPTrackCandidate>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPTrackCandidate>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPTrackCandidate>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RPTrackCandidate>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPTrackCandidate> >*)arg[1]);
  }
}

static void constructor_14525( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPTrackCandidate>(*(const ::std::map<unsigned int,RPTrackCandidate>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPTrackCandidate>(*(const ::std::map<unsigned int,RPTrackCandidate>*)arg[0]);
}

static  void operator_14526( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPTrackCandidate>*)o)->operator=)(*(const ::std::map<unsigned int,RPTrackCandidate>*)arg[0]);
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->operator=)(*(const ::std::map<unsigned int,RPTrackCandidate>*)arg[0]);
}

static  void method_14527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RPTrackCandidate> >)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->get_allocator)();
}

static  void method_14528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >)((((::std::map<unsigned int,RPTrackCandidate>*)o)->begin)());
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->begin)();
}

static  void method_14529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPTrackCandidate> >)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->begin)();
}

static  void method_14530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >)((((::std::map<unsigned int,RPTrackCandidate>*)o)->end)());
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->end)();
}

static  void method_14531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPTrackCandidate> >)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->end)());
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->end)();
}

static  void method_14536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->empty)();
}

static  void method_14537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->size)());
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->size)();
}

static  void method_14538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->max_size)();
}

static  void operator_14539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPTrackCandidate>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPTrackCandidate>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RPTrackCandidate>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >,bool>)((((::std::map<unsigned int,RPTrackCandidate>*)o)->insert)(*(const ::std::pair<const unsigned int,RPTrackCandidate>*)arg[0]));
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->insert)(*(const ::std::pair<const unsigned int,RPTrackCandidate>*)arg[0]);
}

static  void method_14543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >)((((::std::map<unsigned int,RPTrackCandidate>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPTrackCandidate>*)arg[1]));
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPTrackCandidate>*)arg[1]);
}

static  void method_14544( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPTrackCandidate>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >*)arg[0]);
}

static  void method_14545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RPTrackCandidate>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14546( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPTrackCandidate>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >*)arg[1]);
}

static  void method_14547( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPTrackCandidate>*)o)->swap)(*(::std::map<unsigned int,RPTrackCandidate>*)arg[0]);
}

static  void method_14548( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RPTrackCandidate>*)o)->clear)();
}

static  void method_14549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->key_comp)();
}

static  void method_14551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >)((((::std::map<unsigned int,RPTrackCandidate>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPTrackCandidate> >)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >)((((::std::map<unsigned int,RPTrackCandidate>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPTrackCandidate> >)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >)((((::std::map<unsigned int,RPTrackCandidate>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPTrackCandidate> >)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPTrackCandidate> > >)((((::std::map<unsigned int,RPTrackCandidate>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPTrackCandidate>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPTrackCandidate> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPTrackCandidate> > >)((((const ::std::map<unsigned int,RPTrackCandidate>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPTrackCandidate>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2981( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPTrackCandidate> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPTrackCandidate> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPTrackCandidate> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPTrackCandidate> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPTrackCandidate> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x128( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RPTrackCandidate> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RPTrackCandidate> >::Generate();
}

//------Dictionary for class map<unsigned int,RPTrackCandidate,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPTrackCandidate> > > -------------------------------
void __std__map_unsignedsint_RPTrackCandidate__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RPTrackCandidate__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPTrackCandidate__datamem_bld(&__std__map_unsignedsint_RPTrackCandidate__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPTrackCandidate__funcmem_bld(&__std__map_unsignedsint_RPTrackCandidate__db_funcmem);
void __std__map_unsignedsint_RPTrackCandidate__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RPTrackCandidate>"), typeid(::std::map<unsigned int,RPTrackCandidate>), sizeof(::std::map<unsigned int,RPTrackCandidate>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::map<RPId, RPTrackCandidate>")
  .AddTypedef(type_296, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::key_type"))
  .AddTypedef(type_1658, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::mapped_type"))
  .AddTypedef(type_2779, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::value_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::key_compare"))
  .AddTypedef(type_3064, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::allocator_type"))
  .AddTypedef(type_2779, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::_Alloc_value_type"))
  .AddTypedef(type_3064, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::_Pair_alloc_type"))
  .AddTypedef(type_2565, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::_Rep_type"))
  .AddTypedef(type_10643, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::pointer"))
  .AddTypedef(type_10645, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::const_pointer"))
  .AddTypedef(type_10647, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::reference"))
  .AddTypedef(type_10649, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::const_reference"))
  .AddTypedef(type_2917, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::iterator"))
  .AddTypedef(type_2669, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::const_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::difference_type"))
  .AddTypedef(type_3281, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::reverse_iterator"))
  .AddTypedef(type_3280, Reflex::Literal("std::map<unsigned int,RPTrackCandidate>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14522, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14523, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23996, type_24138), Reflex::Literal("map"), constructor_14524, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24496), Reflex::Literal("map"), constructor_14525, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2981, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x128, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RPTrackCandidate__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RPTrackCandidate__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RPTrackCandidate,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPTrackCandidate> > > -------------------
void __std__map_unsignedsint_RPTrackCandidate__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2565, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RPTrackCandidate_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RPTrackCandidate,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPTrackCandidate> > > -------------------
void __std__map_unsignedsint_RPTrackCandidate__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24497, type_24496), Reflex::Literal("operator="), operator_14526, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3064), Reflex::Literal("get_allocator"), method_14527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2917), Reflex::Literal("begin"), method_14528, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2669), Reflex::Literal("begin"), method_14529, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2917), Reflex::Literal("end"), method_14530, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2669), Reflex::Literal("end"), method_14531, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_14536, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_14537, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_14538, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12429, type_23997), Reflex::Literal("operator[]"), operator_14539, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12429, type_23997), Reflex::Literal("at"), method_14540, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12431, type_23997), Reflex::Literal("at"), method_14541, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2818, type_10649), Reflex::Literal("insert"), method_14542, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2917, type_2917, type_10649), Reflex::Literal("insert"), method_14543, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2917), Reflex::Literal("erase"), method_14544, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("erase"), method_14545, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2917, type_2917), Reflex::Literal("erase"), method_14546, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24497), Reflex::Literal("swap"), method_14547, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_14548, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510), Reflex::Literal("key_comp"), method_14549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2917, type_23997), Reflex::Literal("find"), method_14551, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2669, type_23997), Reflex::Literal("find"), method_14552, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("count"), method_14553, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2917, type_23997), Reflex::Literal("lower_bound"), method_14554, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2669, type_23997), Reflex::Literal("lower_bound"), method_14555, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2917, type_23997), Reflex::Literal("upper_bound"), method_14556, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2669, type_23997), Reflex::Literal("upper_bound"), method_14557, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2817, type_23997), Reflex::Literal("equal_range"), method_14558, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2816, type_23997), Reflex::Literal("equal_range"), method_14559, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::vector<RPTrackCandidateCollection, std::allocator<RPTrackCandidateCollection> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPTrackCandidateCollection, std::allocator<RPTrackCandidateCollection> > > > > -------------------------------
static void destructor_14580(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::~map)();
}
static void constructor_14581( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >();
  else ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >();
}

static void constructor_14582( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >*)arg[1]);
  }
}

static void constructor_14583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >(*(const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >(*(const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)arg[0]);
}

static  void operator_14584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)arg[0]);
}

static  void method_14585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->get_allocator)();
}

static  void method_14586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->begin)();
}

static  void method_14587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->begin)();
}

static  void method_14588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->end)();
}

static  void method_14589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->end)();
}

static  void method_14594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->empty)();
}

static  void method_14595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->size)();
}

static  void method_14596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->max_size)();
}

static  void operator_14597( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14598( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >,bool>)((((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> >*)arg[0]);
}

static  void method_14601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> >*)arg[1]);
}

static  void method_14602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >*)arg[0]);
}

static  void method_14603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14604( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >*)arg[1]);
}

static  void method_14605( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->swap)(*(::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)arg[0]);
}

static  void method_14606( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->clear)();
}

static  void method_14607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->key_comp)();
}

static  void method_14609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14610( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > > >)((((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPTrackCandidateCollection> > > >)((((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2984( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x130( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPTrackCandidateCollection> > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<RPTrackCandidateCollection, std::allocator<RPTrackCandidateCollection> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPTrackCandidateCollection, std::allocator<RPTrackCandidateCollection> > > > > -------------------------------
void __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__datamem_bld(&__std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__funcmem_bld(&__std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__db_funcmem);
void __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >"), typeid(::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >), sizeof(::std::map<unsigned int,std::vector<RPTrackCandidateCollection> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::map<RPId, std::vector<RPTrackCandidateCollection> >")
  .AddTypedef(type_296, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::key_type"))
  .AddTypedef(type_2873, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::mapped_type"))
  .AddTypedef(type_2807, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::value_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::key_compare"))
  .AddTypedef(type_3103, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::allocator_type"))
  .AddTypedef(type_2807, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::_Alloc_value_type"))
  .AddTypedef(type_3103, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::_Pair_alloc_type"))
  .AddTypedef(type_2562, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::_Rep_type"))
  .AddTypedef(type_10316, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::pointer"))
  .AddTypedef(type_10318, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::const_pointer"))
  .AddTypedef(type_10320, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::reference"))
  .AddTypedef(type_10322, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::const_reference"))
  .AddTypedef(type_2914, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::iterator"))
  .AddTypedef(type_2666, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::const_iterator"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::size_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::difference_type"))
  .AddTypedef(type_3275, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::reverse_iterator"))
  .AddTypedef(type_3274, Reflex::Literal("std::map<unsigned int,std::vector<RPTrackCandidateCollection> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14580, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14581, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23996, type_24117), Reflex::Literal("map"), constructor_14582, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24498), Reflex::Literal("map"), constructor_14583, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2984, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<RPTrackCandidateCollection, std::allocator<RPTrackCandidateCollection> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPTrackCandidateCollection, std::allocator<RPTrackCandidateCollection> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2562, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<RPTrackCandidateCollection, std::allocator<RPTrackCandidateCollection> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPTrackCandidateCollection, std::allocator<RPTrackCandidateCollection> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24499, type_24498), Reflex::Literal("operator="), operator_14584, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3103), Reflex::Literal("get_allocator"), method_14585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2914), Reflex::Literal("begin"), method_14586, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666), Reflex::Literal("begin"), method_14587, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2914), Reflex::Literal("end"), method_14588, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666), Reflex::Literal("end"), method_14589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("empty"), method_14594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("size"), method_14595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037), Reflex::Literal("max_size"), method_14596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24500, type_23997), Reflex::Literal("operator[]"), operator_14597, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24500, type_23997), Reflex::Literal("at"), method_14598, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24501, type_23997), Reflex::Literal("at"), method_14599, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2809, type_10322), Reflex::Literal("insert"), method_14600, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2914, type_2914, type_10322), Reflex::Literal("insert"), method_14601, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2914), Reflex::Literal("erase"), method_14602, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("erase"), method_14603, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_2914, type_2914), Reflex::Literal("erase"), method_14604, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_24499), Reflex::Literal("swap"), method_14605, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613), Reflex::Literal("clear"), method_14606, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510), Reflex::Literal("key_comp"), method_14607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2914, type_23997), Reflex::Literal("find"), method_14609, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_23997), Reflex::Literal("find"), method_14610, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3037, type_23997), Reflex::Literal("count"), method_14611, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2914, type_23997), Reflex::Literal("lower_bound"), method_14612, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_23997), Reflex::Literal("lower_bound"), method_14613, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2914, type_23997), Reflex::Literal("upper_bound"), method_14614, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_23997), Reflex::Literal("upper_bound"), method_14615, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2808, type_23997), Reflex::Literal("equal_range"), method_14616, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2806, type_23997), Reflex::Literal("equal_range"), method_14617, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, RP2DHitDebug, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RP2DHitDebug> > > > -------------------------------
static void constructor_18257( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >();
}

static void constructor_18258( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >(*(::std::auto_ptr<std::map<unsigned int,RP2DHitDebug> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >(*(::std::auto_ptr<std::map<unsigned int,RP2DHitDebug> >*)arg[0]);
}

static void destructor_18259(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >::~Wrapper)();
}
static  void method_18260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->product)();
}

static  void operator_18261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->operator->)();
}

static  void method_18262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->productTypeInfo)();
}

static  void method_18263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->typeInfo)();
}

static void constructor_18264( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >((::std::map<unsigned int,RP2DHitDebug>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >((::std::map<unsigned int,RP2DHitDebug>*)arg[0]);
}

static  void method_18265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->getInterface)();
}

static  void method_18266( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18267( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18268( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->dynamicTypeInfo)();
}

static  void method_18270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->isPresent)();
}

static  void method_18271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4206( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, RP2DHitDebug, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RP2DHitDebug> > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >"), typeid(::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >), sizeof(::edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<std::map<RPId, RP2DHitDebug> >")
  .AddTypedef(type_2975, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >::value_type"))
  .AddTypedef(type_2975, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RP2DHitDebug> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18257, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2616), Reflex::Literal("Wrapper"), constructor_18258, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18259, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26458), Reflex::Literal("Wrapper"), constructor_18264, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4206, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, RP2DHitDebug, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RP2DHitDebug> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2975, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, RP2DHitDebug, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RP2DHitDebug> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26457), Reflex::Literal("product"), method_18260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26457), Reflex::Literal("operator->"), operator_18261, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18262, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18263, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26459), Reflex::Literal("getInterface"), method_18265, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18266, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18267, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18268, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > -------------------------------
static void constructor_18446( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >();
}

static void constructor_18447( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >(*(::std::auto_ptr<std::map<unsigned int,std::vector<RPFittedTrack> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >(*(::std::auto_ptr<std::map<unsigned int,std::vector<RPFittedTrack> > >*)arg[0]);
}

static void destructor_18448(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >::~Wrapper)();
}
static  void method_18449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->product)();
}

static  void operator_18450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->operator->)();
}

static  void method_18451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->productTypeInfo)();
}

static  void method_18452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->typeInfo)();
}

static void constructor_18453( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >((::std::map<unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >((::std::map<unsigned int,std::vector<RPFittedTrack> >*)arg[0]);
}

static  void method_18454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->getInterface)();
}

static  void method_18455( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18456( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18457( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->dynamicTypeInfo)();
}

static  void method_18459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->isPresent)();
}

static  void method_18460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4215( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >"), typeid(::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >), sizeof(::edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<std::map<RPId, std::vector<RPFittedTrack> > >")
  .AddTypedef(type_2976, Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >::value_type"))
  .AddTypedef(type_2976, Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18446, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2625), Reflex::Literal("Wrapper"), constructor_18447, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18448, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26497), Reflex::Literal("Wrapper"), constructor_18453, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4215, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2976, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26496), Reflex::Literal("product"), method_18449, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26496), Reflex::Literal("operator->"), operator_18450, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18451, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18452, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26498), Reflex::Literal("getInterface"), method_18454, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18455, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18456, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18457, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, RPFittedTrack, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPFittedTrack> > > > -------------------------------
static void constructor_18467( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >();
}

static void constructor_18468( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >(*(::std::auto_ptr<std::map<unsigned int,RPFittedTrack> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >(*(::std::auto_ptr<std::map<unsigned int,RPFittedTrack> >*)arg[0]);
}

static void destructor_18469(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >::~Wrapper)();
}
static  void method_18470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->product)();
}

static  void operator_18471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->operator->)();
}

static  void method_18472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->productTypeInfo)();
}

static  void method_18473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->typeInfo)();
}

static void constructor_18474( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >((::std::map<unsigned int,RPFittedTrack>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >((::std::map<unsigned int,RPFittedTrack>*)arg[0]);
}

static  void method_18475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->getInterface)();
}

static  void method_18476( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18477( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18478( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->dynamicTypeInfo)();
}

static  void method_18480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->isPresent)();
}

static  void method_18481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4216( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPFittedTrack> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, RPFittedTrack, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPFittedTrack> > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPFittedTrack> >"), typeid(::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >), sizeof(::edm::Wrapper<std::map<unsigned int,RPFittedTrack> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<std::map<RPId, RPFittedTrack> >")
  .AddTypedef(type_2977, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPFittedTrack> >::value_type"))
  .AddTypedef(type_2977, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPFittedTrack> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18467, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2626), Reflex::Literal("Wrapper"), constructor_18468, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18469, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26502), Reflex::Literal("Wrapper"), constructor_18474, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4216, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, RPFittedTrack, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPFittedTrack> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2977, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, RPFittedTrack, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPFittedTrack> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26501), Reflex::Literal("product"), method_18470, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26501), Reflex::Literal("operator->"), operator_18471, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18472, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18473, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26503), Reflex::Literal("getInterface"), method_18475, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18476, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18477, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18478, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18479, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18480, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > > > > -------------------------------
static void constructor_18572( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >();
}

static void constructor_18573( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >(*(::std::auto_ptr<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >(*(::std::auto_ptr<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)arg[0]);
}

static void destructor_18574(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::~Wrapper)();
}
static  void method_18575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->product)();
}

static  void operator_18576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->operator->)();
}

static  void method_18577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->productTypeInfo)();
}

static  void method_18578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->typeInfo)();
}

static void constructor_18579( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >((::std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > >*)arg[0]);
}

static  void method_18580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->getInterface)();
}

static  void method_18581( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18582( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18583( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->dynamicTypeInfo)();
}

static  void method_18585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->isPresent)();
}

static  void method_18586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4221( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >"), typeid(::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >), sizeof(::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<std::map<RPId, std::vector<std::vector<RPTrackCandidate> > > >")
  .AddTypedef(type_2978, Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::value_type"))
  .AddTypedef(type_2978, Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18572, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2631), Reflex::Literal("Wrapper"), constructor_18573, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18574, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26525), Reflex::Literal("Wrapper"), constructor_18579, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4221, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2978, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> >, std::allocator<std::vector<RPTrackCandidate, std::allocator<RPTrackCandidate> > > > > > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26524), Reflex::Literal("product"), method_18575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26524), Reflex::Literal("operator->"), operator_18576, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18577, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18578, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26526), Reflex::Literal("getInterface"), method_18580, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18581, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18582, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18583, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18584, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > > > -------------------------------
static void constructor_18635( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >();
}

static void constructor_18636( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >(*(::std::auto_ptr<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >(*(::std::auto_ptr<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)arg[0]);
}

static void destructor_18637(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >::~Wrapper)();
}
static  void method_18638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->product)();
}

static  void operator_18639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->operator->)();
}

static  void method_18640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->productTypeInfo)();
}

static  void method_18641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->typeInfo)();
}

static void constructor_18642( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >((::std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > >*)arg[0]);
}

static  void method_18643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->getInterface)();
}

static  void method_18644( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_18645( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_18646( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_18647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->dynamicTypeInfo)();
}

static  void method_18648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->isPresent)();
}

static  void method_18649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4224( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >"), typeid(::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >), sizeof(::edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<std::map<RPId, std::vector<std::vector<RPFittedTrack> > > >")
  .AddTypedef(type_2979, Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >::value_type"))
  .AddTypedef(type_2979, Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_18635, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2634), Reflex::Literal("Wrapper"), constructor_18636, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_18637, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26540), Reflex::Literal("Wrapper"), constructor_18642, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4224, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1482, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2979, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> >, std::allocator<std::vector<RPFittedTrack, std::allocator<RPFittedTrack> > > > > > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26539), Reflex::Literal("product"), method_18638, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26539), Reflex::Literal("operator->"), operator_18639, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("productTypeInfo"), method_18640, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("typeInfo"), method_18641, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26541), Reflex::Literal("getInterface"), method_18643, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_18758, type_24324, type_26311), Reflex::Literal("fillView"), method_18644, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_288, type_9051), Reflex::Literal("setPtr"), method_18645, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_613, type_16791, type_24325, type_24324), Reflex::Literal("fillPtrVector"), method_18646, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo"), method_18647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1482), Reflex::Literal("isPresent"), method_18648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16791), Reflex::Literal("dynamicTypeInfo_"), method_18649, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __RPFittedTrack_dict(); 
      __RPTrackCandidateDistinctCollectionsSet_dict(); 
      __RPFittedTrackCollection_dict(); 
      __RPDetHitPoint_dict(); 
      __RPMulFittedTrackCollection_dict(); 
      __RPStationTrackFitCollection_dict(); 
      __RPMulTrackCandidateCollection_dict(); 
      __RPMulTrackCandidateSetsCollection_dict(); 
      __RPReconstructedProtonPairCollection_dict(); 
      __RPReconstructedProtonPair_dict(); 
      __CentralMassInfo_dict(); 
      __RPReconstructedProton_dict(); 
      __RPTrackCandidateCollection_dict(); 
      __RPTrackCandidate_dict(); 
      __TObject_dict(); 
      __RP2DHit_dict(); 
      __RP2DHitDebug_dict(); 
      __RPStationTrackFit_dict(); 
      __TVector3_dict(); 
      __RPRecoElasticEvent_dict(); 
      __RPRecognizedPatternsCollection_dict(); 
      __RPRecognizedPatterns_dict(); 
      __RPReconstructedProtonCollection_dict(); 
      __std__less_unsignedsint__dict(); 
      __std__pair_unsignedsint_RP2DHitDebug__dict(); 
      __std__vector_RPStationTrackFit__dict(); 
      __RPRecognizedPatterns__Line_dict(); 
      __std__vector_RPRecognizedPatterns__Line__dict(); 
      __RPRecoElasticEvent__fit_type_dict(); 
      __std__vector_RPRecoElasticEvent__fit_type__dict(); 
      __RPRecoElasticEvent__road_type_dict(); 
      __std__vector_RPRecoElasticEvent__road_type__dict(); 
      __std__vector_RPReconstructedProtonPair__dict(); 
      __std__vector_RPReconstructedProton__dict(); 
      __std__vector_RPDetHitPoint__dict(); 
      __std__vector_RPFittedTrack__dict(); 
      __std__vector_RPTrackCandidate__dict(); 
      __std__vector_std__vector_RPTrackCandidate_s__dict(); 
      __std__vector_std__vector_RPFittedTrack_s__dict(); 
      __std__map_unsignedsint_std__vector_RPStationTrackFit_s__dict(); 
      __std__map_unsignedsint_RPRecognizedPatterns__dict(); 
      __std__binary_function_unsignedsint_unsignedsint_bool__dict(); 
      __std__allocator_std__pair_constsunsignedsint_RPFittedTrack_s__dict(); 
      __std__allocator_std__pair_constsunsignedsint_RPTrackCandidate_s__dict(); 
      __edm__Wrapper_RPStationTrackFitCollection__dict(); 
      __edm__Wrapper_RPRecognizedPatternsCollection__dict(); 
      __edm__Wrapper_RPRecognizedPatterns__dict(); 
      __edm__Wrapper_RPRecoElasticEvent__dict(); 
      __edm__Wrapper_RPReconstructedProtonPairCollection__dict(); 
      __edm__Wrapper_RPReconstructedProtonPair__dict(); 
      __edm__Wrapper_RP2DHitDebug__dict(); 
      __edm__Wrapper_RP2DHit__dict(); 
      __edm__Wrapper_RPReconstructedProtonCollection__dict(); 
      __edm__Wrapper_RPReconstructedProton__dict(); 
      __edm__Wrapper_TObject__dict(); 
      __edm__Wrapper_std__vector_RPDetHitPoint_s__dict(); 
      __edm__Wrapper_TVector3__dict(); 
      __edm__Wrapper_RPDetHitPoint__dict(); 
      __edm__Wrapper_RPMulFittedTrackCollection__dict(); 
      __edm__Wrapper_RPFittedTrackCollection__dict(); 
      __edm__Wrapper_RPFittedTrack__dict(); 
      __edm__Wrapper_RPMulTrackCandidateSetsCollection__dict(); 
      __edm__Wrapper_std__vector_std__vector_RPTrackCandidate_s_s__dict(); 
      __edm__Wrapper_RPMulFittedTrackSetsCollection__dict(); 
      __edm__Wrapper_std__vector_std__vector_RPFittedTrack_s_s__dict(); 
      __edm__Wrapper_RPTrackCandidateDistinctCollectionsSet__dict(); 
      __edm__Wrapper_RPMulTrackCandidateCollection__dict(); 
      __edm__Wrapper_RPTrackCandidateCollection__dict(); 
      __edm__Wrapper_CentralMassInfo__dict(); 
      __std__pair_unsignedsint_std__vector_RPFittedTrack_s__dict(); 
      __std__pair_unsignedsint_RPFittedTrack__dict(); 
      __std__pair_unsignedsint_std__vector_RPTrackCandidate_s__dict(); 
      __std__pair_unsignedsint_RPTrackCandidate__dict(); 
      __std__map_unsignedsint_RP2DHitDebug__dict(); 
      __std__map_unsignedsint_std__vector_RPFittedTrack_s__dict(); 
      __std__map_unsignedsint_RPFittedTrack__dict(); 
      __std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s__dict(); 
      __std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s__dict(); 
      __std__map_unsignedsint_std__vector_RPTrackCandidate_s__dict(); 
      __std__map_unsignedsint_RPTrackCandidate__dict(); 
      __std__map_unsignedsint_std__vector_RPTrackCandidateCollection_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_RP2DHitDebug_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_std__vector_RPFittedTrack_s_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_RPFittedTrack_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPTrackCandidate_s_s_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_std__vector_std__vector_RPFittedTrack_s_s_s__dict(); 
    }
    ~Dictionaries() {
      type_156.Unload(); // class RPFittedTrack 
      type_157.Unload(); // class RPTrackCandidateDistinctCollectionsSet 
      type_215.Unload(); // class RPFittedTrackCollection 
      type_221.Unload(); // class RPDetHitPoint 
      type_225.Unload(); // class RPMulFittedTrackCollection 
      type_252.Unload(); // class RPStationTrackFitCollection 
      type_370.Unload(); // class RPMulTrackCandidateCollection 
      type_586.Unload(); // class RPMulTrackCandidateSetsCollection 
      type_925.Unload(); // class RPReconstructedProtonPairCollection 
      type_1003.Unload(); // class RPReconstructedProtonPair 
      type_1181.Unload(); // class CentralMassInfo 
      type_1565.Unload(); // class RPReconstructedProton 
      type_1597.Unload(); // class RPTrackCandidateCollection 
      type_1658.Unload(); // class RPTrackCandidate 
      type_1672.Unload(); // class TObject 
      type_1741.Unload(); // class RP2DHit 
      type_1929.Unload(); // class RP2DHitDebug 
      type_1969.Unload(); // class RPStationTrackFit 
      type_2017.Unload(); // class TVector3 
      type_2052.Unload(); // class RPRecoElasticEvent 
      type_2062.Unload(); // class RPRecognizedPatternsCollection 
      type_2172.Unload(); // class RPRecognizedPatterns 
      type_2293.Unload(); // class RPReconstructedProtonCollection 
      type_2510.Unload(); // class std::less<unsigned int> 
      type_2774.Unload(); // class std::pair<unsigned int,RP2DHitDebug> 
      type_2842.Unload(); // class std::vector<RPStationTrackFit> 
      type_7382.Unload(); // class RPRecognizedPatterns::Line 
      type_2843.Unload(); // class std::vector<RPRecognizedPatterns::Line> 
      type_7344.Unload(); // class RPRecoElasticEvent::fit_type 
      type_2844.Unload(); // class std::vector<RPRecoElasticEvent::fit_type> 
      type_7343.Unload(); // class RPRecoElasticEvent::road_type 
      type_2845.Unload(); // class std::vector<RPRecoElasticEvent::road_type> 
      type_2846.Unload(); // class std::vector<RPReconstructedProtonPair> 
      type_2847.Unload(); // class std::vector<RPReconstructedProton> 
      type_2848.Unload(); // class std::vector<RPDetHitPoint> 
      type_2849.Unload(); // class std::vector<RPFittedTrack> 
      type_2851.Unload(); // class std::vector<RPTrackCandidate> 
      type_2850.Unload(); // class std::vector<std::vector<RPTrackCandidate> > 
      type_2852.Unload(); // class std::vector<std::vector<RPFittedTrack> > 
      type_2973.Unload(); // class std::map<unsigned int,std::vector<RPStationTrackFit> > 
      type_2974.Unload(); // class std::map<unsigned int,RPRecognizedPatterns> 
      type_2990.Unload(); // class std::binary_function<unsigned int,unsigned int,bool> 
      type_3053.Unload(); // class std::allocator<std::pair<const unsigned int,RPFittedTrack> > 
      type_3064.Unload(); // class std::allocator<std::pair<const unsigned int,RPTrackCandidate> > 
      type_4200.Unload(); // class edm::Wrapper<RPStationTrackFitCollection> 
      type_4201.Unload(); // class edm::Wrapper<RPRecognizedPatternsCollection> 
      type_4202.Unload(); // class edm::Wrapper<RPRecognizedPatterns> 
      type_4203.Unload(); // class edm::Wrapper<RPRecoElasticEvent> 
      type_4204.Unload(); // class edm::Wrapper<RPReconstructedProtonPairCollection> 
      type_4205.Unload(); // class edm::Wrapper<RPReconstructedProtonPair> 
      type_4207.Unload(); // class edm::Wrapper<RP2DHitDebug> 
      type_4208.Unload(); // class edm::Wrapper<RP2DHit> 
      type_4209.Unload(); // class edm::Wrapper<RPReconstructedProtonCollection> 
      type_4210.Unload(); // class edm::Wrapper<RPReconstructedProton> 
      type_4211.Unload(); // class edm::Wrapper<TObject> 
      type_4212.Unload(); // class edm::Wrapper<std::vector<RPDetHitPoint> > 
      type_4213.Unload(); // class edm::Wrapper<TVector3> 
      type_4214.Unload(); // class edm::Wrapper<RPDetHitPoint> 
      type_4217.Unload(); // class edm::Wrapper<RPMulFittedTrackCollection> 
      type_4218.Unload(); // class edm::Wrapper<RPFittedTrackCollection> 
      type_4219.Unload(); // class edm::Wrapper<RPFittedTrack> 
      type_4220.Unload(); // class edm::Wrapper<RPMulTrackCandidateSetsCollection> 
      type_4222.Unload(); // class edm::Wrapper<std::vector<std::vector<RPTrackCandidate> > > 
      type_4223.Unload(); // class edm::Wrapper<RPMulFittedTrackSetsCollection> 
      type_4225.Unload(); // class edm::Wrapper<std::vector<std::vector<RPFittedTrack> > > 
      type_4226.Unload(); // class edm::Wrapper<RPTrackCandidateDistinctCollectionsSet> 
      type_4227.Unload(); // class edm::Wrapper<RPMulTrackCandidateCollection> 
      type_4228.Unload(); // class edm::Wrapper<RPTrackCandidateCollection> 
      type_4229.Unload(); // class edm::Wrapper<CentralMassInfo> 
      type_2777.Unload(); // class std::pair<unsigned int,std::vector<RPFittedTrack> > 
      type_2778.Unload(); // class std::pair<unsigned int,RPFittedTrack> 
      type_2783.Unload(); // class std::pair<unsigned int,std::vector<RPTrackCandidate> > 
      type_2784.Unload(); // class std::pair<unsigned int,RPTrackCandidate> 
      type_2975.Unload(); // class std::map<unsigned int,RP2DHitDebug> 
      type_2976.Unload(); // class std::map<unsigned int,std::vector<RPFittedTrack> > 
      type_2977.Unload(); // class std::map<unsigned int,RPFittedTrack> 
      type_2978.Unload(); // class std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > 
      type_2979.Unload(); // class std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > 
      type_2980.Unload(); // class std::map<unsigned int,std::vector<RPTrackCandidate> > 
      type_2981.Unload(); // class std::map<unsigned int,RPTrackCandidate> 
      type_2984.Unload(); // class std::map<unsigned int,std::vector<RPTrackCandidateCollection> > 
      type_4206.Unload(); // class edm::Wrapper<std::map<unsigned int,RP2DHitDebug> > 
      type_4215.Unload(); // class edm::Wrapper<std::map<unsigned int,std::vector<RPFittedTrack> > > 
      type_4216.Unload(); // class edm::Wrapper<std::map<unsigned int,RPFittedTrack> > 
      type_4221.Unload(); // class edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPTrackCandidate> > > > 
      type_4224.Unload(); // class edm::Wrapper<std::map<unsigned int,std::vector<std::vector<RPFittedTrack> > > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
