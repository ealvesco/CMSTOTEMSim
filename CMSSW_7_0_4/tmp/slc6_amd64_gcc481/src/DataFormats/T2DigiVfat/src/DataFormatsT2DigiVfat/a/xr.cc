// Generated at Mon Jul 11 23:14:43 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/T2DigiVfat/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_69 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_9 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_572 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_98 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1368 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_766 = ::Reflex::TypeBuilder(Reflex::Literal("T2DetId"));
  ::Reflex::Type type_205 = ::Reflex::TypeBuilder(Reflex::Literal("T2DigiVfat"));
  ::Reflex::Type type_278 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_271 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_191 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_392 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3502 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2285 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<T2DetId>"));
  ::Reflex::Type type_2554 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2534 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T2DigiVfat>"));
  ::Reflex::Type type_2289 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned int>"));
  ::Reflex::Type type_2532 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2553 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_2643 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,int>"));
  ::Reflex::Type type_2555 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned char>"));
  ::Reflex::Type type_2701 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<T2DigiVfat>"));
  ::Reflex::Type type_2533 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_1733 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,unsigned int>"));
  ::Reflex::Type type_1259 = ::Reflex::TypeBuilder(Reflex::Literal("TotemDigiCollection<T2DetId,T2DigiVfat>"));
  ::Reflex::Type type_420 = ::Reflex::TypeBuilder(Reflex::Literal("DigiContainerIterator<T2DetId,T2DigiVfat>"));
  ::Reflex::Type type_2640 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >"));
  ::Reflex::Type type_2510 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,unsigned int>"));
  ::Reflex::Type type_2501 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<T2DetId,std::vector<T2DigiVfat> >"));
  ::Reflex::Type type_2503 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const T2DetId,std::vector<T2DigiVfat> >"));
  ::Reflex::Type type_3402 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,unsigned int> >"));
  ::Reflex::Type type_2375 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,unsigned int> >"));
  ::Reflex::Type type_5114 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<T2DigiVfat> >"));
  ::Reflex::Type type_3324 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3404 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >"));
  ::Reflex::Type type_2377 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TotemDigiCollection<T2DetId,T2DigiVfat> >"));
  ::Reflex::Type type_2155 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2DigiVfat,std::allocator<T2DigiVfat> >"));
  ::Reflex::Type type_3403 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >"));
  ::Reflex::Type type_2376 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::pair<T2DetId,std::vector<T2DigiVfat> > >"));
  ::Reflex::Type type_2726 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,unsigned int> >"));
  ::Reflex::Type type_3433 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,unsigned int> >"));
  ::Reflex::Type type_3435 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TotemDigiCollection<T2DetId,T2DigiVfat> >"));
  ::Reflex::Type type_5048 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >"));
  ::Reflex::Type type_2703 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >"));
  ::Reflex::Type type_3434 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::pair<T2DetId,std::vector<T2DigiVfat> > >"));
  ::Reflex::Type type_2591 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >"));
  ::Reflex::Type type_4481 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const T2DigiVfat*,std::vector<T2DigiVfat> >"));
  ::Reflex::Type type_2401 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >"));
  ::Reflex::Type type_2589 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >"));
  ::Reflex::Type type_2399 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >"));
  ::Reflex::Type type_2517 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >,bool>"));
  ::Reflex::Type type_2797 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> > >"));
  ::Reflex::Type type_2505 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >,bool>"));
  ::Reflex::Type type_2839 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> > >"));
  ::Reflex::Type type_2796 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const T2DigiVfat*,std::vector<T2DigiVfat> > >"));
  ::Reflex::Type type_2838 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> > >"));
  ::Reflex::Type type_2793 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > > >"));
  ::Reflex::Type type_2792 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > > >"));
  ::Reflex::Type type_2516 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >,std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> > >"));
  ::Reflex::Type type_2507 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<const T2DigiVfat*,std::vector<T2DigiVfat> >,__gnu_cxx::__normal_iterator<const T2DigiVfat*,std::vector<T2DigiVfat> > >"));
  ::Reflex::Type type_2515 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> > >"));
  ::Reflex::Type type_2504 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >,std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > > >"));
  ::Reflex::Type type_2502 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >,std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > > >"));
  ::Reflex::Type type_2334 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,unsigned int>,std::_Select1st<std::pair<const unsigned int,unsigned int> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,unsigned int> > >"));
  ::Reflex::Type type_2332 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<T2DetId,std::pair<const T2DetId,std::vector<T2DigiVfat> >,std::_Select1st<std::pair<const T2DetId,std::vector<T2DigiVfat> > >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId,std::vector<T2DigiVfat> > > >"));
  ::Reflex::Type type_1734 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2VfatInformation"), type_1733);
  ::Reflex::Type type_1332 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_278);
  ::Reflex::Type type_8576 = ::Reflex::ReferenceBuilder(type_205);
  ::Reflex::Type type_205c = ::Reflex::ConstBuilder(type_205);
  ::Reflex::Type type_8578 = ::Reflex::ReferenceBuilder(type_205c);
  ::Reflex::Type type_2555c = ::Reflex::ConstBuilder(type_2555);
  ::Reflex::Type type_13463 = ::Reflex::ReferenceBuilder(type_1259);
  ::Reflex::Type type_1259c = ::Reflex::ConstBuilder(type_1259);
  ::Reflex::Type type_13464 = ::Reflex::ReferenceBuilder(type_1259c);
  ::Reflex::Type type_766c = ::Reflex::ConstBuilder(type_766);
  ::Reflex::Type type_4173 = ::Reflex::ReferenceBuilder(type_766c);
  ::Reflex::Type type_17098 = ::Reflex::ReferenceBuilder(type_2501);
  ::Reflex::Type type_2501c = ::Reflex::ConstBuilder(type_2501);
  ::Reflex::Type type_17099 = ::Reflex::ReferenceBuilder(type_2501c);
  ::Reflex::Type type_2534c = ::Reflex::ConstBuilder(type_2534);
  ::Reflex::Type type_8643 = ::Reflex::ReferenceBuilder(type_2534c);
  ::Reflex::Type type_6075 = ::Reflex::PointerBuilder(type_205);
  ::Reflex::Type type_8574 = ::Reflex::PointerBuilder(type_205c);
  ::Reflex::Type type_2687 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_271);
  ::Reflex::Type type_2618 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_9);
  ::Reflex::Type type_2701c = ::Reflex::ConstBuilder(type_2701);
  ::Reflex::Type type_16461 = ::Reflex::ReferenceBuilder(type_2701c);
  ::Reflex::Type type_8641 = ::Reflex::ReferenceBuilder(type_2534);
  ::Reflex::Type type_7356 = ::Reflex::PointerBuilder(type_2503);
  ::Reflex::Type type_2503c = ::Reflex::ConstBuilder(type_2503);
  ::Reflex::Type type_7358 = ::Reflex::PointerBuilder(type_2503c);
  ::Reflex::Type type_7360 = ::Reflex::ReferenceBuilder(type_2503);
  ::Reflex::Type type_7362 = ::Reflex::ReferenceBuilder(type_2503c);
  ::Reflex::Type type_2285c = ::Reflex::ConstBuilder(type_2285);
  ::Reflex::Type type_16865 = ::Reflex::ReferenceBuilder(type_2285c);
  ::Reflex::Type type_2703c = ::Reflex::ConstBuilder(type_2703);
  ::Reflex::Type type_16943 = ::Reflex::ReferenceBuilder(type_2703c);
  ::Reflex::Type type_2640c = ::Reflex::ConstBuilder(type_2640);
  ::Reflex::Type type_17225 = ::Reflex::ReferenceBuilder(type_2640c);
  ::Reflex::Type type_17226 = ::Reflex::ReferenceBuilder(type_2640);
  ::Reflex::Type type_18966 = ::Reflex::PointerBuilder(type_2501c);
  ::Reflex::Type type_392c = ::Reflex::ConstBuilder(type_392);
  ::Reflex::Type type_11622 = ::Reflex::ReferenceBuilder(type_392c);
  ::Reflex::Type type_18967 = ::Reflex::PointerBuilder(type_2501);
  ::Reflex::Type type_3434c = ::Reflex::ConstBuilder(type_3434);
  ::Reflex::Type type_18968 = ::Reflex::PointerBuilder(type_3434c);
  ::Reflex::Type type_3502c = ::Reflex::ConstBuilder(type_3502);
  ::Reflex::Type type_12905 = ::Reflex::ReferenceBuilder(type_3502c);
  ::Reflex::Type type_17108 = ::Reflex::ReferenceBuilder(type_2532);
  ::Reflex::Type type_18886 = ::Reflex::ReferenceBuilder(type_3324);
  ::Reflex::Type type_572c = ::Reflex::ConstBuilder(type_572);
  ::Reflex::Type type_3005 = ::Reflex::PointerBuilder(type_572c);
  ::Reflex::Type type_6796 = ::Reflex::ReferenceBuilder(type_3005);
  ::Reflex::Type type_2533c = ::Reflex::ConstBuilder(type_2533);
  ::Reflex::Type type_17109 = ::Reflex::ReferenceBuilder(type_2533c);
  ::Reflex::Type type_18971 = ::Reflex::PointerBuilder(type_1259c);
  ::Reflex::Type type_18972 = ::Reflex::PointerBuilder(type_1259);
  ::Reflex::Type type_3435c = ::Reflex::ConstBuilder(type_3435);
  ::Reflex::Type type_18973 = ::Reflex::PointerBuilder(type_3435c);
  ::Reflex::Type type_5167 = ::Reflex::PointerBuilder(type_2510);
  ::Reflex::Type type_2510c = ::Reflex::ConstBuilder(type_2510);
  ::Reflex::Type type_5169 = ::Reflex::PointerBuilder(type_2510c);
  ::Reflex::Type type_5171 = ::Reflex::ReferenceBuilder(type_2510);
  ::Reflex::Type type_5173 = ::Reflex::ReferenceBuilder(type_2510c);
  ::Reflex::Type type_2289c = ::Reflex::ConstBuilder(type_2289);
  ::Reflex::Type type_15203 = ::Reflex::ReferenceBuilder(type_2289c);
  ::Reflex::Type type_2726c = ::Reflex::ConstBuilder(type_2726);
  ::Reflex::Type type_15204 = ::Reflex::ReferenceBuilder(type_2726c);
  ::Reflex::Type type_1733c = ::Reflex::ConstBuilder(type_1733);
  ::Reflex::Type type_15205 = ::Reflex::ReferenceBuilder(type_1733c);
  ::Reflex::Type type_15206 = ::Reflex::ReferenceBuilder(type_1733);
  ::Reflex::Type type_9755 = ::Reflex::ReferenceBuilder(type_278);
  ::Reflex::Type type_278c = ::Reflex::ConstBuilder(type_278);
  ::Reflex::Type type_15207 = ::Reflex::ReferenceBuilder(type_278c);
  ::Reflex::Type type_18961 = ::Reflex::PointerBuilder(type_1733c);
  ::Reflex::Type type_18962 = ::Reflex::PointerBuilder(type_1733);
  ::Reflex::Type type_3433c = ::Reflex::ConstBuilder(type_3433);
  ::Reflex::Type type_18963 = ::Reflex::PointerBuilder(type_3433c);
  ::Reflex::Type type_3402f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<T2VfatInformation>"), type_3402);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __T2DigiVfat
#undef __T2DigiVfat
#endif
class __T2DigiVfat {
  public:
  __T2DigiVfat();
  virtual ~__T2DigiVfat() throw();
  ::std::map<unsigned int,unsigned int> ChActMap;
  ::std::map<unsigned int,int> ChThrMap;
  ::std::map<unsigned int,unsigned int> DeadChannel;
  ::std::map<unsigned int,unsigned int> NoisyChannel;
  double Efficiency_;
  unsigned int pos_;
  ::uint32_t cmsswt2detid_;
  unsigned short chipID_;
  unsigned int FrameStatus_;
};
#ifdef __TotemDigiCollection_T2DetId_T2DigiVfat_
#undef __TotemDigiCollection_T2DetId_T2DigiVfat_
#endif
class __TotemDigiCollection_T2DetId_T2DigiVfat_ {
  public:
  __TotemDigiCollection_T2DetId_T2DigiVfat_();
  ::std::map<T2DetId,std::vector<T2DigiVfat> > data_;
};
#ifdef __std__pair_T2DetId_std__vector_T2DigiVfat_s_
#undef __std__pair_T2DetId_std__vector_T2DigiVfat_s_
#endif
struct __std__pair_T2DetId_std__vector_T2DigiVfat_s_ {
  public:
  __std__pair_T2DetId_std__vector_T2DigiVfat_s_();
  ::T2DetId first;
  ::std::vector<T2DigiVfat> second;
};
#ifdef __std__vector_T2DigiVfat_
#undef __std__vector_T2DigiVfat_
#endif
class __std__vector_T2DigiVfat_ : protected ::std::_Vector_base<T2DigiVfat,std::allocator<T2DigiVfat> > {
  public:
  __std__vector_T2DigiVfat_();
};
#ifdef __std__map_T2DetId_std__vector_T2DigiVfat_s_
#undef __std__map_T2DetId_std__vector_T2DigiVfat_s_
#endif
class __std__map_T2DetId_std__vector_T2DigiVfat_s_ {
  public:
  __std__map_T2DetId_std__vector_T2DigiVfat_s_();
  ::std::_Rb_tree<T2DetId,std::pair<const T2DetId,std::vector<T2DigiVfat> >,std::_Select1st<std::pair<const T2DetId,std::vector<T2DigiVfat> > >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId,std::vector<T2DigiVfat> > > > _M_t;
};
#ifdef __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s_
#undef __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s_
#endif
class __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s_ {
  public:
  __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s_();
  bool present;
  ::std::pair<T2DetId,std::vector<T2DigiVfat> > obj;
};
#ifdef __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s_
#undef __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s_
#endif
class __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s_ {
  public:
  __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s_();
  bool present;
  ::TotemDigiCollection<T2DetId,T2DigiVfat> obj;
};
#ifdef __std__map_unsignedsint_unsignedsint_
#undef __std__map_unsignedsint_unsignedsint_
#endif
class __std__map_unsignedsint_unsignedsint_ {
  public:
  __std__map_unsignedsint_unsignedsint_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,unsigned int>,std::_Select1st<std::pair<const unsigned int,unsigned int> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,unsigned int> > > _M_t;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_unsignedsint_s_
#undef __edm__Wrapper_std__map_unsignedsint_unsignedsint_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_unsignedsint_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_unsignedsint_s_();
  bool present;
  ::std::map<unsigned int,unsigned int> obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class T2DigiVfat -------------------------------
static  void operator_3060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T2DigiVfat*)o)->operator=)(*(const ::T2DigiVfat*)arg[0]);
  else   (((::T2DigiVfat*)o)->operator=)(*(const ::T2DigiVfat*)arg[0]);
}

static void constructor_3061( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2DigiVfat(*(const ::T2DigiVfat*)arg[0]);
  else ::new(mem) ::T2DigiVfat(*(const ::T2DigiVfat*)arg[0]);
}

static void constructor_3062( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2DigiVfat(*(::uint32_t*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned short*)arg[2]);
  else ::new(mem) ::T2DigiVfat(*(::uint32_t*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned short*)arg[2]);
}

static void constructor_3063( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2DigiVfat(*(::uint32_t*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned short*)arg[2],
      *(const ::std::vector<unsigned char>*)arg[3]);
  else ::new(mem) ::T2DigiVfat(*(::uint32_t*)arg[0],
      *(unsigned int*)arg[1],
      *(unsigned short*)arg[2],
      *(const ::std::vector<unsigned char>*)arg[3]);
}

static void constructor_3064( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2DigiVfat();
  else ::new(mem) ::T2DigiVfat();
}

static void destructor_3065(void*, void * o, const std::vector<void*>&, void *) {
(((::T2DigiVfat*)o)->::T2DigiVfat::~T2DigiVfat)();
}
static  void method_3066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::T2DigiVfat*)o)->IsPad)());
  else   (((::T2DigiVfat*)o)->IsPad)();
}

static  void method_3067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::T2DigiVfat*)o)->IsStrip)());
  else   (((::T2DigiVfat*)o)->IsStrip)();
}

static  void method_3068( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2DigiVfat*)o)->SetFrameStatus)(*(unsigned int*)arg[0]);
}

static  void method_3069( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::T2DigiVfat*)o)->print)();
}

static  void method_3070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::T2DigiVfat*)o)->GetChannel)(*(unsigned int*)arg[0]));
  else   (((::T2DigiVfat*)o)->GetChannel)(*(unsigned int*)arg[0]);
}

static  void method_3071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::T2DigiVfat*)o)->GetThreshold)(*(unsigned int*)arg[0]));
  else   (((::T2DigiVfat*)o)->GetThreshold)(*(unsigned int*)arg[0]);
}

static  void method_3072( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2DigiVfat*)o)->SetChannel)(*(int*)arg[0],
    *(unsigned int*)arg[1]);
}

static  void method_3073( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2DigiVfat*)o)->SetThreshold)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3074( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2DigiVfat*)o)->SetAllThresholds)(*(::std::vector<double>*)arg[0]);
}

static  void method_3075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::T2DigiVfat*)o)->GetNoiseChannel)(*(unsigned int*)arg[0]));
  else   (((::T2DigiVfat*)o)->GetNoiseChannel)(*(unsigned int*)arg[0]);
}

static  void method_3076( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2DigiVfat*)o)->SetNoiseChannel)(*(unsigned int*)arg[0],
    *(int*)arg[1]);
}

static  void method_3077( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2DigiVfat*)o)->SetDeadChannels)(*(::std::vector<unsigned int>*)arg[0]);
}

static  void method_3078( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2DigiVfat*)o)->SetDeadChannelsFromEff)(*(::std::vector<double>*)arg[0]);
}

static  void method_3079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::T2DigiVfat*)o)->IsChannelDead)(*(unsigned int*)arg[0]));
  else   (((::T2DigiVfat*)o)->IsChannelDead)(*(unsigned int*)arg[0]);
}

static  void method_3080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2DigiVfat*)o)->GetVfatPos)());
  else   (((const ::T2DigiVfat*)o)->GetVfatPos)();
}

static  void method_3081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((::T2DigiVfat*)o)->GetVfatDetId)());
  else   (((::T2DigiVfat*)o)->GetVfatDetId)();
}

static  void method_3082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((::T2DigiVfat*)o)->GetChipID)());
  else   (((::T2DigiVfat*)o)->GetChipID)();
}

static  void method_3083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::T2DigiVfat*)o)->GetFrameStatus)());
  else   (((::T2DigiVfat*)o)->GetFrameStatus)();
}

static void method_newdel_205( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T2DigiVfat >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T2DigiVfat >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T2DigiVfat >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T2DigiVfat >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T2DigiVfat >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T2DigiVfat -------------------------------
void __T2DigiVfat_db_datamem(Reflex::Class*);
void __T2DigiVfat_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T2DigiVfat_datamem_bld(&__T2DigiVfat_db_datamem);
Reflex::GenreflexMemberBuilder __T2DigiVfat_funcmem_bld(&__T2DigiVfat_db_funcmem);
void __T2DigiVfat_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T2DigiVfat"), typeid(::T2DigiVfat), sizeof(::T2DigiVfat), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8576, type_8578), Reflex::Literal("operator="), operator_3060, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8578), Reflex::Literal("T2DigiVfat"), constructor_3061, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1332, type_278, type_191), Reflex::Literal("T2DigiVfat"), constructor_3062, 0, "cmsswt2detid;pos;chipID", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1332, type_278, type_191, type_2555c), Reflex::Literal("T2DigiVfat"), constructor_3063, 0, "cmsswt2detid;pos;chipID;activeCh", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T2DigiVfat"), constructor_3064, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T2DigiVfat"), destructor_3065, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_205, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T2DigiVfat_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T2DigiVfat_funcmem_bld);
}

//------Delayed data member builder for class T2DigiVfat -------------------
void __T2DigiVfat_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1733, Reflex::Literal("ChActMap"), OffsetOf(__shadow__::__T2DigiVfat, ChActMap), ::Reflex::PUBLIC)
  .AddDataMember(type_2643, Reflex::Literal("ChThrMap"), OffsetOf(__shadow__::__T2DigiVfat, ChThrMap), ::Reflex::PUBLIC)
  .AddDataMember(type_1733, Reflex::Literal("DeadChannel"), OffsetOf(__shadow__::__T2DigiVfat, DeadChannel), ::Reflex::PUBLIC)
  .AddDataMember(type_1733, Reflex::Literal("NoisyChannel"), OffsetOf(__shadow__::__T2DigiVfat, NoisyChannel), ::Reflex::PUBLIC)
  .AddDataMember(type_98, Reflex::Literal("Efficiency_"), OffsetOf(__shadow__::__T2DigiVfat, Efficiency_), ::Reflex::PUBLIC)
  .AddDataMember(type_278, Reflex::Literal("pos_"), OffsetOf(__shadow__::__T2DigiVfat, pos_), ::Reflex::PRIVATE)
  .AddDataMember(type_1332, Reflex::Literal("cmsswt2detid_"), OffsetOf(__shadow__::__T2DigiVfat, cmsswt2detid_), ::Reflex::PRIVATE)
  .AddDataMember(type_191, Reflex::Literal("chipID_"), OffsetOf(__shadow__::__T2DigiVfat, chipID_), ::Reflex::PRIVATE)
  .AddDataMember(type_278, Reflex::Literal("FrameStatus_"), OffsetOf(__shadow__::__T2DigiVfat, FrameStatus_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T2DigiVfat -------------------
void __T2DigiVfat_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("IsPad"), method_3066, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("IsStrip"), method_3067, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_278), Reflex::Literal("SetFrameStatus"), method_3068, 0, "FrameStatus", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572), Reflex::Literal("print"), method_3069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_69, type_278), Reflex::Literal("GetChannel"), method_3070, 0, "channel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_69, type_278), Reflex::Literal("GetThreshold"), method_3071, 0, "channel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_69, type_278), Reflex::Literal("SetChannel"), method_3072, 0, "channel;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_69, type_69), Reflex::Literal("SetThreshold"), method_3073, 0, "channel;thr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_2554), Reflex::Literal("SetAllThresholds"), method_3074, 0, "thr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_69, type_278), Reflex::Literal("GetNoiseChannel"), method_3075, 0, "channel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_278, type_69), Reflex::Literal("SetNoiseChannel"), method_3076, 0, "channel;noise", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_2553), Reflex::Literal("SetDeadChannels"), method_3077, 0, "channels", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_2554), Reflex::Literal("SetDeadChannelsFromEff"), method_3078, 0, "channels", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368, type_278), Reflex::Literal("IsChannelDead"), method_3079, 0, "channel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("GetVfatPos"), method_3080, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1332), Reflex::Literal("GetVfatDetId"), method_3081, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_191), Reflex::Literal("GetChipID"), method_3082, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("GetFrameStatus"), method_3083, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class TotemDigiCollection<T2DetId,T2DigiVfat> -------------------------------
static void destructor_4486(void*, void * o, const std::vector<void*>&, void *) {
(((::TotemDigiCollection<T2DetId,T2DigiVfat>*)o)->::TotemDigiCollection<T2DetId,T2DigiVfat>::~TotemDigiCollection)();
}
static  void operator_4487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TotemDigiCollection<T2DetId,T2DigiVfat>*)o)->operator=)(*(const ::TotemDigiCollection<T2DetId,T2DigiVfat>*)arg[0]);
  else   (((::TotemDigiCollection<T2DetId,T2DigiVfat>*)o)->operator=)(*(const ::TotemDigiCollection<T2DetId,T2DigiVfat>*)arg[0]);
}

static void constructor_4488( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemDigiCollection<T2DetId,T2DigiVfat>(*(const ::TotemDigiCollection<T2DetId,T2DigiVfat>*)arg[0]);
  else ::new(mem) ::TotemDigiCollection<T2DetId,T2DigiVfat>(*(const ::TotemDigiCollection<T2DetId,T2DigiVfat>*)arg[0]);
}

static void constructor_4489( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemDigiCollection<T2DetId,T2DigiVfat>();
  else ::new(mem) ::TotemDigiCollection<T2DetId,T2DigiVfat>();
}

static  void method_4490( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TotemDigiCollection<T2DetId,T2DigiVfat>*)o)->insertDigi)(*(const ::T2DetId*)arg[0],
    *(const ::T2DigiVfat*)arg[1]);
}

static  void method_4491( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TotemDigiCollection<T2DetId,T2DigiVfat>*)o)->put)(*(::std::pair<__gnu_cxx::__normal_iterator<const T2DigiVfat*,std::vector<T2DigiVfat> >,__gnu_cxx::__normal_iterator<const T2DigiVfat*,std::vector<T2DigiVfat> > >*)arg[0],
    *(const ::T2DetId*)arg[1]);
}

static  void method_4492( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::__normal_iterator<const T2DigiVfat*,std::vector<T2DigiVfat> >,__gnu_cxx::__normal_iterator<const T2DigiVfat*,std::vector<T2DigiVfat> > >)((((const ::TotemDigiCollection<T2DetId,T2DigiVfat>*)o)->get)(*(const ::T2DetId*)arg[0]));
  else   (((const ::TotemDigiCollection<T2DetId,T2DigiVfat>*)o)->get)(*(const ::T2DetId*)arg[0]);
}

static  void method_4493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (DigiContainerIterator<T2DetId,T2DigiVfat>)((((const ::TotemDigiCollection<T2DetId,T2DigiVfat>*)o)->begin)());
  else   (((const ::TotemDigiCollection<T2DetId,T2DigiVfat>*)o)->begin)();
}

static  void method_4494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (DigiContainerIterator<T2DetId,T2DigiVfat>)((((const ::TotemDigiCollection<T2DetId,T2DigiVfat>*)o)->end)());
  else   (((const ::TotemDigiCollection<T2DetId,T2DigiVfat>*)o)->end)();
}

static void method_newdel_1259( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2DigiVfat> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2DigiVfat> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2DigiVfat> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2DigiVfat> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2DigiVfat> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TotemDigiCollection<T2DetId,T2DigiVfat> -------------------------------
void __TotemDigiCollection_T2DetId_T2DigiVfat__db_datamem(Reflex::Class*);
void __TotemDigiCollection_T2DetId_T2DigiVfat__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TotemDigiCollection_T2DetId_T2DigiVfat__datamem_bld(&__TotemDigiCollection_T2DetId_T2DigiVfat__db_datamem);
Reflex::GenreflexMemberBuilder __TotemDigiCollection_T2DetId_T2DigiVfat__funcmem_bld(&__TotemDigiCollection_T2DetId_T2DigiVfat__db_funcmem);
void __TotemDigiCollection_T2DetId_T2DigiVfat__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TotemDigiCollection<T2DetId,T2DigiVfat>"), typeid(::TotemDigiCollection<T2DetId,T2DigiVfat>), sizeof(::TotemDigiCollection<T2DetId,T2DigiVfat>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4481, Reflex::Literal("TotemDigiCollection<T2DetId,T2DigiVfat>::const_iterator"))
  .AddTypedef(type_2507, Reflex::Literal("TotemDigiCollection<T2DetId,T2DigiVfat>::Range"))
  .AddTypedef(type_420, Reflex::Literal("TotemDigiCollection<T2DetId,T2DigiVfat>::DigiRangeIterator"))
  .AddTypedef(type_2640, Reflex::Literal("TotemDigiCollection<T2DetId,T2DigiVfat>::container"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TotemDigiCollection"), destructor_4486, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13463, type_13464), Reflex::Literal("operator="), operator_4487, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13464), Reflex::Literal("TotemDigiCollection"), constructor_4488, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TotemDigiCollection"), constructor_4489, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1259, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TotemDigiCollection_T2DetId_T2DigiVfat__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TotemDigiCollection_T2DetId_T2DigiVfat__funcmem_bld);
}

//------Delayed data member builder for class TotemDigiCollection<T2DetId,T2DigiVfat> -------------------
void __TotemDigiCollection_T2DetId_T2DigiVfat__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2640, Reflex::Literal("data_"), OffsetOf(__shadow__::__TotemDigiCollection_T2DetId_T2DigiVfat_, data_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TotemDigiCollection<T2DetId,T2DigiVfat> -------------------
void __TotemDigiCollection_T2DetId_T2DigiVfat__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_4173, type_8578), Reflex::Literal("insertDigi"), method_4490, 0, "index;digi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_2507, type_4173), Reflex::Literal("put"), method_4491, 0, "range;index", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2507, type_4173), Reflex::Literal("get"), method_4492, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_420), Reflex::Literal("begin"), method_4493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_420), Reflex::Literal("end"), method_4494, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class pair<T2DetId,std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > -------------------------------
static void destructor_8369(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<T2DetId,std::vector<T2DigiVfat> >*)o)->::std::pair<T2DetId,std::vector<T2DigiVfat> >::~pair)();
}
static  void operator_8370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<T2DetId,std::vector<T2DigiVfat> >*)o)->operator=)(*(const ::std::pair<T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
  else   (((::std::pair<T2DetId,std::vector<T2DigiVfat> >*)o)->operator=)(*(const ::std::pair<T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
}

static void constructor_8371( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2DigiVfat> >(*(const ::std::pair<T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2DigiVfat> >(*(const ::std::pair<T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
}

static void constructor_8372( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2DigiVfat> >();
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2DigiVfat> >();
}

static void constructor_8373( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2DigiVfat> >(*(const ::T2DetId*)arg[0],
      *(const ::std::vector<T2DigiVfat>*)arg[1]);
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2DigiVfat> >(*(const ::T2DetId*)arg[0],
      *(const ::std::vector<T2DigiVfat>*)arg[1]);
}

static void method_newdel_2501( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2DigiVfat> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2DigiVfat> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2DigiVfat> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2DigiVfat> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2DigiVfat> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<T2DetId,std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > -------------------------------
void __std__pair_T2DetId_std__vector_T2DigiVfat_s__db_datamem(Reflex::Class*);
void __std__pair_T2DetId_std__vector_T2DigiVfat_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_T2DetId_std__vector_T2DigiVfat_s__datamem_bld(&__std__pair_T2DetId_std__vector_T2DigiVfat_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_T2DetId_std__vector_T2DigiVfat_s__funcmem_bld(&__std__pair_T2DetId_std__vector_T2DigiVfat_s__db_funcmem);
void __std__pair_T2DetId_std__vector_T2DigiVfat_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<T2DetId,std::vector<T2DigiVfat> >"), typeid(::std::pair<T2DetId,std::vector<T2DigiVfat> >), sizeof(::std::pair<T2DetId,std::vector<T2DigiVfat> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_766, Reflex::Literal("std::pair<T2DetId,std::vector<T2DigiVfat> >::first_type"))
  .AddTypedef(type_2534, Reflex::Literal("std::pair<T2DetId,std::vector<T2DigiVfat> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_8369, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17098, type_17099), Reflex::Literal("operator="), operator_8370, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17099), Reflex::Literal("pair"), constructor_8371, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_8372, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4173, type_8643), Reflex::Literal("pair"), constructor_8373, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2501, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_T2DetId_std__vector_T2DigiVfat_s__datamem_bld);
}

//------Delayed data member builder for class pair<T2DetId,std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > -------------------
void __std__pair_T2DetId_std__vector_T2DigiVfat_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_766, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_T2DetId_std__vector_T2DigiVfat_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2534, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_T2DetId_std__vector_T2DigiVfat_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<T2DetId,std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > -------------------
void __std__pair_T2DetId_std__vector_T2DigiVfat_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<T2DigiVfat,std::allocator<T2DigiVfat> > -------------------------------
static void constructor_8587( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2DigiVfat>();
  else ::new(mem) ::std::vector<T2DigiVfat>();
}

static void constructor_8588( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2DigiVfat>(*(const ::std::allocator<T2DigiVfat>*)arg[0]);
  else ::new(mem) ::std::vector<T2DigiVfat>(*(const ::std::allocator<T2DigiVfat>*)arg[0]);
}

static void constructor_8589( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2DigiVfat>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<T2DigiVfat>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2DigiVfat>(*(::std::size_t*)arg[0],
      *(const ::T2DigiVfat*)arg[1]);
  else ::new(mem) ::std::vector<T2DigiVfat>(*(::std::size_t*)arg[0],
      *(const ::T2DigiVfat*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2DigiVfat>(*(::std::size_t*)arg[0],
      *(const ::T2DigiVfat*)arg[1],
      *(const ::std::allocator<T2DigiVfat>*)arg[2]);
  else ::new(mem) ::std::vector<T2DigiVfat>(*(::std::size_t*)arg[0],
      *(const ::T2DigiVfat*)arg[1],
      *(const ::std::allocator<T2DigiVfat>*)arg[2]);
  }
}

static void constructor_8590( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2DigiVfat>(*(const ::std::vector<T2DigiVfat>*)arg[0]);
  else ::new(mem) ::std::vector<T2DigiVfat>(*(const ::std::vector<T2DigiVfat>*)arg[0]);
}

static void destructor_8591(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<T2DigiVfat>*)o)->::std::vector<T2DigiVfat>::~vector)();
}
static  void operator_8592( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2DigiVfat>*)o)->operator=)(*(const ::std::vector<T2DigiVfat>*)arg[0]);
  else   (((::std::vector<T2DigiVfat>*)o)->operator=)(*(const ::std::vector<T2DigiVfat>*)arg[0]);
}

static  void method_8593( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2DigiVfat>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::T2DigiVfat*)arg[1]);
}

static  void method_8594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >)((((::std::vector<T2DigiVfat>*)o)->begin)());
  else   (((::std::vector<T2DigiVfat>*)o)->begin)();
}

static  void method_8595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2DigiVfat*,std::vector<T2DigiVfat> >)((((const ::std::vector<T2DigiVfat>*)o)->begin)());
  else   (((const ::std::vector<T2DigiVfat>*)o)->begin)();
}

static  void method_8596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >)((((::std::vector<T2DigiVfat>*)o)->end)());
  else   (((::std::vector<T2DigiVfat>*)o)->end)();
}

static  void method_8597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2DigiVfat*,std::vector<T2DigiVfat> >)((((const ::std::vector<T2DigiVfat>*)o)->end)());
  else   (((const ::std::vector<T2DigiVfat>*)o)->end)();
}

static  void method_8602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2DigiVfat>*)o)->size)());
  else   (((const ::std::vector<T2DigiVfat>*)o)->size)();
}

static  void method_8603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2DigiVfat>*)o)->max_size)());
  else   (((const ::std::vector<T2DigiVfat>*)o)->max_size)();
}

static  void method_8604( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<T2DigiVfat>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<T2DigiVfat>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::T2DigiVfat*)arg[1]);
  }
}

static  void method_8605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2DigiVfat>*)o)->capacity)());
  else   (((const ::std::vector<T2DigiVfat>*)o)->capacity)();
}

static  void method_8606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<T2DigiVfat>*)o)->empty)());
  else   (((const ::std::vector<T2DigiVfat>*)o)->empty)();
}

static  void method_8607( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2DigiVfat>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8608( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2DigiVfat>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2DigiVfat>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2DigiVfat>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2DigiVfat>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2DigiVfat>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2DigiVfat>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2DigiVfat>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2DigiVfat>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2DigiVfat>*)o)->front)();
  else   (((::std::vector<T2DigiVfat>*)o)->front)();
}

static  void method_8614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2DigiVfat>*)o)->front)();
  else   (((const ::std::vector<T2DigiVfat>*)o)->front)();
}

static  void method_8615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2DigiVfat>*)o)->back)();
  else   (((::std::vector<T2DigiVfat>*)o)->back)();
}

static  void method_8616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2DigiVfat>*)o)->back)();
  else   (((const ::std::vector<T2DigiVfat>*)o)->back)();
}

static  void method_8617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<T2DigiVfat>*)o)->data)());
  else   (((::std::vector<T2DigiVfat>*)o)->data)();
}

static  void method_8618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<T2DigiVfat>*)o)->data)());
  else   (((const ::std::vector<T2DigiVfat>*)o)->data)();
}

static  void method_8619( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2DigiVfat>*)o)->push_back)(*(const ::T2DigiVfat*)arg[0]);
}

static  void method_8620( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2DigiVfat>*)o)->pop_back)();
}

static  void method_8621( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >)((((::std::vector<T2DigiVfat>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >*)arg[0],
    *(const ::T2DigiVfat*)arg[1]));
  else   (((::std::vector<T2DigiVfat>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >*)arg[0],
    *(const ::T2DigiVfat*)arg[1]);
}

static  void method_8622( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2DigiVfat>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::T2DigiVfat*)arg[2]);
}

static  void method_8623( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >)((((::std::vector<T2DigiVfat>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >*)arg[0]));
  else   (((::std::vector<T2DigiVfat>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >*)arg[0]);
}

static  void method_8624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >)((((::std::vector<T2DigiVfat>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >*)arg[1]));
  else   (((::std::vector<T2DigiVfat>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2DigiVfat*,std::vector<T2DigiVfat> >*)arg[1]);
}

static  void method_8625( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2DigiVfat>*)o)->swap)(*(::std::vector<T2DigiVfat>*)arg[0]);
}

static  void method_8626( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2DigiVfat>*)o)->clear)();
}

static void method_newdel_2534( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<T2DigiVfat> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<T2DigiVfat> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<T2DigiVfat> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<T2DigiVfat> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<T2DigiVfat> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2DigiVfat,std::allocator<T2DigiVfat> >")), ::Reflex::BaseOffset< ::std::vector<T2DigiVfat>,::std::_Vector_base<T2DigiVfat,std::allocator<T2DigiVfat> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<T2DigiVfat> >::Generate();
  else ::Reflex::Proxy< ::std::vector<T2DigiVfat> >::Generate();
}

//------Dictionary for class vector<T2DigiVfat,std::allocator<T2DigiVfat> > -------------------------------
void __std__vector_T2DigiVfat__db_datamem(Reflex::Class*);
void __std__vector_T2DigiVfat__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_T2DigiVfat__datamem_bld(&__std__vector_T2DigiVfat__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_T2DigiVfat__funcmem_bld(&__std__vector_T2DigiVfat__db_funcmem);
void __std__vector_T2DigiVfat__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<T2DigiVfat>"), typeid(::std::vector<T2DigiVfat>), sizeof(::std::vector<T2DigiVfat>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2155, ::Reflex::BaseOffset< ::std::vector<T2DigiVfat>, ::std::_Vector_base<T2DigiVfat,std::allocator<T2DigiVfat> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_205, Reflex::Literal("std::vector<T2DigiVfat>::_Alloc_value_type"))
  .AddTypedef(type_2155, Reflex::Literal("std::vector<T2DigiVfat>::_Base"))
  .AddTypedef(type_2701, Reflex::Literal("std::vector<T2DigiVfat>::_Tp_alloc_type"))
  .AddTypedef(type_5114, Reflex::Literal("std::vector<T2DigiVfat>::_Alloc_traits"))
  .AddTypedef(type_205, Reflex::Literal("std::vector<T2DigiVfat>::value_type"))
  .AddTypedef(type_6075, Reflex::Literal("std::vector<T2DigiVfat>::pointer"))
  .AddTypedef(type_8574, Reflex::Literal("std::vector<T2DigiVfat>::const_pointer"))
  .AddTypedef(type_8576, Reflex::Literal("std::vector<T2DigiVfat>::reference"))
  .AddTypedef(type_8578, Reflex::Literal("std::vector<T2DigiVfat>::const_reference"))
  .AddTypedef(type_5048, Reflex::Literal("std::vector<T2DigiVfat>::iterator"))
  .AddTypedef(type_4481, Reflex::Literal("std::vector<T2DigiVfat>::const_iterator"))
  .AddTypedef(type_2796, Reflex::Literal("std::vector<T2DigiVfat>::const_reverse_iterator"))
  .AddTypedef(type_2797, Reflex::Literal("std::vector<T2DigiVfat>::reverse_iterator"))
  .AddTypedef(type_2687, Reflex::Literal("std::vector<T2DigiVfat>::size_type"))
  .AddTypedef(type_2618, Reflex::Literal("std::vector<T2DigiVfat>::difference_type"))
  .AddTypedef(type_2701, Reflex::Literal("std::vector<T2DigiVfat>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8587, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16461), Reflex::Literal("vector"), constructor_8588, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2687, type_8578, type_16461), Reflex::Literal("vector"), constructor_8589, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8643), Reflex::Literal("vector"), constructor_8590, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8591, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2534, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_T2DigiVfat__funcmem_bld);
}

//------Delayed data member builder for class vector<T2DigiVfat,std::allocator<T2DigiVfat> > -------------------
void __std__vector_T2DigiVfat__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<T2DigiVfat,std::allocator<T2DigiVfat> > -------------------
void __std__vector_T2DigiVfat__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8641, type_8643), Reflex::Literal("operator="), operator_8592, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_2687, type_8578), Reflex::Literal("assign"), method_8593, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5048), Reflex::Literal("begin"), method_8594, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4481), Reflex::Literal("begin"), method_8595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5048), Reflex::Literal("end"), method_8596, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4481), Reflex::Literal("end"), method_8597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687), Reflex::Literal("size"), method_8602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687), Reflex::Literal("max_size"), method_8603, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_2687, type_205), Reflex::Literal("resize"), method_8604, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687), Reflex::Literal("capacity"), method_8605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_8606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_2687), Reflex::Literal("reserve"), method_8607, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8576, type_2687), Reflex::Literal("operator[]"), operator_8608, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8578, type_2687), Reflex::Literal("operator[]"), operator_8609, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8576, type_2687), Reflex::Literal("at"), method_8611, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8578, type_2687), Reflex::Literal("at"), method_8612, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8576), Reflex::Literal("front"), method_8613, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8578), Reflex::Literal("front"), method_8614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8576), Reflex::Literal("back"), method_8615, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8578), Reflex::Literal("back"), method_8616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6075), Reflex::Literal("data"), method_8617, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8574), Reflex::Literal("data"), method_8618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_8578), Reflex::Literal("push_back"), method_8619, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572), Reflex::Literal("pop_back"), method_8620, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5048, type_5048, type_8578), Reflex::Literal("insert"), method_8621, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_5048, type_2687, type_8578), Reflex::Literal("insert"), method_8622, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5048, type_5048), Reflex::Literal("erase"), method_8623, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5048, type_5048, type_5048), Reflex::Literal("erase"), method_8624, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_8641), Reflex::Literal("swap"), method_8625, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572), Reflex::Literal("clear"), method_8626, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<T2DetId,std::vector<T2DigiVfat, std::allocator<T2DigiVfat> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > > > -------------------------------
static void destructor_9883(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->::std::map<T2DetId,std::vector<T2DigiVfat> >::~map)();
}
static void constructor_9884( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2DigiVfat> >();
  else ::new(mem) ::std::map<T2DetId,std::vector<T2DigiVfat> >();
}

static void constructor_9885( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2DigiVfat> >(*(const ::std::less<T2DetId>*)arg[0]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2DigiVfat> >(*(const ::std::less<T2DetId>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2DigiVfat> >(*(const ::std::less<T2DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >*)arg[1]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2DigiVfat> >(*(const ::std::less<T2DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >*)arg[1]);
  }
}

static void constructor_9886( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2DigiVfat> >(*(const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2DigiVfat> >(*(const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
}

static  void operator_9887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->operator=)(*(const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->operator=)(*(const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
}

static  void method_9888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->get_allocator)());
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->get_allocator)();
}

static  void method_9889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->begin)());
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->begin)();
}

static  void method_9890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->begin)());
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->begin)();
}

static  void method_9891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->end)());
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->end)();
}

static  void method_9892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->end)());
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->end)();
}

static  void method_9897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->empty)());
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->empty)();
}

static  void method_9898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->size)());
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->size)();
}

static  void method_9899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->max_size)());
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->max_size)();
}

static  void operator_9900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->operator[])(*(const ::T2DetId*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->operator[])(*(const ::T2DetId*)arg[0]);
}

static  void method_9901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->at)(*(const ::T2DetId*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->at)(*(const ::T2DetId*)arg[0]);
}

static  void method_9902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->at)(*(const ::T2DetId*)arg[0]);
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->at)(*(const ::T2DetId*)arg[0]);
}

static  void method_9903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >,bool>)((((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->insert)(*(const ::std::pair<const T2DetId,std::vector<T2DigiVfat> >*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->insert)(*(const ::std::pair<const T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
}

static  void method_9904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >*)arg[0],
    *(const ::std::pair<const T2DetId,std::vector<T2DigiVfat> >*)arg[1]));
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >*)arg[0],
    *(const ::std::pair<const T2DetId,std::vector<T2DigiVfat> >*)arg[1]);
}

static  void method_9905( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >*)arg[0]);
}

static  void method_9906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->erase)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->erase)(*(const ::T2DetId*)arg[0]);
}

static  void method_9907( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >*)arg[1]);
}

static  void method_9908( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->swap)(*(::std::map<T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
}

static  void method_9909( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->clear)();
}

static  void method_9910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<T2DetId>)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->key_comp)());
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->key_comp)();
}

static  void method_9912( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->find)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->find)(*(const ::T2DetId*)arg[0]);
}

static  void method_9913( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->find)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->find)(*(const ::T2DetId*)arg[0]);
}

static  void method_9914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->count)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->count)(*(const ::T2DetId*)arg[0]);
}

static  void method_9915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9917( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >,std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > > >)((((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]);
}

static  void method_9920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > >,std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2DigiVfat> > > >)((((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2DigiVfat> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]);
}

static void method_newdel_2640( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2DigiVfat> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2DigiVfat> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2DigiVfat> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2DigiVfat> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2DigiVfat> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<T2DetId,std::vector<T2DigiVfat> > >::Generate();
  else ::Reflex::Proxy< ::std::map<T2DetId,std::vector<T2DigiVfat> > >::Generate();
}

//------Dictionary for class map<T2DetId,std::vector<T2DigiVfat, std::allocator<T2DigiVfat> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > > > -------------------------------
void __std__map_T2DetId_std__vector_T2DigiVfat_s__db_datamem(Reflex::Class*);
void __std__map_T2DetId_std__vector_T2DigiVfat_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_T2DetId_std__vector_T2DigiVfat_s__datamem_bld(&__std__map_T2DetId_std__vector_T2DigiVfat_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_T2DetId_std__vector_T2DigiVfat_s__funcmem_bld(&__std__map_T2DetId_std__vector_T2DigiVfat_s__db_funcmem);
void __std__map_T2DetId_std__vector_T2DigiVfat_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >"), typeid(::std::map<T2DetId,std::vector<T2DigiVfat> >), sizeof(::std::map<T2DetId,std::vector<T2DigiVfat> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_766, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::key_type"))
  .AddTypedef(type_2534, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::mapped_type"))
  .AddTypedef(type_2503, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::value_type"))
  .AddTypedef(type_2285, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::key_compare"))
  .AddTypedef(type_2703, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::allocator_type"))
  .AddTypedef(type_2503, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::_Alloc_value_type"))
  .AddTypedef(type_2703, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::_Pair_alloc_type"))
  .AddTypedef(type_2332, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::_Rep_type"))
  .AddTypedef(type_7356, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::pointer"))
  .AddTypedef(type_7358, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::const_pointer"))
  .AddTypedef(type_7360, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::reference"))
  .AddTypedef(type_7362, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::const_reference"))
  .AddTypedef(type_2589, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::iterator"))
  .AddTypedef(type_2399, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::const_iterator"))
  .AddTypedef(type_2687, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::size_type"))
  .AddTypedef(type_2618, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::difference_type"))
  .AddTypedef(type_2793, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::reverse_iterator"))
  .AddTypedef(type_2792, Reflex::Literal("std::map<T2DetId,std::vector<T2DigiVfat> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_9883, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_9884, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16865, type_16943), Reflex::Literal("map"), constructor_9885, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17225), Reflex::Literal("map"), constructor_9886, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2640, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_T2DetId_std__vector_T2DigiVfat_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_T2DetId_std__vector_T2DigiVfat_s__funcmem_bld);
}

//------Delayed data member builder for class map<T2DetId,std::vector<T2DigiVfat, std::allocator<T2DigiVfat> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > > > -------------------
void __std__map_T2DetId_std__vector_T2DigiVfat_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2332, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_T2DetId_std__vector_T2DigiVfat_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<T2DetId,std::vector<T2DigiVfat, std::allocator<T2DigiVfat> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > > > -------------------
void __std__map_T2DetId_std__vector_T2DigiVfat_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17226, type_17225), Reflex::Literal("operator="), operator_9887, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703), Reflex::Literal("get_allocator"), method_9888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589), Reflex::Literal("begin"), method_9889, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2399), Reflex::Literal("begin"), method_9890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589), Reflex::Literal("end"), method_9891, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2399), Reflex::Literal("end"), method_9892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_9897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687), Reflex::Literal("size"), method_9898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687), Reflex::Literal("max_size"), method_9899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8641, type_4173), Reflex::Literal("operator[]"), operator_9900, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8641, type_4173), Reflex::Literal("at"), method_9901, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8643, type_4173), Reflex::Literal("at"), method_9902, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2505, type_7362), Reflex::Literal("insert"), method_9903, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589, type_2589, type_7362), Reflex::Literal("insert"), method_9904, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_2589), Reflex::Literal("erase"), method_9905, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687, type_4173), Reflex::Literal("erase"), method_9906, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_2589, type_2589), Reflex::Literal("erase"), method_9907, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_17226), Reflex::Literal("swap"), method_9908, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572), Reflex::Literal("clear"), method_9909, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2285), Reflex::Literal("key_comp"), method_9910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589, type_4173), Reflex::Literal("find"), method_9912, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2399, type_4173), Reflex::Literal("find"), method_9913, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687, type_4173), Reflex::Literal("count"), method_9914, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589, type_4173), Reflex::Literal("lower_bound"), method_9915, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2399, type_4173), Reflex::Literal("lower_bound"), method_9916, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589, type_4173), Reflex::Literal("upper_bound"), method_9917, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2399, type_4173), Reflex::Literal("upper_bound"), method_9918, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504, type_4173), Reflex::Literal("equal_range"), method_9919, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2502, type_4173), Reflex::Literal("equal_range"), method_9920, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::pair<T2DetId, std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > > -------------------------------
static void constructor_12837( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >();
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >();
}

static void constructor_12838( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >(*(::std::auto_ptr<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >(*(::std::auto_ptr<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)arg[0]);
}

static void destructor_12839(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >::~Wrapper)();
}
static  void method_12840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->product)();
}

static  void operator_12841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->operator->)();
}

static  void method_12842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->productTypeInfo)();
}

static  void method_12843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->typeInfo)();
}

static void constructor_12844( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >((::std::pair<T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >((::std::pair<T2DetId,std::vector<T2DigiVfat> >*)arg[0]);
}

static  void method_12845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->getInterface)();
}

static  void method_12846( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12847( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12848( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->dynamicTypeInfo)();
}

static  void method_12850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->isPresent)();
}

static  void method_12851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3403( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::pair<T2DetId, std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > > -------------------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__datamem_bld(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__funcmem_bld(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__db_funcmem);
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >"), typeid(::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >), sizeof(::edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2501, Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >::value_type"))
  .AddTypedef(type_2501, Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12837, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2376), Reflex::Literal("Wrapper"), constructor_12838, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12839, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18967), Reflex::Literal("Wrapper"), constructor_12844, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3403, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::pair<T2DetId, std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > > -------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1368, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2501, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::pair<T2DetId, std::vector<T2DigiVfat, std::allocator<T2DigiVfat> > > > -------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18966), Reflex::Literal("product"), method_12840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18966), Reflex::Literal("operator->"), operator_12841, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("productTypeInfo"), method_12842, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("typeInfo"), method_12843, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18968), Reflex::Literal("getInterface"), method_12845, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_12905, type_17108, type_18886), Reflex::Literal("fillView"), method_12846, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_11622, type_271, type_6796), Reflex::Literal("setPtr"), method_12847, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_11622, type_17109, type_17108), Reflex::Literal("fillPtrVector"), method_12848, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("dynamicTypeInfo"), method_12849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("isPresent"), method_12850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("dynamicTypeInfo_"), method_12851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TotemDigiCollection<T2DetId, T2DigiVfat> > -------------------------------
static void constructor_12858( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >();
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >();
}

static void constructor_12859( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >(*(::std::auto_ptr<TotemDigiCollection<T2DetId,T2DigiVfat> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >(*(::std::auto_ptr<TotemDigiCollection<T2DetId,T2DigiVfat> >*)arg[0]);
}

static void destructor_12860(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >::~Wrapper)();
}
static  void method_12861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->product)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->product)();
}

static  void operator_12862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->operator->)();
}

static  void method_12863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->productTypeInfo)();
}

static  void method_12864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->typeInfo)();
}

static void constructor_12865( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >((::TotemDigiCollection<T2DetId,T2DigiVfat>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >((::TotemDigiCollection<T2DetId,T2DigiVfat>*)arg[0]);
}

static  void method_12866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->getInterface)());
  else   (((::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->getInterface)();
}

static  void method_12867( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12868( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12869( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->dynamicTypeInfo)();
}

static  void method_12871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->isPresent)();
}

static  void method_12872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3404( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TotemDigiCollection<T2DetId, T2DigiVfat> > -------------------------------
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__datamem_bld(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__funcmem_bld(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__db_funcmem);
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >"), typeid(::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >), sizeof(::edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_1259, Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >::value_type"))
  .AddTypedef(type_1259, Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12858, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2377), Reflex::Literal("Wrapper"), constructor_12859, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12860, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18972), Reflex::Literal("Wrapper"), constructor_12865, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3404, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TotemDigiCollection<T2DetId, T2DigiVfat> > -------------------
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1368, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1259, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TotemDigiCollection<T2DetId, T2DigiVfat> > -------------------
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18971), Reflex::Literal("product"), method_12861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18971), Reflex::Literal("operator->"), operator_12862, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("productTypeInfo"), method_12863, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("typeInfo"), method_12864, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18973), Reflex::Literal("getInterface"), method_12866, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_12905, type_17108, type_18886), Reflex::Literal("fillView"), method_12867, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_11622, type_271, type_6796), Reflex::Literal("setPtr"), method_12868, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_11622, type_17109, type_17108), Reflex::Literal("fillPtrVector"), method_12869, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("dynamicTypeInfo"), method_12870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("isPresent"), method_12871, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("dynamicTypeInfo_"), method_12872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,unsigned int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, unsigned int> > > -------------------------------
static void destructor_5181(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,unsigned int>*)o)->::std::map<unsigned int,unsigned int>::~map)();
}
static void constructor_5182( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,unsigned int>();
  else ::new(mem) ::std::map<unsigned int,unsigned int>();
}

static void constructor_5183( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,unsigned int> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,unsigned int> >*)arg[1]);
  }
}

static void constructor_5184( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::map<unsigned int,unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::map<unsigned int,unsigned int>*)arg[0]);
}

static  void operator_5185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,unsigned int>*)o)->operator=)(*(const ::std::map<unsigned int,unsigned int>*)arg[0]);
  else   (((::std::map<unsigned int,unsigned int>*)o)->operator=)(*(const ::std::map<unsigned int,unsigned int>*)arg[0]);
}

static  void method_5186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->get_allocator)();
}

static  void method_5187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->begin)());
  else   (((::std::map<unsigned int,unsigned int>*)o)->begin)();
}

static  void method_5188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->begin)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->begin)();
}

static  void method_5189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->end)());
  else   (((::std::map<unsigned int,unsigned int>*)o)->end)();
}

static  void method_5190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->end)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->end)();
}

static  void method_5195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,unsigned int>*)o)->empty)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->empty)();
}

static  void method_5196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,unsigned int>*)o)->size)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->size)();
}

static  void method_5197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,unsigned int>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->max_size)();
}

static  void operator_5198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,unsigned int>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,unsigned int>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_5199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,unsigned int>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,unsigned int>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_5200( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,unsigned int>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_5201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >,bool>)((((::std::map<unsigned int,unsigned int>*)o)->insert)(*(const ::std::pair<const unsigned int,unsigned int>*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->insert)(*(const ::std::pair<const unsigned int,unsigned int>*)arg[0]);
}

static  void method_5202( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >*)arg[0],
    *(const ::std::pair<const unsigned int,unsigned int>*)arg[1]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >*)arg[0],
    *(const ::std::pair<const unsigned int,unsigned int>*)arg[1]);
}

static  void method_5203( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,unsigned int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >*)arg[0]);
}

static  void method_5204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,unsigned int>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_5205( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,unsigned int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >*)arg[1]);
}

static  void method_5206( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,unsigned int>*)o)->swap)(*(::std::map<unsigned int,unsigned int>*)arg[0]);
}

static  void method_5207( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,unsigned int>*)o)->clear)();
}

static  void method_5208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,unsigned int>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->key_comp)();
}

static  void method_5210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_5211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_5212( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,unsigned int>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_5213( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5215( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_5217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >,std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> > >)((((::std::map<unsigned int,unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_5218( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> > >)((((const ::std::map<unsigned int,unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1733( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,unsigned int> >::Generate();
}

//------Dictionary for class map<unsigned int,unsigned int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, unsigned int> > > -------------------------------
void __std__map_unsignedsint_unsignedsint__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_unsignedsint__datamem_bld(&__std__map_unsignedsint_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_unsignedsint__funcmem_bld(&__std__map_unsignedsint_unsignedsint__db_funcmem);
void __std__map_unsignedsint_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,unsigned int>"), typeid(::std::map<unsigned int,unsigned int>), sizeof(::std::map<unsigned int,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_278, Reflex::Literal("std::map<unsigned int,unsigned int>::key_type"))
  .AddTypedef(type_278, Reflex::Literal("std::map<unsigned int,unsigned int>::mapped_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,unsigned int>::value_type"))
  .AddTypedef(type_2289, Reflex::Literal("std::map<unsigned int,unsigned int>::key_compare"))
  .AddTypedef(type_2726, Reflex::Literal("std::map<unsigned int,unsigned int>::allocator_type"))
  .AddTypedef(type_2510, Reflex::Literal("std::map<unsigned int,unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_2726, Reflex::Literal("std::map<unsigned int,unsigned int>::_Pair_alloc_type"))
  .AddTypedef(type_2334, Reflex::Literal("std::map<unsigned int,unsigned int>::_Rep_type"))
  .AddTypedef(type_5167, Reflex::Literal("std::map<unsigned int,unsigned int>::pointer"))
  .AddTypedef(type_5169, Reflex::Literal("std::map<unsigned int,unsigned int>::const_pointer"))
  .AddTypedef(type_5171, Reflex::Literal("std::map<unsigned int,unsigned int>::reference"))
  .AddTypedef(type_5173, Reflex::Literal("std::map<unsigned int,unsigned int>::const_reference"))
  .AddTypedef(type_2591, Reflex::Literal("std::map<unsigned int,unsigned int>::iterator"))
  .AddTypedef(type_2401, Reflex::Literal("std::map<unsigned int,unsigned int>::const_iterator"))
  .AddTypedef(type_2687, Reflex::Literal("std::map<unsigned int,unsigned int>::size_type"))
  .AddTypedef(type_2618, Reflex::Literal("std::map<unsigned int,unsigned int>::difference_type"))
  .AddTypedef(type_2839, Reflex::Literal("std::map<unsigned int,unsigned int>::reverse_iterator"))
  .AddTypedef(type_2838, Reflex::Literal("std::map<unsigned int,unsigned int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_5181, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_5182, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15203, type_15204), Reflex::Literal("map"), constructor_5183, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15205), Reflex::Literal("map"), constructor_5184, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1733, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,unsigned int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, unsigned int> > > -------------------
void __std__map_unsignedsint_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2334, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_unsignedsint_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,unsigned int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, unsigned int> > > -------------------
void __std__map_unsignedsint_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15206, type_15205), Reflex::Literal("operator="), operator_5185, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2726), Reflex::Literal("get_allocator"), method_5186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2591), Reflex::Literal("begin"), method_5187, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2401), Reflex::Literal("begin"), method_5188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2591), Reflex::Literal("end"), method_5189, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2401), Reflex::Literal("end"), method_5190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_5195, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687), Reflex::Literal("size"), method_5196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687), Reflex::Literal("max_size"), method_5197, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9755, type_15207), Reflex::Literal("operator[]"), operator_5198, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9755, type_15207), Reflex::Literal("at"), method_5199, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15207, type_15207), Reflex::Literal("at"), method_5200, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2517, type_5173), Reflex::Literal("insert"), method_5201, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2591, type_2591, type_5173), Reflex::Literal("insert"), method_5202, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_2591), Reflex::Literal("erase"), method_5203, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687, type_15207), Reflex::Literal("erase"), method_5204, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_2591, type_2591), Reflex::Literal("erase"), method_5205, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_15206), Reflex::Literal("swap"), method_5206, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572), Reflex::Literal("clear"), method_5207, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2289), Reflex::Literal("key_comp"), method_5208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2591, type_15207), Reflex::Literal("find"), method_5210, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2401, type_15207), Reflex::Literal("find"), method_5211, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687, type_15207), Reflex::Literal("count"), method_5212, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2591, type_15207), Reflex::Literal("lower_bound"), method_5213, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2401, type_15207), Reflex::Literal("lower_bound"), method_5214, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2591, type_15207), Reflex::Literal("upper_bound"), method_5215, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2401, type_15207), Reflex::Literal("upper_bound"), method_5216, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2516, type_15207), Reflex::Literal("equal_range"), method_5217, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2515, type_15207), Reflex::Literal("equal_range"), method_5218, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, unsigned int, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, unsigned int> > > > -------------------------------
static void constructor_12816( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,unsigned int> >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,unsigned int> >();
}

static void constructor_12817( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,unsigned int> >(*(::std::auto_ptr<std::map<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,unsigned int> >(*(::std::auto_ptr<std::map<unsigned int,unsigned int> >*)arg[0]);
}

static void destructor_12818(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->::edm::Wrapper<std::map<unsigned int,unsigned int> >::~Wrapper)();
}
static  void method_12819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->product)();
}

static  void operator_12820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->operator->)();
}

static  void method_12821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->productTypeInfo)();
}

static  void method_12822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->typeInfo)();
}

static void constructor_12823( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,unsigned int> >((::std::map<unsigned int,unsigned int>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,unsigned int> >((::std::map<unsigned int,unsigned int>*)arg[0]);
}

static  void method_12824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->getInterface)();
}

static  void method_12825( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12826( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12827( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->dynamicTypeInfo)();
}

static  void method_12829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->isPresent)();
}

static  void method_12830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,unsigned int> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3402( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, unsigned int, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, unsigned int> > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_unsignedsint_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_unsignedsint_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_unsignedsint_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,unsigned int> >"), typeid(::edm::Wrapper<std::map<unsigned int,unsigned int> >), sizeof(::edm::Wrapper<std::map<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<T2VfatInformation>")
  .AddTypedef(type_1733, Reflex::Literal("edm::Wrapper<std::map<unsigned int,unsigned int> >::value_type"))
  .AddTypedef(type_1733, Reflex::Literal("edm::Wrapper<std::map<unsigned int,unsigned int> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12816, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2375), Reflex::Literal("Wrapper"), constructor_12817, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12818, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18962), Reflex::Literal("Wrapper"), constructor_12823, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3402, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_unsignedsint_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, unsigned int, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, unsigned int> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1368, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_unsignedsint_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1733, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_unsignedsint_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, unsigned int, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, unsigned int> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18961), Reflex::Literal("product"), method_12819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18961), Reflex::Literal("operator->"), operator_12820, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("productTypeInfo"), method_12821, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("typeInfo"), method_12822, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18963), Reflex::Literal("getInterface"), method_12824, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_12905, type_17108, type_18886), Reflex::Literal("fillView"), method_12825, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_11622, type_271, type_6796), Reflex::Literal("setPtr"), method_12826, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_572, type_11622, type_17109, type_17108), Reflex::Literal("fillPtrVector"), method_12827, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("dynamicTypeInfo"), method_12828, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("isPresent"), method_12829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11622), Reflex::Literal("dynamicTypeInfo_"), method_12830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __T2DigiVfat_dict(); 
      __TotemDigiCollection_T2DetId_T2DigiVfat__dict(); 
      __std__pair_T2DetId_std__vector_T2DigiVfat_s__dict(); 
      __std__vector_T2DigiVfat__dict(); 
      __std__map_T2DetId_std__vector_T2DigiVfat_s__dict(); 
      __edm__Wrapper_std__pair_T2DetId_std__vector_T2DigiVfat_s_s__dict(); 
      __edm__Wrapper_TotemDigiCollection_T2DetId_T2DigiVfat_s__dict(); 
      __std__map_unsignedsint_unsignedsint__dict(); 
      __edm__Wrapper_std__map_unsignedsint_unsignedsint_s__dict(); 
    }
    ~Dictionaries() {
      type_205.Unload(); // class T2DigiVfat 
      type_1259.Unload(); // class TotemDigiCollection<T2DetId,T2DigiVfat> 
      type_2501.Unload(); // class std::pair<T2DetId,std::vector<T2DigiVfat> > 
      type_2534.Unload(); // class std::vector<T2DigiVfat> 
      type_2640.Unload(); // class std::map<T2DetId,std::vector<T2DigiVfat> > 
      type_3403.Unload(); // class edm::Wrapper<std::pair<T2DetId,std::vector<T2DigiVfat> > > 
      type_3404.Unload(); // class edm::Wrapper<TotemDigiCollection<T2DetId,T2DigiVfat> > 
      type_1733.Unload(); // class std::map<unsigned int,unsigned int> 
      type_3402.Unload(); // class edm::Wrapper<std::map<unsigned int,unsigned int> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
