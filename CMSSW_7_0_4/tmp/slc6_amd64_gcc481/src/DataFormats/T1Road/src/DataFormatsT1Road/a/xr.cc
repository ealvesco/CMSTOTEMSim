// Generated at Mon Jul 11 23:13:45 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/T1Road/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_62 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_714 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_859 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1503 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_106 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_188 = ::Reflex::TypeBuilder(Reflex::Literal("T1DetId"));
  ::Reflex::Type type_356 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_507 = ::Reflex::TypeBuilder(Reflex::Literal("T1RecHitGlobal"));
  ::Reflex::Type type_493 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3760 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_395 = ::Reflex::TypeBuilder(Reflex::Literal("CLHEP::HepSymMatrix"));
  ::Reflex::Type type_2688 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2689 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_1895 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T1RecHitGlobal>"));
  ::Reflex::Type type_466 = ::Reflex::TypeBuilder(Reflex::Literal("Point3DBase<float,GlobalTag>"));
  ::Reflex::Type type_3699 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<T1RecHitGlobal>"));
  ::Reflex::Type type_2509 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<T1RecHitGlobal>"));
  ::Reflex::Type type_2844 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<T1RecHitGlobal>"));
  ::Reflex::Type type_469 = ::Reflex::TypeBuilder(Reflex::Literal("DeepCopyPointer<CLHEP::HepSymMatrix>"));
  ::Reflex::Type type_365 = ::Reflex::TypeBuilder(Reflex::Literal("GlobalErrorBase<double,ErrorMatrixTag>"));
  ::Reflex::Type type_3708 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<T1RecHitGlobal>"));
  ::Reflex::Type type_2002 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >"));
  ::Reflex::Type type_3698 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<T1RecHitGlobal> >"));
  ::Reflex::Type type_2508 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<T1RecHitGlobal> >"));
  ::Reflex::Type type_2843 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<T1RecHitGlobal> >"));
  ::Reflex::Type type_3304 = ::Reflex::TypeBuilder(Reflex::Literal("GlobalErrorBase<double,ErrorMatrixTag>::NullMatrix"));
  ::Reflex::Type type_3707 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<T1RecHitGlobal> >"));
  ::Reflex::Type type_3535 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3697 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >"));
  ::Reflex::Type type_2507 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<std::vector<T1RecHitGlobal> > >"));
  ::Reflex::Type type_5760 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<T1RecHitGlobal> >"));
  ::Reflex::Type type_109 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >"));
  ::Reflex::Type type_2295 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T1RecHitGlobal,std::allocator<T1RecHitGlobal> >"));
  ::Reflex::Type type_3706 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<std::vector<T1RecHitGlobal> > >"));
  ::Reflex::Type type_5759 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::vector<T1RecHitGlobal> > >"));
  ::Reflex::Type type_5668 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >"));
  ::Reflex::Type type_5669 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const T1RecHitGlobal*,std::vector<T1RecHitGlobal> >"));
  ::Reflex::Type type_2294 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<T1RecHitGlobal>,std::allocator<std::vector<T1RecHitGlobal> > >"));
  ::Reflex::Type type_2927 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> > >"));
  ::Reflex::Type type_5666 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >"));
  ::Reflex::Type type_2926 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const T1RecHitGlobal*,std::vector<T1RecHitGlobal> > >"));
  ::Reflex::Type type_5667 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >"));
  ::Reflex::Type type_2925 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > > >"));
  ::Reflex::Type type_2924 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > > >"));
  ::Reflex::Type type_783 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GlobalError"), type_365);
  ::Reflex::Type type_1896 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T1Road"), type_1895);
  ::Reflex::Type type_2003 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T1RoadCollection"), type_2002);
  ::Reflex::Type type_1440 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Global3DPoint"), type_466);
  ::Reflex::Type type_559 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GlobalPoint"), type_1440);
  ::Reflex::Type type_5814 = ::Reflex::ReferenceBuilder(type_507);
  ::Reflex::Type type_507c = ::Reflex::ConstBuilder(type_507);
  ::Reflex::Type type_4833 = ::Reflex::ReferenceBuilder(type_507c);
  ::Reflex::Type type_559c = ::Reflex::ConstBuilder(type_559);
  ::Reflex::Type type_13375 = ::Reflex::ReferenceBuilder(type_559c);
  ::Reflex::Type type_783c = ::Reflex::ConstBuilder(type_783);
  ::Reflex::Type type_13376 = ::Reflex::ReferenceBuilder(type_783c);
  ::Reflex::Type type_188c = ::Reflex::ConstBuilder(type_188);
  ::Reflex::Type type_4834 = ::Reflex::ReferenceBuilder(type_188c);
  ::Reflex::Type type_5810 = ::Reflex::PointerBuilder(type_507);
  ::Reflex::Type type_5812 = ::Reflex::PointerBuilder(type_507c);
  ::Reflex::Type type_2831 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_356);
  ::Reflex::Type type_2759 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_62);
  ::Reflex::Type type_2844c = ::Reflex::ConstBuilder(type_2844);
  ::Reflex::Type type_15372 = ::Reflex::ReferenceBuilder(type_2844c);
  ::Reflex::Type type_1895c = ::Reflex::ConstBuilder(type_1895);
  ::Reflex::Type type_6147 = ::Reflex::ReferenceBuilder(type_1895c);
  ::Reflex::Type type_6145 = ::Reflex::ReferenceBuilder(type_1895);
  ::Reflex::Type type_493c = ::Reflex::ConstBuilder(type_493);
  ::Reflex::Type type_11791 = ::Reflex::ReferenceBuilder(type_493c);
  ::Reflex::Type type_3708c = ::Reflex::ConstBuilder(type_3708);
  ::Reflex::Type type_19335 = ::Reflex::PointerBuilder(type_3708c);
  ::Reflex::Type type_3760c = ::Reflex::ConstBuilder(type_3760);
  ::Reflex::Type type_13039 = ::Reflex::ReferenceBuilder(type_3760c);
  ::Reflex::Type type_17453 = ::Reflex::ReferenceBuilder(type_2688);
  ::Reflex::Type type_19234 = ::Reflex::ReferenceBuilder(type_3535);
  ::Reflex::Type type_714c = ::Reflex::ConstBuilder(type_714);
  ::Reflex::Type type_3195 = ::Reflex::PointerBuilder(type_714c);
  ::Reflex::Type type_7557 = ::Reflex::ReferenceBuilder(type_3195);
  ::Reflex::Type type_2689c = ::Reflex::ConstBuilder(type_2689);
  ::Reflex::Type type_17454 = ::Reflex::ReferenceBuilder(type_2689c);
  ::Reflex::Type type_11814 = ::Reflex::ReferenceBuilder(type_365);
  ::Reflex::Type type_365c = ::Reflex::ConstBuilder(type_365);
  ::Reflex::Type type_11815 = ::Reflex::ReferenceBuilder(type_365c);
  ::Reflex::Type type_3304c = ::Reflex::ConstBuilder(type_3304);
  ::Reflex::Type type_11816 = ::Reflex::ReferenceBuilder(type_3304c);
  ::Reflex::Type type_109c = ::Reflex::ConstBuilder(type_109);
  ::Reflex::Type type_11726 = ::Reflex::ReferenceBuilder(type_109c);
  ::Reflex::Type type_466c = ::Reflex::ConstBuilder(type_466);
  ::Reflex::Type type_11817 = ::Reflex::ReferenceBuilder(type_466c);
  ::Reflex::Type type_6141 = ::Reflex::PointerBuilder(type_1895);
  ::Reflex::Type type_6143 = ::Reflex::PointerBuilder(type_1895c);
  ::Reflex::Type type_2843c = ::Reflex::ConstBuilder(type_2843);
  ::Reflex::Type type_15401 = ::Reflex::ReferenceBuilder(type_2843c);
  ::Reflex::Type type_2002c = ::Reflex::ConstBuilder(type_2002);
  ::Reflex::Type type_15402 = ::Reflex::ReferenceBuilder(type_2002c);
  ::Reflex::Type type_15403 = ::Reflex::ReferenceBuilder(type_2002);
  ::Reflex::Type type_13354 = ::Reflex::PointerBuilder(type_395);
  ::Reflex::Type type_469c = ::Reflex::ConstBuilder(type_469);
  ::Reflex::Type type_13355 = ::Reflex::ReferenceBuilder(type_469c);
  ::Reflex::Type type_13356 = ::Reflex::ReferenceBuilder(type_469);
  ::Reflex::Type type_12800 = ::Reflex::ReferenceBuilder(type_395);
  ::Reflex::Type type_395c = ::Reflex::ConstBuilder(type_395);
  ::Reflex::Type type_12792 = ::Reflex::ReferenceBuilder(type_395c);
  ::Reflex::Type type_13357 = ::Reflex::PointerBuilder(type_395c);
  ::Reflex::Type type_19327 = ::Reflex::PointerBuilder(type_2002c);
  ::Reflex::Type type_19328 = ::Reflex::PointerBuilder(type_2002);
  ::Reflex::Type type_3706c = ::Reflex::ConstBuilder(type_3706);
  ::Reflex::Type type_19329 = ::Reflex::PointerBuilder(type_3706c);
  ::Reflex::Type type_3707c = ::Reflex::ConstBuilder(type_3707);
  ::Reflex::Type type_19332 = ::Reflex::PointerBuilder(type_3707c);
  ::Reflex::Type type_469f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("DeepCopyPointer<AlgebraicSymMatrix>"), type_469);
  ::Reflex::Type type_2002f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<T1Road>"), type_2002);
  ::Reflex::Type type_3697f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<T1RoadCollection>"), type_3697);
  ::Reflex::Type type_3698f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<T1Road>"), type_3698);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __T1RecHitGlobal
#undef __T1RecHitGlobal
#endif
class __T1RecHitGlobal {
  public:
  __T1RecHitGlobal();
  ::GlobalPoint theGlobalPosition;
  ::GlobalError theGlobalError;
  ::T1DetId theId;
};
#ifdef __std__vector_T1RecHitGlobal_
#undef __std__vector_T1RecHitGlobal_
#endif
class __std__vector_T1RecHitGlobal_ : protected ::std::_Vector_base<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > {
  public:
  __std__vector_T1RecHitGlobal_();
};
#ifdef __edm__Wrapper_T1RecHitGlobal_
#undef __edm__Wrapper_T1RecHitGlobal_
#endif
class __edm__Wrapper_T1RecHitGlobal_ {
  public:
  __edm__Wrapper_T1RecHitGlobal_();
  bool present;
  ::T1RecHitGlobal obj;
};
#ifdef __GlobalErrorBase_double_ErrorMatrixTag_
#undef __GlobalErrorBase_double_ErrorMatrixTag_
#endif
class __GlobalErrorBase_double_ErrorMatrixTag_ {
  public:
  __GlobalErrorBase_double_ErrorMatrixTag_();
  ::ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> > theCartesianError;
};
#ifdef __std__vector_std__vector_T1RecHitGlobal_s_
#undef __std__vector_std__vector_T1RecHitGlobal_s_
#endif
class __std__vector_std__vector_T1RecHitGlobal_s_ : protected ::std::_Vector_base<std::vector<T1RecHitGlobal>,std::allocator<std::vector<T1RecHitGlobal> > > {
  public:
  __std__vector_std__vector_T1RecHitGlobal_s_();
};
#ifdef __DeepCopyPointer_CLHEP__HepSymMatrix_
#undef __DeepCopyPointer_CLHEP__HepSymMatrix_
#endif
class __DeepCopyPointer_CLHEP__HepSymMatrix_ {
  public:
  __DeepCopyPointer_CLHEP__HepSymMatrix_();
  void* theData;
};
#ifdef __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s_
#undef __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s_
#endif
class __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s_ {
  public:
  __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s_();
  bool present;
  ::std::vector<std::vector<T1RecHitGlobal> > obj;
};
#ifdef __edm__Wrapper_std__vector_T1RecHitGlobal_s_
#undef __edm__Wrapper_std__vector_T1RecHitGlobal_s_
#endif
class __edm__Wrapper_std__vector_T1RecHitGlobal_s_ {
  public:
  __edm__Wrapper_std__vector_T1RecHitGlobal_s_();
  bool present;
  ::std::vector<T1RecHitGlobal> obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class T1RecHitGlobal -------------------------------
static  void operator_3952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T1RecHitGlobal*)o)->operator=)(*(const ::T1RecHitGlobal*)arg[0]);
  else   (((::T1RecHitGlobal*)o)->operator=)(*(const ::T1RecHitGlobal*)arg[0]);
}

static void constructor_3953( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1RecHitGlobal(*(const ::T1RecHitGlobal*)arg[0]);
  else ::new(mem) ::T1RecHitGlobal(*(const ::T1RecHitGlobal*)arg[0]);
}

static void constructor_3954( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1RecHitGlobal();
  else ::new(mem) ::T1RecHitGlobal();
}

static void constructor_3955( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1RecHitGlobal(*(const ::GlobalPoint*)arg[0],
      *(const ::GlobalError*)arg[1]);
  else ::new(mem) ::T1RecHitGlobal(*(const ::GlobalPoint*)arg[0],
      *(const ::GlobalError*)arg[1]);
}

static void constructor_3956( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1RecHitGlobal(*(const ::T1DetId*)arg[0],
      *(const ::GlobalPoint*)arg[1],
      *(const ::GlobalError*)arg[2]);
  else ::new(mem) ::T1RecHitGlobal(*(const ::T1DetId*)arg[0],
      *(const ::GlobalPoint*)arg[1],
      *(const ::GlobalError*)arg[2]);
}

static void destructor_3957(void*, void * o, const std::vector<void*>&, void *) {
(((::T1RecHitGlobal*)o)->::T1RecHitGlobal::~T1RecHitGlobal)();
}
static  void method_3958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::T1RecHitGlobal*)o)->clone)());
  else   (((const ::T1RecHitGlobal*)o)->clone)();
}

static  void method_3959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (GlobalPoint)((((const ::T1RecHitGlobal*)o)->GlobalPosition)());
  else   (((const ::T1RecHitGlobal*)o)->GlobalPosition)();
}

static  void method_3960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (GlobalError)((((const ::T1RecHitGlobal*)o)->GlobalPositionError)());
  else   (((const ::T1RecHitGlobal*)o)->GlobalPositionError)();
}

static  void method_3961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T1RecHitGlobal*)o)->Eta)(*(float*)arg[0],
    *(float*)arg[1],
    *(float*)arg[2]));
  else   (((const ::T1RecHitGlobal*)o)->Eta)(*(float*)arg[0],
    *(float*)arg[1],
    *(float*)arg[2]);
}

static  void method_3962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T1RecHitGlobal*)o)->Phi)(*(float*)arg[0],
    *(float*)arg[1]));
  else   (((const ::T1RecHitGlobal*)o)->Phi)(*(float*)arg[0],
    *(float*)arg[1]);
}

static  void method_3963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T1RecHitGlobal*)o)->eta)());
  else   (((const ::T1RecHitGlobal*)o)->eta)();
}

static  void method_3964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T1RecHitGlobal*)o)->phi)());
  else   (((const ::T1RecHitGlobal*)o)->phi)();
}

static  void method_3965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (T1DetId)((((const ::T1RecHitGlobal*)o)->Id)());
  else   (((const ::T1RecHitGlobal*)o)->Id)();
}

static void method_newdel_507( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T1RecHitGlobal >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T1RecHitGlobal >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T1RecHitGlobal >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T1RecHitGlobal >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T1RecHitGlobal >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T1RecHitGlobal -------------------------------
void __T1RecHitGlobal_db_datamem(Reflex::Class*);
void __T1RecHitGlobal_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T1RecHitGlobal_datamem_bld(&__T1RecHitGlobal_db_datamem);
Reflex::GenreflexMemberBuilder __T1RecHitGlobal_funcmem_bld(&__T1RecHitGlobal_db_funcmem);
void __T1RecHitGlobal_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T1RecHitGlobal"), typeid(::T1RecHitGlobal), sizeof(::T1RecHitGlobal), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5814, type_4833), Reflex::Literal("operator="), operator_3952, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4833), Reflex::Literal("T1RecHitGlobal"), constructor_3953, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T1RecHitGlobal"), constructor_3954, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13375, type_13376), Reflex::Literal("T1RecHitGlobal"), constructor_3955, 0, "pos;err", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4834, type_13375, type_13376), Reflex::Literal("T1RecHitGlobal"), constructor_3956, 0, "id;pos;err", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T1RecHitGlobal"), destructor_3957, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_507, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T1RecHitGlobal_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T1RecHitGlobal_funcmem_bld);
}

//------Delayed data member builder for class T1RecHitGlobal -------------------
void __T1RecHitGlobal_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_559, Reflex::Literal("theGlobalPosition"), OffsetOf(__shadow__::__T1RecHitGlobal, theGlobalPosition), ::Reflex::PRIVATE)
  .AddDataMember(type_783, Reflex::Literal("theGlobalError"), OffsetOf(__shadow__::__T1RecHitGlobal, theGlobalError), ::Reflex::PRIVATE)
  .AddDataMember(type_188, Reflex::Literal("theId"), OffsetOf(__shadow__::__T1RecHitGlobal, theId), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T1RecHitGlobal -------------------
void __T1RecHitGlobal_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5810), Reflex::Literal("clone"), method_3958, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_559), Reflex::Literal("GlobalPosition"), method_3959, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_783), Reflex::Literal("GlobalPositionError"), method_3960, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859, type_859, type_859, type_859), Reflex::Literal("Eta"), method_3961, 0, ";;", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859, type_859, type_859), Reflex::Literal("Phi"), method_3962, 0, ";", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("eta"), method_3963, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_859), Reflex::Literal("phi"), method_3964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_188), Reflex::Literal("Id"), method_3965, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > -------------------------------
static void constructor_5824( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>();
  else ::new(mem) ::std::vector<T1RecHitGlobal>();
}

static void constructor_5825( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>(*(const ::std::allocator<T1RecHitGlobal>*)arg[0]);
  else ::new(mem) ::std::vector<T1RecHitGlobal>(*(const ::std::allocator<T1RecHitGlobal>*)arg[0]);
}

static void constructor_5826( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0],
      *(const ::T1RecHitGlobal*)arg[1]);
  else ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0],
      *(const ::T1RecHitGlobal*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0],
      *(const ::T1RecHitGlobal*)arg[1],
      *(const ::std::allocator<T1RecHitGlobal>*)arg[2]);
  else ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0],
      *(const ::T1RecHitGlobal*)arg[1],
      *(const ::std::allocator<T1RecHitGlobal>*)arg[2]);
  }
}

static void constructor_5827( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>(*(const ::std::vector<T1RecHitGlobal>*)arg[0]);
  else ::new(mem) ::std::vector<T1RecHitGlobal>(*(const ::std::vector<T1RecHitGlobal>*)arg[0]);
}

static void destructor_5828(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<T1RecHitGlobal>*)o)->::std::vector<T1RecHitGlobal>::~vector)();
}
static  void operator_5829( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1RecHitGlobal>*)o)->operator=)(*(const ::std::vector<T1RecHitGlobal>*)arg[0]);
  else   (((::std::vector<T1RecHitGlobal>*)o)->operator=)(*(const ::std::vector<T1RecHitGlobal>*)arg[0]);
}

static  void method_5830( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::T1RecHitGlobal*)arg[1]);
}

static  void method_5831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((::std::vector<T1RecHitGlobal>*)o)->begin)());
  else   (((::std::vector<T1RecHitGlobal>*)o)->begin)();
}

static  void method_5832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((const ::std::vector<T1RecHitGlobal>*)o)->begin)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->begin)();
}

static  void method_5833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((::std::vector<T1RecHitGlobal>*)o)->end)());
  else   (((::std::vector<T1RecHitGlobal>*)o)->end)();
}

static  void method_5834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((const ::std::vector<T1RecHitGlobal>*)o)->end)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->end)();
}

static  void method_5839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1RecHitGlobal>*)o)->size)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->size)();
}

static  void method_5840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1RecHitGlobal>*)o)->max_size)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->max_size)();
}

static  void method_5841( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<T1RecHitGlobal>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<T1RecHitGlobal>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::T1RecHitGlobal*)arg[1]);
  }
}

static  void method_5842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1RecHitGlobal>*)o)->capacity)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->capacity)();
}

static  void method_5843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<T1RecHitGlobal>*)o)->empty)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->empty)();
}

static  void method_5844( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5845( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1RecHitGlobal>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T1RecHitGlobal>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1RecHitGlobal>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1RecHitGlobal>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T1RecHitGlobal>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1RecHitGlobal>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1RecHitGlobal>*)o)->front)();
  else   (((::std::vector<T1RecHitGlobal>*)o)->front)();
}

static  void method_5851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1RecHitGlobal>*)o)->front)();
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->front)();
}

static  void method_5852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1RecHitGlobal>*)o)->back)();
  else   (((::std::vector<T1RecHitGlobal>*)o)->back)();
}

static  void method_5853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1RecHitGlobal>*)o)->back)();
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->back)();
}

static  void method_5854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<T1RecHitGlobal>*)o)->data)());
  else   (((::std::vector<T1RecHitGlobal>*)o)->data)();
}

static  void method_5855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<T1RecHitGlobal>*)o)->data)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->data)();
}

static  void method_5856( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->push_back)(*(const ::T1RecHitGlobal*)arg[0]);
}

static  void method_5857( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->pop_back)();
}

static  void method_5858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((::std::vector<T1RecHitGlobal>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0],
    *(const ::T1RecHitGlobal*)arg[1]));
  else   (((::std::vector<T1RecHitGlobal>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0],
    *(const ::T1RecHitGlobal*)arg[1]);
}

static  void method_5859( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::T1RecHitGlobal*)arg[2]);
}

static  void method_5860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((::std::vector<T1RecHitGlobal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0]));
  else   (((::std::vector<T1RecHitGlobal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0]);
}

static  void method_5861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((::std::vector<T1RecHitGlobal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[1]));
  else   (((::std::vector<T1RecHitGlobal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[1]);
}

static  void method_5862( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->swap)(*(::std::vector<T1RecHitGlobal>*)arg[0]);
}

static  void method_5863( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->clear)();
}

static void method_newdel_1895( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<T1RecHitGlobal> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<T1RecHitGlobal> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<T1RecHitGlobal> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<T1RecHitGlobal> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<T1RecHitGlobal> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T1RecHitGlobal,std::allocator<T1RecHitGlobal> >")), ::Reflex::BaseOffset< ::std::vector<T1RecHitGlobal>,::std::_Vector_base<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<T1RecHitGlobal> >::Generate();
  else ::Reflex::Proxy< ::std::vector<T1RecHitGlobal> >::Generate();
}

//------Dictionary for class vector<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > -------------------------------
void __std__vector_T1RecHitGlobal__db_datamem(Reflex::Class*);
void __std__vector_T1RecHitGlobal__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_T1RecHitGlobal__datamem_bld(&__std__vector_T1RecHitGlobal__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_T1RecHitGlobal__funcmem_bld(&__std__vector_T1RecHitGlobal__db_funcmem);
void __std__vector_T1RecHitGlobal__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<T1RecHitGlobal>"), typeid(::std::vector<T1RecHitGlobal>), sizeof(::std::vector<T1RecHitGlobal>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2295, ::Reflex::BaseOffset< ::std::vector<T1RecHitGlobal>, ::std::_Vector_base<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_507, Reflex::Literal("std::vector<T1RecHitGlobal>::_Alloc_value_type"))
  .AddTypedef(type_2295, Reflex::Literal("std::vector<T1RecHitGlobal>::_Base"))
  .AddTypedef(type_2844, Reflex::Literal("std::vector<T1RecHitGlobal>::_Tp_alloc_type"))
  .AddTypedef(type_5760, Reflex::Literal("std::vector<T1RecHitGlobal>::_Alloc_traits"))
  .AddTypedef(type_507, Reflex::Literal("std::vector<T1RecHitGlobal>::value_type"))
  .AddTypedef(type_5810, Reflex::Literal("std::vector<T1RecHitGlobal>::pointer"))
  .AddTypedef(type_5812, Reflex::Literal("std::vector<T1RecHitGlobal>::const_pointer"))
  .AddTypedef(type_5814, Reflex::Literal("std::vector<T1RecHitGlobal>::reference"))
  .AddTypedef(type_4833, Reflex::Literal("std::vector<T1RecHitGlobal>::const_reference"))
  .AddTypedef(type_5668, Reflex::Literal("std::vector<T1RecHitGlobal>::iterator"))
  .AddTypedef(type_5669, Reflex::Literal("std::vector<T1RecHitGlobal>::const_iterator"))
  .AddTypedef(type_2926, Reflex::Literal("std::vector<T1RecHitGlobal>::const_reverse_iterator"))
  .AddTypedef(type_2927, Reflex::Literal("std::vector<T1RecHitGlobal>::reverse_iterator"))
  .AddTypedef(type_2831, Reflex::Literal("std::vector<T1RecHitGlobal>::size_type"))
  .AddTypedef(type_2759, Reflex::Literal("std::vector<T1RecHitGlobal>::difference_type"))
  .AddTypedef(type_2844, Reflex::Literal("std::vector<T1RecHitGlobal>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5824, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15372), Reflex::Literal("vector"), constructor_5825, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2831, type_4833, type_15372), Reflex::Literal("vector"), constructor_5826, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6147), Reflex::Literal("vector"), constructor_5827, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5828, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1895, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_T1RecHitGlobal__funcmem_bld);
}

//------Delayed data member builder for class vector<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > -------------------
void __std__vector_T1RecHitGlobal__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > -------------------
void __std__vector_T1RecHitGlobal__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6145, type_6147), Reflex::Literal("operator="), operator_5829, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_2831, type_4833), Reflex::Literal("assign"), method_5830, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5668), Reflex::Literal("begin"), method_5831, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5669), Reflex::Literal("begin"), method_5832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5668), Reflex::Literal("end"), method_5833, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5669), Reflex::Literal("end"), method_5834, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2831), Reflex::Literal("size"), method_5839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2831), Reflex::Literal("max_size"), method_5840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_2831, type_507), Reflex::Literal("resize"), method_5841, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2831), Reflex::Literal("capacity"), method_5842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1503), Reflex::Literal("empty"), method_5843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_2831), Reflex::Literal("reserve"), method_5844, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5814, type_2831), Reflex::Literal("operator[]"), operator_5845, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4833, type_2831), Reflex::Literal("operator[]"), operator_5846, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5814, type_2831), Reflex::Literal("at"), method_5848, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4833, type_2831), Reflex::Literal("at"), method_5849, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5814), Reflex::Literal("front"), method_5850, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4833), Reflex::Literal("front"), method_5851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5814), Reflex::Literal("back"), method_5852, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4833), Reflex::Literal("back"), method_5853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5810), Reflex::Literal("data"), method_5854, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5812), Reflex::Literal("data"), method_5855, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_4833), Reflex::Literal("push_back"), method_5856, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714), Reflex::Literal("pop_back"), method_5857, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5668, type_5668, type_4833), Reflex::Literal("insert"), method_5858, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_5668, type_2831, type_4833), Reflex::Literal("insert"), method_5859, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5668, type_5668), Reflex::Literal("erase"), method_5860, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5668, type_5668, type_5668), Reflex::Literal("erase"), method_5861, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_6145), Reflex::Literal("swap"), method_5862, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714), Reflex::Literal("clear"), method_5863, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<T1RecHitGlobal> -------------------------------
static void constructor_12992( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<T1RecHitGlobal>();
  else ::new(mem) ::edm::Wrapper<T1RecHitGlobal>();
}

static void constructor_12993( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<T1RecHitGlobal>(*(::std::auto_ptr<T1RecHitGlobal>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<T1RecHitGlobal>(*(::std::auto_ptr<T1RecHitGlobal>*)arg[0]);
}

static void destructor_12994(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<T1RecHitGlobal>*)o)->::edm::Wrapper<T1RecHitGlobal>::~Wrapper)();
}
static  void method_12995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<T1RecHitGlobal>*)o)->product)());
  else   (((const ::edm::Wrapper<T1RecHitGlobal>*)o)->product)();
}

static  void operator_12996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<T1RecHitGlobal>*)o)->operator->)());
  else   (((const ::edm::Wrapper<T1RecHitGlobal>*)o)->operator->)();
}

static  void method_12997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<T1RecHitGlobal>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<T1RecHitGlobal>*)o)->productTypeInfo)();
}

static  void method_12998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<T1RecHitGlobal>*)o)->typeInfo)();
  else   (((::edm::Wrapper<T1RecHitGlobal>*)o)->typeInfo)();
}

static void constructor_12999( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<T1RecHitGlobal>((::T1RecHitGlobal*)arg[0]);
  else ::new(mem) ::edm::Wrapper<T1RecHitGlobal>((::T1RecHitGlobal*)arg[0]);
}

static  void method_13000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<T1RecHitGlobal>*)o)->getInterface)());
  else   (((::edm::Wrapper<T1RecHitGlobal>*)o)->getInterface)();
}

static  void method_13001( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<T1RecHitGlobal>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13002( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<T1RecHitGlobal>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13003( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<T1RecHitGlobal>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<T1RecHitGlobal>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<T1RecHitGlobal>*)o)->dynamicTypeInfo)();
}

static  void method_13005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<T1RecHitGlobal>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<T1RecHitGlobal>*)o)->isPresent)();
}

static  void method_13006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<T1RecHitGlobal>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<T1RecHitGlobal>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3699( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T1RecHitGlobal> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T1RecHitGlobal> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T1RecHitGlobal> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T1RecHitGlobal> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T1RecHitGlobal> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<T1RecHitGlobal> -------------------------------
void __edm__Wrapper_T1RecHitGlobal__db_datamem(Reflex::Class*);
void __edm__Wrapper_T1RecHitGlobal__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_T1RecHitGlobal__datamem_bld(&__edm__Wrapper_T1RecHitGlobal__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_T1RecHitGlobal__funcmem_bld(&__edm__Wrapper_T1RecHitGlobal__db_funcmem);
void __edm__Wrapper_T1RecHitGlobal__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<T1RecHitGlobal>"), typeid(::edm::Wrapper<T1RecHitGlobal>), sizeof(::edm::Wrapper<T1RecHitGlobal>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_507, Reflex::Literal("edm::Wrapper<T1RecHitGlobal>::value_type"))
  .AddTypedef(type_507, Reflex::Literal("edm::Wrapper<T1RecHitGlobal>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12992, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2509), Reflex::Literal("Wrapper"), constructor_12993, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12994, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5810), Reflex::Literal("Wrapper"), constructor_12999, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3699, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_T1RecHitGlobal__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_T1RecHitGlobal__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<T1RecHitGlobal> -------------------
void __edm__Wrapper_T1RecHitGlobal__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1503, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_T1RecHitGlobal_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_507, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_T1RecHitGlobal_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<T1RecHitGlobal> -------------------
void __edm__Wrapper_T1RecHitGlobal__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5812), Reflex::Literal("product"), method_12995, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5812), Reflex::Literal("operator->"), operator_12996, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("productTypeInfo"), method_12997, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("typeInfo"), method_12998, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19335), Reflex::Literal("getInterface"), method_13000, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_13039, type_17453, type_19234), Reflex::Literal("fillView"), method_13001, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_11791, type_356, type_7557), Reflex::Literal("setPtr"), method_13002, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_11791, type_17454, type_17453), Reflex::Literal("fillPtrVector"), method_13003, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("dynamicTypeInfo"), method_13004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1503), Reflex::Literal("isPresent"), method_13005, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("dynamicTypeInfo_"), method_13006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class GlobalErrorBase<double,ErrorMatrixTag> -------------------------------
static  void operator_3305( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GlobalErrorBase<double,ErrorMatrixTag>*)o)->operator=)(*(const ::GlobalErrorBase<double,ErrorMatrixTag>*)arg[0]);
  else   (((::GlobalErrorBase<double,ErrorMatrixTag>*)o)->operator=)(*(const ::GlobalErrorBase<double,ErrorMatrixTag>*)arg[0]);
}

static void constructor_3306( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GlobalErrorBase<double,ErrorMatrixTag>(*(const ::GlobalErrorBase<double,ErrorMatrixTag>*)arg[0]);
  else ::new(mem) ::GlobalErrorBase<double,ErrorMatrixTag>(*(const ::GlobalErrorBase<double,ErrorMatrixTag>*)arg[0]);
}

static void constructor_3307( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GlobalErrorBase<double,ErrorMatrixTag>();
  else ::new(mem) ::GlobalErrorBase<double,ErrorMatrixTag>();
}

static void constructor_3308( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GlobalErrorBase<double,ErrorMatrixTag>(*(const ::GlobalErrorBase<double,ErrorMatrixTag>::NullMatrix*)arg[0]);
  else ::new(mem) ::GlobalErrorBase<double,ErrorMatrixTag>(*(const ::GlobalErrorBase<double,ErrorMatrixTag>::NullMatrix*)arg[0]);
}

static void constructor_3309( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GlobalErrorBase<double,ErrorMatrixTag>(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]);
  else ::new(mem) ::GlobalErrorBase<double,ErrorMatrixTag>(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]);
}

static void constructor_3310( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GlobalErrorBase<double,ErrorMatrixTag>(*(const ::ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*)arg[0]);
  else ::new(mem) ::GlobalErrorBase<double,ErrorMatrixTag>(*(const ::ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >*)arg[0]);
}

static void destructor_3311(void*, void * o, const std::vector<void*>&, void *) {
(((::GlobalErrorBase<double,ErrorMatrixTag>*)o)->::GlobalErrorBase<double,ErrorMatrixTag>::~GlobalErrorBase)();
}
static  void method_3312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->cxx)());
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->cxx)();
}

static  void method_3313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->cyx)());
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->cyx)();
}

static  void method_3314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->cyy)());
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->cyy)();
}

static  void method_3315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->czx)());
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->czx)();
}

static  void method_3316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->czy)());
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->czy)();
}

static  void method_3317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->czz)());
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->czz)();
}

static  void method_3318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->matrix)();
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->matrix)();
}

static  void method_3319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->matrix_new)();
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->matrix_new)();
}

static  void method_3320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->rerr)(*(const ::Point3DBase<float,GlobalTag>*)arg[0]));
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->rerr)(*(const ::Point3DBase<float,GlobalTag>*)arg[0]);
}

static  void method_3321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->phierr)(*(const ::Point3DBase<float,GlobalTag>*)arg[0]));
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->phierr)(*(const ::Point3DBase<float,GlobalTag>*)arg[0]);
}

static  void operator_3322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (GlobalErrorBase<double,ErrorMatrixTag>)((((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->operator+)(*(const ::GlobalErrorBase<double,ErrorMatrixTag>*)arg[0]));
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->operator+)(*(const ::GlobalErrorBase<double,ErrorMatrixTag>*)arg[0]);
}

static  void operator_3323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (GlobalErrorBase<double,ErrorMatrixTag>)((((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->operator-)(*(const ::GlobalErrorBase<double,ErrorMatrixTag>*)arg[0]));
  else   (((const ::GlobalErrorBase<double,ErrorMatrixTag>*)o)->operator-)(*(const ::GlobalErrorBase<double,ErrorMatrixTag>*)arg[0]);
}

static void method_newdel_365( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GlobalErrorBase<double,ErrorMatrixTag> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GlobalErrorBase<double,ErrorMatrixTag> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GlobalErrorBase<double,ErrorMatrixTag> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GlobalErrorBase<double,ErrorMatrixTag> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GlobalErrorBase<double,ErrorMatrixTag> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GlobalErrorBase<double,ErrorMatrixTag> -------------------------------
void __GlobalErrorBase_double_ErrorMatrixTag__db_datamem(Reflex::Class*);
void __GlobalErrorBase_double_ErrorMatrixTag__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GlobalErrorBase_double_ErrorMatrixTag__datamem_bld(&__GlobalErrorBase_double_ErrorMatrixTag__db_datamem);
Reflex::GenreflexMemberBuilder __GlobalErrorBase_double_ErrorMatrixTag__funcmem_bld(&__GlobalErrorBase_double_ErrorMatrixTag__db_funcmem);
void __GlobalErrorBase_double_ErrorMatrixTag__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GlobalErrorBase<double,ErrorMatrixTag>"), typeid(::GlobalErrorBase<double,ErrorMatrixTag>), sizeof(::GlobalErrorBase<double,ErrorMatrixTag>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11814, type_11815), Reflex::Literal("operator="), operator_3305, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11815), Reflex::Literal("GlobalErrorBase"), constructor_3306, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GlobalErrorBase"), constructor_3307, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11816), Reflex::Literal("GlobalErrorBase"), constructor_3308, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_106, type_106, type_106, type_106, type_106, type_106), Reflex::Literal("GlobalErrorBase"), constructor_3309, 0, "c11;c21;c22;c31;c32;c33", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11726), Reflex::Literal("GlobalErrorBase"), constructor_3310, 0, "err", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GlobalErrorBase"), destructor_3311, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_365, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GlobalErrorBase_double_ErrorMatrixTag__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GlobalErrorBase_double_ErrorMatrixTag__funcmem_bld);
}

//------Delayed data member builder for class GlobalErrorBase<double,ErrorMatrixTag> -------------------
void __GlobalErrorBase_double_ErrorMatrixTag__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_109, Reflex::Literal("theCartesianError"), OffsetOf(__shadow__::__GlobalErrorBase_double_ErrorMatrixTag_, theCartesianError), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GlobalErrorBase<double,ErrorMatrixTag> -------------------
void __GlobalErrorBase_double_ErrorMatrixTag__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_106), Reflex::Literal("cxx"), method_3312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_106), Reflex::Literal("cyx"), method_3313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_106), Reflex::Literal("cyy"), method_3314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_106), Reflex::Literal("czx"), method_3315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_106), Reflex::Literal("czy"), method_3316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_106), Reflex::Literal("czz"), method_3317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11726), Reflex::Literal("matrix"), method_3318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11726), Reflex::Literal("matrix_new"), method_3319, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_106, type_11817), Reflex::Literal("rerr"), method_3320, 0, "aPoint", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_106, type_11817), Reflex::Literal("phierr"), method_3321, 0, "aPoint", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_365, type_11815), Reflex::Literal("operator+"), operator_3322, 0, "err", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_365, type_11815), Reflex::Literal("operator-"), operator_3323, 0, "err", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class vector<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> >,std::allocator<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > > -------------------------------
static void constructor_6156( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >();
  else ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >();
}

static void constructor_6157( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >(*(const ::std::allocator<std::vector<T1RecHitGlobal> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >(*(const ::std::allocator<std::vector<T1RecHitGlobal> >*)arg[0]);
}

static void constructor_6158( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<T1RecHitGlobal>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<T1RecHitGlobal>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<T1RecHitGlobal>*)arg[1],
      *(const ::std::allocator<std::vector<T1RecHitGlobal> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<T1RecHitGlobal>*)arg[1],
      *(const ::std::allocator<std::vector<T1RecHitGlobal> >*)arg[2]);
  }
}

static void constructor_6159( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >(*(const ::std::vector<std::vector<T1RecHitGlobal> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<T1RecHitGlobal> >(*(const ::std::vector<std::vector<T1RecHitGlobal> >*)arg[0]);
}

static void destructor_6160(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<T1RecHitGlobal> >*)o)->::std::vector<std::vector<T1RecHitGlobal> >::~vector)();
}
static  void operator_6161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<T1RecHitGlobal> >*)o)->operator=)(*(const ::std::vector<std::vector<T1RecHitGlobal> >*)arg[0]);
  else   (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->operator=)(*(const ::std::vector<std::vector<T1RecHitGlobal> >*)arg[0]);
}

static  void method_6162( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<T1RecHitGlobal>*)arg[1]);
}

static  void method_6163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >)((((::std::vector<std::vector<T1RecHitGlobal> >*)o)->begin)());
  else   (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->begin)();
}

static  void method_6164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >)((((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->begin)();
}

static  void method_6165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >)((((::std::vector<std::vector<T1RecHitGlobal> >*)o)->end)());
  else   (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->end)();
}

static  void method_6166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >)((((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->end)());
  else   (((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->end)();
}

static  void method_6171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->size)());
  else   (((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->size)();
}

static  void method_6172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->max_size)();
}

static  void method_6173( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<T1RecHitGlobal>*)arg[1]);
  }
}

static  void method_6174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->capacity)();
}

static  void method_6175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->empty)();
}

static  void method_6176( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<T1RecHitGlobal> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<T1RecHitGlobal> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<T1RecHitGlobal> >*)o)->front)();
  else   (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->front)();
}

static  void method_6183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->front)();
  else   (((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->front)();
}

static  void method_6184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<T1RecHitGlobal> >*)o)->back)();
  else   (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->back)();
}

static  void method_6185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->back)();
  else   (((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->back)();
}

static  void method_6186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<T1RecHitGlobal> >*)o)->data)());
  else   (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->data)();
}

static  void method_6187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->data)());
  else   (((const ::std::vector<std::vector<T1RecHitGlobal> >*)o)->data)();
}

static  void method_6188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->push_back)(*(const ::std::vector<T1RecHitGlobal>*)arg[0]);
}

static  void method_6189( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->pop_back)();
}

static  void method_6190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >)((((::std::vector<std::vector<T1RecHitGlobal> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >*)arg[0],
    *(const ::std::vector<T1RecHitGlobal>*)arg[1]));
  else   (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >*)arg[0],
    *(const ::std::vector<T1RecHitGlobal>*)arg[1]);
}

static  void method_6191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<T1RecHitGlobal>*)arg[2]);
}

static  void method_6192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >)((((::std::vector<std::vector<T1RecHitGlobal> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >*)arg[0]));
  else   (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >*)arg[0]);
}

static  void method_6193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >)((((::std::vector<std::vector<T1RecHitGlobal> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >*)arg[1]));
  else   (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<T1RecHitGlobal>*,std::vector<std::vector<T1RecHitGlobal> > >*)arg[1]);
}

static  void method_6194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->swap)(*(::std::vector<std::vector<T1RecHitGlobal> >*)arg[0]);
}

static  void method_6195( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<T1RecHitGlobal> >*)o)->clear)();
}

static void method_newdel_2002( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<T1RecHitGlobal> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<T1RecHitGlobal> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<T1RecHitGlobal> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<T1RecHitGlobal> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<T1RecHitGlobal> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<T1RecHitGlobal>,std::allocator<std::vector<T1RecHitGlobal> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<T1RecHitGlobal> >,::std::_Vector_base<std::vector<T1RecHitGlobal>,std::allocator<std::vector<T1RecHitGlobal> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<T1RecHitGlobal> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<T1RecHitGlobal> > >::Generate();
}

//------Dictionary for class vector<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> >,std::allocator<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > > -------------------------------
void __std__vector_std__vector_T1RecHitGlobal_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_T1RecHitGlobal_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_T1RecHitGlobal_s__datamem_bld(&__std__vector_std__vector_T1RecHitGlobal_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_T1RecHitGlobal_s__funcmem_bld(&__std__vector_std__vector_T1RecHitGlobal_s__db_funcmem);
void __std__vector_std__vector_T1RecHitGlobal_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >"), typeid(::std::vector<std::vector<T1RecHitGlobal> >), sizeof(::std::vector<std::vector<T1RecHitGlobal> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::vector<T1Road>")
  .AddBase(type_2294, ::Reflex::BaseOffset< ::std::vector<std::vector<T1RecHitGlobal> >, ::std::_Vector_base<std::vector<T1RecHitGlobal>,std::allocator<std::vector<T1RecHitGlobal> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1895, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::_Alloc_value_type"))
  .AddTypedef(type_2294, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::_Base"))
  .AddTypedef(type_2843, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::_Tp_alloc_type"))
  .AddTypedef(type_5759, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::_Alloc_traits"))
  .AddTypedef(type_1895, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::value_type"))
  .AddTypedef(type_6141, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::pointer"))
  .AddTypedef(type_6143, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::const_pointer"))
  .AddTypedef(type_6145, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::reference"))
  .AddTypedef(type_6147, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::const_reference"))
  .AddTypedef(type_5666, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::iterator"))
  .AddTypedef(type_5667, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::const_iterator"))
  .AddTypedef(type_2924, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::const_reverse_iterator"))
  .AddTypedef(type_2925, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::reverse_iterator"))
  .AddTypedef(type_2831, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::size_type"))
  .AddTypedef(type_2759, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::difference_type"))
  .AddTypedef(type_2843, Reflex::Literal("std::vector<std::vector<T1RecHitGlobal> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6156, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15401), Reflex::Literal("vector"), constructor_6157, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2831, type_6147, type_15401), Reflex::Literal("vector"), constructor_6158, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15402), Reflex::Literal("vector"), constructor_6159, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6160, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2002, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_T1RecHitGlobal_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> >,std::allocator<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > > -------------------
void __std__vector_std__vector_T1RecHitGlobal_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> >,std::allocator<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > > -------------------
void __std__vector_std__vector_T1RecHitGlobal_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15403, type_15402), Reflex::Literal("operator="), operator_6161, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_2831, type_6147), Reflex::Literal("assign"), method_6162, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5666), Reflex::Literal("begin"), method_6163, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5667), Reflex::Literal("begin"), method_6164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5666), Reflex::Literal("end"), method_6165, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5667), Reflex::Literal("end"), method_6166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2831), Reflex::Literal("size"), method_6171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2831), Reflex::Literal("max_size"), method_6172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_2831, type_1895), Reflex::Literal("resize"), method_6173, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2831), Reflex::Literal("capacity"), method_6174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1503), Reflex::Literal("empty"), method_6175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_2831), Reflex::Literal("reserve"), method_6176, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6145, type_2831), Reflex::Literal("operator[]"), operator_6177, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6147, type_2831), Reflex::Literal("operator[]"), operator_6178, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6145, type_2831), Reflex::Literal("at"), method_6180, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6147, type_2831), Reflex::Literal("at"), method_6181, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6145), Reflex::Literal("front"), method_6182, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6147), Reflex::Literal("front"), method_6183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6145), Reflex::Literal("back"), method_6184, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6147), Reflex::Literal("back"), method_6185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6141), Reflex::Literal("data"), method_6186, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6143), Reflex::Literal("data"), method_6187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_6147), Reflex::Literal("push_back"), method_6188, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714), Reflex::Literal("pop_back"), method_6189, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5666, type_5666, type_6147), Reflex::Literal("insert"), method_6190, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_5666, type_2831, type_6147), Reflex::Literal("insert"), method_6191, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5666, type_5666), Reflex::Literal("erase"), method_6192, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5666, type_5666, type_5666), Reflex::Literal("erase"), method_6193, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_15403), Reflex::Literal("swap"), method_6194, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714), Reflex::Literal("clear"), method_6195, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class DeepCopyPointer<CLHEP::HepSymMatrix> -------------------------------
static void destructor_3818(void*, void * o, const std::vector<void*>&, void *) {
(((::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->::DeepCopyPointer<CLHEP::HepSymMatrix>::~DeepCopyPointer)();
}
static void constructor_3819( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DeepCopyPointer<CLHEP::HepSymMatrix>();
  else ::new(mem) ::DeepCopyPointer<CLHEP::HepSymMatrix>();
}

static void constructor_3820( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DeepCopyPointer<CLHEP::HepSymMatrix>((::CLHEP::HepSymMatrix*)arg[0]);
  else ::new(mem) ::DeepCopyPointer<CLHEP::HepSymMatrix>((::CLHEP::HepSymMatrix*)arg[0]);
}

static void constructor_3821( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DeepCopyPointer<CLHEP::HepSymMatrix>(*(const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)arg[0]);
  else ::new(mem) ::DeepCopyPointer<CLHEP::HepSymMatrix>(*(const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)arg[0]);
}

static  void operator_3822( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator=)(*(const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)arg[0]);
  else   (((::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator=)(*(const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)arg[0]);
}

static  void method_3823( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->replaceWith)((::CLHEP::HepSymMatrix*)arg[0]);
}

static  void method_3824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->replaceInplace)());
  else   (((::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->replaceInplace)();
}

static  void operator_3825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator*)();
  else   (((::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator*)();
}

static  void operator_3826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator*)();
  else   (((const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator*)();
}

static  void operator_3827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator->)());
  else   (((::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator->)();
}

static  void operator_3828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator->)());
  else   (((const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator->)();
}

static  void converter_3829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator bool)());
  else   (((const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator bool)();
}

static  void operator_3830( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator==)((const ::CLHEP::HepSymMatrix*)arg[0]));
  else   (((const ::DeepCopyPointer<CLHEP::HepSymMatrix>*)o)->operator==)((const ::CLHEP::HepSymMatrix*)arg[0]);
}

static void method_newdel_469( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::DeepCopyPointer<CLHEP::HepSymMatrix> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::DeepCopyPointer<CLHEP::HepSymMatrix> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::DeepCopyPointer<CLHEP::HepSymMatrix> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::DeepCopyPointer<CLHEP::HepSymMatrix> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::DeepCopyPointer<CLHEP::HepSymMatrix> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DeepCopyPointer<CLHEP::HepSymMatrix> -------------------------------
void __DeepCopyPointer_CLHEP__HepSymMatrix__db_datamem(Reflex::Class*);
void __DeepCopyPointer_CLHEP__HepSymMatrix__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __DeepCopyPointer_CLHEP__HepSymMatrix__datamem_bld(&__DeepCopyPointer_CLHEP__HepSymMatrix__db_datamem);
Reflex::GenreflexMemberBuilder __DeepCopyPointer_CLHEP__HepSymMatrix__funcmem_bld(&__DeepCopyPointer_CLHEP__HepSymMatrix__db_funcmem);
void __DeepCopyPointer_CLHEP__HepSymMatrix__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("DeepCopyPointer<CLHEP::HepSymMatrix>"), typeid(::DeepCopyPointer<CLHEP::HepSymMatrix>), sizeof(::DeepCopyPointer<CLHEP::HepSymMatrix>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "DeepCopyPointer<AlgebraicSymMatrix>")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DeepCopyPointer"), destructor_3818, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DeepCopyPointer"), constructor_3819, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13354), Reflex::Literal("DeepCopyPointer"), constructor_3820, 0, "t", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13355), Reflex::Literal("DeepCopyPointer"), constructor_3821, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_469, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__DeepCopyPointer_CLHEP__HepSymMatrix__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__DeepCopyPointer_CLHEP__HepSymMatrix__funcmem_bld);
}

//------Delayed data member builder for class DeepCopyPointer<CLHEP::HepSymMatrix> -------------------
void __DeepCopyPointer_CLHEP__HepSymMatrix__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_13354, Reflex::Literal("theData"), OffsetOf(__shadow__::__DeepCopyPointer_CLHEP__HepSymMatrix_, theData), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class DeepCopyPointer<CLHEP::HepSymMatrix> -------------------
void __DeepCopyPointer_CLHEP__HepSymMatrix__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13356, type_13355), Reflex::Literal("operator="), operator_3822, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_13354), Reflex::Literal("replaceWith"), method_3823, 0, "otherP", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13354), Reflex::Literal("replaceInplace"), method_3824, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12800), Reflex::Literal("operator*"), operator_3825, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12792), Reflex::Literal("operator*"), operator_3826, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13354), Reflex::Literal("operator->"), operator_3827, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13357), Reflex::Literal("operator->"), operator_3828, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1503), Reflex::Literal("operator bool"), converter_3829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1503, type_13357), Reflex::Literal("operator=="), operator_3830, 0, "otherP", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> >, std::allocator<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > > > -------------------------------
static void constructor_12950( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >();
}

static void constructor_12951( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >(*(::std::auto_ptr<std::vector<std::vector<T1RecHitGlobal> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >(*(::std::auto_ptr<std::vector<std::vector<T1RecHitGlobal> > >*)arg[0]);
}

static void destructor_12952(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >::~Wrapper)();
}
static  void method_12953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->product)();
}

static  void operator_12954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->operator->)();
}

static  void method_12955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->productTypeInfo)();
}

static  void method_12956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->typeInfo)();
}

static void constructor_12957( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >((::std::vector<std::vector<T1RecHitGlobal> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >((::std::vector<std::vector<T1RecHitGlobal> >*)arg[0]);
}

static  void method_12958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->getInterface)();
}

static  void method_12959( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12960( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12961( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->dynamicTypeInfo)();
}

static  void method_12963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->isPresent)();
}

static  void method_12964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3697( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> >, std::allocator<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > > > -------------------------------
void __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__datamem_bld(&__edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__funcmem_bld(&__edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__db_funcmem);
void __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >"), typeid(::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >), sizeof(::edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<T1RoadCollection>")
  .AddTypedef(type_2002, Reflex::Literal("edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >::value_type"))
  .AddTypedef(type_2002, Reflex::Literal("edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12950, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2507), Reflex::Literal("Wrapper"), constructor_12951, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12952, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19328), Reflex::Literal("Wrapper"), constructor_12957, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3697, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> >, std::allocator<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > > > -------------------
void __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1503, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2002, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> >, std::allocator<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > > > -------------------
void __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19327), Reflex::Literal("product"), method_12953, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19327), Reflex::Literal("operator->"), operator_12954, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("productTypeInfo"), method_12955, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("typeInfo"), method_12956, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19329), Reflex::Literal("getInterface"), method_12958, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_13039, type_17453, type_19234), Reflex::Literal("fillView"), method_12959, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_11791, type_356, type_7557), Reflex::Literal("setPtr"), method_12960, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_11791, type_17454, type_17453), Reflex::Literal("fillPtrVector"), method_12961, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("dynamicTypeInfo"), method_12962, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1503), Reflex::Literal("isPresent"), method_12963, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("dynamicTypeInfo_"), method_12964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > -------------------------------
static void constructor_12971( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T1RecHitGlobal> >();
  else ::new(mem) ::edm::Wrapper<std::vector<T1RecHitGlobal> >();
}

static void constructor_12972( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T1RecHitGlobal> >(*(::std::auto_ptr<std::vector<T1RecHitGlobal> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<T1RecHitGlobal> >(*(::std::auto_ptr<std::vector<T1RecHitGlobal> >*)arg[0]);
}

static void destructor_12973(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->::edm::Wrapper<std::vector<T1RecHitGlobal> >::~Wrapper)();
}
static  void method_12974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->product)();
}

static  void operator_12975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->operator->)();
}

static  void method_12976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->productTypeInfo)();
}

static  void method_12977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->typeInfo)();
}

static void constructor_12978( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T1RecHitGlobal> >((::std::vector<T1RecHitGlobal>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<T1RecHitGlobal> >((::std::vector<T1RecHitGlobal>*)arg[0]);
}

static  void method_12979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->getInterface)();
}

static  void method_12980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12981( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12982( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->dynamicTypeInfo)();
}

static  void method_12984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->isPresent)();
}

static  void method_12985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<T1RecHitGlobal> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3698( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1RecHitGlobal> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1RecHitGlobal> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1RecHitGlobal> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1RecHitGlobal> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1RecHitGlobal> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > -------------------------------
void __edm__Wrapper_std__vector_T1RecHitGlobal_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_T1RecHitGlobal_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_T1RecHitGlobal_s__datamem_bld(&__edm__Wrapper_std__vector_T1RecHitGlobal_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_T1RecHitGlobal_s__funcmem_bld(&__edm__Wrapper_std__vector_T1RecHitGlobal_s__db_funcmem);
void __edm__Wrapper_std__vector_T1RecHitGlobal_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<T1RecHitGlobal> >"), typeid(::edm::Wrapper<std::vector<T1RecHitGlobal> >), sizeof(::edm::Wrapper<std::vector<T1RecHitGlobal> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<T1Road>")
  .AddTypedef(type_1895, Reflex::Literal("edm::Wrapper<std::vector<T1RecHitGlobal> >::value_type"))
  .AddTypedef(type_1895, Reflex::Literal("edm::Wrapper<std::vector<T1RecHitGlobal> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12971, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2508), Reflex::Literal("Wrapper"), constructor_12972, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12973, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6141), Reflex::Literal("Wrapper"), constructor_12978, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3698, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_T1RecHitGlobal_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_T1RecHitGlobal_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > -------------------
void __edm__Wrapper_std__vector_T1RecHitGlobal_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1503, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_T1RecHitGlobal_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1895, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_T1RecHitGlobal_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<T1RecHitGlobal, std::allocator<T1RecHitGlobal> > > -------------------
void __edm__Wrapper_std__vector_T1RecHitGlobal_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6143), Reflex::Literal("product"), method_12974, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6143), Reflex::Literal("operator->"), operator_12975, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("productTypeInfo"), method_12976, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("typeInfo"), method_12977, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19332), Reflex::Literal("getInterface"), method_12979, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_13039, type_17453, type_19234), Reflex::Literal("fillView"), method_12980, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_11791, type_356, type_7557), Reflex::Literal("setPtr"), method_12981, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_714, type_11791, type_17454, type_17453), Reflex::Literal("fillPtrVector"), method_12982, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("dynamicTypeInfo"), method_12983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1503), Reflex::Literal("isPresent"), method_12984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11791), Reflex::Literal("dynamicTypeInfo_"), method_12985, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __T1RecHitGlobal_dict(); 
      __std__vector_T1RecHitGlobal__dict(); 
      __edm__Wrapper_T1RecHitGlobal__dict(); 
      __GlobalErrorBase_double_ErrorMatrixTag__dict(); 
      __std__vector_std__vector_T1RecHitGlobal_s__dict(); 
      __DeepCopyPointer_CLHEP__HepSymMatrix__dict(); 
      __edm__Wrapper_std__vector_std__vector_T1RecHitGlobal_s_s__dict(); 
      __edm__Wrapper_std__vector_T1RecHitGlobal_s__dict(); 
    }
    ~Dictionaries() {
      type_507.Unload(); // class T1RecHitGlobal 
      type_1895.Unload(); // class std::vector<T1RecHitGlobal> 
      type_3699.Unload(); // class edm::Wrapper<T1RecHitGlobal> 
      type_365.Unload(); // class GlobalErrorBase<double,ErrorMatrixTag> 
      type_2002.Unload(); // class std::vector<std::vector<T1RecHitGlobal> > 
      type_469.Unload(); // class DeepCopyPointer<CLHEP::HepSymMatrix> 
      type_3697.Unload(); // class edm::Wrapper<std::vector<std::vector<T1RecHitGlobal> > > 
      type_3698.Unload(); // class edm::Wrapper<std::vector<T1RecHitGlobal> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
