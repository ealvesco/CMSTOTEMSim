// Generated at Mon Jul 11 23:11:29 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/TotemRPDataTypes/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("__gnu_cxx") );
  ::Reflex::Type type_67 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_61 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_584 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_97 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1368 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_379 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_2007 = ::Reflex::TypeBuilder(Reflex::Literal("RPRecoHit"));
  ::Reflex::Type type_3550 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Other"));
  ::Reflex::Type type_186 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_2071 = ::Reflex::TypeBuilder(Reflex::Literal("RPStripDigi"));
  ::Reflex::Type type_1150 = ::Reflex::TypeBuilder(Reflex::Literal("RPDetTrigger"));
  ::Reflex::Type type_1373 = ::Reflex::TypeBuilder(Reflex::Literal("RPDigCluster"));
  ::Reflex::Type type_269 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_190 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_395 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3572 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_3488 = ::Reflex::TypeBuilder(Reflex::Literal("edm::BoolCache"));
  ::Reflex::Type type_1474 = ::Reflex::TypeBuilder(Reflex::Literal("RPTimingDetectorHit"));
  ::Reflex::Type type_2545 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRecoHit>"));
  ::Reflex::Type type_3534 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DetSet<RPRecoHit>"));
  ::Reflex::Type type_2549 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPStripDigi>"));
  ::Reflex::Type type_3535 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DetSet<RPStripDigi>"));
  ::Reflex::Type type_2537 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2542 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPDigCluster>"));
  ::Reflex::Type type_3532 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DetSet<RPDigCluster>"));
  ::Reflex::Type type_2544 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPDetTrigger>"));
  ::Reflex::Type type_3533 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DetSet<RPDetTrigger>"));
  ::Reflex::Type type_2711 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRecoHit>"));
  ::Reflex::Type type_2541 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_2538 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_1561 = ::Reflex::TypeBuilder(Reflex::Literal("Point2DBase<float,LocalTag>"));
  ::Reflex::Type type_2715 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPStripDigi>"));
  ::Reflex::Type type_2708 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPDigCluster>"));
  ::Reflex::Type type_2710 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPDetTrigger>"));
  ::Reflex::Type type_3511 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DetSetVector<RPRecoHit>"));
  ::Reflex::Type type_2546 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const RPRecoHit*>"));
  ::Reflex::Type type_3512 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DetSetVector<RPStripDigi>"));
  ::Reflex::Type type_3509 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DetSetVector<RPDigCluster>"));
  ::Reflex::Type type_3510 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DetSetVector<RPDetTrigger>"));
  ::Reflex::Type type_2260 = ::Reflex::TypeBuilder(Reflex::Literal("std::random_access_iterator_tag"));
  ::Reflex::Type type_2539 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPTimingDetectorHit>"));
  ::Reflex::Type type_2712 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<const RPRecoHit*>"));
  ::Reflex::Type type_2705 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPTimingDetectorHit>"));
  ::Reflex::Type type_3538 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase"));
  ::Reflex::Type type_2547 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >"));
  ::Reflex::Type type_2548 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >"));
  ::Reflex::Type type_2217 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const RPRecoHit*>"));
  ::Reflex::Type type_2540 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >"));
  ::Reflex::Type type_2543 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >"));
  ::Reflex::Type type_2713 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::DetSet<RPRecoHit> >"));
  ::Reflex::Type type_3460 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::DetSet<RPStripDigi> >"));
  ::Reflex::Type type_2391 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::DetSet<RPStripDigi> >"));
  ::Reflex::Type type_3457 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::DetSet<RPDetTrigger> >"));
  ::Reflex::Type type_2714 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::DetSet<RPStripDigi> >"));
  ::Reflex::Type type_2388 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::DetSet<RPDetTrigger> >"));
  ::Reflex::Type type_2706 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::DetSet<RPDigCluster> >"));
  ::Reflex::Type type_2709 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::DetSet<RPDetTrigger> >"));
  ::Reflex::Type type_3458 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPRecoHit> >"));
  ::Reflex::Type type_2389 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::DetSetVector<RPRecoHit> >"));
  ::Reflex::Type type_3459 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPStripDigi> >"));
  ::Reflex::Type type_2390 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::DetSetVector<RPStripDigi> >"));
  ::Reflex::Type type_3455 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPDigCluster> >"));
  ::Reflex::Type type_3456 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPDetTrigger> >"));
  ::Reflex::Type type_2386 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::DetSetVector<RPDigCluster> >"));
  ::Reflex::Type type_2387 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::DetSetVector<RPDetTrigger> >"));
  ::Reflex::Type type_3454 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPTimingDetectorHit> >"));
  ::Reflex::Type type_2385 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<RPTimingDetectorHit> >"));
  ::Reflex::Type type_3497 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::DetSet<RPStripDigi> >"));
  ::Reflex::Type type_3494 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::DetSet<RPDetTrigger> >"));
  ::Reflex::Type type_3495 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::DetSetVector<RPRecoHit> >"));
  ::Reflex::Type type_5323 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRecoHit> >"));
  ::Reflex::Type type_3346 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3496 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::DetSetVector<RPStripDigi> >"));
  ::Reflex::Type type_2185 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRecoHit,std::allocator<RPRecoHit> >"));
  ::Reflex::Type type_5325 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPStripDigi> >"));
  ::Reflex::Type type_3492 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::DetSetVector<RPDigCluster> >"));
  ::Reflex::Type type_3493 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::DetSetVector<RPDetTrigger> >"));
  ::Reflex::Type type_5318 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPDigCluster> >"));
  ::Reflex::Type type_5320 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPDetTrigger> >"));
  ::Reflex::Type type_3491 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<RPTimingDetectorHit> >"));
  ::Reflex::Type type_2187 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPStripDigi,std::allocator<RPStripDigi> >"));
  ::Reflex::Type type_5321 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<const RPRecoHit*> >"));
  ::Reflex::Type type_2180 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPDigCluster,std::allocator<RPDigCluster> >"));
  ::Reflex::Type type_2182 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPDetTrigger,std::allocator<RPDetTrigger> >"));
  ::Reflex::Type type_5316 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPTimingDetectorHit> >"));
  ::Reflex::Type type_5247 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >"));
  ::Reflex::Type type_5322 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<edm::DetSet<RPRecoHit> > >"));
  ::Reflex::Type type_5250 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >"));
  ::Reflex::Type type_2183 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const RPRecoHit*,std::allocator<const RPRecoHit*> >"));
  ::Reflex::Type type_5324 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<edm::DetSet<RPStripDigi> > >"));
  ::Reflex::Type type_5242 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >"));
  ::Reflex::Type type_5236 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >"));
  ::Reflex::Type type_5317 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<edm::DetSet<RPDigCluster> > >"));
  ::Reflex::Type type_5240 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >"));
  ::Reflex::Type type_5319 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<edm::DetSet<RPDetTrigger> > >"));
  ::Reflex::Type type_5251 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPStripDigi*,std::vector<RPStripDigi> >"));
  ::Reflex::Type type_2178 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPTimingDetectorHit,std::allocator<RPTimingDetectorHit> >"));
  ::Reflex::Type type_5237 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPDigCluster*,std::vector<RPDigCluster> >"));
  ::Reflex::Type type_5241 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPDetTrigger*,std::vector<RPDetTrigger> >"));
  ::Reflex::Type type_5243 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >"));
  ::Reflex::Type type_2184 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::DetSet<RPRecoHit>,std::allocator<edm::DetSet<RPRecoHit> > >"));
  ::Reflex::Type type_5232 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >"));
  ::Reflex::Type type_5244 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit* const*,std::vector<const RPRecoHit*> >"));
  ::Reflex::Type type_2186 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::DetSet<RPStripDigi>,std::allocator<edm::DetSet<RPStripDigi> > >"));
  ::Reflex::Type type_2179 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::DetSet<RPDigCluster>,std::allocator<edm::DetSet<RPDigCluster> > >"));
  ::Reflex::Type type_2181 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::DetSet<RPDetTrigger>,std::allocator<edm::DetSet<RPDetTrigger> > >"));
  ::Reflex::Type type_2816 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> > >"));
  ::Reflex::Type type_5233 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >"));
  ::Reflex::Type type_5245 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >"));
  ::Reflex::Type type_2820 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> > >"));
  ::Reflex::Type type_2806 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> > >"));
  ::Reflex::Type type_2810 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> > >"));
  ::Reflex::Type type_2815 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >"));
  ::Reflex::Type type_5248 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >"));
  ::Reflex::Type type_5234 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >"));
  ::Reflex::Type type_5238 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >"));
  ::Reflex::Type type_5246 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >"));
  ::Reflex::Type type_2819 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPStripDigi*,std::vector<RPStripDigi> > >"));
  ::Reflex::Type type_2805 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPDigCluster*,std::vector<RPDigCluster> > >"));
  ::Reflex::Type type_2809 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPDetTrigger*,std::vector<RPDetTrigger> > >"));
  ::Reflex::Type type_5249 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >"));
  ::Reflex::Type type_2812 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> > >"));
  ::Reflex::Type type_5235 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >"));
  ::Reflex::Type type_5239 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >"));
  ::Reflex::Type type_2802 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> > >"));
  ::Reflex::Type type_2811 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRecoHit* const*,std::vector<const RPRecoHit*> > >"));
  ::Reflex::Type type_2801 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> > >"));
  ::Reflex::Type type_2814 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > > >"));
  ::Reflex::Type type_2818 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > > >"));
  ::Reflex::Type type_2804 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > > >"));
  ::Reflex::Type type_2808 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > > >"));
  ::Reflex::Type type_2813 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > > >"));
  ::Reflex::Type type_2817 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > > >"));
  ::Reflex::Type type_2803 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > > >"));
  ::Reflex::Type type_2807 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > > >"));
  ::Reflex::Type type_2517 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >"));
  ::Reflex::Type type_13868 = ::Reflex::TypeBuilder(Reflex::Literal("boost::concepts::detail::instantiate<boost::concepts::requirement<boost::concepts::failed************ Model::************>::failed [with Model = boost::LessThanComparableConcept<RPRecoHit>]>"));
  ::Reflex::Type type_13903 = ::Reflex::TypeBuilder(Reflex::Literal("boost::concepts::detail::instantiate<boost::concepts::requirement<boost::concepts::failed************ Model::************>::failed [with Model = boost::LessThanComparableConcept<RPStripDigi>]>"));
  ::Reflex::Type type_13798 = ::Reflex::TypeBuilder(Reflex::Literal("boost::concepts::detail::instantiate<boost::concepts::requirement<boost::concepts::failed************ Model::************>::failed [with Model = boost::LessThanComparableConcept<RPDigCluster>]>"));
  ::Reflex::Type type_13833 = ::Reflex::TypeBuilder(Reflex::Literal("boost::concepts::detail::instantiate<boost::concepts::requirement<boost::concepts::failed************ Model::************>::failed [with Model = boost::LessThanComparableConcept<RPDetTrigger>]>"));
  ::Reflex::Type type_1326 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_186);
  ::Reflex::Type type_1785 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("RPDetId"), type_1326);
  ::Reflex::Type type_8714 = ::Reflex::ReferenceBuilder(type_1150);
  ::Reflex::Type type_1150c = ::Reflex::ConstBuilder(type_1150);
  ::Reflex::Type type_5783 = ::Reflex::ReferenceBuilder(type_1150c);
  ::Reflex::Type type_8585 = ::Reflex::ReferenceBuilder(type_1373);
  ::Reflex::Type type_1373c = ::Reflex::ConstBuilder(type_1373);
  ::Reflex::Type type_5782 = ::Reflex::ReferenceBuilder(type_1373c);
  ::Reflex::Type type_1562 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Local2DPoint"), type_1561);
  ::Reflex::Type type_8456 = ::Reflex::ReferenceBuilder(type_1474);
  ::Reflex::Type type_1474c = ::Reflex::ConstBuilder(type_1474);
  ::Reflex::Type type_5780 = ::Reflex::ReferenceBuilder(type_1474c);
  ::Reflex::Type type_1785c = ::Reflex::ConstBuilder(type_1785);
  ::Reflex::Type type_14750 = ::Reflex::ReferenceBuilder(type_1785c);
  ::Reflex::Type type_1562c = ::Reflex::ConstBuilder(type_1562);
  ::Reflex::Type type_14752 = ::Reflex::ReferenceBuilder(type_1562c);
  ::Reflex::Type type_8777 = ::Reflex::ReferenceBuilder(type_2007);
  ::Reflex::Type type_2007c = ::Reflex::ConstBuilder(type_2007);
  ::Reflex::Type type_5781 = ::Reflex::ReferenceBuilder(type_2007c);
  ::Reflex::Type type_6338 = ::Reflex::PointerBuilder(type_2007);
  ::Reflex::Type type_9036 = ::Reflex::ReferenceBuilder(type_2071);
  ::Reflex::Type type_2071c = ::Reflex::ConstBuilder(type_2071);
  ::Reflex::Type type_5784 = ::Reflex::ReferenceBuilder(type_2071c);
  ::Reflex::Type type_18550 = ::Reflex::ReferenceBuilder(type_2517);
  ::Reflex::Type type_2517c = ::Reflex::ConstBuilder(type_2517);
  ::Reflex::Type type_18551 = ::Reflex::ReferenceBuilder(type_2517c);
  ::Reflex::Type type_5242c = ::Reflex::ConstBuilder(type_5242);
  ::Reflex::Type type_18552 = ::Reflex::ReferenceBuilder(type_5242c);
  ::Reflex::Type type_6205 = ::Reflex::PointerBuilder(type_1474);
  ::Reflex::Type type_8454 = ::Reflex::PointerBuilder(type_1474c);
  ::Reflex::Type type_2691 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_269);
  ::Reflex::Type type_2625 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_61);
  ::Reflex::Type type_2705c = ::Reflex::ConstBuilder(type_2705);
  ::Reflex::Type type_17830 = ::Reflex::ReferenceBuilder(type_2705c);
  ::Reflex::Type type_2539c = ::Reflex::ConstBuilder(type_2539);
  ::Reflex::Type type_18564 = ::Reflex::ReferenceBuilder(type_2539c);
  ::Reflex::Type type_18565 = ::Reflex::ReferenceBuilder(type_2539);
  ::Reflex::Type type_3566 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::det_id_type"), type_1326);
  ::Reflex::Type type_8520 = ::Reflex::ReferenceBuilder(type_3532);
  ::Reflex::Type type_3532c = ::Reflex::ConstBuilder(type_3532);
  ::Reflex::Type type_8522 = ::Reflex::ReferenceBuilder(type_3532c);
  ::Reflex::Type type_1833 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_269);
  ::Reflex::Type type_6224 = ::Reflex::PointerBuilder(type_3532);
  ::Reflex::Type type_8518 = ::Reflex::PointerBuilder(type_3532c);
  ::Reflex::Type type_2706c = ::Reflex::ConstBuilder(type_2706);
  ::Reflex::Type type_17843 = ::Reflex::ReferenceBuilder(type_2706c);
  ::Reflex::Type type_2540c = ::Reflex::ConstBuilder(type_2540);
  ::Reflex::Type type_18567 = ::Reflex::ReferenceBuilder(type_2540c);
  ::Reflex::Type type_18568 = ::Reflex::ReferenceBuilder(type_2540);
  ::Reflex::Type type_6243 = ::Reflex::PointerBuilder(type_1373);
  ::Reflex::Type type_8583 = ::Reflex::PointerBuilder(type_1373c);
  ::Reflex::Type type_2708c = ::Reflex::ConstBuilder(type_2708);
  ::Reflex::Type type_17856 = ::Reflex::ReferenceBuilder(type_2708c);
  ::Reflex::Type type_2542c = ::Reflex::ConstBuilder(type_2542);
  ::Reflex::Type type_18569 = ::Reflex::ReferenceBuilder(type_2542c);
  ::Reflex::Type type_18570 = ::Reflex::ReferenceBuilder(type_2542);
  ::Reflex::Type type_8649 = ::Reflex::ReferenceBuilder(type_3533);
  ::Reflex::Type type_3533c = ::Reflex::ConstBuilder(type_3533);
  ::Reflex::Type type_8651 = ::Reflex::ReferenceBuilder(type_3533c);
  ::Reflex::Type type_6262 = ::Reflex::PointerBuilder(type_3533);
  ::Reflex::Type type_8647 = ::Reflex::PointerBuilder(type_3533c);
  ::Reflex::Type type_2709c = ::Reflex::ConstBuilder(type_2709);
  ::Reflex::Type type_17869 = ::Reflex::ReferenceBuilder(type_2709c);
  ::Reflex::Type type_2543c = ::Reflex::ConstBuilder(type_2543);
  ::Reflex::Type type_18572 = ::Reflex::ReferenceBuilder(type_2543c);
  ::Reflex::Type type_18573 = ::Reflex::ReferenceBuilder(type_2543);
  ::Reflex::Type type_6281 = ::Reflex::PointerBuilder(type_1150);
  ::Reflex::Type type_8712 = ::Reflex::PointerBuilder(type_1150c);
  ::Reflex::Type type_2710c = ::Reflex::ConstBuilder(type_2710);
  ::Reflex::Type type_17882 = ::Reflex::ReferenceBuilder(type_2710c);
  ::Reflex::Type type_2544c = ::Reflex::ConstBuilder(type_2544);
  ::Reflex::Type type_18574 = ::Reflex::ReferenceBuilder(type_2544c);
  ::Reflex::Type type_18575 = ::Reflex::ReferenceBuilder(type_2544);
  ::Reflex::Type type_6863 = ::Reflex::PointerBuilder(type_2007c);
  ::Reflex::Type type_2711c = ::Reflex::ConstBuilder(type_2711);
  ::Reflex::Type type_17921 = ::Reflex::ReferenceBuilder(type_2711c);
  ::Reflex::Type type_2545c = ::Reflex::ConstBuilder(type_2545);
  ::Reflex::Type type_18576 = ::Reflex::ReferenceBuilder(type_2545c);
  ::Reflex::Type type_18577 = ::Reflex::ReferenceBuilder(type_2545);
  ::Reflex::Type type_6300 = ::Reflex::PointerBuilder(type_6863);
  ::Reflex::Type type_6863c = ::Reflex::ConstBuilder(type_6863);
  ::Reflex::Type type_8839 = ::Reflex::PointerBuilder(type_6863c);
  ::Reflex::Type type_8841 = ::Reflex::ReferenceBuilder(type_6863);
  ::Reflex::Type type_8843 = ::Reflex::ReferenceBuilder(type_6863c);
  ::Reflex::Type type_2712c = ::Reflex::ConstBuilder(type_2712);
  ::Reflex::Type type_17895 = ::Reflex::ReferenceBuilder(type_2712c);
  ::Reflex::Type type_2546c = ::Reflex::ConstBuilder(type_2546);
  ::Reflex::Type type_18579 = ::Reflex::ReferenceBuilder(type_2546c);
  ::Reflex::Type type_18580 = ::Reflex::ReferenceBuilder(type_2546);
  ::Reflex::Type type_8906 = ::Reflex::ReferenceBuilder(type_3534);
  ::Reflex::Type type_3534c = ::Reflex::ConstBuilder(type_3534);
  ::Reflex::Type type_8908 = ::Reflex::ReferenceBuilder(type_3534c);
  ::Reflex::Type type_6319 = ::Reflex::PointerBuilder(type_3534);
  ::Reflex::Type type_8904 = ::Reflex::PointerBuilder(type_3534c);
  ::Reflex::Type type_2713c = ::Reflex::ConstBuilder(type_2713);
  ::Reflex::Type type_17908 = ::Reflex::ReferenceBuilder(type_2713c);
  ::Reflex::Type type_2547c = ::Reflex::ConstBuilder(type_2547);
  ::Reflex::Type type_18582 = ::Reflex::ReferenceBuilder(type_2547c);
  ::Reflex::Type type_18583 = ::Reflex::ReferenceBuilder(type_2547);
  ::Reflex::Type type_8971 = ::Reflex::ReferenceBuilder(type_3535);
  ::Reflex::Type type_3535c = ::Reflex::ConstBuilder(type_3535);
  ::Reflex::Type type_8973 = ::Reflex::ReferenceBuilder(type_3535c);
  ::Reflex::Type type_6357 = ::Reflex::PointerBuilder(type_3535);
  ::Reflex::Type type_8969 = ::Reflex::PointerBuilder(type_3535c);
  ::Reflex::Type type_2714c = ::Reflex::ConstBuilder(type_2714);
  ::Reflex::Type type_17934 = ::Reflex::ReferenceBuilder(type_2714c);
  ::Reflex::Type type_2548c = ::Reflex::ConstBuilder(type_2548);
  ::Reflex::Type type_18585 = ::Reflex::ReferenceBuilder(type_2548c);
  ::Reflex::Type type_18586 = ::Reflex::ReferenceBuilder(type_2548);
  ::Reflex::Type type_6376 = ::Reflex::PointerBuilder(type_2071);
  ::Reflex::Type type_9034 = ::Reflex::PointerBuilder(type_2071c);
  ::Reflex::Type type_2715c = ::Reflex::ConstBuilder(type_2715);
  ::Reflex::Type type_17947 = ::Reflex::ReferenceBuilder(type_2715c);
  ::Reflex::Type type_2549c = ::Reflex::ConstBuilder(type_2549);
  ::Reflex::Type type_18587 = ::Reflex::ReferenceBuilder(type_2549c);
  ::Reflex::Type type_18588 = ::Reflex::ReferenceBuilder(type_2549);
  ::Reflex::Type type_21086 = ::Reflex::PointerBuilder(type_2539c);
  ::Reflex::Type type_395c = ::Reflex::ConstBuilder(type_395);
  ::Reflex::Type type_11984 = ::Reflex::ReferenceBuilder(type_395c);
  ::Reflex::Type type_21087 = ::Reflex::PointerBuilder(type_2539);
  ::Reflex::Type type_3491c = ::Reflex::ConstBuilder(type_3491);
  ::Reflex::Type type_21088 = ::Reflex::PointerBuilder(type_3491c);
  ::Reflex::Type type_3572c = ::Reflex::ConstBuilder(type_3572);
  ::Reflex::Type type_13739 = ::Reflex::ReferenceBuilder(type_3572c);
  ::Reflex::Type type_18561 = ::Reflex::ReferenceBuilder(type_2537);
  ::Reflex::Type type_20960 = ::Reflex::ReferenceBuilder(type_3346);
  ::Reflex::Type type_584c = ::Reflex::ConstBuilder(type_584);
  ::Reflex::Type type_3024 = ::Reflex::PointerBuilder(type_584c);
  ::Reflex::Type type_7075 = ::Reflex::ReferenceBuilder(type_3024);
  ::Reflex::Type type_2538c = ::Reflex::ConstBuilder(type_2538);
  ::Reflex::Type type_18562 = ::Reflex::ReferenceBuilder(type_2538c);
  ::Reflex::Type type_3509c = ::Reflex::ConstBuilder(type_3509);
  ::Reflex::Type type_21146 = ::Reflex::ReferenceBuilder(type_3509c);
  ::Reflex::Type type_21147 = ::Reflex::ReferenceBuilder(type_3509);
  ::Reflex::Type type_10274 = ::Reflex::ReferenceBuilder(type_2541);
  ::Reflex::Type type_3539 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::helper_vector"), type_3538);
  ::Reflex::Type type_21148 = ::Reflex::ReferenceBuilder(type_3539);
  ::Reflex::Type type_21091 = ::Reflex::PointerBuilder(type_3509c);
  ::Reflex::Type type_21092 = ::Reflex::PointerBuilder(type_3509);
  ::Reflex::Type type_3492c = ::Reflex::ConstBuilder(type_3492);
  ::Reflex::Type type_21093 = ::Reflex::PointerBuilder(type_3492c);
  ::Reflex::Type type_3510c = ::Reflex::ConstBuilder(type_3510);
  ::Reflex::Type type_21149 = ::Reflex::ReferenceBuilder(type_3510c);
  ::Reflex::Type type_21150 = ::Reflex::ReferenceBuilder(type_3510);
  ::Reflex::Type type_21096 = ::Reflex::PointerBuilder(type_3510c);
  ::Reflex::Type type_21097 = ::Reflex::PointerBuilder(type_3510);
  ::Reflex::Type type_3493c = ::Reflex::ConstBuilder(type_3493);
  ::Reflex::Type type_21098 = ::Reflex::PointerBuilder(type_3493c);
  ::Reflex::Type type_3494c = ::Reflex::ConstBuilder(type_3494);
  ::Reflex::Type type_21101 = ::Reflex::PointerBuilder(type_3494c);
  ::Reflex::Type type_3511c = ::Reflex::ConstBuilder(type_3511);
  ::Reflex::Type type_21151 = ::Reflex::ReferenceBuilder(type_3511c);
  ::Reflex::Type type_21152 = ::Reflex::ReferenceBuilder(type_3511);
  ::Reflex::Type type_21104 = ::Reflex::PointerBuilder(type_3511c);
  ::Reflex::Type type_21105 = ::Reflex::PointerBuilder(type_3511);
  ::Reflex::Type type_3495c = ::Reflex::ConstBuilder(type_3495);
  ::Reflex::Type type_21106 = ::Reflex::PointerBuilder(type_3495c);
  ::Reflex::Type type_3512c = ::Reflex::ConstBuilder(type_3512);
  ::Reflex::Type type_21153 = ::Reflex::ReferenceBuilder(type_3512c);
  ::Reflex::Type type_21154 = ::Reflex::ReferenceBuilder(type_3512);
  ::Reflex::Type type_21109 = ::Reflex::PointerBuilder(type_3512c);
  ::Reflex::Type type_21110 = ::Reflex::PointerBuilder(type_3512);
  ::Reflex::Type type_3496c = ::Reflex::ConstBuilder(type_3496);
  ::Reflex::Type type_21111 = ::Reflex::PointerBuilder(type_3496c);
  ::Reflex::Type type_3497c = ::Reflex::ConstBuilder(type_3497);
  ::Reflex::Type type_21114 = ::Reflex::PointerBuilder(type_3497c);
  ::Reflex::Type type_21470 = ::Reflex::ReferenceBuilder(type_5242);
  ::Reflex::Type type_2625c = ::Reflex::ConstBuilder(type_2625);
  ::Reflex::Type type_21471 = ::Reflex::ReferenceBuilder(type_2625c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __RPDetTrigger
#undef __RPDetTrigger
#endif
class __RPDetTrigger {
  public:
  __RPDetTrigger();
  ::RPDetId det_id_;
  unsigned short sector_no_;
};
#ifdef __RPDigCluster
#undef __RPDigCluster
#endif
class __RPDigCluster {
  public:
  __RPDigCluster();
  ::RPDetId det_id_;
  unsigned short str_beg_;
  unsigned short str_end_;
};
#ifdef __RPTimingDetectorHit
#undef __RPTimingDetectorHit
#endif
class __RPTimingDetectorHit {
  public:
  __RPTimingDetectorHit();
  ::RPDetId det_id;
  unsigned short electrode_id;
  ::Local2DPoint position;
};
#ifdef __RPRecoHit
#undef __RPRecoHit
#endif
class __RPRecoHit {
  public:
  __RPRecoHit();
  ::RPDetId det_id_;
  double position_;
  double sigma_;
};
#ifdef __RPStripDigi
#undef __RPStripDigi
#endif
class __RPStripDigi {
  public:
  __RPStripDigi();
  ::RPDetId det_id_;
  unsigned short strip_no_;
};
#ifdef __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s_
#undef __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s_
#endif
struct __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s_ {
  public:
  __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s_();
  ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > first;
  ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > second;
};
#ifdef __std__vector_RPTimingDetectorHit_
#undef __std__vector_RPTimingDetectorHit_
#endif
class __std__vector_RPTimingDetectorHit_ : protected ::std::_Vector_base<RPTimingDetectorHit,std::allocator<RPTimingDetectorHit> > {
  public:
  __std__vector_RPTimingDetectorHit_();
};
#ifdef __edm__DetSet_RPDigCluster_
#undef __edm__DetSet_RPDigCluster_
#endif
struct __edm__DetSet_RPDigCluster_ {
  public:
  __edm__DetSet_RPDigCluster_();
  ::edm::det_id_type id;
  ::std::vector<RPDigCluster> data;
};
#ifdef __std__vector_edm__DetSet_RPDigCluster_s_
#undef __std__vector_edm__DetSet_RPDigCluster_s_
#endif
class __std__vector_edm__DetSet_RPDigCluster_s_ : protected ::std::_Vector_base<edm::DetSet<RPDigCluster>,std::allocator<edm::DetSet<RPDigCluster> > > {
  public:
  __std__vector_edm__DetSet_RPDigCluster_s_();
};
#ifdef __std__vector_RPDigCluster_
#undef __std__vector_RPDigCluster_
#endif
class __std__vector_RPDigCluster_ : protected ::std::_Vector_base<RPDigCluster,std::allocator<RPDigCluster> > {
  public:
  __std__vector_RPDigCluster_();
};
#ifdef __edm__DetSet_RPDetTrigger_
#undef __edm__DetSet_RPDetTrigger_
#endif
struct __edm__DetSet_RPDetTrigger_ {
  public:
  __edm__DetSet_RPDetTrigger_();
  ::edm::det_id_type id;
  ::std::vector<RPDetTrigger> data;
};
#ifdef __std__vector_edm__DetSet_RPDetTrigger_s_
#undef __std__vector_edm__DetSet_RPDetTrigger_s_
#endif
class __std__vector_edm__DetSet_RPDetTrigger_s_ : protected ::std::_Vector_base<edm::DetSet<RPDetTrigger>,std::allocator<edm::DetSet<RPDetTrigger> > > {
  public:
  __std__vector_edm__DetSet_RPDetTrigger_s_();
};
#ifdef __std__vector_RPDetTrigger_
#undef __std__vector_RPDetTrigger_
#endif
class __std__vector_RPDetTrigger_ : protected ::std::_Vector_base<RPDetTrigger,std::allocator<RPDetTrigger> > {
  public:
  __std__vector_RPDetTrigger_();
};
#ifdef __std__vector_RPRecoHit_
#undef __std__vector_RPRecoHit_
#endif
class __std__vector_RPRecoHit_ : protected ::std::_Vector_base<RPRecoHit,std::allocator<RPRecoHit> > {
  public:
  __std__vector_RPRecoHit_();
};
#ifdef __std__vector_constsRPRecoHitp_
#undef __std__vector_constsRPRecoHitp_
#endif
class __std__vector_constsRPRecoHitp_ : protected ::std::_Vector_base<const RPRecoHit*,std::allocator<const RPRecoHit*> > {
  public:
  __std__vector_constsRPRecoHitp_();
};
#ifdef __edm__DetSet_RPRecoHit_
#undef __edm__DetSet_RPRecoHit_
#endif
struct __edm__DetSet_RPRecoHit_ {
  public:
  __edm__DetSet_RPRecoHit_();
  ::edm::det_id_type id;
  ::std::vector<RPRecoHit> data;
};
#ifdef __std__vector_edm__DetSet_RPRecoHit_s_
#undef __std__vector_edm__DetSet_RPRecoHit_s_
#endif
class __std__vector_edm__DetSet_RPRecoHit_s_ : protected ::std::_Vector_base<edm::DetSet<RPRecoHit>,std::allocator<edm::DetSet<RPRecoHit> > > {
  public:
  __std__vector_edm__DetSet_RPRecoHit_s_();
};
#ifdef __edm__DetSet_RPStripDigi_
#undef __edm__DetSet_RPStripDigi_
#endif
struct __edm__DetSet_RPStripDigi_ {
  public:
  __edm__DetSet_RPStripDigi_();
  ::edm::det_id_type id;
  ::std::vector<RPStripDigi> data;
};
#ifdef __std__vector_edm__DetSet_RPStripDigi_s_
#undef __std__vector_edm__DetSet_RPStripDigi_s_
#endif
class __std__vector_edm__DetSet_RPStripDigi_s_ : protected ::std::_Vector_base<edm::DetSet<RPStripDigi>,std::allocator<edm::DetSet<RPStripDigi> > > {
  public:
  __std__vector_edm__DetSet_RPStripDigi_s_();
};
#ifdef __std__vector_RPStripDigi_
#undef __std__vector_RPStripDigi_
#endif
class __std__vector_RPStripDigi_ : protected ::std::_Vector_base<RPStripDigi,std::allocator<RPStripDigi> > {
  public:
  __std__vector_RPStripDigi_();
};
#ifdef __edm__Wrapper_std__vector_RPTimingDetectorHit_s_
#undef __edm__Wrapper_std__vector_RPTimingDetectorHit_s_
#endif
class __edm__Wrapper_std__vector_RPTimingDetectorHit_s_ {
  public:
  __edm__Wrapper_std__vector_RPTimingDetectorHit_s_();
  bool present;
  ::std::vector<RPTimingDetectorHit> obj;
};
#ifdef __edm__DetSetVector_RPDigCluster_
#undef __edm__DetSetVector_RPDigCluster_
#endif
class __edm__DetSetVector_RPDigCluster_ : public ::edm::Other {
  public:
  __edm__DetSetVector_RPDigCluster_();
  ::std::vector<edm::DetSet<RPDigCluster> > _sets;
  ::edm::BoolCache _alreadySorted;
};
#ifdef __edm__Wrapper_edm__DetSetVector_RPDigCluster_s_
#undef __edm__Wrapper_edm__DetSetVector_RPDigCluster_s_
#endif
class __edm__Wrapper_edm__DetSetVector_RPDigCluster_s_ {
  public:
  __edm__Wrapper_edm__DetSetVector_RPDigCluster_s_();
  bool present;
  ::edm::DetSetVector<RPDigCluster> obj;
};
#ifdef __edm__DetSetVector_RPDetTrigger_
#undef __edm__DetSetVector_RPDetTrigger_
#endif
class __edm__DetSetVector_RPDetTrigger_ : public ::edm::Other {
  public:
  __edm__DetSetVector_RPDetTrigger_();
  ::std::vector<edm::DetSet<RPDetTrigger> > _sets;
  ::edm::BoolCache _alreadySorted;
};
#ifdef __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s_
#undef __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s_
#endif
class __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s_ {
  public:
  __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s_();
  bool present;
  ::edm::DetSetVector<RPDetTrigger> obj;
};
#ifdef __edm__Wrapper_edm__DetSet_RPDetTrigger_s_
#undef __edm__Wrapper_edm__DetSet_RPDetTrigger_s_
#endif
class __edm__Wrapper_edm__DetSet_RPDetTrigger_s_ {
  public:
  __edm__Wrapper_edm__DetSet_RPDetTrigger_s_();
  bool present;
  ::edm::DetSet<RPDetTrigger> obj;
};
#ifdef __edm__DetSetVector_RPRecoHit_
#undef __edm__DetSetVector_RPRecoHit_
#endif
class __edm__DetSetVector_RPRecoHit_ : public ::edm::Other {
  public:
  __edm__DetSetVector_RPRecoHit_();
  ::std::vector<edm::DetSet<RPRecoHit> > _sets;
  ::edm::BoolCache _alreadySorted;
};
#ifdef __edm__Wrapper_edm__DetSetVector_RPRecoHit_s_
#undef __edm__Wrapper_edm__DetSetVector_RPRecoHit_s_
#endif
class __edm__Wrapper_edm__DetSetVector_RPRecoHit_s_ {
  public:
  __edm__Wrapper_edm__DetSetVector_RPRecoHit_s_();
  bool present;
  ::edm::DetSetVector<RPRecoHit> obj;
};
#ifdef __edm__DetSetVector_RPStripDigi_
#undef __edm__DetSetVector_RPStripDigi_
#endif
class __edm__DetSetVector_RPStripDigi_ : public ::edm::Other {
  public:
  __edm__DetSetVector_RPStripDigi_();
  ::std::vector<edm::DetSet<RPStripDigi> > _sets;
  ::edm::BoolCache _alreadySorted;
};
#ifdef __edm__Wrapper_edm__DetSetVector_RPStripDigi_s_
#undef __edm__Wrapper_edm__DetSetVector_RPStripDigi_s_
#endif
class __edm__Wrapper_edm__DetSetVector_RPStripDigi_s_ {
  public:
  __edm__Wrapper_edm__DetSetVector_RPStripDigi_s_();
  bool present;
  ::edm::DetSetVector<RPStripDigi> obj;
};
#ifdef __edm__Wrapper_edm__DetSet_RPStripDigi_s_
#undef __edm__Wrapper_edm__DetSet_RPStripDigi_s_
#endif
class __edm__Wrapper_edm__DetSet_RPStripDigi_s_ {
  public:
  __edm__Wrapper_edm__DetSet_RPStripDigi_s_();
  bool present;
  ::edm::DetSet<RPStripDigi> obj;
};
#ifdef ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_
#undef ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_
#endif
class ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_ {
  public:
  ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_();
  void* _M_current;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class RPDetTrigger -------------------------------
static void destructor_4618(void*, void * o, const std::vector<void*>&, void *) {
(((::RPDetTrigger*)o)->::RPDetTrigger::~RPDetTrigger)();
}
static  void operator_4619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPDetTrigger*)o)->operator=)(*(const ::RPDetTrigger*)arg[0]);
  else   (((::RPDetTrigger*)o)->operator=)(*(const ::RPDetTrigger*)arg[0]);
}

static void constructor_4620( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPDetTrigger(*(const ::RPDetTrigger*)arg[0]);
  else ::new(mem) ::RPDetTrigger(*(const ::RPDetTrigger*)arg[0]);
}

static void constructor_4621( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPDetTrigger();
  else ::new(mem) ::RPDetTrigger();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPDetTrigger(*(::RPDetId*)arg[0]);
  else ::new(mem) ::RPDetTrigger(*(::RPDetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPDetTrigger(*(::RPDetId*)arg[0],
      *(unsigned short*)arg[1]);
  else ::new(mem) ::RPDetTrigger(*(::RPDetId*)arg[0],
      *(unsigned short*)arg[1]);
  }
}

static  void method_4622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (RPDetId)((((const ::RPDetTrigger*)o)->GetDetId)());
  else   (((const ::RPDetTrigger*)o)->GetDetId)();
}

static  void method_4623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::RPDetTrigger*)o)->GetSector)());
  else   (((const ::RPDetTrigger*)o)->GetSector)();
}

static void constructor_x0( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPDetTrigger();
  else ::new(mem) ::RPDetTrigger();
}

static void method_newdel_1150( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPDetTrigger >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPDetTrigger >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPDetTrigger >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPDetTrigger >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPDetTrigger >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPDetTrigger -------------------------------
void __RPDetTrigger_db_datamem(Reflex::Class*);
void __RPDetTrigger_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPDetTrigger_datamem_bld(&__RPDetTrigger_db_datamem);
Reflex::GenreflexMemberBuilder __RPDetTrigger_funcmem_bld(&__RPDetTrigger_db_funcmem);
void __RPDetTrigger_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPDetTrigger"), typeid(::RPDetTrigger), sizeof(::RPDetTrigger), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPDetTrigger"), destructor_4618, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8714, type_5783), Reflex::Literal("operator="), operator_4619, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5783), Reflex::Literal("RPDetTrigger"), constructor_4620, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1785, type_190), Reflex::Literal("RPDetTrigger"), constructor_4621, 0, "det_id=0;sector_no=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPDetTrigger"), constructor_x0, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1150, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPDetTrigger_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPDetTrigger_funcmem_bld);
}

//------Delayed data member builder for class RPDetTrigger -------------------
void __RPDetTrigger_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1785, Reflex::Literal("det_id_"), OffsetOf(__shadow__::__RPDetTrigger, det_id_), ::Reflex::PRIVATE)
  .AddDataMember(type_190, Reflex::Literal("sector_no_"), OffsetOf(__shadow__::__RPDetTrigger, sector_no_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPDetTrigger -------------------
void __RPDetTrigger_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1785), Reflex::Literal("GetDetId"), method_4622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_190), Reflex::Literal("GetSector"), method_4623, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RPDigCluster -------------------------------
static void destructor_4678(void*, void * o, const std::vector<void*>&, void *) {
(((::RPDigCluster*)o)->::RPDigCluster::~RPDigCluster)();
}
static  void operator_4679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPDigCluster*)o)->operator=)(*(const ::RPDigCluster*)arg[0]);
  else   (((::RPDigCluster*)o)->operator=)(*(const ::RPDigCluster*)arg[0]);
}

static void constructor_4680( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPDigCluster(*(const ::RPDigCluster*)arg[0]);
  else ::new(mem) ::RPDigCluster(*(const ::RPDigCluster*)arg[0]);
}

static void constructor_4681( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPDigCluster(*(::RPDetId*)arg[0],
      *(unsigned short*)arg[1],
      *(unsigned short*)arg[2]);
  else ::new(mem) ::RPDigCluster(*(::RPDetId*)arg[0],
      *(unsigned short*)arg[1],
      *(unsigned short*)arg[2]);
}

static void constructor_4682( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPDigCluster();
  else ::new(mem) ::RPDigCluster();
}

static  void method_4683( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPDigCluster*)o)->DetId)(*(::RPDetId*)arg[0]);
}

static  void method_4684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (RPDetId)((((const ::RPDigCluster*)o)->DetId)());
  else   (((const ::RPDigCluster*)o)->DetId)();
}

static  void method_4685( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPDigCluster*)o)->StrBeg)(*(unsigned short*)arg[0]);
}

static  void method_4686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::RPDigCluster*)o)->StrBeg)());
  else   (((const ::RPDigCluster*)o)->StrBeg)();
}

static  void method_4687( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPDigCluster*)o)->StrEnd)(*(unsigned short*)arg[0]);
}

static  void method_4688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::RPDigCluster*)o)->StrEnd)());
  else   (((const ::RPDigCluster*)o)->StrEnd)();
}

static  void method_4689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::RPDigCluster*)o)->GetNumberOfStrips)());
  else   (((const ::RPDigCluster*)o)->GetNumberOfStrips)();
}

static  void method_4690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPDigCluster*)o)->CentreStripPos)());
  else   (((const ::RPDigCluster*)o)->CentreStripPos)();
}

static void method_newdel_1373( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPDigCluster >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPDigCluster >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPDigCluster >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPDigCluster >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPDigCluster >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPDigCluster -------------------------------
void __RPDigCluster_db_datamem(Reflex::Class*);
void __RPDigCluster_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPDigCluster_datamem_bld(&__RPDigCluster_db_datamem);
Reflex::GenreflexMemberBuilder __RPDigCluster_funcmem_bld(&__RPDigCluster_db_funcmem);
void __RPDigCluster_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPDigCluster"), typeid(::RPDigCluster), sizeof(::RPDigCluster), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPDigCluster"), destructor_4678, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8585, type_5782), Reflex::Literal("operator="), operator_4679, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5782), Reflex::Literal("RPDigCluster"), constructor_4680, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1785, type_190, type_190), Reflex::Literal("RPDigCluster"), constructor_4681, 0, "det_id;str_beg;str_end", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPDigCluster"), constructor_4682, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1373, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPDigCluster_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPDigCluster_funcmem_bld);
}

//------Delayed data member builder for class RPDigCluster -------------------
void __RPDigCluster_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1785, Reflex::Literal("det_id_"), OffsetOf(__shadow__::__RPDigCluster, det_id_), ::Reflex::PRIVATE)
  .AddDataMember(type_190, Reflex::Literal("str_beg_"), OffsetOf(__shadow__::__RPDigCluster, str_beg_), ::Reflex::PRIVATE)
  .AddDataMember(type_190, Reflex::Literal("str_end_"), OffsetOf(__shadow__::__RPDigCluster, str_end_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPDigCluster -------------------
void __RPDigCluster_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_1785), Reflex::Literal("DetId"), method_4683, 0, "det_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1785), Reflex::Literal("DetId"), method_4684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_190), Reflex::Literal("StrBeg"), method_4685, 0, "str_beg", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_190), Reflex::Literal("StrBeg"), method_4686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_190), Reflex::Literal("StrEnd"), method_4687, 0, "str_end", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_190), Reflex::Literal("StrEnd"), method_4688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_67), Reflex::Literal("GetNumberOfStrips"), method_4689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("CentreStripPos"), method_4690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RPTimingDetectorHit -------------------------------
static void destructor_4749(void*, void * o, const std::vector<void*>&, void *) {
(((::RPTimingDetectorHit*)o)->::RPTimingDetectorHit::~RPTimingDetectorHit)();
}
static  void operator_4750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPTimingDetectorHit*)o)->operator=)(*(const ::RPTimingDetectorHit*)arg[0]);
  else   (((::RPTimingDetectorHit*)o)->operator=)(*(const ::RPTimingDetectorHit*)arg[0]);
}

static void constructor_4751( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPTimingDetectorHit(*(const ::RPTimingDetectorHit*)arg[0]);
  else ::new(mem) ::RPTimingDetectorHit(*(const ::RPTimingDetectorHit*)arg[0]);
}

static void constructor_4752( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPTimingDetectorHit();
  else ::new(mem) ::RPTimingDetectorHit();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPTimingDetectorHit(*(const ::RPDetId*)arg[0]);
  else ::new(mem) ::RPTimingDetectorHit(*(const ::RPDetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPTimingDetectorHit(*(const ::RPDetId*)arg[0],
      *(unsigned short*)arg[1]);
  else ::new(mem) ::RPTimingDetectorHit(*(const ::RPDetId*)arg[0],
      *(unsigned short*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPTimingDetectorHit(*(const ::RPDetId*)arg[0],
      *(unsigned short*)arg[1],
      *(const ::Local2DPoint*)arg[2]);
  else ::new(mem) ::RPTimingDetectorHit(*(const ::RPDetId*)arg[0],
      *(unsigned short*)arg[1],
      *(const ::Local2DPoint*)arg[2]);
  }
}

static  void method_4753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (RPDetId)((((const ::RPTimingDetectorHit*)o)->GetDetId)());
  else   (((const ::RPTimingDetectorHit*)o)->GetDetId)();
}

static  void method_4754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::RPTimingDetectorHit*)o)->GetElectrodeId)());
  else   (((const ::RPTimingDetectorHit*)o)->GetElectrodeId)();
}

static  void method_4755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RPTimingDetectorHit*)o)->GetPosition)();
  else   (((const ::RPTimingDetectorHit*)o)->GetPosition)();
}

static void constructor_x3( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPTimingDetectorHit();
  else ::new(mem) ::RPTimingDetectorHit();
}

static void method_newdel_1474( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPTimingDetectorHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPTimingDetectorHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPTimingDetectorHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPTimingDetectorHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPTimingDetectorHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPTimingDetectorHit -------------------------------
void __RPTimingDetectorHit_db_datamem(Reflex::Class*);
void __RPTimingDetectorHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPTimingDetectorHit_datamem_bld(&__RPTimingDetectorHit_db_datamem);
Reflex::GenreflexMemberBuilder __RPTimingDetectorHit_funcmem_bld(&__RPTimingDetectorHit_db_funcmem);
void __RPTimingDetectorHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPTimingDetectorHit"), typeid(::RPTimingDetectorHit), sizeof(::RPTimingDetectorHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPTimingDetectorHit"), destructor_4749, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8456, type_5780), Reflex::Literal("operator="), operator_4750, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5780), Reflex::Literal("RPTimingDetectorHit"), constructor_4751, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14750, type_190, type_1562c), Reflex::Literal("RPTimingDetectorHit"), constructor_4752, 0, "det_id=0;electrode_id=0;position=Point2DBase<float, LocalTag>(((const float&)((const float*)(&0.0f))), ((const float&)((const float*)(&0.0f))))", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPTimingDetectorHit"), constructor_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1474, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPTimingDetectorHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPTimingDetectorHit_funcmem_bld);
}

//------Delayed data member builder for class RPTimingDetectorHit -------------------
void __RPTimingDetectorHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1785, Reflex::Literal("det_id"), OffsetOf(__shadow__::__RPTimingDetectorHit, det_id), ::Reflex::PRIVATE)
  .AddDataMember(type_190, Reflex::Literal("electrode_id"), OffsetOf(__shadow__::__RPTimingDetectorHit, electrode_id), ::Reflex::PRIVATE)
  .AddDataMember(type_1562, Reflex::Literal("position"), OffsetOf(__shadow__::__RPTimingDetectorHit, position), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPTimingDetectorHit -------------------
void __RPTimingDetectorHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1785), Reflex::Literal("GetDetId"), method_4753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_190), Reflex::Literal("GetElectrodeId"), method_4754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14752), Reflex::Literal("GetPosition"), method_4755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RPRecoHit -------------------------------
static void destructor_5788(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRecoHit*)o)->::RPRecoHit::~RPRecoHit)();
}
static  void operator_5789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRecoHit*)o)->operator=)(*(const ::RPRecoHit*)arg[0]);
  else   (((::RPRecoHit*)o)->operator=)(*(const ::RPRecoHit*)arg[0]);
}

static void constructor_5790( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecoHit(*(const ::RPRecoHit*)arg[0]);
  else ::new(mem) ::RPRecoHit(*(const ::RPRecoHit*)arg[0]);
}

static void constructor_5791( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecoHit(*(::RPDetId*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::RPRecoHit(*(::RPDetId*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
}

static void constructor_5792( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRecoHit();
  else ::new(mem) ::RPRecoHit();
}

static  void method_5793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPRecoHit*)o)->Position)());
  else   (((const ::RPRecoHit*)o)->Position)();
}

static  void method_5794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPRecoHit*)o)->Position)(*(double*)arg[0]);
}

static  void method_5795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPRecoHit*)o)->Sigma)());
  else   (((const ::RPRecoHit*)o)->Sigma)();
}

static  void method_5796( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPRecoHit*)o)->Sigma)(*(double*)arg[0]);
}

static  void method_5797( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPRecoHit*)o)->DetId)(*(::RPDetId*)arg[0]);
}

static  void method_5798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::RPRecoHit*)o)->DetId)());
  else   (((const ::RPRecoHit*)o)->DetId)();
}

static  void method_5799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RPRecoHit*)o)->clone)());
  else   (((const ::RPRecoHit*)o)->clone)();
}

static void method_newdel_2007( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRecoHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRecoHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRecoHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRecoHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRecoHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRecoHit -------------------------------
void __RPRecoHit_db_datamem(Reflex::Class*);
void __RPRecoHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRecoHit_datamem_bld(&__RPRecoHit_db_datamem);
Reflex::GenreflexMemberBuilder __RPRecoHit_funcmem_bld(&__RPRecoHit_db_funcmem);
void __RPRecoHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRecoHit"), typeid(::RPRecoHit), sizeof(::RPRecoHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRecoHit"), destructor_5788, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8777, type_5781), Reflex::Literal("operator="), operator_5789, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5781), Reflex::Literal("RPRecoHit"), constructor_5790, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1785, type_97, type_97), Reflex::Literal("RPRecoHit"), constructor_5791, 0, "det_id;position;sigma", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRecoHit"), constructor_5792, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2007, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRecoHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPRecoHit_funcmem_bld);
}

//------Delayed data member builder for class RPRecoHit -------------------
void __RPRecoHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1785, Reflex::Literal("det_id_"), OffsetOf(__shadow__::__RPRecoHit, det_id_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("position_"), OffsetOf(__shadow__::__RPRecoHit, position_), ::Reflex::PRIVATE)
  .AddDataMember(type_97, Reflex::Literal("sigma_"), OffsetOf(__shadow__::__RPRecoHit, sigma_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPRecoHit -------------------
void __RPRecoHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Position"), method_5793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_97), Reflex::Literal("Position"), method_5794, 0, "position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_97), Reflex::Literal("Sigma"), method_5795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_97), Reflex::Literal("Sigma"), method_5796, 0, "sigma", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_1785), Reflex::Literal("DetId"), method_5797, 0, "det_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_186), Reflex::Literal("DetId"), method_5798, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6338), Reflex::Literal("clone"), method_5799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RPStripDigi -------------------------------
static void destructor_5804(void*, void * o, const std::vector<void*>&, void *) {
(((::RPStripDigi*)o)->::RPStripDigi::~RPStripDigi)();
}
static  void operator_5805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPStripDigi*)o)->operator=)(*(const ::RPStripDigi*)arg[0]);
  else   (((::RPStripDigi*)o)->operator=)(*(const ::RPStripDigi*)arg[0]);
}

static void constructor_5806( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPStripDigi(*(const ::RPStripDigi*)arg[0]);
  else ::new(mem) ::RPStripDigi(*(const ::RPStripDigi*)arg[0]);
}

static void constructor_5807( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPStripDigi();
  else ::new(mem) ::RPStripDigi();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPStripDigi(*(::RPDetId*)arg[0]);
  else ::new(mem) ::RPStripDigi(*(::RPDetId*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPStripDigi(*(::RPDetId*)arg[0],
      *(unsigned short*)arg[1]);
  else ::new(mem) ::RPStripDigi(*(::RPDetId*)arg[0],
      *(unsigned short*)arg[1]);
  }
}

static  void method_5808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (RPDetId)((((const ::RPStripDigi*)o)->GetDetId)());
  else   (((const ::RPStripDigi*)o)->GetDetId)();
}

static  void method_5809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::RPStripDigi*)o)->GetStripNo)());
  else   (((const ::RPStripDigi*)o)->GetStripNo)();
}

static void constructor_x6( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPStripDigi();
  else ::new(mem) ::RPStripDigi();
}

static void method_newdel_2071( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPStripDigi >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPStripDigi >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPStripDigi >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPStripDigi >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPStripDigi >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPStripDigi -------------------------------
void __RPStripDigi_db_datamem(Reflex::Class*);
void __RPStripDigi_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPStripDigi_datamem_bld(&__RPStripDigi_db_datamem);
Reflex::GenreflexMemberBuilder __RPStripDigi_funcmem_bld(&__RPStripDigi_db_funcmem);
void __RPStripDigi_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPStripDigi"), typeid(::RPStripDigi), sizeof(::RPStripDigi), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPStripDigi"), destructor_5804, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9036, type_5784), Reflex::Literal("operator="), operator_5805, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5784), Reflex::Literal("RPStripDigi"), constructor_5806, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1785, type_190), Reflex::Literal("RPStripDigi"), constructor_5807, 0, "det_id=0;strip_no=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPStripDigi"), constructor_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2071, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPStripDigi_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPStripDigi_funcmem_bld);
}

//------Delayed data member builder for class RPStripDigi -------------------
void __RPStripDigi_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1785, Reflex::Literal("det_id_"), OffsetOf(__shadow__::__RPStripDigi, det_id_), ::Reflex::PRIVATE)
  .AddDataMember(type_190, Reflex::Literal("strip_no_"), OffsetOf(__shadow__::__RPStripDigi, strip_no_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPStripDigi -------------------
void __RPStripDigi_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1785), Reflex::Literal("GetDetId"), method_5808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_190), Reflex::Literal("GetStripNo"), method_5809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class pair<__gnu_cxx::__normal_iterator<const RPRecoHit*, std::vector<RPRecoHit, std::allocator<RPRecoHit> > >,__gnu_cxx::__normal_iterator<const RPRecoHit*, std::vector<RPRecoHit, std::allocator<RPRecoHit> > > > -------------------------------
static void destructor_8249(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >*)o)->::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >::~pair)();
}
static  void operator_8250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >*)o)->operator=)(*(const ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >*)arg[0]);
  else   (((::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >*)o)->operator=)(*(const ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >*)arg[0]);
}

static void constructor_8251( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >(*(const ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >*)arg[0]);
  else ::new(mem) ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >(*(const ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >*)arg[0]);
}

static void constructor_8252( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >();
  else ::new(mem) ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >();
}

static void constructor_8253( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >(*(const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)arg[1]);
  else ::new(mem) ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >(*(const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)arg[0],
      *(const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)arg[1]);
}

static void method_newdel_2517( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<__gnu_cxx::__normal_iterator<const RPRecoHit*, std::vector<RPRecoHit, std::allocator<RPRecoHit> > >,__gnu_cxx::__normal_iterator<const RPRecoHit*, std::vector<RPRecoHit, std::allocator<RPRecoHit> > > > -------------------------------
void __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s__db_datamem(Reflex::Class*);
void __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s__datamem_bld(&__std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s__funcmem_bld(&__std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s__db_funcmem);
void __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >"), typeid(::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >), sizeof(::std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_5242, Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >::first_type"))
  .AddTypedef(type_5242, Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_8249, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18550, type_18551), Reflex::Literal("operator="), operator_8250, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18551), Reflex::Literal("pair"), constructor_8251, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_8252, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18552, type_18552), Reflex::Literal("pair"), constructor_8253, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2517, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<__gnu_cxx::__normal_iterator<const RPRecoHit*, std::vector<RPRecoHit, std::allocator<RPRecoHit> > >,__gnu_cxx::__normal_iterator<const RPRecoHit*, std::vector<RPRecoHit, std::allocator<RPRecoHit> > > > -------------------
void __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5242, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_5242, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<__gnu_cxx::__normal_iterator<const RPRecoHit*, std::vector<RPRecoHit, std::allocator<RPRecoHit> > >,__gnu_cxx::__normal_iterator<const RPRecoHit*, std::vector<RPRecoHit, std::allocator<RPRecoHit> > > > -------------------
void __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<RPTimingDetectorHit,std::allocator<RPTimingDetectorHit> > -------------------------------
static void constructor_8466( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTimingDetectorHit>();
  else ::new(mem) ::std::vector<RPTimingDetectorHit>();
}

static void constructor_8467( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTimingDetectorHit>(*(const ::std::allocator<RPTimingDetectorHit>*)arg[0]);
  else ::new(mem) ::std::vector<RPTimingDetectorHit>(*(const ::std::allocator<RPTimingDetectorHit>*)arg[0]);
}

static void constructor_8468( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTimingDetectorHit>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPTimingDetectorHit>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTimingDetectorHit>(*(::std::size_t*)arg[0],
      *(const ::RPTimingDetectorHit*)arg[1]);
  else ::new(mem) ::std::vector<RPTimingDetectorHit>(*(::std::size_t*)arg[0],
      *(const ::RPTimingDetectorHit*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTimingDetectorHit>(*(::std::size_t*)arg[0],
      *(const ::RPTimingDetectorHit*)arg[1],
      *(const ::std::allocator<RPTimingDetectorHit>*)arg[2]);
  else ::new(mem) ::std::vector<RPTimingDetectorHit>(*(::std::size_t*)arg[0],
      *(const ::RPTimingDetectorHit*)arg[1],
      *(const ::std::allocator<RPTimingDetectorHit>*)arg[2]);
  }
}

static void constructor_8469( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPTimingDetectorHit>(*(const ::std::vector<RPTimingDetectorHit>*)arg[0]);
  else ::new(mem) ::std::vector<RPTimingDetectorHit>(*(const ::std::vector<RPTimingDetectorHit>*)arg[0]);
}

static void destructor_8470(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPTimingDetectorHit>*)o)->::std::vector<RPTimingDetectorHit>::~vector)();
}
static  void operator_8471( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPTimingDetectorHit>*)o)->operator=)(*(const ::std::vector<RPTimingDetectorHit>*)arg[0]);
  else   (((::std::vector<RPTimingDetectorHit>*)o)->operator=)(*(const ::std::vector<RPTimingDetectorHit>*)arg[0]);
}

static  void method_8472( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPTimingDetectorHit>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPTimingDetectorHit*)arg[1]);
}

static  void method_8473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >)((((::std::vector<RPTimingDetectorHit>*)o)->begin)());
  else   (((::std::vector<RPTimingDetectorHit>*)o)->begin)();
}

static  void method_8474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >)((((const ::std::vector<RPTimingDetectorHit>*)o)->begin)());
  else   (((const ::std::vector<RPTimingDetectorHit>*)o)->begin)();
}

static  void method_8475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >)((((::std::vector<RPTimingDetectorHit>*)o)->end)());
  else   (((::std::vector<RPTimingDetectorHit>*)o)->end)();
}

static  void method_8476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >)((((const ::std::vector<RPTimingDetectorHit>*)o)->end)());
  else   (((const ::std::vector<RPTimingDetectorHit>*)o)->end)();
}

static  void method_8481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPTimingDetectorHit>*)o)->size)());
  else   (((const ::std::vector<RPTimingDetectorHit>*)o)->size)();
}

static  void method_8482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPTimingDetectorHit>*)o)->max_size)());
  else   (((const ::std::vector<RPTimingDetectorHit>*)o)->max_size)();
}

static  void method_8483( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPTimingDetectorHit>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPTimingDetectorHit>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPTimingDetectorHit*)arg[1]);
  }
}

static  void method_8484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPTimingDetectorHit>*)o)->capacity)());
  else   (((const ::std::vector<RPTimingDetectorHit>*)o)->capacity)();
}

static  void method_8485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPTimingDetectorHit>*)o)->empty)());
  else   (((const ::std::vector<RPTimingDetectorHit>*)o)->empty)();
}

static  void method_8486( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPTimingDetectorHit>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPTimingDetectorHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPTimingDetectorHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPTimingDetectorHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPTimingDetectorHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8490( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPTimingDetectorHit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPTimingDetectorHit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPTimingDetectorHit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPTimingDetectorHit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPTimingDetectorHit>*)o)->front)();
  else   (((::std::vector<RPTimingDetectorHit>*)o)->front)();
}

static  void method_8493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPTimingDetectorHit>*)o)->front)();
  else   (((const ::std::vector<RPTimingDetectorHit>*)o)->front)();
}

static  void method_8494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPTimingDetectorHit>*)o)->back)();
  else   (((::std::vector<RPTimingDetectorHit>*)o)->back)();
}

static  void method_8495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPTimingDetectorHit>*)o)->back)();
  else   (((const ::std::vector<RPTimingDetectorHit>*)o)->back)();
}

static  void method_8496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPTimingDetectorHit>*)o)->data)());
  else   (((::std::vector<RPTimingDetectorHit>*)o)->data)();
}

static  void method_8497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPTimingDetectorHit>*)o)->data)());
  else   (((const ::std::vector<RPTimingDetectorHit>*)o)->data)();
}

static  void method_8498( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPTimingDetectorHit>*)o)->push_back)(*(const ::RPTimingDetectorHit*)arg[0]);
}

static  void method_8499( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPTimingDetectorHit>*)o)->pop_back)();
}

static  void method_8500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >)((((::std::vector<RPTimingDetectorHit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >*)arg[0],
    *(const ::RPTimingDetectorHit*)arg[1]));
  else   (((::std::vector<RPTimingDetectorHit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >*)arg[0],
    *(const ::RPTimingDetectorHit*)arg[1]);
}

static  void method_8501( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPTimingDetectorHit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPTimingDetectorHit*)arg[2]);
}

static  void method_8502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >)((((::std::vector<RPTimingDetectorHit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >*)arg[0]));
  else   (((::std::vector<RPTimingDetectorHit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >*)arg[0]);
}

static  void method_8503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >)((((::std::vector<RPTimingDetectorHit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >*)arg[1]));
  else   (((::std::vector<RPTimingDetectorHit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPTimingDetectorHit*,std::vector<RPTimingDetectorHit> >*)arg[1]);
}

static  void method_8504( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPTimingDetectorHit>*)o)->swap)(*(::std::vector<RPTimingDetectorHit>*)arg[0]);
}

static  void method_8505( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPTimingDetectorHit>*)o)->clear)();
}

static void method_newdel_2539( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPTimingDetectorHit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPTimingDetectorHit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPTimingDetectorHit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPTimingDetectorHit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPTimingDetectorHit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPTimingDetectorHit,std::allocator<RPTimingDetectorHit> >")), ::Reflex::BaseOffset< ::std::vector<RPTimingDetectorHit>,::std::_Vector_base<RPTimingDetectorHit,std::allocator<RPTimingDetectorHit> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPTimingDetectorHit> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPTimingDetectorHit> >::Generate();
}

//------Dictionary for class vector<RPTimingDetectorHit,std::allocator<RPTimingDetectorHit> > -------------------------------
void __std__vector_RPTimingDetectorHit__db_datamem(Reflex::Class*);
void __std__vector_RPTimingDetectorHit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPTimingDetectorHit__datamem_bld(&__std__vector_RPTimingDetectorHit__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPTimingDetectorHit__funcmem_bld(&__std__vector_RPTimingDetectorHit__db_funcmem);
void __std__vector_RPTimingDetectorHit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPTimingDetectorHit>"), typeid(::std::vector<RPTimingDetectorHit>), sizeof(::std::vector<RPTimingDetectorHit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2178, ::Reflex::BaseOffset< ::std::vector<RPTimingDetectorHit>, ::std::_Vector_base<RPTimingDetectorHit,std::allocator<RPTimingDetectorHit> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1474, Reflex::Literal("std::vector<RPTimingDetectorHit>::_Alloc_value_type"))
  .AddTypedef(type_2178, Reflex::Literal("std::vector<RPTimingDetectorHit>::_Base"))
  .AddTypedef(type_2705, Reflex::Literal("std::vector<RPTimingDetectorHit>::_Tp_alloc_type"))
  .AddTypedef(type_5316, Reflex::Literal("std::vector<RPTimingDetectorHit>::_Alloc_traits"))
  .AddTypedef(type_1474, Reflex::Literal("std::vector<RPTimingDetectorHit>::value_type"))
  .AddTypedef(type_6205, Reflex::Literal("std::vector<RPTimingDetectorHit>::pointer"))
  .AddTypedef(type_8454, Reflex::Literal("std::vector<RPTimingDetectorHit>::const_pointer"))
  .AddTypedef(type_8456, Reflex::Literal("std::vector<RPTimingDetectorHit>::reference"))
  .AddTypedef(type_5780, Reflex::Literal("std::vector<RPTimingDetectorHit>::const_reference"))
  .AddTypedef(type_5232, Reflex::Literal("std::vector<RPTimingDetectorHit>::iterator"))
  .AddTypedef(type_5233, Reflex::Literal("std::vector<RPTimingDetectorHit>::const_iterator"))
  .AddTypedef(type_2801, Reflex::Literal("std::vector<RPTimingDetectorHit>::const_reverse_iterator"))
  .AddTypedef(type_2802, Reflex::Literal("std::vector<RPTimingDetectorHit>::reverse_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("std::vector<RPTimingDetectorHit>::size_type"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<RPTimingDetectorHit>::difference_type"))
  .AddTypedef(type_2705, Reflex::Literal("std::vector<RPTimingDetectorHit>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8466, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17830), Reflex::Literal("vector"), constructor_8467, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2691, type_5780, type_17830), Reflex::Literal("vector"), constructor_8468, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18564), Reflex::Literal("vector"), constructor_8469, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8470, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2539, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPTimingDetectorHit__funcmem_bld);
}

//------Delayed data member builder for class vector<RPTimingDetectorHit,std::allocator<RPTimingDetectorHit> > -------------------
void __std__vector_RPTimingDetectorHit__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPTimingDetectorHit,std::allocator<RPTimingDetectorHit> > -------------------
void __std__vector_RPTimingDetectorHit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18565, type_18564), Reflex::Literal("operator="), operator_8471, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_5780), Reflex::Literal("assign"), method_8472, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5232), Reflex::Literal("begin"), method_8473, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5233), Reflex::Literal("begin"), method_8474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5232), Reflex::Literal("end"), method_8475, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5233), Reflex::Literal("end"), method_8476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_8481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("max_size"), method_8482, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_1474), Reflex::Literal("resize"), method_8483, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("capacity"), method_8484, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_8485, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691), Reflex::Literal("reserve"), method_8486, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8456, type_2691), Reflex::Literal("operator[]"), operator_8487, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5780, type_2691), Reflex::Literal("operator[]"), operator_8488, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8456, type_2691), Reflex::Literal("at"), method_8490, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5780, type_2691), Reflex::Literal("at"), method_8491, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8456), Reflex::Literal("front"), method_8492, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5780), Reflex::Literal("front"), method_8493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8456), Reflex::Literal("back"), method_8494, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5780), Reflex::Literal("back"), method_8495, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6205), Reflex::Literal("data"), method_8496, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8454), Reflex::Literal("data"), method_8497, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5780), Reflex::Literal("push_back"), method_8498, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("pop_back"), method_8499, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5232, type_5232, type_5780), Reflex::Literal("insert"), method_8500, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5232, type_2691, type_5780), Reflex::Literal("insert"), method_8501, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5232, type_5232), Reflex::Literal("erase"), method_8502, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5232, type_5232, type_5232), Reflex::Literal("erase"), method_8503, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_18565), Reflex::Literal("swap"), method_8504, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_8505, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class DetSet<RPDigCluster> -------------------------------
static void destructor_14050(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DetSet<RPDigCluster>*)o)->::edm::DetSet<RPDigCluster>::~DetSet)();
}
static  void operator_14051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSet<RPDigCluster>*)o)->operator=)(*(const ::edm::DetSet<RPDigCluster>*)arg[0]);
  else   (((::edm::DetSet<RPDigCluster>*)o)->operator=)(*(const ::edm::DetSet<RPDigCluster>*)arg[0]);
}

static void constructor_14052( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPDigCluster>(*(const ::edm::DetSet<RPDigCluster>*)arg[0]);
  else ::new(mem) ::edm::DetSet<RPDigCluster>(*(const ::edm::DetSet<RPDigCluster>*)arg[0]);
}

static void constructor_14053( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPDigCluster>();
  else ::new(mem) ::edm::DetSet<RPDigCluster>();
}

static void constructor_14054( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPDigCluster>(*(::edm::det_id_type*)arg[0]);
  else ::new(mem) ::edm::DetSet<RPDigCluster>(*(::edm::det_id_type*)arg[0]);
}

static  void method_14055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >)((((::edm::DetSet<RPDigCluster>*)o)->begin)());
  else   (((::edm::DetSet<RPDigCluster>*)o)->begin)();
}

static  void method_14056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >)((((::edm::DetSet<RPDigCluster>*)o)->end)());
  else   (((::edm::DetSet<RPDigCluster>*)o)->end)();
}

static  void method_14057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPDigCluster*,std::vector<RPDigCluster> >)((((const ::edm::DetSet<RPDigCluster>*)o)->begin)());
  else   (((const ::edm::DetSet<RPDigCluster>*)o)->begin)();
}

static  void method_14058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPDigCluster*,std::vector<RPDigCluster> >)((((const ::edm::DetSet<RPDigCluster>*)o)->end)());
  else   (((const ::edm::DetSet<RPDigCluster>*)o)->end)();
}

static  void method_14059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::DetSet<RPDigCluster>*)o)->size)());
  else   (((const ::edm::DetSet<RPDigCluster>*)o)->size)();
}

static  void method_14060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::DetSet<RPDigCluster>*)o)->empty)());
  else   (((const ::edm::DetSet<RPDigCluster>*)o)->empty)();
}

static  void operator_14061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSet<RPDigCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::edm::DetSet<RPDigCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14062( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::DetSet<RPDigCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::edm::DetSet<RPDigCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPDigCluster>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_14064( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPDigCluster>*)o)->push_back)(*(const ::RPDigCluster*)arg[0]);
}

static  void method_14065( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::DetSet<RPDigCluster>*)o)->clear)();
}

static  void method_14066( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPDigCluster>*)o)->swap)(*(::edm::DetSet<RPDigCluster>*)arg[0]);
}

static  void method_14067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::det_id_type)((((const ::edm::DetSet<RPDigCluster>*)o)->detId)());
  else   (((const ::edm::DetSet<RPDigCluster>*)o)->detId)();
}

static  void method_14068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::DetSet<RPDigCluster>*)o)->Class_Version)());
  else   (((::edm::DetSet<RPDigCluster>*)o)->Class_Version)();
}

static void method_newdel_3532( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPDigCluster> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPDigCluster> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPDigCluster> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPDigCluster> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPDigCluster> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DetSet<RPDigCluster> -------------------------------
void __edm__DetSet_RPDigCluster__db_datamem(Reflex::Class*);
void __edm__DetSet_RPDigCluster__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DetSet_RPDigCluster__datamem_bld(&__edm__DetSet_RPDigCluster__db_datamem);
Reflex::GenreflexMemberBuilder __edm__DetSet_RPDigCluster__funcmem_bld(&__edm__DetSet_RPDigCluster__db_funcmem);
void __edm__DetSet_RPDigCluster__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DetSet<RPDigCluster>"), typeid(::edm::DetSet<RPDigCluster>), sizeof(::edm::DetSet<RPDigCluster>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::DetSet<RPDigCluster>::Class_Version())
  .AddTypedef(type_2542, Reflex::Literal("edm::DetSet<RPDigCluster>::collection_type"))
  .AddTypedef(type_1373, Reflex::Literal("edm::DetSet<RPDigCluster>::value_type"))
  .AddTypedef(type_8585, Reflex::Literal("edm::DetSet<RPDigCluster>::reference"))
  .AddTypedef(type_5782, Reflex::Literal("edm::DetSet<RPDigCluster>::const_reference"))
  .AddTypedef(type_5236, Reflex::Literal("edm::DetSet<RPDigCluster>::iterator"))
  .AddTypedef(type_5237, Reflex::Literal("edm::DetSet<RPDigCluster>::const_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("edm::DetSet<RPDigCluster>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetSet"), destructor_14050, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8520, type_8522), Reflex::Literal("operator="), operator_14051, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8522), Reflex::Literal("DetSet"), constructor_14052, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetSet"), constructor_14053, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3566), Reflex::Literal("DetSet"), constructor_14054, 0, "i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3532, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__DetSet_RPDigCluster__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__DetSet_RPDigCluster__funcmem_bld);
}

//------Delayed data member builder for class DetSet<RPDigCluster> -------------------
void __edm__DetSet_RPDigCluster__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3566, Reflex::Literal("id"), OffsetOf(__shadow__::__edm__DetSet_RPDigCluster_, id), ::Reflex::PUBLIC)
  .AddDataMember(type_2542, Reflex::Literal("data"), OffsetOf(__shadow__::__edm__DetSet_RPDigCluster_, data), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class DetSet<RPDigCluster> -------------------
void __edm__DetSet_RPDigCluster__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5236), Reflex::Literal("begin"), method_14055, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5236), Reflex::Literal("end"), method_14056, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5237), Reflex::Literal("begin"), method_14057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5237), Reflex::Literal("end"), method_14058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_14059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_14060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8585, type_2691), Reflex::Literal("operator[]"), operator_14061, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5782, type_2691), Reflex::Literal("operator[]"), operator_14062, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_1833), Reflex::Literal("reserve"), method_14063, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5782), Reflex::Literal("push_back"), method_14064, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_14065, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8520), Reflex::Literal("swap"), method_14066, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3566), Reflex::Literal("detId"), method_14067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_379), Reflex::Literal("Class_Version"), method_14068, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::DetSet<RPDigCluster>,std::allocator<edm::DetSet<RPDigCluster> > > -------------------------------
static void constructor_8531( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >();
  else ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >();
}

static void constructor_8532( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >(*(const ::std::allocator<edm::DetSet<RPDigCluster> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >(*(const ::std::allocator<edm::DetSet<RPDigCluster> >*)arg[0]);
}

static void constructor_8533( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPDigCluster>*)arg[1]);
  else ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPDigCluster>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPDigCluster>*)arg[1],
      *(const ::std::allocator<edm::DetSet<RPDigCluster> >*)arg[2]);
  else ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPDigCluster>*)arg[1],
      *(const ::std::allocator<edm::DetSet<RPDigCluster> >*)arg[2]);
  }
}

static void constructor_8534( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >(*(const ::std::vector<edm::DetSet<RPDigCluster> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPDigCluster> >(*(const ::std::vector<edm::DetSet<RPDigCluster> >*)arg[0]);
}

static void destructor_8535(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::DetSet<RPDigCluster> >*)o)->::std::vector<edm::DetSet<RPDigCluster> >::~vector)();
}
static  void operator_8536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPDigCluster> >*)o)->operator=)(*(const ::std::vector<edm::DetSet<RPDigCluster> >*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->operator=)(*(const ::std::vector<edm::DetSet<RPDigCluster> >*)arg[0]);
}

static  void method_8537( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::DetSet<RPDigCluster>*)arg[1]);
}

static  void method_8538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((::std::vector<edm::DetSet<RPDigCluster> >*)o)->begin)());
  else   (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->begin)();
}

static  void method_8539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->begin)());
  else   (((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->begin)();
}

static  void method_8540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((::std::vector<edm::DetSet<RPDigCluster> >*)o)->end)());
  else   (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->end)();
}

static  void method_8541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->end)());
  else   (((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->end)();
}

static  void method_8546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->size)());
  else   (((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->size)();
}

static  void method_8547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->max_size)());
  else   (((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->max_size)();
}

static  void method_8548( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::DetSet<RPDigCluster>*)arg[1]);
  }
}

static  void method_8549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->capacity)());
  else   (((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->capacity)();
}

static  void method_8550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->empty)());
  else   (((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->empty)();
}

static  void method_8551( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPDigCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPDigCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPDigCluster> >*)o)->front)();
  else   (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->front)();
}

static  void method_8558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->front)();
  else   (((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->front)();
}

static  void method_8559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPDigCluster> >*)o)->back)();
  else   (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->back)();
}

static  void method_8560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->back)();
  else   (((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->back)();
}

static  void method_8561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::DetSet<RPDigCluster> >*)o)->data)());
  else   (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->data)();
}

static  void method_8562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->data)());
  else   (((const ::std::vector<edm::DetSet<RPDigCluster> >*)o)->data)();
}

static  void method_8563( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->push_back)(*(const ::edm::DetSet<RPDigCluster>*)arg[0]);
}

static  void method_8564( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->pop_back)();
}

static  void method_8565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((::std::vector<edm::DetSet<RPDigCluster> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >*)arg[0],
    *(const ::edm::DetSet<RPDigCluster>*)arg[1]));
  else   (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >*)arg[0],
    *(const ::edm::DetSet<RPDigCluster>*)arg[1]);
}

static  void method_8566( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::DetSet<RPDigCluster>*)arg[2]);
}

static  void method_8567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((::std::vector<edm::DetSet<RPDigCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >*)arg[0]));
  else   (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >*)arg[0]);
}

static  void method_8568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((::std::vector<edm::DetSet<RPDigCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >*)arg[1]));
  else   (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >*)arg[1]);
}

static  void method_8569( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->swap)(*(::std::vector<edm::DetSet<RPDigCluster> >*)arg[0]);
}

static  void method_8570( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::DetSet<RPDigCluster> >*)o)->clear)();
}

static void method_newdel_2540( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPDigCluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPDigCluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPDigCluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPDigCluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPDigCluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::DetSet<RPDigCluster>,std::allocator<edm::DetSet<RPDigCluster> > >")), ::Reflex::BaseOffset< ::std::vector<edm::DetSet<RPDigCluster> >,::std::_Vector_base<edm::DetSet<RPDigCluster>,std::allocator<edm::DetSet<RPDigCluster> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::DetSet<RPDigCluster> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::DetSet<RPDigCluster> > >::Generate();
}

//------Dictionary for class vector<edm::DetSet<RPDigCluster>,std::allocator<edm::DetSet<RPDigCluster> > > -------------------------------
void __std__vector_edm__DetSet_RPDigCluster_s__db_datamem(Reflex::Class*);
void __std__vector_edm__DetSet_RPDigCluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__DetSet_RPDigCluster_s__datamem_bld(&__std__vector_edm__DetSet_RPDigCluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__DetSet_RPDigCluster_s__funcmem_bld(&__std__vector_edm__DetSet_RPDigCluster_s__db_funcmem);
void __std__vector_edm__DetSet_RPDigCluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >"), typeid(::std::vector<edm::DetSet<RPDigCluster> >), sizeof(::std::vector<edm::DetSet<RPDigCluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2179, ::Reflex::BaseOffset< ::std::vector<edm::DetSet<RPDigCluster> >, ::std::_Vector_base<edm::DetSet<RPDigCluster>,std::allocator<edm::DetSet<RPDigCluster> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3532, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::_Alloc_value_type"))
  .AddTypedef(type_2179, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::_Base"))
  .AddTypedef(type_2706, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::_Tp_alloc_type"))
  .AddTypedef(type_5317, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::_Alloc_traits"))
  .AddTypedef(type_3532, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::value_type"))
  .AddTypedef(type_6224, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::pointer"))
  .AddTypedef(type_8518, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::const_pointer"))
  .AddTypedef(type_8520, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::reference"))
  .AddTypedef(type_8522, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::const_reference"))
  .AddTypedef(type_5234, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::iterator"))
  .AddTypedef(type_5235, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::const_iterator"))
  .AddTypedef(type_2803, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::const_reverse_iterator"))
  .AddTypedef(type_2804, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::reverse_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::size_type"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::difference_type"))
  .AddTypedef(type_2706, Reflex::Literal("std::vector<edm::DetSet<RPDigCluster> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8531, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17843), Reflex::Literal("vector"), constructor_8532, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2691, type_8522, type_17843), Reflex::Literal("vector"), constructor_8533, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18567), Reflex::Literal("vector"), constructor_8534, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8535, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2540, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__DetSet_RPDigCluster_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::DetSet<RPDigCluster>,std::allocator<edm::DetSet<RPDigCluster> > > -------------------
void __std__vector_edm__DetSet_RPDigCluster_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::DetSet<RPDigCluster>,std::allocator<edm::DetSet<RPDigCluster> > > -------------------
void __std__vector_edm__DetSet_RPDigCluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18568, type_18567), Reflex::Literal("operator="), operator_8536, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_8522), Reflex::Literal("assign"), method_8537, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5234), Reflex::Literal("begin"), method_8538, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5235), Reflex::Literal("begin"), method_8539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5234), Reflex::Literal("end"), method_8540, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5235), Reflex::Literal("end"), method_8541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_8546, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("max_size"), method_8547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_3532), Reflex::Literal("resize"), method_8548, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("capacity"), method_8549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_8550, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691), Reflex::Literal("reserve"), method_8551, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8520, type_2691), Reflex::Literal("operator[]"), operator_8552, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8522, type_2691), Reflex::Literal("operator[]"), operator_8553, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8520, type_2691), Reflex::Literal("at"), method_8555, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8522, type_2691), Reflex::Literal("at"), method_8556, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8520), Reflex::Literal("front"), method_8557, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8522), Reflex::Literal("front"), method_8558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8520), Reflex::Literal("back"), method_8559, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8522), Reflex::Literal("back"), method_8560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6224), Reflex::Literal("data"), method_8561, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8518), Reflex::Literal("data"), method_8562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8522), Reflex::Literal("push_back"), method_8563, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("pop_back"), method_8564, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5234, type_5234, type_8522), Reflex::Literal("insert"), method_8565, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5234, type_2691, type_8522), Reflex::Literal("insert"), method_8566, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5234, type_5234), Reflex::Literal("erase"), method_8567, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5234, type_5234, type_5234), Reflex::Literal("erase"), method_8568, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_18568), Reflex::Literal("swap"), method_8569, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_8570, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPDigCluster,std::allocator<RPDigCluster> > -------------------------------
static void constructor_8595( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDigCluster>();
  else ::new(mem) ::std::vector<RPDigCluster>();
}

static void constructor_8596( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDigCluster>(*(const ::std::allocator<RPDigCluster>*)arg[0]);
  else ::new(mem) ::std::vector<RPDigCluster>(*(const ::std::allocator<RPDigCluster>*)arg[0]);
}

static void constructor_8597( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDigCluster>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPDigCluster>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDigCluster>(*(::std::size_t*)arg[0],
      *(const ::RPDigCluster*)arg[1]);
  else ::new(mem) ::std::vector<RPDigCluster>(*(::std::size_t*)arg[0],
      *(const ::RPDigCluster*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDigCluster>(*(::std::size_t*)arg[0],
      *(const ::RPDigCluster*)arg[1],
      *(const ::std::allocator<RPDigCluster>*)arg[2]);
  else ::new(mem) ::std::vector<RPDigCluster>(*(::std::size_t*)arg[0],
      *(const ::RPDigCluster*)arg[1],
      *(const ::std::allocator<RPDigCluster>*)arg[2]);
  }
}

static void constructor_8598( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDigCluster>(*(const ::std::vector<RPDigCluster>*)arg[0]);
  else ::new(mem) ::std::vector<RPDigCluster>(*(const ::std::vector<RPDigCluster>*)arg[0]);
}

static void destructor_8599(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPDigCluster>*)o)->::std::vector<RPDigCluster>::~vector)();
}
static  void operator_8600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDigCluster>*)o)->operator=)(*(const ::std::vector<RPDigCluster>*)arg[0]);
  else   (((::std::vector<RPDigCluster>*)o)->operator=)(*(const ::std::vector<RPDigCluster>*)arg[0]);
}

static  void method_8601( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDigCluster>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPDigCluster*)arg[1]);
}

static  void method_8602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >)((((::std::vector<RPDigCluster>*)o)->begin)());
  else   (((::std::vector<RPDigCluster>*)o)->begin)();
}

static  void method_8603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPDigCluster*,std::vector<RPDigCluster> >)((((const ::std::vector<RPDigCluster>*)o)->begin)());
  else   (((const ::std::vector<RPDigCluster>*)o)->begin)();
}

static  void method_8604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >)((((::std::vector<RPDigCluster>*)o)->end)());
  else   (((::std::vector<RPDigCluster>*)o)->end)();
}

static  void method_8605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPDigCluster*,std::vector<RPDigCluster> >)((((const ::std::vector<RPDigCluster>*)o)->end)());
  else   (((const ::std::vector<RPDigCluster>*)o)->end)();
}

static  void method_8610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPDigCluster>*)o)->size)());
  else   (((const ::std::vector<RPDigCluster>*)o)->size)();
}

static  void method_8611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPDigCluster>*)o)->max_size)());
  else   (((const ::std::vector<RPDigCluster>*)o)->max_size)();
}

static  void method_8612( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPDigCluster>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPDigCluster>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPDigCluster*)arg[1]);
  }
}

static  void method_8613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPDigCluster>*)o)->capacity)());
  else   (((const ::std::vector<RPDigCluster>*)o)->capacity)();
}

static  void method_8614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPDigCluster>*)o)->empty)());
  else   (((const ::std::vector<RPDigCluster>*)o)->empty)();
}

static  void method_8615( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDigCluster>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDigCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPDigCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDigCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPDigCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDigCluster>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPDigCluster>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDigCluster>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPDigCluster>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDigCluster>*)o)->front)();
  else   (((::std::vector<RPDigCluster>*)o)->front)();
}

static  void method_8622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDigCluster>*)o)->front)();
  else   (((const ::std::vector<RPDigCluster>*)o)->front)();
}

static  void method_8623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDigCluster>*)o)->back)();
  else   (((::std::vector<RPDigCluster>*)o)->back)();
}

static  void method_8624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDigCluster>*)o)->back)();
  else   (((const ::std::vector<RPDigCluster>*)o)->back)();
}

static  void method_8625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPDigCluster>*)o)->data)());
  else   (((::std::vector<RPDigCluster>*)o)->data)();
}

static  void method_8626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPDigCluster>*)o)->data)());
  else   (((const ::std::vector<RPDigCluster>*)o)->data)();
}

static  void method_8627( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDigCluster>*)o)->push_back)(*(const ::RPDigCluster*)arg[0]);
}

static  void method_8628( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPDigCluster>*)o)->pop_back)();
}

static  void method_8629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >)((((::std::vector<RPDigCluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >*)arg[0],
    *(const ::RPDigCluster*)arg[1]));
  else   (((::std::vector<RPDigCluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >*)arg[0],
    *(const ::RPDigCluster*)arg[1]);
}

static  void method_8630( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDigCluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPDigCluster*)arg[2]);
}

static  void method_8631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >)((((::std::vector<RPDigCluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >*)arg[0]));
  else   (((::std::vector<RPDigCluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >*)arg[0]);
}

static  void method_8632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >)((((::std::vector<RPDigCluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >*)arg[1]));
  else   (((::std::vector<RPDigCluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPDigCluster*,std::vector<RPDigCluster> >*)arg[1]);
}

static  void method_8633( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDigCluster>*)o)->swap)(*(::std::vector<RPDigCluster>*)arg[0]);
}

static  void method_8634( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPDigCluster>*)o)->clear)();
}

static void method_newdel_2542( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPDigCluster> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPDigCluster> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPDigCluster> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPDigCluster> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPDigCluster> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPDigCluster,std::allocator<RPDigCluster> >")), ::Reflex::BaseOffset< ::std::vector<RPDigCluster>,::std::_Vector_base<RPDigCluster,std::allocator<RPDigCluster> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPDigCluster> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPDigCluster> >::Generate();
}

//------Dictionary for class vector<RPDigCluster,std::allocator<RPDigCluster> > -------------------------------
void __std__vector_RPDigCluster__db_datamem(Reflex::Class*);
void __std__vector_RPDigCluster__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPDigCluster__datamem_bld(&__std__vector_RPDigCluster__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPDigCluster__funcmem_bld(&__std__vector_RPDigCluster__db_funcmem);
void __std__vector_RPDigCluster__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPDigCluster>"), typeid(::std::vector<RPDigCluster>), sizeof(::std::vector<RPDigCluster>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2180, ::Reflex::BaseOffset< ::std::vector<RPDigCluster>, ::std::_Vector_base<RPDigCluster,std::allocator<RPDigCluster> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1373, Reflex::Literal("std::vector<RPDigCluster>::_Alloc_value_type"))
  .AddTypedef(type_2180, Reflex::Literal("std::vector<RPDigCluster>::_Base"))
  .AddTypedef(type_2708, Reflex::Literal("std::vector<RPDigCluster>::_Tp_alloc_type"))
  .AddTypedef(type_5318, Reflex::Literal("std::vector<RPDigCluster>::_Alloc_traits"))
  .AddTypedef(type_1373, Reflex::Literal("std::vector<RPDigCluster>::value_type"))
  .AddTypedef(type_6243, Reflex::Literal("std::vector<RPDigCluster>::pointer"))
  .AddTypedef(type_8583, Reflex::Literal("std::vector<RPDigCluster>::const_pointer"))
  .AddTypedef(type_8585, Reflex::Literal("std::vector<RPDigCluster>::reference"))
  .AddTypedef(type_5782, Reflex::Literal("std::vector<RPDigCluster>::const_reference"))
  .AddTypedef(type_5236, Reflex::Literal("std::vector<RPDigCluster>::iterator"))
  .AddTypedef(type_5237, Reflex::Literal("std::vector<RPDigCluster>::const_iterator"))
  .AddTypedef(type_2805, Reflex::Literal("std::vector<RPDigCluster>::const_reverse_iterator"))
  .AddTypedef(type_2806, Reflex::Literal("std::vector<RPDigCluster>::reverse_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("std::vector<RPDigCluster>::size_type"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<RPDigCluster>::difference_type"))
  .AddTypedef(type_2708, Reflex::Literal("std::vector<RPDigCluster>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8595, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17856), Reflex::Literal("vector"), constructor_8596, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2691, type_5782, type_17856), Reflex::Literal("vector"), constructor_8597, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18569), Reflex::Literal("vector"), constructor_8598, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8599, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2542, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPDigCluster__funcmem_bld);
}

//------Delayed data member builder for class vector<RPDigCluster,std::allocator<RPDigCluster> > -------------------
void __std__vector_RPDigCluster__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPDigCluster,std::allocator<RPDigCluster> > -------------------
void __std__vector_RPDigCluster__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18570, type_18569), Reflex::Literal("operator="), operator_8600, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_5782), Reflex::Literal("assign"), method_8601, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5236), Reflex::Literal("begin"), method_8602, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5237), Reflex::Literal("begin"), method_8603, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5236), Reflex::Literal("end"), method_8604, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5237), Reflex::Literal("end"), method_8605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_8610, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("max_size"), method_8611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_1373), Reflex::Literal("resize"), method_8612, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("capacity"), method_8613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_8614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691), Reflex::Literal("reserve"), method_8615, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8585, type_2691), Reflex::Literal("operator[]"), operator_8616, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5782, type_2691), Reflex::Literal("operator[]"), operator_8617, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8585, type_2691), Reflex::Literal("at"), method_8619, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5782, type_2691), Reflex::Literal("at"), method_8620, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8585), Reflex::Literal("front"), method_8621, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5782), Reflex::Literal("front"), method_8622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8585), Reflex::Literal("back"), method_8623, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5782), Reflex::Literal("back"), method_8624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6243), Reflex::Literal("data"), method_8625, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8583), Reflex::Literal("data"), method_8626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5782), Reflex::Literal("push_back"), method_8627, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("pop_back"), method_8628, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5236, type_5236, type_5782), Reflex::Literal("insert"), method_8629, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5236, type_2691, type_5782), Reflex::Literal("insert"), method_8630, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5236, type_5236), Reflex::Literal("erase"), method_8631, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5236, type_5236, type_5236), Reflex::Literal("erase"), method_8632, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_18570), Reflex::Literal("swap"), method_8633, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_8634, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class DetSet<RPDetTrigger> -------------------------------
static void destructor_14078(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DetSet<RPDetTrigger>*)o)->::edm::DetSet<RPDetTrigger>::~DetSet)();
}
static  void operator_14079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSet<RPDetTrigger>*)o)->operator=)(*(const ::edm::DetSet<RPDetTrigger>*)arg[0]);
  else   (((::edm::DetSet<RPDetTrigger>*)o)->operator=)(*(const ::edm::DetSet<RPDetTrigger>*)arg[0]);
}

static void constructor_14080( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPDetTrigger>(*(const ::edm::DetSet<RPDetTrigger>*)arg[0]);
  else ::new(mem) ::edm::DetSet<RPDetTrigger>(*(const ::edm::DetSet<RPDetTrigger>*)arg[0]);
}

static void constructor_14081( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPDetTrigger>();
  else ::new(mem) ::edm::DetSet<RPDetTrigger>();
}

static void constructor_14082( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPDetTrigger>(*(::edm::det_id_type*)arg[0]);
  else ::new(mem) ::edm::DetSet<RPDetTrigger>(*(::edm::det_id_type*)arg[0]);
}

static  void method_14083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >)((((::edm::DetSet<RPDetTrigger>*)o)->begin)());
  else   (((::edm::DetSet<RPDetTrigger>*)o)->begin)();
}

static  void method_14084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >)((((::edm::DetSet<RPDetTrigger>*)o)->end)());
  else   (((::edm::DetSet<RPDetTrigger>*)o)->end)();
}

static  void method_14085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPDetTrigger*,std::vector<RPDetTrigger> >)((((const ::edm::DetSet<RPDetTrigger>*)o)->begin)());
  else   (((const ::edm::DetSet<RPDetTrigger>*)o)->begin)();
}

static  void method_14086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPDetTrigger*,std::vector<RPDetTrigger> >)((((const ::edm::DetSet<RPDetTrigger>*)o)->end)());
  else   (((const ::edm::DetSet<RPDetTrigger>*)o)->end)();
}

static  void method_14087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::DetSet<RPDetTrigger>*)o)->size)());
  else   (((const ::edm::DetSet<RPDetTrigger>*)o)->size)();
}

static  void method_14088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::DetSet<RPDetTrigger>*)o)->empty)());
  else   (((const ::edm::DetSet<RPDetTrigger>*)o)->empty)();
}

static  void operator_14089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSet<RPDetTrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::edm::DetSet<RPDetTrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14090( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::DetSet<RPDetTrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::edm::DetSet<RPDetTrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14091( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPDetTrigger>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_14092( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPDetTrigger>*)o)->push_back)(*(const ::RPDetTrigger*)arg[0]);
}

static  void method_14093( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::DetSet<RPDetTrigger>*)o)->clear)();
}

static  void method_14094( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPDetTrigger>*)o)->swap)(*(::edm::DetSet<RPDetTrigger>*)arg[0]);
}

static  void method_14095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::det_id_type)((((const ::edm::DetSet<RPDetTrigger>*)o)->detId)());
  else   (((const ::edm::DetSet<RPDetTrigger>*)o)->detId)();
}

static  void method_14096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::DetSet<RPDetTrigger>*)o)->Class_Version)());
  else   (((::edm::DetSet<RPDetTrigger>*)o)->Class_Version)();
}

static void method_newdel_3533( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPDetTrigger> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPDetTrigger> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPDetTrigger> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPDetTrigger> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPDetTrigger> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DetSet<RPDetTrigger> -------------------------------
void __edm__DetSet_RPDetTrigger__db_datamem(Reflex::Class*);
void __edm__DetSet_RPDetTrigger__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DetSet_RPDetTrigger__datamem_bld(&__edm__DetSet_RPDetTrigger__db_datamem);
Reflex::GenreflexMemberBuilder __edm__DetSet_RPDetTrigger__funcmem_bld(&__edm__DetSet_RPDetTrigger__db_funcmem);
void __edm__DetSet_RPDetTrigger__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DetSet<RPDetTrigger>"), typeid(::edm::DetSet<RPDetTrigger>), sizeof(::edm::DetSet<RPDetTrigger>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::DetSet<RPDetTrigger>::Class_Version())
  .AddTypedef(type_2544, Reflex::Literal("edm::DetSet<RPDetTrigger>::collection_type"))
  .AddTypedef(type_1150, Reflex::Literal("edm::DetSet<RPDetTrigger>::value_type"))
  .AddTypedef(type_8714, Reflex::Literal("edm::DetSet<RPDetTrigger>::reference"))
  .AddTypedef(type_5783, Reflex::Literal("edm::DetSet<RPDetTrigger>::const_reference"))
  .AddTypedef(type_5240, Reflex::Literal("edm::DetSet<RPDetTrigger>::iterator"))
  .AddTypedef(type_5241, Reflex::Literal("edm::DetSet<RPDetTrigger>::const_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("edm::DetSet<RPDetTrigger>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetSet"), destructor_14078, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8649, type_8651), Reflex::Literal("operator="), operator_14079, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8651), Reflex::Literal("DetSet"), constructor_14080, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetSet"), constructor_14081, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3566), Reflex::Literal("DetSet"), constructor_14082, 0, "i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3533, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__DetSet_RPDetTrigger__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__DetSet_RPDetTrigger__funcmem_bld);
}

//------Delayed data member builder for class DetSet<RPDetTrigger> -------------------
void __edm__DetSet_RPDetTrigger__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3566, Reflex::Literal("id"), OffsetOf(__shadow__::__edm__DetSet_RPDetTrigger_, id), ::Reflex::PUBLIC)
  .AddDataMember(type_2544, Reflex::Literal("data"), OffsetOf(__shadow__::__edm__DetSet_RPDetTrigger_, data), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class DetSet<RPDetTrigger> -------------------
void __edm__DetSet_RPDetTrigger__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5240), Reflex::Literal("begin"), method_14083, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5240), Reflex::Literal("end"), method_14084, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5241), Reflex::Literal("begin"), method_14085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5241), Reflex::Literal("end"), method_14086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_14087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_14088, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8714, type_2691), Reflex::Literal("operator[]"), operator_14089, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5783, type_2691), Reflex::Literal("operator[]"), operator_14090, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_1833), Reflex::Literal("reserve"), method_14091, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5783), Reflex::Literal("push_back"), method_14092, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_14093, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8649), Reflex::Literal("swap"), method_14094, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3566), Reflex::Literal("detId"), method_14095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_379), Reflex::Literal("Class_Version"), method_14096, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::DetSet<RPDetTrigger>,std::allocator<edm::DetSet<RPDetTrigger> > > -------------------------------
static void constructor_8660( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >();
  else ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >();
}

static void constructor_8661( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >(*(const ::std::allocator<edm::DetSet<RPDetTrigger> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >(*(const ::std::allocator<edm::DetSet<RPDetTrigger> >*)arg[0]);
}

static void constructor_8662( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPDetTrigger>*)arg[1]);
  else ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPDetTrigger>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPDetTrigger>*)arg[1],
      *(const ::std::allocator<edm::DetSet<RPDetTrigger> >*)arg[2]);
  else ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPDetTrigger>*)arg[1],
      *(const ::std::allocator<edm::DetSet<RPDetTrigger> >*)arg[2]);
  }
}

static void constructor_8663( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >(*(const ::std::vector<edm::DetSet<RPDetTrigger> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPDetTrigger> >(*(const ::std::vector<edm::DetSet<RPDetTrigger> >*)arg[0]);
}

static void destructor_8664(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->::std::vector<edm::DetSet<RPDetTrigger> >::~vector)();
}
static  void operator_8665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->operator=)(*(const ::std::vector<edm::DetSet<RPDetTrigger> >*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->operator=)(*(const ::std::vector<edm::DetSet<RPDetTrigger> >*)arg[0]);
}

static  void method_8666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::DetSet<RPDetTrigger>*)arg[1]);
}

static  void method_8667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->begin)());
  else   (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->begin)();
}

static  void method_8668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->begin)());
  else   (((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->begin)();
}

static  void method_8669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->end)());
  else   (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->end)();
}

static  void method_8670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->end)());
  else   (((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->end)();
}

static  void method_8675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->size)());
  else   (((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->size)();
}

static  void method_8676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->max_size)());
  else   (((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->max_size)();
}

static  void method_8677( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::DetSet<RPDetTrigger>*)arg[1]);
  }
}

static  void method_8678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->capacity)());
  else   (((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->capacity)();
}

static  void method_8679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->empty)());
  else   (((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->empty)();
}

static  void method_8680( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->front)();
  else   (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->front)();
}

static  void method_8687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->front)();
  else   (((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->front)();
}

static  void method_8688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->back)();
  else   (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->back)();
}

static  void method_8689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->back)();
  else   (((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->back)();
}

static  void method_8690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->data)());
  else   (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->data)();
}

static  void method_8691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->data)());
  else   (((const ::std::vector<edm::DetSet<RPDetTrigger> >*)o)->data)();
}

static  void method_8692( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->push_back)(*(const ::edm::DetSet<RPDetTrigger>*)arg[0]);
}

static  void method_8693( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->pop_back)();
}

static  void method_8694( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >*)arg[0],
    *(const ::edm::DetSet<RPDetTrigger>*)arg[1]));
  else   (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >*)arg[0],
    *(const ::edm::DetSet<RPDetTrigger>*)arg[1]);
}

static  void method_8695( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::DetSet<RPDetTrigger>*)arg[2]);
}

static  void method_8696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >*)arg[0]));
  else   (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >*)arg[0]);
}

static  void method_8697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >*)arg[1]));
  else   (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >*)arg[1]);
}

static  void method_8698( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->swap)(*(::std::vector<edm::DetSet<RPDetTrigger> >*)arg[0]);
}

static  void method_8699( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::DetSet<RPDetTrigger> >*)o)->clear)();
}

static void method_newdel_2543( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPDetTrigger> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPDetTrigger> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPDetTrigger> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPDetTrigger> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPDetTrigger> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::DetSet<RPDetTrigger>,std::allocator<edm::DetSet<RPDetTrigger> > >")), ::Reflex::BaseOffset< ::std::vector<edm::DetSet<RPDetTrigger> >,::std::_Vector_base<edm::DetSet<RPDetTrigger>,std::allocator<edm::DetSet<RPDetTrigger> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::DetSet<RPDetTrigger> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::DetSet<RPDetTrigger> > >::Generate();
}

//------Dictionary for class vector<edm::DetSet<RPDetTrigger>,std::allocator<edm::DetSet<RPDetTrigger> > > -------------------------------
void __std__vector_edm__DetSet_RPDetTrigger_s__db_datamem(Reflex::Class*);
void __std__vector_edm__DetSet_RPDetTrigger_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__DetSet_RPDetTrigger_s__datamem_bld(&__std__vector_edm__DetSet_RPDetTrigger_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__DetSet_RPDetTrigger_s__funcmem_bld(&__std__vector_edm__DetSet_RPDetTrigger_s__db_funcmem);
void __std__vector_edm__DetSet_RPDetTrigger_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >"), typeid(::std::vector<edm::DetSet<RPDetTrigger> >), sizeof(::std::vector<edm::DetSet<RPDetTrigger> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2181, ::Reflex::BaseOffset< ::std::vector<edm::DetSet<RPDetTrigger> >, ::std::_Vector_base<edm::DetSet<RPDetTrigger>,std::allocator<edm::DetSet<RPDetTrigger> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3533, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::_Alloc_value_type"))
  .AddTypedef(type_2181, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::_Base"))
  .AddTypedef(type_2709, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::_Tp_alloc_type"))
  .AddTypedef(type_5319, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::_Alloc_traits"))
  .AddTypedef(type_3533, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::value_type"))
  .AddTypedef(type_6262, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::pointer"))
  .AddTypedef(type_8647, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::const_pointer"))
  .AddTypedef(type_8649, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::reference"))
  .AddTypedef(type_8651, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::const_reference"))
  .AddTypedef(type_5238, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::iterator"))
  .AddTypedef(type_5239, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::const_iterator"))
  .AddTypedef(type_2807, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::const_reverse_iterator"))
  .AddTypedef(type_2808, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::reverse_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::size_type"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::difference_type"))
  .AddTypedef(type_2709, Reflex::Literal("std::vector<edm::DetSet<RPDetTrigger> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8660, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17869), Reflex::Literal("vector"), constructor_8661, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2691, type_8651, type_17869), Reflex::Literal("vector"), constructor_8662, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18572), Reflex::Literal("vector"), constructor_8663, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8664, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2543, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__DetSet_RPDetTrigger_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::DetSet<RPDetTrigger>,std::allocator<edm::DetSet<RPDetTrigger> > > -------------------
void __std__vector_edm__DetSet_RPDetTrigger_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::DetSet<RPDetTrigger>,std::allocator<edm::DetSet<RPDetTrigger> > > -------------------
void __std__vector_edm__DetSet_RPDetTrigger_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18573, type_18572), Reflex::Literal("operator="), operator_8665, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_8651), Reflex::Literal("assign"), method_8666, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5238), Reflex::Literal("begin"), method_8667, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5239), Reflex::Literal("begin"), method_8668, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5238), Reflex::Literal("end"), method_8669, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5239), Reflex::Literal("end"), method_8670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_8675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("max_size"), method_8676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_3533), Reflex::Literal("resize"), method_8677, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("capacity"), method_8678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_8679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691), Reflex::Literal("reserve"), method_8680, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8649, type_2691), Reflex::Literal("operator[]"), operator_8681, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8651, type_2691), Reflex::Literal("operator[]"), operator_8682, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8649, type_2691), Reflex::Literal("at"), method_8684, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8651, type_2691), Reflex::Literal("at"), method_8685, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8649), Reflex::Literal("front"), method_8686, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8651), Reflex::Literal("front"), method_8687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8649), Reflex::Literal("back"), method_8688, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8651), Reflex::Literal("back"), method_8689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6262), Reflex::Literal("data"), method_8690, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8647), Reflex::Literal("data"), method_8691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8651), Reflex::Literal("push_back"), method_8692, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("pop_back"), method_8693, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5238, type_5238, type_8651), Reflex::Literal("insert"), method_8694, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5238, type_2691, type_8651), Reflex::Literal("insert"), method_8695, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5238, type_5238), Reflex::Literal("erase"), method_8696, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5238, type_5238, type_5238), Reflex::Literal("erase"), method_8697, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_18573), Reflex::Literal("swap"), method_8698, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_8699, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPDetTrigger,std::allocator<RPDetTrigger> > -------------------------------
static void constructor_8724( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetTrigger>();
  else ::new(mem) ::std::vector<RPDetTrigger>();
}

static void constructor_8725( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetTrigger>(*(const ::std::allocator<RPDetTrigger>*)arg[0]);
  else ::new(mem) ::std::vector<RPDetTrigger>(*(const ::std::allocator<RPDetTrigger>*)arg[0]);
}

static void constructor_8726( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetTrigger>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPDetTrigger>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetTrigger>(*(::std::size_t*)arg[0],
      *(const ::RPDetTrigger*)arg[1]);
  else ::new(mem) ::std::vector<RPDetTrigger>(*(::std::size_t*)arg[0],
      *(const ::RPDetTrigger*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetTrigger>(*(::std::size_t*)arg[0],
      *(const ::RPDetTrigger*)arg[1],
      *(const ::std::allocator<RPDetTrigger>*)arg[2]);
  else ::new(mem) ::std::vector<RPDetTrigger>(*(::std::size_t*)arg[0],
      *(const ::RPDetTrigger*)arg[1],
      *(const ::std::allocator<RPDetTrigger>*)arg[2]);
  }
}

static void constructor_8727( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPDetTrigger>(*(const ::std::vector<RPDetTrigger>*)arg[0]);
  else ::new(mem) ::std::vector<RPDetTrigger>(*(const ::std::vector<RPDetTrigger>*)arg[0]);
}

static void destructor_8728(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPDetTrigger>*)o)->::std::vector<RPDetTrigger>::~vector)();
}
static  void operator_8729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDetTrigger>*)o)->operator=)(*(const ::std::vector<RPDetTrigger>*)arg[0]);
  else   (((::std::vector<RPDetTrigger>*)o)->operator=)(*(const ::std::vector<RPDetTrigger>*)arg[0]);
}

static  void method_8730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDetTrigger>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPDetTrigger*)arg[1]);
}

static  void method_8731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >)((((::std::vector<RPDetTrigger>*)o)->begin)());
  else   (((::std::vector<RPDetTrigger>*)o)->begin)();
}

static  void method_8732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPDetTrigger*,std::vector<RPDetTrigger> >)((((const ::std::vector<RPDetTrigger>*)o)->begin)());
  else   (((const ::std::vector<RPDetTrigger>*)o)->begin)();
}

static  void method_8733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >)((((::std::vector<RPDetTrigger>*)o)->end)());
  else   (((::std::vector<RPDetTrigger>*)o)->end)();
}

static  void method_8734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPDetTrigger*,std::vector<RPDetTrigger> >)((((const ::std::vector<RPDetTrigger>*)o)->end)());
  else   (((const ::std::vector<RPDetTrigger>*)o)->end)();
}

static  void method_8739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPDetTrigger>*)o)->size)());
  else   (((const ::std::vector<RPDetTrigger>*)o)->size)();
}

static  void method_8740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPDetTrigger>*)o)->max_size)());
  else   (((const ::std::vector<RPDetTrigger>*)o)->max_size)();
}

static  void method_8741( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPDetTrigger>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPDetTrigger>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPDetTrigger*)arg[1]);
  }
}

static  void method_8742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPDetTrigger>*)o)->capacity)());
  else   (((const ::std::vector<RPDetTrigger>*)o)->capacity)();
}

static  void method_8743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPDetTrigger>*)o)->empty)());
  else   (((const ::std::vector<RPDetTrigger>*)o)->empty)();
}

static  void method_8744( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDetTrigger>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDetTrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPDetTrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDetTrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPDetTrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDetTrigger>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPDetTrigger>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDetTrigger>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPDetTrigger>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDetTrigger>*)o)->front)();
  else   (((::std::vector<RPDetTrigger>*)o)->front)();
}

static  void method_8751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDetTrigger>*)o)->front)();
  else   (((const ::std::vector<RPDetTrigger>*)o)->front)();
}

static  void method_8752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPDetTrigger>*)o)->back)();
  else   (((::std::vector<RPDetTrigger>*)o)->back)();
}

static  void method_8753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPDetTrigger>*)o)->back)();
  else   (((const ::std::vector<RPDetTrigger>*)o)->back)();
}

static  void method_8754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPDetTrigger>*)o)->data)());
  else   (((::std::vector<RPDetTrigger>*)o)->data)();
}

static  void method_8755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPDetTrigger>*)o)->data)());
  else   (((const ::std::vector<RPDetTrigger>*)o)->data)();
}

static  void method_8756( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDetTrigger>*)o)->push_back)(*(const ::RPDetTrigger*)arg[0]);
}

static  void method_8757( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPDetTrigger>*)o)->pop_back)();
}

static  void method_8758( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >)((((::std::vector<RPDetTrigger>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >*)arg[0],
    *(const ::RPDetTrigger*)arg[1]));
  else   (((::std::vector<RPDetTrigger>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >*)arg[0],
    *(const ::RPDetTrigger*)arg[1]);
}

static  void method_8759( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDetTrigger>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPDetTrigger*)arg[2]);
}

static  void method_8760( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >)((((::std::vector<RPDetTrigger>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >*)arg[0]));
  else   (((::std::vector<RPDetTrigger>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >*)arg[0]);
}

static  void method_8761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >)((((::std::vector<RPDetTrigger>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >*)arg[1]));
  else   (((::std::vector<RPDetTrigger>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPDetTrigger*,std::vector<RPDetTrigger> >*)arg[1]);
}

static  void method_8762( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPDetTrigger>*)o)->swap)(*(::std::vector<RPDetTrigger>*)arg[0]);
}

static  void method_8763( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPDetTrigger>*)o)->clear)();
}

static void method_newdel_2544( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPDetTrigger> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPDetTrigger> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPDetTrigger> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPDetTrigger> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPDetTrigger> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPDetTrigger,std::allocator<RPDetTrigger> >")), ::Reflex::BaseOffset< ::std::vector<RPDetTrigger>,::std::_Vector_base<RPDetTrigger,std::allocator<RPDetTrigger> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPDetTrigger> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPDetTrigger> >::Generate();
}

//------Dictionary for class vector<RPDetTrigger,std::allocator<RPDetTrigger> > -------------------------------
void __std__vector_RPDetTrigger__db_datamem(Reflex::Class*);
void __std__vector_RPDetTrigger__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPDetTrigger__datamem_bld(&__std__vector_RPDetTrigger__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPDetTrigger__funcmem_bld(&__std__vector_RPDetTrigger__db_funcmem);
void __std__vector_RPDetTrigger__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPDetTrigger>"), typeid(::std::vector<RPDetTrigger>), sizeof(::std::vector<RPDetTrigger>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2182, ::Reflex::BaseOffset< ::std::vector<RPDetTrigger>, ::std::_Vector_base<RPDetTrigger,std::allocator<RPDetTrigger> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1150, Reflex::Literal("std::vector<RPDetTrigger>::_Alloc_value_type"))
  .AddTypedef(type_2182, Reflex::Literal("std::vector<RPDetTrigger>::_Base"))
  .AddTypedef(type_2710, Reflex::Literal("std::vector<RPDetTrigger>::_Tp_alloc_type"))
  .AddTypedef(type_5320, Reflex::Literal("std::vector<RPDetTrigger>::_Alloc_traits"))
  .AddTypedef(type_1150, Reflex::Literal("std::vector<RPDetTrigger>::value_type"))
  .AddTypedef(type_6281, Reflex::Literal("std::vector<RPDetTrigger>::pointer"))
  .AddTypedef(type_8712, Reflex::Literal("std::vector<RPDetTrigger>::const_pointer"))
  .AddTypedef(type_8714, Reflex::Literal("std::vector<RPDetTrigger>::reference"))
  .AddTypedef(type_5783, Reflex::Literal("std::vector<RPDetTrigger>::const_reference"))
  .AddTypedef(type_5240, Reflex::Literal("std::vector<RPDetTrigger>::iterator"))
  .AddTypedef(type_5241, Reflex::Literal("std::vector<RPDetTrigger>::const_iterator"))
  .AddTypedef(type_2809, Reflex::Literal("std::vector<RPDetTrigger>::const_reverse_iterator"))
  .AddTypedef(type_2810, Reflex::Literal("std::vector<RPDetTrigger>::reverse_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("std::vector<RPDetTrigger>::size_type"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<RPDetTrigger>::difference_type"))
  .AddTypedef(type_2710, Reflex::Literal("std::vector<RPDetTrigger>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8724, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17882), Reflex::Literal("vector"), constructor_8725, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2691, type_5783, type_17882), Reflex::Literal("vector"), constructor_8726, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18574), Reflex::Literal("vector"), constructor_8727, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8728, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2544, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPDetTrigger__funcmem_bld);
}

//------Delayed data member builder for class vector<RPDetTrigger,std::allocator<RPDetTrigger> > -------------------
void __std__vector_RPDetTrigger__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPDetTrigger,std::allocator<RPDetTrigger> > -------------------
void __std__vector_RPDetTrigger__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18575, type_18574), Reflex::Literal("operator="), operator_8729, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_5783), Reflex::Literal("assign"), method_8730, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5240), Reflex::Literal("begin"), method_8731, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5241), Reflex::Literal("begin"), method_8732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5240), Reflex::Literal("end"), method_8733, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5241), Reflex::Literal("end"), method_8734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_8739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("max_size"), method_8740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_1150), Reflex::Literal("resize"), method_8741, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("capacity"), method_8742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_8743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691), Reflex::Literal("reserve"), method_8744, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8714, type_2691), Reflex::Literal("operator[]"), operator_8745, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5783, type_2691), Reflex::Literal("operator[]"), operator_8746, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8714, type_2691), Reflex::Literal("at"), method_8748, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5783, type_2691), Reflex::Literal("at"), method_8749, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8714), Reflex::Literal("front"), method_8750, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5783), Reflex::Literal("front"), method_8751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8714), Reflex::Literal("back"), method_8752, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5783), Reflex::Literal("back"), method_8753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6281), Reflex::Literal("data"), method_8754, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8712), Reflex::Literal("data"), method_8755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5783), Reflex::Literal("push_back"), method_8756, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("pop_back"), method_8757, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5240, type_5240, type_5783), Reflex::Literal("insert"), method_8758, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5240, type_2691, type_5783), Reflex::Literal("insert"), method_8759, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5240, type_5240), Reflex::Literal("erase"), method_8760, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5240, type_5240, type_5240), Reflex::Literal("erase"), method_8761, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_18575), Reflex::Literal("swap"), method_8762, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_8763, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPRecoHit,std::allocator<RPRecoHit> > -------------------------------
static void constructor_8787( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoHit>();
  else ::new(mem) ::std::vector<RPRecoHit>();
}

static void constructor_8788( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoHit>(*(const ::std::allocator<RPRecoHit>*)arg[0]);
  else ::new(mem) ::std::vector<RPRecoHit>(*(const ::std::allocator<RPRecoHit>*)arg[0]);
}

static void constructor_8789( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoHit>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRecoHit>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoHit>(*(::std::size_t*)arg[0],
      *(const ::RPRecoHit*)arg[1]);
  else ::new(mem) ::std::vector<RPRecoHit>(*(::std::size_t*)arg[0],
      *(const ::RPRecoHit*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoHit>(*(::std::size_t*)arg[0],
      *(const ::RPRecoHit*)arg[1],
      *(const ::std::allocator<RPRecoHit>*)arg[2]);
  else ::new(mem) ::std::vector<RPRecoHit>(*(::std::size_t*)arg[0],
      *(const ::RPRecoHit*)arg[1],
      *(const ::std::allocator<RPRecoHit>*)arg[2]);
  }
}

static void constructor_8790( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRecoHit>(*(const ::std::vector<RPRecoHit>*)arg[0]);
  else ::new(mem) ::std::vector<RPRecoHit>(*(const ::std::vector<RPRecoHit>*)arg[0]);
}

static void destructor_8791(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRecoHit>*)o)->::std::vector<RPRecoHit>::~vector)();
}
static  void operator_8792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoHit>*)o)->operator=)(*(const ::std::vector<RPRecoHit>*)arg[0]);
  else   (((::std::vector<RPRecoHit>*)o)->operator=)(*(const ::std::vector<RPRecoHit>*)arg[0]);
}

static  void method_8793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoHit>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRecoHit*)arg[1]);
}

static  void method_8794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >)((((::std::vector<RPRecoHit>*)o)->begin)());
  else   (((::std::vector<RPRecoHit>*)o)->begin)();
}

static  void method_8795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >)((((const ::std::vector<RPRecoHit>*)o)->begin)());
  else   (((const ::std::vector<RPRecoHit>*)o)->begin)();
}

static  void method_8796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >)((((::std::vector<RPRecoHit>*)o)->end)());
  else   (((::std::vector<RPRecoHit>*)o)->end)();
}

static  void method_8797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >)((((const ::std::vector<RPRecoHit>*)o)->end)());
  else   (((const ::std::vector<RPRecoHit>*)o)->end)();
}

static  void method_8802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecoHit>*)o)->size)());
  else   (((const ::std::vector<RPRecoHit>*)o)->size)();
}

static  void method_8803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecoHit>*)o)->max_size)());
  else   (((const ::std::vector<RPRecoHit>*)o)->max_size)();
}

static  void method_8804( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRecoHit>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRecoHit>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRecoHit*)arg[1]);
  }
}

static  void method_8805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRecoHit>*)o)->capacity)());
  else   (((const ::std::vector<RPRecoHit>*)o)->capacity)();
}

static  void method_8806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRecoHit>*)o)->empty)());
  else   (((const ::std::vector<RPRecoHit>*)o)->empty)();
}

static  void method_8807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoHit>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRecoHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRecoHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoHit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRecoHit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoHit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRecoHit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoHit>*)o)->front)();
  else   (((::std::vector<RPRecoHit>*)o)->front)();
}

static  void method_8814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoHit>*)o)->front)();
  else   (((const ::std::vector<RPRecoHit>*)o)->front)();
}

static  void method_8815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRecoHit>*)o)->back)();
  else   (((::std::vector<RPRecoHit>*)o)->back)();
}

static  void method_8816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRecoHit>*)o)->back)();
  else   (((const ::std::vector<RPRecoHit>*)o)->back)();
}

static  void method_8817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRecoHit>*)o)->data)());
  else   (((::std::vector<RPRecoHit>*)o)->data)();
}

static  void method_8818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRecoHit>*)o)->data)());
  else   (((const ::std::vector<RPRecoHit>*)o)->data)();
}

static  void method_8819( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoHit>*)o)->push_back)(*(const ::RPRecoHit*)arg[0]);
}

static  void method_8820( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRecoHit>*)o)->pop_back)();
}

static  void method_8821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >)((((::std::vector<RPRecoHit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >*)arg[0],
    *(const ::RPRecoHit*)arg[1]));
  else   (((::std::vector<RPRecoHit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >*)arg[0],
    *(const ::RPRecoHit*)arg[1]);
}

static  void method_8822( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoHit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRecoHit*)arg[2]);
}

static  void method_8823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >)((((::std::vector<RPRecoHit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >*)arg[0]));
  else   (((::std::vector<RPRecoHit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >*)arg[0]);
}

static  void method_8824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >)((((::std::vector<RPRecoHit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >*)arg[1]));
  else   (((::std::vector<RPRecoHit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >*)arg[1]);
}

static  void method_8825( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRecoHit>*)o)->swap)(*(::std::vector<RPRecoHit>*)arg[0]);
}

static  void method_8826( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRecoHit>*)o)->clear)();
}

static void method_newdel_2545( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoHit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoHit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoHit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoHit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRecoHit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRecoHit,std::allocator<RPRecoHit> >")), ::Reflex::BaseOffset< ::std::vector<RPRecoHit>,::std::_Vector_base<RPRecoHit,std::allocator<RPRecoHit> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRecoHit> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRecoHit> >::Generate();
}

//------Dictionary for class vector<RPRecoHit,std::allocator<RPRecoHit> > -------------------------------
void __std__vector_RPRecoHit__db_datamem(Reflex::Class*);
void __std__vector_RPRecoHit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRecoHit__datamem_bld(&__std__vector_RPRecoHit__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRecoHit__funcmem_bld(&__std__vector_RPRecoHit__db_funcmem);
void __std__vector_RPRecoHit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRecoHit>"), typeid(::std::vector<RPRecoHit>), sizeof(::std::vector<RPRecoHit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2185, ::Reflex::BaseOffset< ::std::vector<RPRecoHit>, ::std::_Vector_base<RPRecoHit,std::allocator<RPRecoHit> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2007, Reflex::Literal("std::vector<RPRecoHit>::_Alloc_value_type"))
  .AddTypedef(type_2185, Reflex::Literal("std::vector<RPRecoHit>::_Base"))
  .AddTypedef(type_2711, Reflex::Literal("std::vector<RPRecoHit>::_Tp_alloc_type"))
  .AddTypedef(type_5323, Reflex::Literal("std::vector<RPRecoHit>::_Alloc_traits"))
  .AddTypedef(type_2007, Reflex::Literal("std::vector<RPRecoHit>::value_type"))
  .AddTypedef(type_6338, Reflex::Literal("std::vector<RPRecoHit>::pointer"))
  .AddTypedef(type_6863, Reflex::Literal("std::vector<RPRecoHit>::const_pointer"))
  .AddTypedef(type_8777, Reflex::Literal("std::vector<RPRecoHit>::reference"))
  .AddTypedef(type_5781, Reflex::Literal("std::vector<RPRecoHit>::const_reference"))
  .AddTypedef(type_5247, Reflex::Literal("std::vector<RPRecoHit>::iterator"))
  .AddTypedef(type_5242, Reflex::Literal("std::vector<RPRecoHit>::const_iterator"))
  .AddTypedef(type_2815, Reflex::Literal("std::vector<RPRecoHit>::const_reverse_iterator"))
  .AddTypedef(type_2816, Reflex::Literal("std::vector<RPRecoHit>::reverse_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("std::vector<RPRecoHit>::size_type"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<RPRecoHit>::difference_type"))
  .AddTypedef(type_2711, Reflex::Literal("std::vector<RPRecoHit>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8787, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17921), Reflex::Literal("vector"), constructor_8788, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2691, type_5781, type_17921), Reflex::Literal("vector"), constructor_8789, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18576), Reflex::Literal("vector"), constructor_8790, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8791, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2545, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRecoHit__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRecoHit,std::allocator<RPRecoHit> > -------------------
void __std__vector_RPRecoHit__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRecoHit,std::allocator<RPRecoHit> > -------------------
void __std__vector_RPRecoHit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18577, type_18576), Reflex::Literal("operator="), operator_8792, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_5781), Reflex::Literal("assign"), method_8793, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5247), Reflex::Literal("begin"), method_8794, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5242), Reflex::Literal("begin"), method_8795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5247), Reflex::Literal("end"), method_8796, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5242), Reflex::Literal("end"), method_8797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_8802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("max_size"), method_8803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_2007), Reflex::Literal("resize"), method_8804, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("capacity"), method_8805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_8806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691), Reflex::Literal("reserve"), method_8807, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8777, type_2691), Reflex::Literal("operator[]"), operator_8808, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5781, type_2691), Reflex::Literal("operator[]"), operator_8809, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8777, type_2691), Reflex::Literal("at"), method_8811, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5781, type_2691), Reflex::Literal("at"), method_8812, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8777), Reflex::Literal("front"), method_8813, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5781), Reflex::Literal("front"), method_8814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8777), Reflex::Literal("back"), method_8815, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5781), Reflex::Literal("back"), method_8816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6338), Reflex::Literal("data"), method_8817, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6863), Reflex::Literal("data"), method_8818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5781), Reflex::Literal("push_back"), method_8819, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("pop_back"), method_8820, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5247, type_5247, type_5781), Reflex::Literal("insert"), method_8821, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5247, type_2691, type_5781), Reflex::Literal("insert"), method_8822, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5247, type_5247), Reflex::Literal("erase"), method_8823, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5247, type_5247, type_5247), Reflex::Literal("erase"), method_8824, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_18577), Reflex::Literal("swap"), method_8825, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_8826, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<const RPRecoHit*,std::allocator<const RPRecoHit*> > -------------------------------
static void constructor_8852( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RPRecoHit*>();
  else ::new(mem) ::std::vector<const RPRecoHit*>();
}

static void constructor_8853( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RPRecoHit*>(*(const ::std::allocator<const RPRecoHit*>*)arg[0]);
  else ::new(mem) ::std::vector<const RPRecoHit*>(*(const ::std::allocator<const RPRecoHit*>*)arg[0]);
}

static void constructor_8854( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RPRecoHit*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<const RPRecoHit*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RPRecoHit*>(*(::std::size_t*)arg[0],
      *(const ::RPRecoHit* const*)arg[1]);
  else ::new(mem) ::std::vector<const RPRecoHit*>(*(::std::size_t*)arg[0],
      *(const ::RPRecoHit* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RPRecoHit*>(*(::std::size_t*)arg[0],
      *(const ::RPRecoHit* const*)arg[1],
      *(const ::std::allocator<const RPRecoHit*>*)arg[2]);
  else ::new(mem) ::std::vector<const RPRecoHit*>(*(::std::size_t*)arg[0],
      *(const ::RPRecoHit* const*)arg[1],
      *(const ::std::allocator<const RPRecoHit*>*)arg[2]);
  }
}

static void constructor_8855( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RPRecoHit*>(*(const ::std::vector<const RPRecoHit*>*)arg[0]);
  else ::new(mem) ::std::vector<const RPRecoHit*>(*(const ::std::vector<const RPRecoHit*>*)arg[0]);
}

static void destructor_8856(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<const RPRecoHit*>*)o)->::std::vector<const RPRecoHit*>::~vector)();
}
static  void operator_8857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RPRecoHit*>*)o)->operator=)(*(const ::std::vector<const RPRecoHit*>*)arg[0]);
  else   (((::std::vector<const RPRecoHit*>*)o)->operator=)(*(const ::std::vector<const RPRecoHit*>*)arg[0]);
}

static  void method_8858( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RPRecoHit*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRecoHit* const*)arg[1]);
}

static  void method_8859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >)((((::std::vector<const RPRecoHit*>*)o)->begin)());
  else   (((::std::vector<const RPRecoHit*>*)o)->begin)();
}

static  void method_8860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit* const*,std::vector<const RPRecoHit*> >)((((const ::std::vector<const RPRecoHit*>*)o)->begin)());
  else   (((const ::std::vector<const RPRecoHit*>*)o)->begin)();
}

static  void method_8861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >)((((::std::vector<const RPRecoHit*>*)o)->end)());
  else   (((::std::vector<const RPRecoHit*>*)o)->end)();
}

static  void method_8862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit* const*,std::vector<const RPRecoHit*> >)((((const ::std::vector<const RPRecoHit*>*)o)->end)());
  else   (((const ::std::vector<const RPRecoHit*>*)o)->end)();
}

static  void method_8867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const RPRecoHit*>*)o)->size)());
  else   (((const ::std::vector<const RPRecoHit*>*)o)->size)();
}

static  void method_8868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const RPRecoHit*>*)o)->max_size)());
  else   (((const ::std::vector<const RPRecoHit*>*)o)->max_size)();
}

static  void method_8869( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<const RPRecoHit*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<const RPRecoHit*>*)o)->resize)(*(::std::size_t*)arg[0],
      (const ::RPRecoHit*)arg[1]);
  }
}

static  void method_8870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const RPRecoHit*>*)o)->capacity)());
  else   (((const ::std::vector<const RPRecoHit*>*)o)->capacity)();
}

static  void method_8871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<const RPRecoHit*>*)o)->empty)());
  else   (((const ::std::vector<const RPRecoHit*>*)o)->empty)();
}

static  void method_8872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RPRecoHit*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RPRecoHit*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const RPRecoHit*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RPRecoHit*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const RPRecoHit*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RPRecoHit*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const RPRecoHit*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RPRecoHit*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const RPRecoHit*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RPRecoHit*>*)o)->front)();
  else   (((::std::vector<const RPRecoHit*>*)o)->front)();
}

static  void method_8879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RPRecoHit*>*)o)->front)();
  else   (((const ::std::vector<const RPRecoHit*>*)o)->front)();
}

static  void method_8880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RPRecoHit*>*)o)->back)();
  else   (((::std::vector<const RPRecoHit*>*)o)->back)();
}

static  void method_8881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RPRecoHit*>*)o)->back)();
  else   (((const ::std::vector<const RPRecoHit*>*)o)->back)();
}

static  void method_8882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<const RPRecoHit*>*)o)->data)());
  else   (((::std::vector<const RPRecoHit*>*)o)->data)();
}

static  void method_8883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<const RPRecoHit*>*)o)->data)());
  else   (((const ::std::vector<const RPRecoHit*>*)o)->data)();
}

static  void method_8884( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RPRecoHit*>*)o)->push_back)(*(const ::RPRecoHit* const*)arg[0]);
}

static  void method_8885( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const RPRecoHit*>*)o)->pop_back)();
}

static  void method_8886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >)((((::std::vector<const RPRecoHit*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >*)arg[0],
    *(const ::RPRecoHit* const*)arg[1]));
  else   (((::std::vector<const RPRecoHit*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >*)arg[0],
    *(const ::RPRecoHit* const*)arg[1]);
}

static  void method_8887( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RPRecoHit*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRecoHit* const*)arg[2]);
}

static  void method_8888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >)((((::std::vector<const RPRecoHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >*)arg[0]));
  else   (((::std::vector<const RPRecoHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >*)arg[0]);
}

static  void method_8889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >)((((::std::vector<const RPRecoHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >*)arg[1]));
  else   (((::std::vector<const RPRecoHit*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const RPRecoHit**,std::vector<const RPRecoHit*> >*)arg[1]);
}

static  void method_8890( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RPRecoHit*>*)o)->swap)(*(::std::vector<const RPRecoHit*>*)arg[0]);
}

static  void method_8891( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const RPRecoHit*>*)o)->clear)();
}

static void method_newdel_2546( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<const RPRecoHit*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<const RPRecoHit*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<const RPRecoHit*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<const RPRecoHit*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<const RPRecoHit*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const RPRecoHit*,std::allocator<const RPRecoHit*> >")), ::Reflex::BaseOffset< ::std::vector<const RPRecoHit*>,::std::_Vector_base<const RPRecoHit*,std::allocator<const RPRecoHit*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<const RPRecoHit*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<const RPRecoHit*> >::Generate();
}

//------Dictionary for class vector<const RPRecoHit*,std::allocator<const RPRecoHit*> > -------------------------------
void __std__vector_constsRPRecoHitp__db_datamem(Reflex::Class*);
void __std__vector_constsRPRecoHitp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_constsRPRecoHitp__datamem_bld(&__std__vector_constsRPRecoHitp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_constsRPRecoHitp__funcmem_bld(&__std__vector_constsRPRecoHitp__db_funcmem);
void __std__vector_constsRPRecoHitp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<const RPRecoHit*>"), typeid(::std::vector<const RPRecoHit*>), sizeof(::std::vector<const RPRecoHit*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2183, ::Reflex::BaseOffset< ::std::vector<const RPRecoHit*>, ::std::_Vector_base<const RPRecoHit*,std::allocator<const RPRecoHit*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_6863, Reflex::Literal("std::vector<const RPRecoHit*>::_Alloc_value_type"))
  .AddTypedef(type_2183, Reflex::Literal("std::vector<const RPRecoHit*>::_Base"))
  .AddTypedef(type_2712, Reflex::Literal("std::vector<const RPRecoHit*>::_Tp_alloc_type"))
  .AddTypedef(type_5321, Reflex::Literal("std::vector<const RPRecoHit*>::_Alloc_traits"))
  .AddTypedef(type_6863, Reflex::Literal("std::vector<const RPRecoHit*>::value_type"))
  .AddTypedef(type_6300, Reflex::Literal("std::vector<const RPRecoHit*>::pointer"))
  .AddTypedef(type_8839, Reflex::Literal("std::vector<const RPRecoHit*>::const_pointer"))
  .AddTypedef(type_8841, Reflex::Literal("std::vector<const RPRecoHit*>::reference"))
  .AddTypedef(type_8843, Reflex::Literal("std::vector<const RPRecoHit*>::const_reference"))
  .AddTypedef(type_5243, Reflex::Literal("std::vector<const RPRecoHit*>::iterator"))
  .AddTypedef(type_5244, Reflex::Literal("std::vector<const RPRecoHit*>::const_iterator"))
  .AddTypedef(type_2811, Reflex::Literal("std::vector<const RPRecoHit*>::const_reverse_iterator"))
  .AddTypedef(type_2812, Reflex::Literal("std::vector<const RPRecoHit*>::reverse_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("std::vector<const RPRecoHit*>::size_type"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<const RPRecoHit*>::difference_type"))
  .AddTypedef(type_2712, Reflex::Literal("std::vector<const RPRecoHit*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8852, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17895), Reflex::Literal("vector"), constructor_8853, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2691, type_8843, type_17895), Reflex::Literal("vector"), constructor_8854, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18579), Reflex::Literal("vector"), constructor_8855, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8856, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2546, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_constsRPRecoHitp__funcmem_bld);
}

//------Delayed data member builder for class vector<const RPRecoHit*,std::allocator<const RPRecoHit*> > -------------------
void __std__vector_constsRPRecoHitp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<const RPRecoHit*,std::allocator<const RPRecoHit*> > -------------------
void __std__vector_constsRPRecoHitp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18580, type_18579), Reflex::Literal("operator="), operator_8857, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_8843), Reflex::Literal("assign"), method_8858, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5243), Reflex::Literal("begin"), method_8859, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5244), Reflex::Literal("begin"), method_8860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5243), Reflex::Literal("end"), method_8861, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5244), Reflex::Literal("end"), method_8862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_8867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("max_size"), method_8868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_6863), Reflex::Literal("resize"), method_8869, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("capacity"), method_8870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_8871, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691), Reflex::Literal("reserve"), method_8872, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8841, type_2691), Reflex::Literal("operator[]"), operator_8873, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8843, type_2691), Reflex::Literal("operator[]"), operator_8874, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8841, type_2691), Reflex::Literal("at"), method_8876, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8843, type_2691), Reflex::Literal("at"), method_8877, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8841), Reflex::Literal("front"), method_8878, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8843), Reflex::Literal("front"), method_8879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8841), Reflex::Literal("back"), method_8880, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8843), Reflex::Literal("back"), method_8881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6300), Reflex::Literal("data"), method_8882, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8839), Reflex::Literal("data"), method_8883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8843), Reflex::Literal("push_back"), method_8884, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("pop_back"), method_8885, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5243, type_5243, type_8843), Reflex::Literal("insert"), method_8886, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5243, type_2691, type_8843), Reflex::Literal("insert"), method_8887, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5243, type_5243), Reflex::Literal("erase"), method_8888, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5243, type_5243, type_5243), Reflex::Literal("erase"), method_8889, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_18580), Reflex::Literal("swap"), method_8890, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_8891, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class DetSet<RPRecoHit> -------------------------------
static void destructor_14106(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DetSet<RPRecoHit>*)o)->::edm::DetSet<RPRecoHit>::~DetSet)();
}
static  void operator_14107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSet<RPRecoHit>*)o)->operator=)(*(const ::edm::DetSet<RPRecoHit>*)arg[0]);
  else   (((::edm::DetSet<RPRecoHit>*)o)->operator=)(*(const ::edm::DetSet<RPRecoHit>*)arg[0]);
}

static void constructor_14108( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPRecoHit>(*(const ::edm::DetSet<RPRecoHit>*)arg[0]);
  else ::new(mem) ::edm::DetSet<RPRecoHit>(*(const ::edm::DetSet<RPRecoHit>*)arg[0]);
}

static void constructor_14109( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPRecoHit>();
  else ::new(mem) ::edm::DetSet<RPRecoHit>();
}

static void constructor_14110( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPRecoHit>(*(::edm::det_id_type*)arg[0]);
  else ::new(mem) ::edm::DetSet<RPRecoHit>(*(::edm::det_id_type*)arg[0]);
}

static  void method_14111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >)((((::edm::DetSet<RPRecoHit>*)o)->begin)());
  else   (((::edm::DetSet<RPRecoHit>*)o)->begin)();
}

static  void method_14112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRecoHit*,std::vector<RPRecoHit> >)((((::edm::DetSet<RPRecoHit>*)o)->end)());
  else   (((::edm::DetSet<RPRecoHit>*)o)->end)();
}

static  void method_14113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >)((((const ::edm::DetSet<RPRecoHit>*)o)->begin)());
  else   (((const ::edm::DetSet<RPRecoHit>*)o)->begin)();
}

static  void method_14114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >)((((const ::edm::DetSet<RPRecoHit>*)o)->end)());
  else   (((const ::edm::DetSet<RPRecoHit>*)o)->end)();
}

static  void method_14115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::DetSet<RPRecoHit>*)o)->size)());
  else   (((const ::edm::DetSet<RPRecoHit>*)o)->size)();
}

static  void method_14116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::DetSet<RPRecoHit>*)o)->empty)());
  else   (((const ::edm::DetSet<RPRecoHit>*)o)->empty)();
}

static  void operator_14117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSet<RPRecoHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::edm::DetSet<RPRecoHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::DetSet<RPRecoHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::edm::DetSet<RPRecoHit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14119( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPRecoHit>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_14120( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPRecoHit>*)o)->push_back)(*(const ::RPRecoHit*)arg[0]);
}

static  void method_14121( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::DetSet<RPRecoHit>*)o)->clear)();
}

static  void method_14122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPRecoHit>*)o)->swap)(*(::edm::DetSet<RPRecoHit>*)arg[0]);
}

static  void method_14123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::det_id_type)((((const ::edm::DetSet<RPRecoHit>*)o)->detId)());
  else   (((const ::edm::DetSet<RPRecoHit>*)o)->detId)();
}

static  void method_14124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::DetSet<RPRecoHit>*)o)->Class_Version)());
  else   (((::edm::DetSet<RPRecoHit>*)o)->Class_Version)();
}

static void method_newdel_3534( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPRecoHit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPRecoHit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPRecoHit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPRecoHit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPRecoHit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DetSet<RPRecoHit> -------------------------------
void __edm__DetSet_RPRecoHit__db_datamem(Reflex::Class*);
void __edm__DetSet_RPRecoHit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DetSet_RPRecoHit__datamem_bld(&__edm__DetSet_RPRecoHit__db_datamem);
Reflex::GenreflexMemberBuilder __edm__DetSet_RPRecoHit__funcmem_bld(&__edm__DetSet_RPRecoHit__db_funcmem);
void __edm__DetSet_RPRecoHit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DetSet<RPRecoHit>"), typeid(::edm::DetSet<RPRecoHit>), sizeof(::edm::DetSet<RPRecoHit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::DetSet<RPRecoHit>::Class_Version())
  .AddTypedef(type_2545, Reflex::Literal("edm::DetSet<RPRecoHit>::collection_type"))
  .AddTypedef(type_2007, Reflex::Literal("edm::DetSet<RPRecoHit>::value_type"))
  .AddTypedef(type_8777, Reflex::Literal("edm::DetSet<RPRecoHit>::reference"))
  .AddTypedef(type_5781, Reflex::Literal("edm::DetSet<RPRecoHit>::const_reference"))
  .AddTypedef(type_5247, Reflex::Literal("edm::DetSet<RPRecoHit>::iterator"))
  .AddTypedef(type_5242, Reflex::Literal("edm::DetSet<RPRecoHit>::const_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("edm::DetSet<RPRecoHit>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetSet"), destructor_14106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8906, type_8908), Reflex::Literal("operator="), operator_14107, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8908), Reflex::Literal("DetSet"), constructor_14108, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetSet"), constructor_14109, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3566), Reflex::Literal("DetSet"), constructor_14110, 0, "i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3534, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__DetSet_RPRecoHit__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__DetSet_RPRecoHit__funcmem_bld);
}

//------Delayed data member builder for class DetSet<RPRecoHit> -------------------
void __edm__DetSet_RPRecoHit__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3566, Reflex::Literal("id"), OffsetOf(__shadow__::__edm__DetSet_RPRecoHit_, id), ::Reflex::PUBLIC)
  .AddDataMember(type_2545, Reflex::Literal("data"), OffsetOf(__shadow__::__edm__DetSet_RPRecoHit_, data), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class DetSet<RPRecoHit> -------------------
void __edm__DetSet_RPRecoHit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5247), Reflex::Literal("begin"), method_14111, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5247), Reflex::Literal("end"), method_14112, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5242), Reflex::Literal("begin"), method_14113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5242), Reflex::Literal("end"), method_14114, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_14115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_14116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8777, type_2691), Reflex::Literal("operator[]"), operator_14117, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5781, type_2691), Reflex::Literal("operator[]"), operator_14118, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_1833), Reflex::Literal("reserve"), method_14119, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5781), Reflex::Literal("push_back"), method_14120, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_14121, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8906), Reflex::Literal("swap"), method_14122, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3566), Reflex::Literal("detId"), method_14123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_379), Reflex::Literal("Class_Version"), method_14124, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::DetSet<RPRecoHit>,std::allocator<edm::DetSet<RPRecoHit> > > -------------------------------
static void constructor_8917( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >();
  else ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >();
}

static void constructor_8918( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >(*(const ::std::allocator<edm::DetSet<RPRecoHit> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >(*(const ::std::allocator<edm::DetSet<RPRecoHit> >*)arg[0]);
}

static void constructor_8919( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPRecoHit>*)arg[1]);
  else ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPRecoHit>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPRecoHit>*)arg[1],
      *(const ::std::allocator<edm::DetSet<RPRecoHit> >*)arg[2]);
  else ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPRecoHit>*)arg[1],
      *(const ::std::allocator<edm::DetSet<RPRecoHit> >*)arg[2]);
  }
}

static void constructor_8920( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >(*(const ::std::vector<edm::DetSet<RPRecoHit> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPRecoHit> >(*(const ::std::vector<edm::DetSet<RPRecoHit> >*)arg[0]);
}

static void destructor_8921(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::DetSet<RPRecoHit> >*)o)->::std::vector<edm::DetSet<RPRecoHit> >::~vector)();
}
static  void operator_8922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPRecoHit> >*)o)->operator=)(*(const ::std::vector<edm::DetSet<RPRecoHit> >*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->operator=)(*(const ::std::vector<edm::DetSet<RPRecoHit> >*)arg[0]);
}

static  void method_8923( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::DetSet<RPRecoHit>*)arg[1]);
}

static  void method_8924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((::std::vector<edm::DetSet<RPRecoHit> >*)o)->begin)());
  else   (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->begin)();
}

static  void method_8925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->begin)());
  else   (((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->begin)();
}

static  void method_8926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((::std::vector<edm::DetSet<RPRecoHit> >*)o)->end)());
  else   (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->end)();
}

static  void method_8927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->end)());
  else   (((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->end)();
}

static  void method_8932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->size)());
  else   (((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->size)();
}

static  void method_8933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->max_size)());
  else   (((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->max_size)();
}

static  void method_8934( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::DetSet<RPRecoHit>*)arg[1]);
  }
}

static  void method_8935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->capacity)());
  else   (((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->capacity)();
}

static  void method_8936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->empty)());
  else   (((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->empty)();
}

static  void method_8937( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPRecoHit> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPRecoHit> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPRecoHit> >*)o)->front)();
  else   (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->front)();
}

static  void method_8944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->front)();
  else   (((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->front)();
}

static  void method_8945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPRecoHit> >*)o)->back)();
  else   (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->back)();
}

static  void method_8946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->back)();
  else   (((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->back)();
}

static  void method_8947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::DetSet<RPRecoHit> >*)o)->data)());
  else   (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->data)();
}

static  void method_8948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->data)());
  else   (((const ::std::vector<edm::DetSet<RPRecoHit> >*)o)->data)();
}

static  void method_8949( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->push_back)(*(const ::edm::DetSet<RPRecoHit>*)arg[0]);
}

static  void method_8950( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->pop_back)();
}

static  void method_8951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((::std::vector<edm::DetSet<RPRecoHit> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >*)arg[0],
    *(const ::edm::DetSet<RPRecoHit>*)arg[1]));
  else   (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >*)arg[0],
    *(const ::edm::DetSet<RPRecoHit>*)arg[1]);
}

static  void method_8952( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::DetSet<RPRecoHit>*)arg[2]);
}

static  void method_8953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((::std::vector<edm::DetSet<RPRecoHit> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >*)arg[0]));
  else   (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >*)arg[0]);
}

static  void method_8954( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((::std::vector<edm::DetSet<RPRecoHit> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >*)arg[1]));
  else   (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >*)arg[1]);
}

static  void method_8955( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->swap)(*(::std::vector<edm::DetSet<RPRecoHit> >*)arg[0]);
}

static  void method_8956( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::DetSet<RPRecoHit> >*)o)->clear)();
}

static void method_newdel_2547( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPRecoHit> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPRecoHit> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPRecoHit> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPRecoHit> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPRecoHit> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x34( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::DetSet<RPRecoHit>,std::allocator<edm::DetSet<RPRecoHit> > >")), ::Reflex::BaseOffset< ::std::vector<edm::DetSet<RPRecoHit> >,::std::_Vector_base<edm::DetSet<RPRecoHit>,std::allocator<edm::DetSet<RPRecoHit> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::DetSet<RPRecoHit> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::DetSet<RPRecoHit> > >::Generate();
}

//------Dictionary for class vector<edm::DetSet<RPRecoHit>,std::allocator<edm::DetSet<RPRecoHit> > > -------------------------------
void __std__vector_edm__DetSet_RPRecoHit_s__db_datamem(Reflex::Class*);
void __std__vector_edm__DetSet_RPRecoHit_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__DetSet_RPRecoHit_s__datamem_bld(&__std__vector_edm__DetSet_RPRecoHit_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__DetSet_RPRecoHit_s__funcmem_bld(&__std__vector_edm__DetSet_RPRecoHit_s__db_funcmem);
void __std__vector_edm__DetSet_RPRecoHit_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >"), typeid(::std::vector<edm::DetSet<RPRecoHit> >), sizeof(::std::vector<edm::DetSet<RPRecoHit> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2184, ::Reflex::BaseOffset< ::std::vector<edm::DetSet<RPRecoHit> >, ::std::_Vector_base<edm::DetSet<RPRecoHit>,std::allocator<edm::DetSet<RPRecoHit> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3534, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::_Alloc_value_type"))
  .AddTypedef(type_2184, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::_Base"))
  .AddTypedef(type_2713, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::_Tp_alloc_type"))
  .AddTypedef(type_5322, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::_Alloc_traits"))
  .AddTypedef(type_3534, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::value_type"))
  .AddTypedef(type_6319, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::pointer"))
  .AddTypedef(type_8904, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::const_pointer"))
  .AddTypedef(type_8906, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::reference"))
  .AddTypedef(type_8908, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::const_reference"))
  .AddTypedef(type_5245, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::iterator"))
  .AddTypedef(type_5246, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::const_iterator"))
  .AddTypedef(type_2813, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::const_reverse_iterator"))
  .AddTypedef(type_2814, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::reverse_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::size_type"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::difference_type"))
  .AddTypedef(type_2713, Reflex::Literal("std::vector<edm::DetSet<RPRecoHit> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8917, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17908), Reflex::Literal("vector"), constructor_8918, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2691, type_8908, type_17908), Reflex::Literal("vector"), constructor_8919, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18582), Reflex::Literal("vector"), constructor_8920, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8921, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2547, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x34, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__DetSet_RPRecoHit_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::DetSet<RPRecoHit>,std::allocator<edm::DetSet<RPRecoHit> > > -------------------
void __std__vector_edm__DetSet_RPRecoHit_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::DetSet<RPRecoHit>,std::allocator<edm::DetSet<RPRecoHit> > > -------------------
void __std__vector_edm__DetSet_RPRecoHit_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18583, type_18582), Reflex::Literal("operator="), operator_8922, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_8908), Reflex::Literal("assign"), method_8923, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5245), Reflex::Literal("begin"), method_8924, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5246), Reflex::Literal("begin"), method_8925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5245), Reflex::Literal("end"), method_8926, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5246), Reflex::Literal("end"), method_8927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_8932, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("max_size"), method_8933, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_3534), Reflex::Literal("resize"), method_8934, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("capacity"), method_8935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_8936, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691), Reflex::Literal("reserve"), method_8937, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8906, type_2691), Reflex::Literal("operator[]"), operator_8938, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8908, type_2691), Reflex::Literal("operator[]"), operator_8939, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8906, type_2691), Reflex::Literal("at"), method_8941, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8908, type_2691), Reflex::Literal("at"), method_8942, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8906), Reflex::Literal("front"), method_8943, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8908), Reflex::Literal("front"), method_8944, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8906), Reflex::Literal("back"), method_8945, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8908), Reflex::Literal("back"), method_8946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6319), Reflex::Literal("data"), method_8947, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8904), Reflex::Literal("data"), method_8948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8908), Reflex::Literal("push_back"), method_8949, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("pop_back"), method_8950, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5245, type_5245, type_8908), Reflex::Literal("insert"), method_8951, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5245, type_2691, type_8908), Reflex::Literal("insert"), method_8952, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5245, type_5245), Reflex::Literal("erase"), method_8953, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5245, type_5245, type_5245), Reflex::Literal("erase"), method_8954, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_18583), Reflex::Literal("swap"), method_8955, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_8956, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class DetSet<RPStripDigi> -------------------------------
static void destructor_14134(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DetSet<RPStripDigi>*)o)->::edm::DetSet<RPStripDigi>::~DetSet)();
}
static  void operator_14135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSet<RPStripDigi>*)o)->operator=)(*(const ::edm::DetSet<RPStripDigi>*)arg[0]);
  else   (((::edm::DetSet<RPStripDigi>*)o)->operator=)(*(const ::edm::DetSet<RPStripDigi>*)arg[0]);
}

static void constructor_14136( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPStripDigi>(*(const ::edm::DetSet<RPStripDigi>*)arg[0]);
  else ::new(mem) ::edm::DetSet<RPStripDigi>(*(const ::edm::DetSet<RPStripDigi>*)arg[0]);
}

static void constructor_14137( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPStripDigi>();
  else ::new(mem) ::edm::DetSet<RPStripDigi>();
}

static void constructor_14138( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSet<RPStripDigi>(*(::edm::det_id_type*)arg[0]);
  else ::new(mem) ::edm::DetSet<RPStripDigi>(*(::edm::det_id_type*)arg[0]);
}

static  void method_14139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >)((((::edm::DetSet<RPStripDigi>*)o)->begin)());
  else   (((::edm::DetSet<RPStripDigi>*)o)->begin)();
}

static  void method_14140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >)((((::edm::DetSet<RPStripDigi>*)o)->end)());
  else   (((::edm::DetSet<RPStripDigi>*)o)->end)();
}

static  void method_14141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPStripDigi*,std::vector<RPStripDigi> >)((((const ::edm::DetSet<RPStripDigi>*)o)->begin)());
  else   (((const ::edm::DetSet<RPStripDigi>*)o)->begin)();
}

static  void method_14142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPStripDigi*,std::vector<RPStripDigi> >)((((const ::edm::DetSet<RPStripDigi>*)o)->end)());
  else   (((const ::edm::DetSet<RPStripDigi>*)o)->end)();
}

static  void method_14143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::DetSet<RPStripDigi>*)o)->size)());
  else   (((const ::edm::DetSet<RPStripDigi>*)o)->size)();
}

static  void method_14144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::DetSet<RPStripDigi>*)o)->empty)());
  else   (((const ::edm::DetSet<RPStripDigi>*)o)->empty)();
}

static  void operator_14145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSet<RPStripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::edm::DetSet<RPStripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::DetSet<RPStripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::edm::DetSet<RPStripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPStripDigi>*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_14148( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPStripDigi>*)o)->push_back)(*(const ::RPStripDigi*)arg[0]);
}

static  void method_14149( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::DetSet<RPStripDigi>*)o)->clear)();
}

static  void method_14150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSet<RPStripDigi>*)o)->swap)(*(::edm::DetSet<RPStripDigi>*)arg[0]);
}

static  void method_14151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::det_id_type)((((const ::edm::DetSet<RPStripDigi>*)o)->detId)());
  else   (((const ::edm::DetSet<RPStripDigi>*)o)->detId)();
}

static  void method_14152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::DetSet<RPStripDigi>*)o)->Class_Version)());
  else   (((::edm::DetSet<RPStripDigi>*)o)->Class_Version)();
}

static void method_newdel_3535( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPStripDigi> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPStripDigi> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPStripDigi> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPStripDigi> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DetSet<RPStripDigi> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DetSet<RPStripDigi> -------------------------------
void __edm__DetSet_RPStripDigi__db_datamem(Reflex::Class*);
void __edm__DetSet_RPStripDigi__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DetSet_RPStripDigi__datamem_bld(&__edm__DetSet_RPStripDigi__db_datamem);
Reflex::GenreflexMemberBuilder __edm__DetSet_RPStripDigi__funcmem_bld(&__edm__DetSet_RPStripDigi__db_funcmem);
void __edm__DetSet_RPStripDigi__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DetSet<RPStripDigi>"), typeid(::edm::DetSet<RPStripDigi>), sizeof(::edm::DetSet<RPStripDigi>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::DetSet<RPStripDigi>::Class_Version())
  .AddTypedef(type_2549, Reflex::Literal("edm::DetSet<RPStripDigi>::collection_type"))
  .AddTypedef(type_2071, Reflex::Literal("edm::DetSet<RPStripDigi>::value_type"))
  .AddTypedef(type_9036, Reflex::Literal("edm::DetSet<RPStripDigi>::reference"))
  .AddTypedef(type_5784, Reflex::Literal("edm::DetSet<RPStripDigi>::const_reference"))
  .AddTypedef(type_5250, Reflex::Literal("edm::DetSet<RPStripDigi>::iterator"))
  .AddTypedef(type_5251, Reflex::Literal("edm::DetSet<RPStripDigi>::const_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("edm::DetSet<RPStripDigi>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetSet"), destructor_14134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8971, type_8973), Reflex::Literal("operator="), operator_14135, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8973), Reflex::Literal("DetSet"), constructor_14136, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetSet"), constructor_14137, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3566), Reflex::Literal("DetSet"), constructor_14138, 0, "i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3535, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__DetSet_RPStripDigi__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__DetSet_RPStripDigi__funcmem_bld);
}

//------Delayed data member builder for class DetSet<RPStripDigi> -------------------
void __edm__DetSet_RPStripDigi__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3566, Reflex::Literal("id"), OffsetOf(__shadow__::__edm__DetSet_RPStripDigi_, id), ::Reflex::PUBLIC)
  .AddDataMember(type_2549, Reflex::Literal("data"), OffsetOf(__shadow__::__edm__DetSet_RPStripDigi_, data), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class DetSet<RPStripDigi> -------------------
void __edm__DetSet_RPStripDigi__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5250), Reflex::Literal("begin"), method_14139, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5250), Reflex::Literal("end"), method_14140, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5251), Reflex::Literal("begin"), method_14141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5251), Reflex::Literal("end"), method_14142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_14143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_14144, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9036, type_2691), Reflex::Literal("operator[]"), operator_14145, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5784, type_2691), Reflex::Literal("operator[]"), operator_14146, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_1833), Reflex::Literal("reserve"), method_14147, 0, "s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5784), Reflex::Literal("push_back"), method_14148, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_14149, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8971), Reflex::Literal("swap"), method_14150, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3566), Reflex::Literal("detId"), method_14151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_379), Reflex::Literal("Class_Version"), method_14152, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::DetSet<RPStripDigi>,std::allocator<edm::DetSet<RPStripDigi> > > -------------------------------
static void constructor_8982( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >();
  else ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >();
}

static void constructor_8983( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >(*(const ::std::allocator<edm::DetSet<RPStripDigi> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >(*(const ::std::allocator<edm::DetSet<RPStripDigi> >*)arg[0]);
}

static void constructor_8984( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPStripDigi>*)arg[1]);
  else ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPStripDigi>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPStripDigi>*)arg[1],
      *(const ::std::allocator<edm::DetSet<RPStripDigi> >*)arg[2]);
  else ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >(*(::std::size_t*)arg[0],
      *(const ::edm::DetSet<RPStripDigi>*)arg[1],
      *(const ::std::allocator<edm::DetSet<RPStripDigi> >*)arg[2]);
  }
}

static void constructor_8985( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >(*(const ::std::vector<edm::DetSet<RPStripDigi> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::DetSet<RPStripDigi> >(*(const ::std::vector<edm::DetSet<RPStripDigi> >*)arg[0]);
}

static void destructor_8986(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::DetSet<RPStripDigi> >*)o)->::std::vector<edm::DetSet<RPStripDigi> >::~vector)();
}
static  void operator_8987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPStripDigi> >*)o)->operator=)(*(const ::std::vector<edm::DetSet<RPStripDigi> >*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->operator=)(*(const ::std::vector<edm::DetSet<RPStripDigi> >*)arg[0]);
}

static  void method_8988( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::DetSet<RPStripDigi>*)arg[1]);
}

static  void method_8989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((::std::vector<edm::DetSet<RPStripDigi> >*)o)->begin)());
  else   (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->begin)();
}

static  void method_8990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->begin)());
  else   (((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->begin)();
}

static  void method_8991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((::std::vector<edm::DetSet<RPStripDigi> >*)o)->end)());
  else   (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->end)();
}

static  void method_8992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->end)());
  else   (((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->end)();
}

static  void method_8997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->size)());
  else   (((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->size)();
}

static  void method_8998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->max_size)());
  else   (((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->max_size)();
}

static  void method_8999( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::DetSet<RPStripDigi>*)arg[1]);
  }
}

static  void method_9000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->capacity)());
  else   (((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->capacity)();
}

static  void method_9001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->empty)());
  else   (((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->empty)();
}

static  void method_9002( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPStripDigi> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9004( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9006( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPStripDigi> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9007( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPStripDigi> >*)o)->front)();
  else   (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->front)();
}

static  void method_9009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->front)();
  else   (((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->front)();
}

static  void method_9010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::DetSet<RPStripDigi> >*)o)->back)();
  else   (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->back)();
}

static  void method_9011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->back)();
  else   (((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->back)();
}

static  void method_9012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::DetSet<RPStripDigi> >*)o)->data)());
  else   (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->data)();
}

static  void method_9013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->data)());
  else   (((const ::std::vector<edm::DetSet<RPStripDigi> >*)o)->data)();
}

static  void method_9014( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->push_back)(*(const ::edm::DetSet<RPStripDigi>*)arg[0]);
}

static  void method_9015( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->pop_back)();
}

static  void method_9016( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((::std::vector<edm::DetSet<RPStripDigi> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >*)arg[0],
    *(const ::edm::DetSet<RPStripDigi>*)arg[1]));
  else   (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >*)arg[0],
    *(const ::edm::DetSet<RPStripDigi>*)arg[1]);
}

static  void method_9017( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::DetSet<RPStripDigi>*)arg[2]);
}

static  void method_9018( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((::std::vector<edm::DetSet<RPStripDigi> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >*)arg[0]));
  else   (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >*)arg[0]);
}

static  void method_9019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((::std::vector<edm::DetSet<RPStripDigi> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >*)arg[1]));
  else   (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >*)arg[1]);
}

static  void method_9020( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->swap)(*(::std::vector<edm::DetSet<RPStripDigi> >*)arg[0]);
}

static  void method_9021( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::DetSet<RPStripDigi> >*)o)->clear)();
}

static void method_newdel_2548( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPStripDigi> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPStripDigi> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPStripDigi> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPStripDigi> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::DetSet<RPStripDigi> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x38( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::DetSet<RPStripDigi>,std::allocator<edm::DetSet<RPStripDigi> > >")), ::Reflex::BaseOffset< ::std::vector<edm::DetSet<RPStripDigi> >,::std::_Vector_base<edm::DetSet<RPStripDigi>,std::allocator<edm::DetSet<RPStripDigi> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::DetSet<RPStripDigi> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::DetSet<RPStripDigi> > >::Generate();
}

//------Dictionary for class vector<edm::DetSet<RPStripDigi>,std::allocator<edm::DetSet<RPStripDigi> > > -------------------------------
void __std__vector_edm__DetSet_RPStripDigi_s__db_datamem(Reflex::Class*);
void __std__vector_edm__DetSet_RPStripDigi_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__DetSet_RPStripDigi_s__datamem_bld(&__std__vector_edm__DetSet_RPStripDigi_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__DetSet_RPStripDigi_s__funcmem_bld(&__std__vector_edm__DetSet_RPStripDigi_s__db_funcmem);
void __std__vector_edm__DetSet_RPStripDigi_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >"), typeid(::std::vector<edm::DetSet<RPStripDigi> >), sizeof(::std::vector<edm::DetSet<RPStripDigi> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2186, ::Reflex::BaseOffset< ::std::vector<edm::DetSet<RPStripDigi> >, ::std::_Vector_base<edm::DetSet<RPStripDigi>,std::allocator<edm::DetSet<RPStripDigi> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3535, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::_Alloc_value_type"))
  .AddTypedef(type_2186, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::_Base"))
  .AddTypedef(type_2714, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::_Tp_alloc_type"))
  .AddTypedef(type_5324, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::_Alloc_traits"))
  .AddTypedef(type_3535, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::value_type"))
  .AddTypedef(type_6357, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::pointer"))
  .AddTypedef(type_8969, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::const_pointer"))
  .AddTypedef(type_8971, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::reference"))
  .AddTypedef(type_8973, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::const_reference"))
  .AddTypedef(type_5248, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::iterator"))
  .AddTypedef(type_5249, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::const_iterator"))
  .AddTypedef(type_2817, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::const_reverse_iterator"))
  .AddTypedef(type_2818, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::reverse_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::size_type"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::difference_type"))
  .AddTypedef(type_2714, Reflex::Literal("std::vector<edm::DetSet<RPStripDigi> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8982, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17934), Reflex::Literal("vector"), constructor_8983, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2691, type_8973, type_17934), Reflex::Literal("vector"), constructor_8984, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18585), Reflex::Literal("vector"), constructor_8985, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8986, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2548, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x38, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__DetSet_RPStripDigi_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::DetSet<RPStripDigi>,std::allocator<edm::DetSet<RPStripDigi> > > -------------------
void __std__vector_edm__DetSet_RPStripDigi_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::DetSet<RPStripDigi>,std::allocator<edm::DetSet<RPStripDigi> > > -------------------
void __std__vector_edm__DetSet_RPStripDigi_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18586, type_18585), Reflex::Literal("operator="), operator_8987, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_8973), Reflex::Literal("assign"), method_8988, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5248), Reflex::Literal("begin"), method_8989, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5249), Reflex::Literal("begin"), method_8990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5248), Reflex::Literal("end"), method_8991, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5249), Reflex::Literal("end"), method_8992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_8997, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("max_size"), method_8998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_3535), Reflex::Literal("resize"), method_8999, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("capacity"), method_9000, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_9001, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691), Reflex::Literal("reserve"), method_9002, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8971, type_2691), Reflex::Literal("operator[]"), operator_9003, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8973, type_2691), Reflex::Literal("operator[]"), operator_9004, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8971, type_2691), Reflex::Literal("at"), method_9006, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8973, type_2691), Reflex::Literal("at"), method_9007, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8971), Reflex::Literal("front"), method_9008, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8973), Reflex::Literal("front"), method_9009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8971), Reflex::Literal("back"), method_9010, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8973), Reflex::Literal("back"), method_9011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6357), Reflex::Literal("data"), method_9012, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8969), Reflex::Literal("data"), method_9013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8973), Reflex::Literal("push_back"), method_9014, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("pop_back"), method_9015, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5248, type_5248, type_8973), Reflex::Literal("insert"), method_9016, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5248, type_2691, type_8973), Reflex::Literal("insert"), method_9017, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5248, type_5248), Reflex::Literal("erase"), method_9018, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5248, type_5248, type_5248), Reflex::Literal("erase"), method_9019, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_18586), Reflex::Literal("swap"), method_9020, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_9021, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPStripDigi,std::allocator<RPStripDigi> > -------------------------------
static void constructor_9046( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStripDigi>();
  else ::new(mem) ::std::vector<RPStripDigi>();
}

static void constructor_9047( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStripDigi>(*(const ::std::allocator<RPStripDigi>*)arg[0]);
  else ::new(mem) ::std::vector<RPStripDigi>(*(const ::std::allocator<RPStripDigi>*)arg[0]);
}

static void constructor_9048( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStripDigi>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPStripDigi>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStripDigi>(*(::std::size_t*)arg[0],
      *(const ::RPStripDigi*)arg[1]);
  else ::new(mem) ::std::vector<RPStripDigi>(*(::std::size_t*)arg[0],
      *(const ::RPStripDigi*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStripDigi>(*(::std::size_t*)arg[0],
      *(const ::RPStripDigi*)arg[1],
      *(const ::std::allocator<RPStripDigi>*)arg[2]);
  else ::new(mem) ::std::vector<RPStripDigi>(*(::std::size_t*)arg[0],
      *(const ::RPStripDigi*)arg[1],
      *(const ::std::allocator<RPStripDigi>*)arg[2]);
  }
}

static void constructor_9049( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPStripDigi>(*(const ::std::vector<RPStripDigi>*)arg[0]);
  else ::new(mem) ::std::vector<RPStripDigi>(*(const ::std::vector<RPStripDigi>*)arg[0]);
}

static void destructor_9050(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPStripDigi>*)o)->::std::vector<RPStripDigi>::~vector)();
}
static  void operator_9051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPStripDigi>*)o)->operator=)(*(const ::std::vector<RPStripDigi>*)arg[0]);
  else   (((::std::vector<RPStripDigi>*)o)->operator=)(*(const ::std::vector<RPStripDigi>*)arg[0]);
}

static  void method_9052( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPStripDigi>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPStripDigi*)arg[1]);
}

static  void method_9053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >)((((::std::vector<RPStripDigi>*)o)->begin)());
  else   (((::std::vector<RPStripDigi>*)o)->begin)();
}

static  void method_9054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPStripDigi*,std::vector<RPStripDigi> >)((((const ::std::vector<RPStripDigi>*)o)->begin)());
  else   (((const ::std::vector<RPStripDigi>*)o)->begin)();
}

static  void method_9055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >)((((::std::vector<RPStripDigi>*)o)->end)());
  else   (((::std::vector<RPStripDigi>*)o)->end)();
}

static  void method_9056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPStripDigi*,std::vector<RPStripDigi> >)((((const ::std::vector<RPStripDigi>*)o)->end)());
  else   (((const ::std::vector<RPStripDigi>*)o)->end)();
}

static  void method_9061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPStripDigi>*)o)->size)());
  else   (((const ::std::vector<RPStripDigi>*)o)->size)();
}

static  void method_9062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPStripDigi>*)o)->max_size)());
  else   (((const ::std::vector<RPStripDigi>*)o)->max_size)();
}

static  void method_9063( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPStripDigi>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPStripDigi>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPStripDigi*)arg[1]);
  }
}

static  void method_9064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPStripDigi>*)o)->capacity)());
  else   (((const ::std::vector<RPStripDigi>*)o)->capacity)();
}

static  void method_9065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPStripDigi>*)o)->empty)());
  else   (((const ::std::vector<RPStripDigi>*)o)->empty)();
}

static  void method_9066( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPStripDigi>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPStripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPStripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPStripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPStripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPStripDigi>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPStripDigi>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPStripDigi>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPStripDigi>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPStripDigi>*)o)->front)();
  else   (((::std::vector<RPStripDigi>*)o)->front)();
}

static  void method_9073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPStripDigi>*)o)->front)();
  else   (((const ::std::vector<RPStripDigi>*)o)->front)();
}

static  void method_9074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPStripDigi>*)o)->back)();
  else   (((::std::vector<RPStripDigi>*)o)->back)();
}

static  void method_9075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPStripDigi>*)o)->back)();
  else   (((const ::std::vector<RPStripDigi>*)o)->back)();
}

static  void method_9076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPStripDigi>*)o)->data)());
  else   (((::std::vector<RPStripDigi>*)o)->data)();
}

static  void method_9077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPStripDigi>*)o)->data)());
  else   (((const ::std::vector<RPStripDigi>*)o)->data)();
}

static  void method_9078( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPStripDigi>*)o)->push_back)(*(const ::RPStripDigi*)arg[0]);
}

static  void method_9079( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPStripDigi>*)o)->pop_back)();
}

static  void method_9080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >)((((::std::vector<RPStripDigi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >*)arg[0],
    *(const ::RPStripDigi*)arg[1]));
  else   (((::std::vector<RPStripDigi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >*)arg[0],
    *(const ::RPStripDigi*)arg[1]);
}

static  void method_9081( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPStripDigi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPStripDigi*)arg[2]);
}

static  void method_9082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >)((((::std::vector<RPStripDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >*)arg[0]));
  else   (((::std::vector<RPStripDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >*)arg[0]);
}

static  void method_9083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >)((((::std::vector<RPStripDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >*)arg[1]));
  else   (((::std::vector<RPStripDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPStripDigi*,std::vector<RPStripDigi> >*)arg[1]);
}

static  void method_9084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPStripDigi>*)o)->swap)(*(::std::vector<RPStripDigi>*)arg[0]);
}

static  void method_9085( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPStripDigi>*)o)->clear)();
}

static void method_newdel_2549( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPStripDigi> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPStripDigi> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPStripDigi> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPStripDigi> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPStripDigi> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x41( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPStripDigi,std::allocator<RPStripDigi> >")), ::Reflex::BaseOffset< ::std::vector<RPStripDigi>,::std::_Vector_base<RPStripDigi,std::allocator<RPStripDigi> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPStripDigi> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPStripDigi> >::Generate();
}

//------Dictionary for class vector<RPStripDigi,std::allocator<RPStripDigi> > -------------------------------
void __std__vector_RPStripDigi__db_datamem(Reflex::Class*);
void __std__vector_RPStripDigi__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPStripDigi__datamem_bld(&__std__vector_RPStripDigi__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPStripDigi__funcmem_bld(&__std__vector_RPStripDigi__db_funcmem);
void __std__vector_RPStripDigi__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPStripDigi>"), typeid(::std::vector<RPStripDigi>), sizeof(::std::vector<RPStripDigi>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2187, ::Reflex::BaseOffset< ::std::vector<RPStripDigi>, ::std::_Vector_base<RPStripDigi,std::allocator<RPStripDigi> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2071, Reflex::Literal("std::vector<RPStripDigi>::_Alloc_value_type"))
  .AddTypedef(type_2187, Reflex::Literal("std::vector<RPStripDigi>::_Base"))
  .AddTypedef(type_2715, Reflex::Literal("std::vector<RPStripDigi>::_Tp_alloc_type"))
  .AddTypedef(type_5325, Reflex::Literal("std::vector<RPStripDigi>::_Alloc_traits"))
  .AddTypedef(type_2071, Reflex::Literal("std::vector<RPStripDigi>::value_type"))
  .AddTypedef(type_6376, Reflex::Literal("std::vector<RPStripDigi>::pointer"))
  .AddTypedef(type_9034, Reflex::Literal("std::vector<RPStripDigi>::const_pointer"))
  .AddTypedef(type_9036, Reflex::Literal("std::vector<RPStripDigi>::reference"))
  .AddTypedef(type_5784, Reflex::Literal("std::vector<RPStripDigi>::const_reference"))
  .AddTypedef(type_5250, Reflex::Literal("std::vector<RPStripDigi>::iterator"))
  .AddTypedef(type_5251, Reflex::Literal("std::vector<RPStripDigi>::const_iterator"))
  .AddTypedef(type_2819, Reflex::Literal("std::vector<RPStripDigi>::const_reverse_iterator"))
  .AddTypedef(type_2820, Reflex::Literal("std::vector<RPStripDigi>::reverse_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("std::vector<RPStripDigi>::size_type"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<RPStripDigi>::difference_type"))
  .AddTypedef(type_2715, Reflex::Literal("std::vector<RPStripDigi>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9046, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17947), Reflex::Literal("vector"), constructor_9047, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2691, type_5784, type_17947), Reflex::Literal("vector"), constructor_9048, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18587), Reflex::Literal("vector"), constructor_9049, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9050, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2549, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x41, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPStripDigi__funcmem_bld);
}

//------Delayed data member builder for class vector<RPStripDigi,std::allocator<RPStripDigi> > -------------------
void __std__vector_RPStripDigi__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPStripDigi,std::allocator<RPStripDigi> > -------------------
void __std__vector_RPStripDigi__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18588, type_18587), Reflex::Literal("operator="), operator_9051, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_5784), Reflex::Literal("assign"), method_9052, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5250), Reflex::Literal("begin"), method_9053, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5251), Reflex::Literal("begin"), method_9054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5250), Reflex::Literal("end"), method_9055, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5251), Reflex::Literal("end"), method_9056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_9061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("max_size"), method_9062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691, type_2071), Reflex::Literal("resize"), method_9063, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("capacity"), method_9064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_9065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_2691), Reflex::Literal("reserve"), method_9066, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9036, type_2691), Reflex::Literal("operator[]"), operator_9067, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5784, type_2691), Reflex::Literal("operator[]"), operator_9068, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9036, type_2691), Reflex::Literal("at"), method_9070, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5784, type_2691), Reflex::Literal("at"), method_9071, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9036), Reflex::Literal("front"), method_9072, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5784), Reflex::Literal("front"), method_9073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9036), Reflex::Literal("back"), method_9074, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5784), Reflex::Literal("back"), method_9075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6376), Reflex::Literal("data"), method_9076, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9034), Reflex::Literal("data"), method_9077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5784), Reflex::Literal("push_back"), method_9078, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("pop_back"), method_9079, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5250, type_5250, type_5784), Reflex::Literal("insert"), method_9080, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_5250, type_2691, type_5784), Reflex::Literal("insert"), method_9081, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5250, type_5250), Reflex::Literal("erase"), method_9082, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5250, type_5250, type_5250), Reflex::Literal("erase"), method_9083, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_18588), Reflex::Literal("swap"), method_9084, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("clear"), method_9085, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<std::vector<RPTimingDetectorHit, std::allocator<RPTimingDetectorHit> > > -------------------------------
static void constructor_13565( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPTimingDetectorHit> >();
  else ::new(mem) ::edm::Wrapper<std::vector<RPTimingDetectorHit> >();
}

static void constructor_13566( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPTimingDetectorHit> >(*(::std::auto_ptr<std::vector<RPTimingDetectorHit> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPTimingDetectorHit> >(*(::std::auto_ptr<std::vector<RPTimingDetectorHit> >*)arg[0]);
}

static void destructor_13567(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->::edm::Wrapper<std::vector<RPTimingDetectorHit> >::~Wrapper)();
}
static  void method_13568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->product)();
}

static  void operator_13569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->operator->)();
}

static  void method_13570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->productTypeInfo)();
}

static  void method_13571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->typeInfo)();
}

static void constructor_13572( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPTimingDetectorHit> >((::std::vector<RPTimingDetectorHit>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPTimingDetectorHit> >((::std::vector<RPTimingDetectorHit>*)arg[0]);
}

static  void method_13573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->getInterface)();
}

static  void method_13574( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13575( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13576( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->dynamicTypeInfo)();
}

static  void method_13578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->isPresent)();
}

static  void method_13579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<RPTimingDetectorHit> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3454( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPTimingDetectorHit> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPTimingDetectorHit> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPTimingDetectorHit> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPTimingDetectorHit> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPTimingDetectorHit> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<RPTimingDetectorHit, std::allocator<RPTimingDetectorHit> > > -------------------------------
void __edm__Wrapper_std__vector_RPTimingDetectorHit_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_RPTimingDetectorHit_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPTimingDetectorHit_s__datamem_bld(&__edm__Wrapper_std__vector_RPTimingDetectorHit_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPTimingDetectorHit_s__funcmem_bld(&__edm__Wrapper_std__vector_RPTimingDetectorHit_s__db_funcmem);
void __edm__Wrapper_std__vector_RPTimingDetectorHit_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPTimingDetectorHit> >"), typeid(::edm::Wrapper<std::vector<RPTimingDetectorHit> >), sizeof(::edm::Wrapper<std::vector<RPTimingDetectorHit> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2539, Reflex::Literal("edm::Wrapper<std::vector<RPTimingDetectorHit> >::value_type"))
  .AddTypedef(type_2539, Reflex::Literal("edm::Wrapper<std::vector<RPTimingDetectorHit> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13565, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2385), Reflex::Literal("Wrapper"), constructor_13566, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13567, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21087), Reflex::Literal("Wrapper"), constructor_13572, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3454, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_RPTimingDetectorHit_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_RPTimingDetectorHit_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<RPTimingDetectorHit, std::allocator<RPTimingDetectorHit> > > -------------------
void __edm__Wrapper_std__vector_RPTimingDetectorHit_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1368, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPTimingDetectorHit_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2539, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPTimingDetectorHit_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<RPTimingDetectorHit, std::allocator<RPTimingDetectorHit> > > -------------------
void __edm__Wrapper_std__vector_RPTimingDetectorHit_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21086), Reflex::Literal("product"), method_13568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21086), Reflex::Literal("operator->"), operator_13569, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("productTypeInfo"), method_13570, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("typeInfo"), method_13571, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21088), Reflex::Literal("getInterface"), method_13573, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_13739, type_18561, type_20960), Reflex::Literal("fillView"), method_13574, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_269, type_7075), Reflex::Literal("setPtr"), method_13575, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_18562, type_18561), Reflex::Literal("fillPtrVector"), method_13576, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo"), method_13577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("isPresent"), method_13578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo_"), method_13579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class DetSetVector<RPDigCluster> -------------------------------
static void destructor_13808(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DetSetVector<RPDigCluster>*)o)->::edm::DetSetVector<RPDigCluster>::~DetSetVector)();
}
static void constructor_13809( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPDigCluster>(*(const ::edm::DetSetVector<RPDigCluster>*)arg[0]);
  else ::new(mem) ::edm::DetSetVector<RPDigCluster>(*(const ::edm::DetSetVector<RPDigCluster>*)arg[0]);
}

static void constructor_13810( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPDigCluster>();
  else ::new(mem) ::edm::DetSetVector<RPDigCluster>();
}

static void constructor_13811( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPDigCluster>(*(::std::vector<edm::DetSet<RPDigCluster> >*)arg[0]);
  else ::new(mem) ::edm::DetSetVector<RPDigCluster>(*(::std::vector<edm::DetSet<RPDigCluster> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPDigCluster>(*(::std::vector<edm::DetSet<RPDigCluster> >*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::edm::DetSetVector<RPDigCluster>(*(::std::vector<edm::DetSet<RPDigCluster> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_13812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSetVector<RPDigCluster>*)o)->swap)(*(::edm::DetSetVector<RPDigCluster>*)arg[0]);
}

static  void operator_13813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPDigCluster>*)o)->operator=)(*(const ::edm::DetSetVector<RPDigCluster>*)arg[0]);
  else   (((::edm::DetSetVector<RPDigCluster>*)o)->operator=)(*(const ::edm::DetSetVector<RPDigCluster>*)arg[0]);
}

static  void method_13814( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSetVector<RPDigCluster>*)o)->insert)(*(const ::edm::DetSet<RPDigCluster>*)arg[0]);
}

static  void method_13815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPDigCluster>*)o)->find_or_insert)(*(::edm::det_id_type*)arg[0]);
  else   (((::edm::DetSetVector<RPDigCluster>*)o)->find_or_insert)(*(::edm::det_id_type*)arg[0]);
}

static  void method_13816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::DetSetVector<RPDigCluster>*)o)->empty)());
  else   (((const ::edm::DetSetVector<RPDigCluster>*)o)->empty)();
}

static  void method_13817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::DetSetVector<RPDigCluster>*)o)->size)());
  else   (((const ::edm::DetSetVector<RPDigCluster>*)o)->size)();
}

static  void method_13818( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((::edm::DetSetVector<RPDigCluster>*)o)->find)(*(::edm::det_id_type*)arg[0]));
  else   (((::edm::DetSetVector<RPDigCluster>*)o)->find)(*(::edm::det_id_type*)arg[0]);
}

static  void method_13819( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((const ::edm::DetSetVector<RPDigCluster>*)o)->find)(*(::edm::det_id_type*)arg[0]));
  else   (((const ::edm::DetSetVector<RPDigCluster>*)o)->find)(*(::edm::det_id_type*)arg[0]);
}

static  void operator_13820( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPDigCluster>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
  else   (((::edm::DetSetVector<RPDigCluster>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
}

static  void operator_13821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::DetSetVector<RPDigCluster>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
  else   (((const ::edm::DetSetVector<RPDigCluster>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
}

static  void method_13822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((::edm::DetSetVector<RPDigCluster>*)o)->begin)());
  else   (((::edm::DetSetVector<RPDigCluster>*)o)->begin)();
}

static  void method_13823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((const ::edm::DetSetVector<RPDigCluster>*)o)->begin)());
  else   (((const ::edm::DetSetVector<RPDigCluster>*)o)->begin)();
}

static  void method_13824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((::edm::DetSetVector<RPDigCluster>*)o)->end)());
  else   (((::edm::DetSetVector<RPDigCluster>*)o)->end)();
}

static  void method_13825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPDigCluster>*,std::vector<edm::DetSet<RPDigCluster> > >)((((const ::edm::DetSetVector<RPDigCluster>*)o)->end)());
  else   (((const ::edm::DetSetVector<RPDigCluster>*)o)->end)();
}

static  void method_13826( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::DetSetVector<RPDigCluster>*)o)->getIds)(*(::std::vector<unsigned int>*)arg[0]);
}

static  void method_13827( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::DetSetVector<RPDigCluster>*)o)->post_insert)();
}

static  void method_13828( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::DetSetVector<RPDigCluster>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_13829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::DetSetVector<RPDigCluster>*)o)->Class_Version)());
  else   (((::edm::DetSetVector<RPDigCluster>*)o)->Class_Version)();
}

static void method_newdel_3509( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPDigCluster> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPDigCluster> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPDigCluster> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPDigCluster> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPDigCluster> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x45( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::Other")), ::Reflex::BaseOffset< ::edm::DetSetVector<RPDigCluster>,::edm::Other >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DetSetVector<RPDigCluster> -------------------------------
void __edm__DetSetVector_RPDigCluster__db_datamem(Reflex::Class*);
void __edm__DetSetVector_RPDigCluster__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DetSetVector_RPDigCluster__datamem_bld(&__edm__DetSetVector_RPDigCluster__db_datamem);
Reflex::GenreflexMemberBuilder __edm__DetSetVector_RPDigCluster__funcmem_bld(&__edm__DetSetVector_RPDigCluster__db_funcmem);
void __edm__DetSetVector_RPDigCluster__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DetSetVector<RPDigCluster>"), typeid(::edm::DetSetVector<RPDigCluster>), sizeof(::edm::DetSetVector<RPDigCluster>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::DetSetVector<RPDigCluster>::Class_Version())
  .AddBase(type_3550, ::Reflex::BaseOffset< ::edm::DetSetVector<RPDigCluster>, ::edm::Other >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_13798, Reflex::Literal("edm::DetSetVector<RPDigCluster>::boost_concept_check95"))
  .AddTypedef(type_3532, Reflex::Literal("edm::DetSetVector<RPDigCluster>::detset"))
  .AddTypedef(type_3532, Reflex::Literal("edm::DetSetVector<RPDigCluster>::value_type"))
  .AddTypedef(type_2540, Reflex::Literal("edm::DetSetVector<RPDigCluster>::collection_type"))
  .AddTypedef(type_8520, Reflex::Literal("edm::DetSetVector<RPDigCluster>::reference"))
  .AddTypedef(type_8522, Reflex::Literal("edm::DetSetVector<RPDigCluster>::const_reference"))
  .AddTypedef(type_5234, Reflex::Literal("edm::DetSetVector<RPDigCluster>::iterator"))
  .AddTypedef(type_5235, Reflex::Literal("edm::DetSetVector<RPDigCluster>::const_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("edm::DetSetVector<RPDigCluster>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetSetVector"), destructor_13808, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21146), Reflex::Literal("DetSetVector"), constructor_13809, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetSetVector"), constructor_13810, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18568, type_1368), Reflex::Literal("DetSetVector"), constructor_13811, 0, "input;alreadySorted=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3509, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x45, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__DetSetVector_RPDigCluster__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__DetSetVector_RPDigCluster__funcmem_bld);
}

//------Delayed data member builder for class DetSetVector<RPDigCluster> -------------------
void __edm__DetSetVector_RPDigCluster__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2540, Reflex::Literal("_sets"), OffsetOf(__shadow__::__edm__DetSetVector_RPDigCluster_, _sets), ::Reflex::PRIVATE)
  .AddDataMember(type_3488, Reflex::Literal("_alreadySorted"), OffsetOf(__shadow__::__edm__DetSetVector_RPDigCluster_, _alreadySorted), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class DetSetVector<RPDigCluster> -------------------
void __edm__DetSetVector_RPDigCluster__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_21147), Reflex::Literal("swap"), method_13812, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21147, type_21146), Reflex::Literal("operator="), operator_13813, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8522), Reflex::Literal("insert"), method_13814, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8520, type_3566), Reflex::Literal("find_or_insert"), method_13815, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_13816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_13817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5234, type_3566), Reflex::Literal("find"), method_13818, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5235, type_3566), Reflex::Literal("find"), method_13819, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8520, type_3566), Reflex::Literal("operator[]"), operator_13820, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8522, type_3566), Reflex::Literal("operator[]"), operator_13821, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5234), Reflex::Literal("begin"), method_13822, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5235), Reflex::Literal("begin"), method_13823, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5234), Reflex::Literal("end"), method_13824, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5235), Reflex::Literal("end"), method_13825, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_10274), Reflex::Literal("getIds"), method_13826, 0, "result", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("post_insert"), method_13827, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_13739, type_18561, type_21148), Reflex::Literal("fillView"), method_13828, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_379), Reflex::Literal("Class_Version"), method_13829, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::DetSetVector<RPDigCluster> > -------------------------------
static void constructor_13586( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >();
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >();
}

static void constructor_13587( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >(*(::std::auto_ptr<edm::DetSetVector<RPDigCluster> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >(*(::std::auto_ptr<edm::DetSetVector<RPDigCluster> >*)arg[0]);
}

static void destructor_13588(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->::edm::Wrapper<edm::DetSetVector<RPDigCluster> >::~Wrapper)();
}
static  void method_13589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->product)();
}

static  void operator_13590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->operator->)();
}

static  void method_13591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->productTypeInfo)();
}

static  void method_13592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->typeInfo)();
}

static void constructor_13593( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >((::edm::DetSetVector<RPDigCluster>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >((::edm::DetSetVector<RPDigCluster>*)arg[0]);
}

static  void method_13594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->getInterface)();
}

static  void method_13595( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13596( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13597( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->dynamicTypeInfo)();
}

static  void method_13599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->isPresent)();
}

static  void method_13600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPDigCluster> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3455( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPDigCluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPDigCluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPDigCluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPDigCluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPDigCluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::DetSetVector<RPDigCluster> > -------------------------------
void __edm__Wrapper_edm__DetSetVector_RPDigCluster_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__DetSetVector_RPDigCluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSetVector_RPDigCluster_s__datamem_bld(&__edm__Wrapper_edm__DetSetVector_RPDigCluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSetVector_RPDigCluster_s__funcmem_bld(&__edm__Wrapper_edm__DetSetVector_RPDigCluster_s__db_funcmem);
void __edm__Wrapper_edm__DetSetVector_RPDigCluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPDigCluster> >"), typeid(::edm::Wrapper<edm::DetSetVector<RPDigCluster> >), sizeof(::edm::Wrapper<edm::DetSetVector<RPDigCluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3509, Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPDigCluster> >::value_type"))
  .AddTypedef(type_3509, Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPDigCluster> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13586, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2386), Reflex::Literal("Wrapper"), constructor_13587, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13588, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21092), Reflex::Literal("Wrapper"), constructor_13593, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3455, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__DetSetVector_RPDigCluster_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__DetSetVector_RPDigCluster_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::DetSetVector<RPDigCluster> > -------------------
void __edm__Wrapper_edm__DetSetVector_RPDigCluster_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1368, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSetVector_RPDigCluster_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3509, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSetVector_RPDigCluster_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::DetSetVector<RPDigCluster> > -------------------
void __edm__Wrapper_edm__DetSetVector_RPDigCluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21091), Reflex::Literal("product"), method_13589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21091), Reflex::Literal("operator->"), operator_13590, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("productTypeInfo"), method_13591, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("typeInfo"), method_13592, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21093), Reflex::Literal("getInterface"), method_13594, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_13739, type_18561, type_20960), Reflex::Literal("fillView"), method_13595, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_269, type_7075), Reflex::Literal("setPtr"), method_13596, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_18562, type_18561), Reflex::Literal("fillPtrVector"), method_13597, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo"), method_13598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("isPresent"), method_13599, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo_"), method_13600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class DetSetVector<RPDetTrigger> -------------------------------
static void destructor_13843(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DetSetVector<RPDetTrigger>*)o)->::edm::DetSetVector<RPDetTrigger>::~DetSetVector)();
}
static void constructor_13844( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPDetTrigger>(*(const ::edm::DetSetVector<RPDetTrigger>*)arg[0]);
  else ::new(mem) ::edm::DetSetVector<RPDetTrigger>(*(const ::edm::DetSetVector<RPDetTrigger>*)arg[0]);
}

static void constructor_13845( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPDetTrigger>();
  else ::new(mem) ::edm::DetSetVector<RPDetTrigger>();
}

static void constructor_13846( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPDetTrigger>(*(::std::vector<edm::DetSet<RPDetTrigger> >*)arg[0]);
  else ::new(mem) ::edm::DetSetVector<RPDetTrigger>(*(::std::vector<edm::DetSet<RPDetTrigger> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPDetTrigger>(*(::std::vector<edm::DetSet<RPDetTrigger> >*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::edm::DetSetVector<RPDetTrigger>(*(::std::vector<edm::DetSet<RPDetTrigger> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_13847( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSetVector<RPDetTrigger>*)o)->swap)(*(::edm::DetSetVector<RPDetTrigger>*)arg[0]);
}

static  void operator_13848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPDetTrigger>*)o)->operator=)(*(const ::edm::DetSetVector<RPDetTrigger>*)arg[0]);
  else   (((::edm::DetSetVector<RPDetTrigger>*)o)->operator=)(*(const ::edm::DetSetVector<RPDetTrigger>*)arg[0]);
}

static  void method_13849( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSetVector<RPDetTrigger>*)o)->insert)(*(const ::edm::DetSet<RPDetTrigger>*)arg[0]);
}

static  void method_13850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPDetTrigger>*)o)->find_or_insert)(*(::edm::det_id_type*)arg[0]);
  else   (((::edm::DetSetVector<RPDetTrigger>*)o)->find_or_insert)(*(::edm::det_id_type*)arg[0]);
}

static  void method_13851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::DetSetVector<RPDetTrigger>*)o)->empty)());
  else   (((const ::edm::DetSetVector<RPDetTrigger>*)o)->empty)();
}

static  void method_13852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::DetSetVector<RPDetTrigger>*)o)->size)());
  else   (((const ::edm::DetSetVector<RPDetTrigger>*)o)->size)();
}

static  void method_13853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((::edm::DetSetVector<RPDetTrigger>*)o)->find)(*(::edm::det_id_type*)arg[0]));
  else   (((::edm::DetSetVector<RPDetTrigger>*)o)->find)(*(::edm::det_id_type*)arg[0]);
}

static  void method_13854( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((const ::edm::DetSetVector<RPDetTrigger>*)o)->find)(*(::edm::det_id_type*)arg[0]));
  else   (((const ::edm::DetSetVector<RPDetTrigger>*)o)->find)(*(::edm::det_id_type*)arg[0]);
}

static  void operator_13855( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPDetTrigger>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
  else   (((::edm::DetSetVector<RPDetTrigger>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
}

static  void operator_13856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::DetSetVector<RPDetTrigger>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
  else   (((const ::edm::DetSetVector<RPDetTrigger>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
}

static  void method_13857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((::edm::DetSetVector<RPDetTrigger>*)o)->begin)());
  else   (((::edm::DetSetVector<RPDetTrigger>*)o)->begin)();
}

static  void method_13858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((const ::edm::DetSetVector<RPDetTrigger>*)o)->begin)());
  else   (((const ::edm::DetSetVector<RPDetTrigger>*)o)->begin)();
}

static  void method_13859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((::edm::DetSetVector<RPDetTrigger>*)o)->end)());
  else   (((::edm::DetSetVector<RPDetTrigger>*)o)->end)();
}

static  void method_13860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPDetTrigger>*,std::vector<edm::DetSet<RPDetTrigger> > >)((((const ::edm::DetSetVector<RPDetTrigger>*)o)->end)());
  else   (((const ::edm::DetSetVector<RPDetTrigger>*)o)->end)();
}

static  void method_13861( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::DetSetVector<RPDetTrigger>*)o)->getIds)(*(::std::vector<unsigned int>*)arg[0]);
}

static  void method_13862( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::DetSetVector<RPDetTrigger>*)o)->post_insert)();
}

static  void method_13863( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::DetSetVector<RPDetTrigger>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_13864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::DetSetVector<RPDetTrigger>*)o)->Class_Version)());
  else   (((::edm::DetSetVector<RPDetTrigger>*)o)->Class_Version)();
}

static void method_newdel_3510( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPDetTrigger> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPDetTrigger> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPDetTrigger> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPDetTrigger> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPDetTrigger> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x48( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::Other")), ::Reflex::BaseOffset< ::edm::DetSetVector<RPDetTrigger>,::edm::Other >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DetSetVector<RPDetTrigger> -------------------------------
void __edm__DetSetVector_RPDetTrigger__db_datamem(Reflex::Class*);
void __edm__DetSetVector_RPDetTrigger__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DetSetVector_RPDetTrigger__datamem_bld(&__edm__DetSetVector_RPDetTrigger__db_datamem);
Reflex::GenreflexMemberBuilder __edm__DetSetVector_RPDetTrigger__funcmem_bld(&__edm__DetSetVector_RPDetTrigger__db_funcmem);
void __edm__DetSetVector_RPDetTrigger__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DetSetVector<RPDetTrigger>"), typeid(::edm::DetSetVector<RPDetTrigger>), sizeof(::edm::DetSetVector<RPDetTrigger>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::DetSetVector<RPDetTrigger>::Class_Version())
  .AddBase(type_3550, ::Reflex::BaseOffset< ::edm::DetSetVector<RPDetTrigger>, ::edm::Other >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_13833, Reflex::Literal("edm::DetSetVector<RPDetTrigger>::boost_concept_check95"))
  .AddTypedef(type_3533, Reflex::Literal("edm::DetSetVector<RPDetTrigger>::detset"))
  .AddTypedef(type_3533, Reflex::Literal("edm::DetSetVector<RPDetTrigger>::value_type"))
  .AddTypedef(type_2543, Reflex::Literal("edm::DetSetVector<RPDetTrigger>::collection_type"))
  .AddTypedef(type_8649, Reflex::Literal("edm::DetSetVector<RPDetTrigger>::reference"))
  .AddTypedef(type_8651, Reflex::Literal("edm::DetSetVector<RPDetTrigger>::const_reference"))
  .AddTypedef(type_5238, Reflex::Literal("edm::DetSetVector<RPDetTrigger>::iterator"))
  .AddTypedef(type_5239, Reflex::Literal("edm::DetSetVector<RPDetTrigger>::const_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("edm::DetSetVector<RPDetTrigger>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetSetVector"), destructor_13843, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21149), Reflex::Literal("DetSetVector"), constructor_13844, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetSetVector"), constructor_13845, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18573, type_1368), Reflex::Literal("DetSetVector"), constructor_13846, 0, "input;alreadySorted=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3510, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x48, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__DetSetVector_RPDetTrigger__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__DetSetVector_RPDetTrigger__funcmem_bld);
}

//------Delayed data member builder for class DetSetVector<RPDetTrigger> -------------------
void __edm__DetSetVector_RPDetTrigger__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2543, Reflex::Literal("_sets"), OffsetOf(__shadow__::__edm__DetSetVector_RPDetTrigger_, _sets), ::Reflex::PRIVATE)
  .AddDataMember(type_3488, Reflex::Literal("_alreadySorted"), OffsetOf(__shadow__::__edm__DetSetVector_RPDetTrigger_, _alreadySorted), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class DetSetVector<RPDetTrigger> -------------------
void __edm__DetSetVector_RPDetTrigger__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_21150), Reflex::Literal("swap"), method_13847, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21150, type_21149), Reflex::Literal("operator="), operator_13848, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8651), Reflex::Literal("insert"), method_13849, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8649, type_3566), Reflex::Literal("find_or_insert"), method_13850, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_13851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_13852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5238, type_3566), Reflex::Literal("find"), method_13853, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5239, type_3566), Reflex::Literal("find"), method_13854, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8649, type_3566), Reflex::Literal("operator[]"), operator_13855, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8651, type_3566), Reflex::Literal("operator[]"), operator_13856, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5238), Reflex::Literal("begin"), method_13857, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5239), Reflex::Literal("begin"), method_13858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5238), Reflex::Literal("end"), method_13859, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5239), Reflex::Literal("end"), method_13860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_10274), Reflex::Literal("getIds"), method_13861, 0, "result", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("post_insert"), method_13862, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_13739, type_18561, type_21148), Reflex::Literal("fillView"), method_13863, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_379), Reflex::Literal("Class_Version"), method_13864, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::DetSetVector<RPDetTrigger> > -------------------------------
static void constructor_13607( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >();
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >();
}

static void constructor_13608( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >(*(::std::auto_ptr<edm::DetSetVector<RPDetTrigger> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >(*(::std::auto_ptr<edm::DetSetVector<RPDetTrigger> >*)arg[0]);
}

static void destructor_13609(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >::~Wrapper)();
}
static  void method_13610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->product)();
}

static  void operator_13611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->operator->)();
}

static  void method_13612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->productTypeInfo)();
}

static  void method_13613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->typeInfo)();
}

static void constructor_13614( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >((::edm::DetSetVector<RPDetTrigger>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >((::edm::DetSetVector<RPDetTrigger>*)arg[0]);
}

static  void method_13615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->getInterface)();
}

static  void method_13616( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13617( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13618( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->dynamicTypeInfo)();
}

static  void method_13620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->isPresent)();
}

static  void method_13621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3456( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPDetTrigger> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::DetSetVector<RPDetTrigger> > -------------------------------
void __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__datamem_bld(&__edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__funcmem_bld(&__edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__db_funcmem);
void __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPDetTrigger> >"), typeid(::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >), sizeof(::edm::Wrapper<edm::DetSetVector<RPDetTrigger> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3510, Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPDetTrigger> >::value_type"))
  .AddTypedef(type_3510, Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPDetTrigger> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13607, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2387), Reflex::Literal("Wrapper"), constructor_13608, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13609, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21097), Reflex::Literal("Wrapper"), constructor_13614, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3456, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::DetSetVector<RPDetTrigger> > -------------------
void __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1368, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSetVector_RPDetTrigger_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3510, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSetVector_RPDetTrigger_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::DetSetVector<RPDetTrigger> > -------------------
void __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21096), Reflex::Literal("product"), method_13610, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21096), Reflex::Literal("operator->"), operator_13611, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("productTypeInfo"), method_13612, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("typeInfo"), method_13613, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21098), Reflex::Literal("getInterface"), method_13615, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_13739, type_18561, type_20960), Reflex::Literal("fillView"), method_13616, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_269, type_7075), Reflex::Literal("setPtr"), method_13617, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_18562, type_18561), Reflex::Literal("fillPtrVector"), method_13618, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo"), method_13619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("isPresent"), method_13620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo_"), method_13621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::DetSet<RPDetTrigger> > -------------------------------
static void constructor_13628( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSet<RPDetTrigger> >();
  else ::new(mem) ::edm::Wrapper<edm::DetSet<RPDetTrigger> >();
}

static void constructor_13629( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSet<RPDetTrigger> >(*(::std::auto_ptr<edm::DetSet<RPDetTrigger> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSet<RPDetTrigger> >(*(::std::auto_ptr<edm::DetSet<RPDetTrigger> >*)arg[0]);
}

static void destructor_13630(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->::edm::Wrapper<edm::DetSet<RPDetTrigger> >::~Wrapper)();
}
static  void method_13631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->product)();
}

static  void operator_13632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->operator->)();
}

static  void method_13633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->productTypeInfo)();
}

static  void method_13634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->typeInfo)();
}

static void constructor_13635( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSet<RPDetTrigger> >((::edm::DetSet<RPDetTrigger>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSet<RPDetTrigger> >((::edm::DetSet<RPDetTrigger>*)arg[0]);
}

static  void method_13636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->getInterface)();
}

static  void method_13637( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13638( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13639( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->dynamicTypeInfo)();
}

static  void method_13641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->isPresent)();
}

static  void method_13642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::DetSet<RPDetTrigger> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3457( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSet<RPDetTrigger> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSet<RPDetTrigger> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSet<RPDetTrigger> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSet<RPDetTrigger> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSet<RPDetTrigger> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::DetSet<RPDetTrigger> > -------------------------------
void __edm__Wrapper_edm__DetSet_RPDetTrigger_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__DetSet_RPDetTrigger_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSet_RPDetTrigger_s__datamem_bld(&__edm__Wrapper_edm__DetSet_RPDetTrigger_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSet_RPDetTrigger_s__funcmem_bld(&__edm__Wrapper_edm__DetSet_RPDetTrigger_s__db_funcmem);
void __edm__Wrapper_edm__DetSet_RPDetTrigger_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::DetSet<RPDetTrigger> >"), typeid(::edm::Wrapper<edm::DetSet<RPDetTrigger> >), sizeof(::edm::Wrapper<edm::DetSet<RPDetTrigger> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3533, Reflex::Literal("edm::Wrapper<edm::DetSet<RPDetTrigger> >::value_type"))
  .AddTypedef(type_3533, Reflex::Literal("edm::Wrapper<edm::DetSet<RPDetTrigger> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13628, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2388), Reflex::Literal("Wrapper"), constructor_13629, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13630, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6262), Reflex::Literal("Wrapper"), constructor_13635, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3457, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__DetSet_RPDetTrigger_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__DetSet_RPDetTrigger_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::DetSet<RPDetTrigger> > -------------------
void __edm__Wrapper_edm__DetSet_RPDetTrigger_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1368, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSet_RPDetTrigger_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3533, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSet_RPDetTrigger_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::DetSet<RPDetTrigger> > -------------------
void __edm__Wrapper_edm__DetSet_RPDetTrigger_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8647), Reflex::Literal("product"), method_13631, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8647), Reflex::Literal("operator->"), operator_13632, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("productTypeInfo"), method_13633, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("typeInfo"), method_13634, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21101), Reflex::Literal("getInterface"), method_13636, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_13739, type_18561, type_20960), Reflex::Literal("fillView"), method_13637, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_269, type_7075), Reflex::Literal("setPtr"), method_13638, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_18562, type_18561), Reflex::Literal("fillPtrVector"), method_13639, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo"), method_13640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("isPresent"), method_13641, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo_"), method_13642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class DetSetVector<RPRecoHit> -------------------------------
static void destructor_13878(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DetSetVector<RPRecoHit>*)o)->::edm::DetSetVector<RPRecoHit>::~DetSetVector)();
}
static void constructor_13879( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPRecoHit>(*(const ::edm::DetSetVector<RPRecoHit>*)arg[0]);
  else ::new(mem) ::edm::DetSetVector<RPRecoHit>(*(const ::edm::DetSetVector<RPRecoHit>*)arg[0]);
}

static void constructor_13880( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPRecoHit>();
  else ::new(mem) ::edm::DetSetVector<RPRecoHit>();
}

static void constructor_13881( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPRecoHit>(*(::std::vector<edm::DetSet<RPRecoHit> >*)arg[0]);
  else ::new(mem) ::edm::DetSetVector<RPRecoHit>(*(::std::vector<edm::DetSet<RPRecoHit> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPRecoHit>(*(::std::vector<edm::DetSet<RPRecoHit> >*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::edm::DetSetVector<RPRecoHit>(*(::std::vector<edm::DetSet<RPRecoHit> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_13882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSetVector<RPRecoHit>*)o)->swap)(*(::edm::DetSetVector<RPRecoHit>*)arg[0]);
}

static  void operator_13883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPRecoHit>*)o)->operator=)(*(const ::edm::DetSetVector<RPRecoHit>*)arg[0]);
  else   (((::edm::DetSetVector<RPRecoHit>*)o)->operator=)(*(const ::edm::DetSetVector<RPRecoHit>*)arg[0]);
}

static  void method_13884( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSetVector<RPRecoHit>*)o)->insert)(*(const ::edm::DetSet<RPRecoHit>*)arg[0]);
}

static  void method_13885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPRecoHit>*)o)->find_or_insert)(*(::edm::det_id_type*)arg[0]);
  else   (((::edm::DetSetVector<RPRecoHit>*)o)->find_or_insert)(*(::edm::det_id_type*)arg[0]);
}

static  void method_13886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::DetSetVector<RPRecoHit>*)o)->empty)());
  else   (((const ::edm::DetSetVector<RPRecoHit>*)o)->empty)();
}

static  void method_13887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::DetSetVector<RPRecoHit>*)o)->size)());
  else   (((const ::edm::DetSetVector<RPRecoHit>*)o)->size)();
}

static  void method_13888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((::edm::DetSetVector<RPRecoHit>*)o)->find)(*(::edm::det_id_type*)arg[0]));
  else   (((::edm::DetSetVector<RPRecoHit>*)o)->find)(*(::edm::det_id_type*)arg[0]);
}

static  void method_13889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((const ::edm::DetSetVector<RPRecoHit>*)o)->find)(*(::edm::det_id_type*)arg[0]));
  else   (((const ::edm::DetSetVector<RPRecoHit>*)o)->find)(*(::edm::det_id_type*)arg[0]);
}

static  void operator_13890( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPRecoHit>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
  else   (((::edm::DetSetVector<RPRecoHit>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
}

static  void operator_13891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::DetSetVector<RPRecoHit>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
  else   (((const ::edm::DetSetVector<RPRecoHit>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
}

static  void method_13892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((::edm::DetSetVector<RPRecoHit>*)o)->begin)());
  else   (((::edm::DetSetVector<RPRecoHit>*)o)->begin)();
}

static  void method_13893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((const ::edm::DetSetVector<RPRecoHit>*)o)->begin)());
  else   (((const ::edm::DetSetVector<RPRecoHit>*)o)->begin)();
}

static  void method_13894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((::edm::DetSetVector<RPRecoHit>*)o)->end)());
  else   (((::edm::DetSetVector<RPRecoHit>*)o)->end)();
}

static  void method_13895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPRecoHit>*,std::vector<edm::DetSet<RPRecoHit> > >)((((const ::edm::DetSetVector<RPRecoHit>*)o)->end)());
  else   (((const ::edm::DetSetVector<RPRecoHit>*)o)->end)();
}

static  void method_13896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::DetSetVector<RPRecoHit>*)o)->getIds)(*(::std::vector<unsigned int>*)arg[0]);
}

static  void method_13897( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::DetSetVector<RPRecoHit>*)o)->post_insert)();
}

static  void method_13898( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::DetSetVector<RPRecoHit>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_13899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::DetSetVector<RPRecoHit>*)o)->Class_Version)());
  else   (((::edm::DetSetVector<RPRecoHit>*)o)->Class_Version)();
}

static void method_newdel_3511( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPRecoHit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPRecoHit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPRecoHit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPRecoHit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPRecoHit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x52( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::Other")), ::Reflex::BaseOffset< ::edm::DetSetVector<RPRecoHit>,::edm::Other >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DetSetVector<RPRecoHit> -------------------------------
void __edm__DetSetVector_RPRecoHit__db_datamem(Reflex::Class*);
void __edm__DetSetVector_RPRecoHit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DetSetVector_RPRecoHit__datamem_bld(&__edm__DetSetVector_RPRecoHit__db_datamem);
Reflex::GenreflexMemberBuilder __edm__DetSetVector_RPRecoHit__funcmem_bld(&__edm__DetSetVector_RPRecoHit__db_funcmem);
void __edm__DetSetVector_RPRecoHit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DetSetVector<RPRecoHit>"), typeid(::edm::DetSetVector<RPRecoHit>), sizeof(::edm::DetSetVector<RPRecoHit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::DetSetVector<RPRecoHit>::Class_Version())
  .AddBase(type_3550, ::Reflex::BaseOffset< ::edm::DetSetVector<RPRecoHit>, ::edm::Other >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_13868, Reflex::Literal("edm::DetSetVector<RPRecoHit>::boost_concept_check95"))
  .AddTypedef(type_3534, Reflex::Literal("edm::DetSetVector<RPRecoHit>::detset"))
  .AddTypedef(type_3534, Reflex::Literal("edm::DetSetVector<RPRecoHit>::value_type"))
  .AddTypedef(type_2547, Reflex::Literal("edm::DetSetVector<RPRecoHit>::collection_type"))
  .AddTypedef(type_8906, Reflex::Literal("edm::DetSetVector<RPRecoHit>::reference"))
  .AddTypedef(type_8908, Reflex::Literal("edm::DetSetVector<RPRecoHit>::const_reference"))
  .AddTypedef(type_5245, Reflex::Literal("edm::DetSetVector<RPRecoHit>::iterator"))
  .AddTypedef(type_5246, Reflex::Literal("edm::DetSetVector<RPRecoHit>::const_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("edm::DetSetVector<RPRecoHit>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetSetVector"), destructor_13878, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21151), Reflex::Literal("DetSetVector"), constructor_13879, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetSetVector"), constructor_13880, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18583, type_1368), Reflex::Literal("DetSetVector"), constructor_13881, 0, "input;alreadySorted=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3511, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x52, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__DetSetVector_RPRecoHit__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__DetSetVector_RPRecoHit__funcmem_bld);
}

//------Delayed data member builder for class DetSetVector<RPRecoHit> -------------------
void __edm__DetSetVector_RPRecoHit__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2547, Reflex::Literal("_sets"), OffsetOf(__shadow__::__edm__DetSetVector_RPRecoHit_, _sets), ::Reflex::PRIVATE)
  .AddDataMember(type_3488, Reflex::Literal("_alreadySorted"), OffsetOf(__shadow__::__edm__DetSetVector_RPRecoHit_, _alreadySorted), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class DetSetVector<RPRecoHit> -------------------
void __edm__DetSetVector_RPRecoHit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_21152), Reflex::Literal("swap"), method_13882, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21152, type_21151), Reflex::Literal("operator="), operator_13883, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8908), Reflex::Literal("insert"), method_13884, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8906, type_3566), Reflex::Literal("find_or_insert"), method_13885, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_13886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_13887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5245, type_3566), Reflex::Literal("find"), method_13888, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5246, type_3566), Reflex::Literal("find"), method_13889, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8906, type_3566), Reflex::Literal("operator[]"), operator_13890, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8908, type_3566), Reflex::Literal("operator[]"), operator_13891, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5245), Reflex::Literal("begin"), method_13892, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5246), Reflex::Literal("begin"), method_13893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5245), Reflex::Literal("end"), method_13894, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5246), Reflex::Literal("end"), method_13895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_10274), Reflex::Literal("getIds"), method_13896, 0, "result", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("post_insert"), method_13897, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_13739, type_18561, type_21148), Reflex::Literal("fillView"), method_13898, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_379), Reflex::Literal("Class_Version"), method_13899, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::DetSetVector<RPRecoHit> > -------------------------------
static void constructor_13649( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >();
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >();
}

static void constructor_13650( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >(*(::std::auto_ptr<edm::DetSetVector<RPRecoHit> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >(*(::std::auto_ptr<edm::DetSetVector<RPRecoHit> >*)arg[0]);
}

static void destructor_13651(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->::edm::Wrapper<edm::DetSetVector<RPRecoHit> >::~Wrapper)();
}
static  void method_13652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->product)();
}

static  void operator_13653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->operator->)();
}

static  void method_13654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->productTypeInfo)();
}

static  void method_13655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->typeInfo)();
}

static void constructor_13656( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >((::edm::DetSetVector<RPRecoHit>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >((::edm::DetSetVector<RPRecoHit>*)arg[0]);
}

static  void method_13657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->getInterface)();
}

static  void method_13658( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13659( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13660( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->dynamicTypeInfo)();
}

static  void method_13662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->isPresent)();
}

static  void method_13663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPRecoHit> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3458( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPRecoHit> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPRecoHit> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPRecoHit> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPRecoHit> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPRecoHit> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::DetSetVector<RPRecoHit> > -------------------------------
void __edm__Wrapper_edm__DetSetVector_RPRecoHit_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__DetSetVector_RPRecoHit_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSetVector_RPRecoHit_s__datamem_bld(&__edm__Wrapper_edm__DetSetVector_RPRecoHit_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSetVector_RPRecoHit_s__funcmem_bld(&__edm__Wrapper_edm__DetSetVector_RPRecoHit_s__db_funcmem);
void __edm__Wrapper_edm__DetSetVector_RPRecoHit_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPRecoHit> >"), typeid(::edm::Wrapper<edm::DetSetVector<RPRecoHit> >), sizeof(::edm::Wrapper<edm::DetSetVector<RPRecoHit> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3511, Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPRecoHit> >::value_type"))
  .AddTypedef(type_3511, Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPRecoHit> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13649, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2389), Reflex::Literal("Wrapper"), constructor_13650, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13651, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21105), Reflex::Literal("Wrapper"), constructor_13656, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3458, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__DetSetVector_RPRecoHit_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__DetSetVector_RPRecoHit_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::DetSetVector<RPRecoHit> > -------------------
void __edm__Wrapper_edm__DetSetVector_RPRecoHit_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1368, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSetVector_RPRecoHit_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3511, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSetVector_RPRecoHit_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::DetSetVector<RPRecoHit> > -------------------
void __edm__Wrapper_edm__DetSetVector_RPRecoHit_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21104), Reflex::Literal("product"), method_13652, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21104), Reflex::Literal("operator->"), operator_13653, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("productTypeInfo"), method_13654, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("typeInfo"), method_13655, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21106), Reflex::Literal("getInterface"), method_13657, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_13739, type_18561, type_20960), Reflex::Literal("fillView"), method_13658, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_269, type_7075), Reflex::Literal("setPtr"), method_13659, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_18562, type_18561), Reflex::Literal("fillPtrVector"), method_13660, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo"), method_13661, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("isPresent"), method_13662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo_"), method_13663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class DetSetVector<RPStripDigi> -------------------------------
static void destructor_13913(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DetSetVector<RPStripDigi>*)o)->::edm::DetSetVector<RPStripDigi>::~DetSetVector)();
}
static void constructor_13914( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPStripDigi>(*(const ::edm::DetSetVector<RPStripDigi>*)arg[0]);
  else ::new(mem) ::edm::DetSetVector<RPStripDigi>(*(const ::edm::DetSetVector<RPStripDigi>*)arg[0]);
}

static void constructor_13915( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPStripDigi>();
  else ::new(mem) ::edm::DetSetVector<RPStripDigi>();
}

static void constructor_13916( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPStripDigi>(*(::std::vector<edm::DetSet<RPStripDigi> >*)arg[0]);
  else ::new(mem) ::edm::DetSetVector<RPStripDigi>(*(::std::vector<edm::DetSet<RPStripDigi> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DetSetVector<RPStripDigi>(*(::std::vector<edm::DetSet<RPStripDigi> >*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::edm::DetSetVector<RPStripDigi>(*(::std::vector<edm::DetSet<RPStripDigi> >*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_13917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSetVector<RPStripDigi>*)o)->swap)(*(::edm::DetSetVector<RPStripDigi>*)arg[0]);
}

static  void operator_13918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPStripDigi>*)o)->operator=)(*(const ::edm::DetSetVector<RPStripDigi>*)arg[0]);
  else   (((::edm::DetSetVector<RPStripDigi>*)o)->operator=)(*(const ::edm::DetSetVector<RPStripDigi>*)arg[0]);
}

static  void method_13919( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DetSetVector<RPStripDigi>*)o)->insert)(*(const ::edm::DetSet<RPStripDigi>*)arg[0]);
}

static  void method_13920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPStripDigi>*)o)->find_or_insert)(*(::edm::det_id_type*)arg[0]);
  else   (((::edm::DetSetVector<RPStripDigi>*)o)->find_or_insert)(*(::edm::det_id_type*)arg[0]);
}

static  void method_13921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::DetSetVector<RPStripDigi>*)o)->empty)());
  else   (((const ::edm::DetSetVector<RPStripDigi>*)o)->empty)();
}

static  void method_13922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::DetSetVector<RPStripDigi>*)o)->size)());
  else   (((const ::edm::DetSetVector<RPStripDigi>*)o)->size)();
}

static  void method_13923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((::edm::DetSetVector<RPStripDigi>*)o)->find)(*(::edm::det_id_type*)arg[0]));
  else   (((::edm::DetSetVector<RPStripDigi>*)o)->find)(*(::edm::det_id_type*)arg[0]);
}

static  void method_13924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((const ::edm::DetSetVector<RPStripDigi>*)o)->find)(*(::edm::det_id_type*)arg[0]));
  else   (((const ::edm::DetSetVector<RPStripDigi>*)o)->find)(*(::edm::det_id_type*)arg[0]);
}

static  void operator_13925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DetSetVector<RPStripDigi>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
  else   (((::edm::DetSetVector<RPStripDigi>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
}

static  void operator_13926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::DetSetVector<RPStripDigi>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
  else   (((const ::edm::DetSetVector<RPStripDigi>*)o)->operator[])(*(::edm::det_id_type*)arg[0]);
}

static  void method_13927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((::edm::DetSetVector<RPStripDigi>*)o)->begin)());
  else   (((::edm::DetSetVector<RPStripDigi>*)o)->begin)();
}

static  void method_13928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((const ::edm::DetSetVector<RPStripDigi>*)o)->begin)());
  else   (((const ::edm::DetSetVector<RPStripDigi>*)o)->begin)();
}

static  void method_13929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((::edm::DetSetVector<RPStripDigi>*)o)->end)());
  else   (((::edm::DetSetVector<RPStripDigi>*)o)->end)();
}

static  void method_13930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::DetSet<RPStripDigi>*,std::vector<edm::DetSet<RPStripDigi> > >)((((const ::edm::DetSetVector<RPStripDigi>*)o)->end)());
  else   (((const ::edm::DetSetVector<RPStripDigi>*)o)->end)();
}

static  void method_13931( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::DetSetVector<RPStripDigi>*)o)->getIds)(*(::std::vector<unsigned int>*)arg[0]);
}

static  void method_13932( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::DetSetVector<RPStripDigi>*)o)->post_insert)();
}

static  void method_13933( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::DetSetVector<RPStripDigi>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_13934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::DetSetVector<RPStripDigi>*)o)->Class_Version)());
  else   (((::edm::DetSetVector<RPStripDigi>*)o)->Class_Version)();
}

static void method_newdel_3512( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPStripDigi> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPStripDigi> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPStripDigi> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPStripDigi> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DetSetVector<RPStripDigi> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x55( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::Other")), ::Reflex::BaseOffset< ::edm::DetSetVector<RPStripDigi>,::edm::Other >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DetSetVector<RPStripDigi> -------------------------------
void __edm__DetSetVector_RPStripDigi__db_datamem(Reflex::Class*);
void __edm__DetSetVector_RPStripDigi__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DetSetVector_RPStripDigi__datamem_bld(&__edm__DetSetVector_RPStripDigi__db_datamem);
Reflex::GenreflexMemberBuilder __edm__DetSetVector_RPStripDigi__funcmem_bld(&__edm__DetSetVector_RPStripDigi__db_funcmem);
void __edm__DetSetVector_RPStripDigi__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DetSetVector<RPStripDigi>"), typeid(::edm::DetSetVector<RPStripDigi>), sizeof(::edm::DetSetVector<RPStripDigi>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::DetSetVector<RPStripDigi>::Class_Version())
  .AddBase(type_3550, ::Reflex::BaseOffset< ::edm::DetSetVector<RPStripDigi>, ::edm::Other >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_13903, Reflex::Literal("edm::DetSetVector<RPStripDigi>::boost_concept_check95"))
  .AddTypedef(type_3535, Reflex::Literal("edm::DetSetVector<RPStripDigi>::detset"))
  .AddTypedef(type_3535, Reflex::Literal("edm::DetSetVector<RPStripDigi>::value_type"))
  .AddTypedef(type_2548, Reflex::Literal("edm::DetSetVector<RPStripDigi>::collection_type"))
  .AddTypedef(type_8971, Reflex::Literal("edm::DetSetVector<RPStripDigi>::reference"))
  .AddTypedef(type_8973, Reflex::Literal("edm::DetSetVector<RPStripDigi>::const_reference"))
  .AddTypedef(type_5248, Reflex::Literal("edm::DetSetVector<RPStripDigi>::iterator"))
  .AddTypedef(type_5249, Reflex::Literal("edm::DetSetVector<RPStripDigi>::const_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("edm::DetSetVector<RPStripDigi>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetSetVector"), destructor_13913, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21153), Reflex::Literal("DetSetVector"), constructor_13914, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetSetVector"), constructor_13915, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18586, type_1368), Reflex::Literal("DetSetVector"), constructor_13916, 0, "input;alreadySorted=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3512, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x55, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__DetSetVector_RPStripDigi__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__DetSetVector_RPStripDigi__funcmem_bld);
}

//------Delayed data member builder for class DetSetVector<RPStripDigi> -------------------
void __edm__DetSetVector_RPStripDigi__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2548, Reflex::Literal("_sets"), OffsetOf(__shadow__::__edm__DetSetVector_RPStripDigi_, _sets), ::Reflex::PRIVATE)
  .AddDataMember(type_3488, Reflex::Literal("_alreadySorted"), OffsetOf(__shadow__::__edm__DetSetVector_RPStripDigi_, _alreadySorted), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class DetSetVector<RPStripDigi> -------------------
void __edm__DetSetVector_RPStripDigi__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_21154), Reflex::Literal("swap"), method_13917, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21154, type_21153), Reflex::Literal("operator="), operator_13918, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_8973), Reflex::Literal("insert"), method_13919, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8971, type_3566), Reflex::Literal("find_or_insert"), method_13920, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("empty"), method_13921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2691), Reflex::Literal("size"), method_13922, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5248, type_3566), Reflex::Literal("find"), method_13923, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5249, type_3566), Reflex::Literal("find"), method_13924, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8971, type_3566), Reflex::Literal("operator[]"), operator_13925, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8973, type_3566), Reflex::Literal("operator[]"), operator_13926, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5248), Reflex::Literal("begin"), method_13927, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5249), Reflex::Literal("begin"), method_13928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5248), Reflex::Literal("end"), method_13929, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5249), Reflex::Literal("end"), method_13930, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_10274), Reflex::Literal("getIds"), method_13931, 0, "result", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584), Reflex::Literal("post_insert"), method_13932, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_13739, type_18561, type_21148), Reflex::Literal("fillView"), method_13933, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_379), Reflex::Literal("Class_Version"), method_13934, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::DetSetVector<RPStripDigi> > -------------------------------
static void constructor_13670( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >();
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >();
}

static void constructor_13671( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >(*(::std::auto_ptr<edm::DetSetVector<RPStripDigi> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >(*(::std::auto_ptr<edm::DetSetVector<RPStripDigi> >*)arg[0]);
}

static void destructor_13672(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->::edm::Wrapper<edm::DetSetVector<RPStripDigi> >::~Wrapper)();
}
static  void method_13673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->product)();
}

static  void operator_13674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->operator->)();
}

static  void method_13675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->productTypeInfo)();
}

static  void method_13676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->typeInfo)();
}

static void constructor_13677( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >((::edm::DetSetVector<RPStripDigi>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >((::edm::DetSetVector<RPStripDigi>*)arg[0]);
}

static  void method_13678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->getInterface)();
}

static  void method_13679( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13680( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13681( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->dynamicTypeInfo)();
}

static  void method_13683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->isPresent)();
}

static  void method_13684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::DetSetVector<RPStripDigi> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3459( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPStripDigi> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPStripDigi> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPStripDigi> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPStripDigi> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSetVector<RPStripDigi> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::DetSetVector<RPStripDigi> > -------------------------------
void __edm__Wrapper_edm__DetSetVector_RPStripDigi_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__DetSetVector_RPStripDigi_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSetVector_RPStripDigi_s__datamem_bld(&__edm__Wrapper_edm__DetSetVector_RPStripDigi_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSetVector_RPStripDigi_s__funcmem_bld(&__edm__Wrapper_edm__DetSetVector_RPStripDigi_s__db_funcmem);
void __edm__Wrapper_edm__DetSetVector_RPStripDigi_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPStripDigi> >"), typeid(::edm::Wrapper<edm::DetSetVector<RPStripDigi> >), sizeof(::edm::Wrapper<edm::DetSetVector<RPStripDigi> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3512, Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPStripDigi> >::value_type"))
  .AddTypedef(type_3512, Reflex::Literal("edm::Wrapper<edm::DetSetVector<RPStripDigi> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13670, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2390), Reflex::Literal("Wrapper"), constructor_13671, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13672, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21110), Reflex::Literal("Wrapper"), constructor_13677, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3459, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__DetSetVector_RPStripDigi_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__DetSetVector_RPStripDigi_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::DetSetVector<RPStripDigi> > -------------------
void __edm__Wrapper_edm__DetSetVector_RPStripDigi_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1368, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSetVector_RPStripDigi_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3512, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSetVector_RPStripDigi_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::DetSetVector<RPStripDigi> > -------------------
void __edm__Wrapper_edm__DetSetVector_RPStripDigi_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21109), Reflex::Literal("product"), method_13673, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21109), Reflex::Literal("operator->"), operator_13674, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("productTypeInfo"), method_13675, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("typeInfo"), method_13676, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21111), Reflex::Literal("getInterface"), method_13678, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_13739, type_18561, type_20960), Reflex::Literal("fillView"), method_13679, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_269, type_7075), Reflex::Literal("setPtr"), method_13680, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_18562, type_18561), Reflex::Literal("fillPtrVector"), method_13681, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo"), method_13682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("isPresent"), method_13683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo_"), method_13684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::DetSet<RPStripDigi> > -------------------------------
static void constructor_13691( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSet<RPStripDigi> >();
  else ::new(mem) ::edm::Wrapper<edm::DetSet<RPStripDigi> >();
}

static void constructor_13692( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSet<RPStripDigi> >(*(::std::auto_ptr<edm::DetSet<RPStripDigi> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSet<RPStripDigi> >(*(::std::auto_ptr<edm::DetSet<RPStripDigi> >*)arg[0]);
}

static void destructor_13693(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->::edm::Wrapper<edm::DetSet<RPStripDigi> >::~Wrapper)();
}
static  void method_13694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->product)();
}

static  void operator_13695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->operator->)();
}

static  void method_13696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->productTypeInfo)();
}

static  void method_13697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->typeInfo)();
}

static void constructor_13698( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DetSet<RPStripDigi> >((::edm::DetSet<RPStripDigi>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DetSet<RPStripDigi> >((::edm::DetSet<RPStripDigi>*)arg[0]);
}

static  void method_13699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->getInterface)();
}

static  void method_13700( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13701( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13702( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->dynamicTypeInfo)();
}

static  void method_13704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->isPresent)();
}

static  void method_13705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::DetSet<RPStripDigi> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3460( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSet<RPStripDigi> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSet<RPStripDigi> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSet<RPStripDigi> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSet<RPStripDigi> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DetSet<RPStripDigi> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::DetSet<RPStripDigi> > -------------------------------
void __edm__Wrapper_edm__DetSet_RPStripDigi_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__DetSet_RPStripDigi_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSet_RPStripDigi_s__datamem_bld(&__edm__Wrapper_edm__DetSet_RPStripDigi_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DetSet_RPStripDigi_s__funcmem_bld(&__edm__Wrapper_edm__DetSet_RPStripDigi_s__db_funcmem);
void __edm__Wrapper_edm__DetSet_RPStripDigi_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::DetSet<RPStripDigi> >"), typeid(::edm::Wrapper<edm::DetSet<RPStripDigi> >), sizeof(::edm::Wrapper<edm::DetSet<RPStripDigi> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3535, Reflex::Literal("edm::Wrapper<edm::DetSet<RPStripDigi> >::value_type"))
  .AddTypedef(type_3535, Reflex::Literal("edm::Wrapper<edm::DetSet<RPStripDigi> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13691, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2391), Reflex::Literal("Wrapper"), constructor_13692, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13693, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6357), Reflex::Literal("Wrapper"), constructor_13698, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3460, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__DetSet_RPStripDigi_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__DetSet_RPStripDigi_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::DetSet<RPStripDigi> > -------------------
void __edm__Wrapper_edm__DetSet_RPStripDigi_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1368, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSet_RPStripDigi_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3535, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__DetSet_RPStripDigi_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::DetSet<RPStripDigi> > -------------------
void __edm__Wrapper_edm__DetSet_RPStripDigi_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8969), Reflex::Literal("product"), method_13694, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8969), Reflex::Literal("operator->"), operator_13695, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("productTypeInfo"), method_13696, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("typeInfo"), method_13697, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21114), Reflex::Literal("getInterface"), method_13699, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_13739, type_18561, type_20960), Reflex::Literal("fillView"), method_13700, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_269, type_7075), Reflex::Literal("setPtr"), method_13701, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_584, type_11984, type_18562, type_18561), Reflex::Literal("fillPtrVector"), method_13702, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo"), method_13703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1368), Reflex::Literal("isPresent"), method_13704, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11984), Reflex::Literal("dynamicTypeInfo_"), method_13705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const RPRecoHit*,std::vector<RPRecoHit, std::allocator<RPRecoHit> > > -------------------------------
static void destructor_15431(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >::~__normal_iterator)();
}
static  void operator_15432( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)arg[0]);
}

static void constructor_15433( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >(*(const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >(*(const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)arg[0]);
}

static void constructor_15434( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >();
}

static void constructor_15435( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >(*(const ::RPRecoHit* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >(*(const ::RPRecoHit* const*)arg[0]);
}

static  void operator_15436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator*)();
}

static  void operator_15437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator->)();
}

static  void operator_15438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator++)();
}

static  void operator_15439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >)((((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_15440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator--)();
}

static  void operator_15441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >)((((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_15442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_15443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_15444( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >)((((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_15445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_15446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >)((((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_15447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >*)o)->base)();
}

static void method_newdel_5242( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const RPRecoHit*,std::vector<RPRecoHit, std::allocator<RPRecoHit> > > -------------------------------
void ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__datamem_bld(&____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__funcmem_bld(&____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >"), typeid(::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >), sizeof(::__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2217, Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >::__traits_type"))
  .AddTypedef(type_6863, Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >::iterator_type"))
  .AddTypedef(type_2260, Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >::iterator_category"))
  .AddTypedef(type_2007, Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >::value_type"))
  .AddTypedef(type_2625, Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >::difference_type"))
  .AddTypedef(type_5781, Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >::reference"))
  .AddTypedef(type_6863, Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_15431, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21470, type_18552), Reflex::Literal("operator="), operator_15432, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18552), Reflex::Literal("__normal_iterator"), constructor_15433, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_15434, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8843), Reflex::Literal("__normal_iterator"), constructor_15435, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5242, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const RPRecoHit*,std::vector<RPRecoHit, std::allocator<RPRecoHit> > > -------------------
void ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6863, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const RPRecoHit*,std::vector<RPRecoHit, std::allocator<RPRecoHit> > > -------------------
void ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5781), Reflex::Literal("operator*"), operator_15436, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6863), Reflex::Literal("operator->"), operator_15437, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21470), Reflex::Literal("operator++"), operator_15438, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5242, type_67), Reflex::Literal("operator++"), operator_15439, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21470), Reflex::Literal("operator--"), operator_15440, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5242, type_67), Reflex::Literal("operator--"), operator_15441, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5781, type_21471), Reflex::Literal("operator[]"), operator_15442, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21470, type_21471), Reflex::Literal("operator+="), operator_15443, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5242, type_21471), Reflex::Literal("operator+"), operator_15444, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21470, type_21471), Reflex::Literal("operator-="), operator_15445, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5242, type_21471), Reflex::Literal("operator-"), operator_15446, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8843), Reflex::Literal("base"), method_15447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __RPDetTrigger_dict(); 
      __RPDigCluster_dict(); 
      __RPTimingDetectorHit_dict(); 
      __RPRecoHit_dict(); 
      __RPStripDigi_dict(); 
      __std__pair___gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s_s__dict(); 
      __std__vector_RPTimingDetectorHit__dict(); 
      __edm__DetSet_RPDigCluster__dict(); 
      __std__vector_edm__DetSet_RPDigCluster_s__dict(); 
      __std__vector_RPDigCluster__dict(); 
      __edm__DetSet_RPDetTrigger__dict(); 
      __std__vector_edm__DetSet_RPDetTrigger_s__dict(); 
      __std__vector_RPDetTrigger__dict(); 
      __std__vector_RPRecoHit__dict(); 
      __std__vector_constsRPRecoHitp__dict(); 
      __edm__DetSet_RPRecoHit__dict(); 
      __std__vector_edm__DetSet_RPRecoHit_s__dict(); 
      __edm__DetSet_RPStripDigi__dict(); 
      __std__vector_edm__DetSet_RPStripDigi_s__dict(); 
      __std__vector_RPStripDigi__dict(); 
      __edm__Wrapper_std__vector_RPTimingDetectorHit_s__dict(); 
      __edm__DetSetVector_RPDigCluster__dict(); 
      __edm__Wrapper_edm__DetSetVector_RPDigCluster_s__dict(); 
      __edm__DetSetVector_RPDetTrigger__dict(); 
      __edm__Wrapper_edm__DetSetVector_RPDetTrigger_s__dict(); 
      __edm__Wrapper_edm__DetSet_RPDetTrigger_s__dict(); 
      __edm__DetSetVector_RPRecoHit__dict(); 
      __edm__Wrapper_edm__DetSetVector_RPRecoHit_s__dict(); 
      __edm__DetSetVector_RPStripDigi__dict(); 
      __edm__Wrapper_edm__DetSetVector_RPStripDigi_s__dict(); 
      __edm__Wrapper_edm__DetSet_RPStripDigi_s__dict(); 
      ____gnu_cxx____normal_iterator_constsRPRecoHitp_std__vector_RPRecoHit_s__dict(); 
    }
    ~Dictionaries() {
      type_1150.Unload(); // class RPDetTrigger 
      type_1373.Unload(); // class RPDigCluster 
      type_1474.Unload(); // class RPTimingDetectorHit 
      type_2007.Unload(); // class RPRecoHit 
      type_2071.Unload(); // class RPStripDigi 
      type_2517.Unload(); // class std::pair<__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> >,__gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > > 
      type_2539.Unload(); // class std::vector<RPTimingDetectorHit> 
      type_3532.Unload(); // class edm::DetSet<RPDigCluster> 
      type_2540.Unload(); // class std::vector<edm::DetSet<RPDigCluster> > 
      type_2542.Unload(); // class std::vector<RPDigCluster> 
      type_3533.Unload(); // class edm::DetSet<RPDetTrigger> 
      type_2543.Unload(); // class std::vector<edm::DetSet<RPDetTrigger> > 
      type_2544.Unload(); // class std::vector<RPDetTrigger> 
      type_2545.Unload(); // class std::vector<RPRecoHit> 
      type_2546.Unload(); // class std::vector<const RPRecoHit*> 
      type_3534.Unload(); // class edm::DetSet<RPRecoHit> 
      type_2547.Unload(); // class std::vector<edm::DetSet<RPRecoHit> > 
      type_3535.Unload(); // class edm::DetSet<RPStripDigi> 
      type_2548.Unload(); // class std::vector<edm::DetSet<RPStripDigi> > 
      type_2549.Unload(); // class std::vector<RPStripDigi> 
      type_3454.Unload(); // class edm::Wrapper<std::vector<RPTimingDetectorHit> > 
      type_3509.Unload(); // class edm::DetSetVector<RPDigCluster> 
      type_3455.Unload(); // class edm::Wrapper<edm::DetSetVector<RPDigCluster> > 
      type_3510.Unload(); // class edm::DetSetVector<RPDetTrigger> 
      type_3456.Unload(); // class edm::Wrapper<edm::DetSetVector<RPDetTrigger> > 
      type_3457.Unload(); // class edm::Wrapper<edm::DetSet<RPDetTrigger> > 
      type_3511.Unload(); // class edm::DetSetVector<RPRecoHit> 
      type_3458.Unload(); // class edm::Wrapper<edm::DetSetVector<RPRecoHit> > 
      type_3512.Unload(); // class edm::DetSetVector<RPStripDigi> 
      type_3459.Unload(); // class edm::Wrapper<edm::DetSetVector<RPStripDigi> > 
      type_3460.Unload(); // class edm::Wrapper<edm::DetSet<RPStripDigi> > 
      type_5242.Unload(); // class __gnu_cxx::__normal_iterator<const RPRecoHit*,std::vector<RPRecoHit> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
