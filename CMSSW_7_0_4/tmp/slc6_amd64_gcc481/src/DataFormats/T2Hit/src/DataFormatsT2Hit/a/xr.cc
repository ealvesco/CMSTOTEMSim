// Generated at Mon Jul 11 23:12:59 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/T2Hit/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_69 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_10 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_578 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_754 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1372 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_99 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1379 = ::Reflex::TypeBuilder(Reflex::Literal("T2Hit"));
  ::Reflex::Type type_1712 = ::Reflex::TypeBuilder(Reflex::Literal("hit_entry"));
  ::Reflex::Type type_278 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_271 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_394 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3584 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2297 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<long>"));
  ::Reflex::Type type_268 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T2Hit>"));
  ::Reflex::Type type_2550 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long>"));
  ::Reflex::Type type_1780 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<long,int>"));
  ::Reflex::Type type_2521 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<long,long>"));
  ::Reflex::Type type_2721 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<T2Hit>"));
  ::Reflex::Type type_2555 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<hit_entry>"));
  ::Reflex::Type type_2548 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2729 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<hit_entry>"));
  ::Reflex::Type type_2518 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const long,int>"));
  ::Reflex::Type type_2556 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<cluster_entry>"));
  ::Reflex::Type type_2549 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_741 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<long,std::vector<long> >"));
  ::Reflex::Type type_2298 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<std::pair<long,long> >"));
  ::Reflex::Type type_2551 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::map<long,int> >"));
  ::Reflex::Type type_2554 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<T2Hit> >"));
  ::Reflex::Type type_3476 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<long,int> >"));
  ::Reflex::Type type_3479 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<T2Hit> >"));
  ::Reflex::Type type_2388 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<long,int> >"));
  ::Reflex::Type type_2391 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<T2Hit> >"));
  ::Reflex::Type type_2519 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const long,std::vector<long> >"));
  ::Reflex::Type type_2717 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const long,int> >"));
  ::Reflex::Type type_3508 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<long,int> >"));
  ::Reflex::Type type_3511 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<T2Hit> >"));
  ::Reflex::Type type_967 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::pair<long,long>,unsigned long>"));
  ::Reflex::Type type_1142 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::map<long,int> > >"));
  ::Reflex::Type type_1474 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::vector<T2Hit> > >"));
  ::Reflex::Type type_2166 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2Hit,std::allocator<T2Hit> >"));
  ::Reflex::Type type_2552 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::map<long,std::vector<long> > >"));
  ::Reflex::Type type_2392 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<std::map<long,int> > >"));
  ::Reflex::Type type_2395 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<std::vector<T2Hit> > >"));
  ::Reflex::Type type_3477 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<long,std::vector<long> > >"));
  ::Reflex::Type type_3125 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<T2Hit> >"));
  ::Reflex::Type type_2389 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<long,std::vector<long> > >"));
  ::Reflex::Type type_2606 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const long,int> >"));
  ::Reflex::Type type_2520 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::pair<long,long>,unsigned long>"));
  ::Reflex::Type type_5463 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<hit_entry> >"));
  ::Reflex::Type type_3400 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_2167 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<hit_entry,std::allocator<hit_entry> >"));
  ::Reflex::Type type_3136 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >"));
  ::Reflex::Type type_2702 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const long,int> >"));
  ::Reflex::Type type_3512 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<std::map<long,int> > >"));
  ::Reflex::Type type_3515 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<std::vector<T2Hit> > >"));
  ::Reflex::Type type_2718 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const long,std::vector<long> > >"));
  ::Reflex::Type type_3509 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<long,std::vector<long> > >"));
  ::Reflex::Type type_2553 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::map<std::pair<long,long>,unsigned long> >"));
  ::Reflex::Type type_3478 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >"));
  ::Reflex::Type type_2390 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<std::pair<long,long>,unsigned long> >"));
  ::Reflex::Type type_1499 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >"));
  ::Reflex::Type type_3138 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const T2Hit*,std::vector<T2Hit> >"));
  ::Reflex::Type type_2393 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<std::map<long,std::vector<long> > > >"));
  ::Reflex::Type type_5389 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >"));
  ::Reflex::Type type_2607 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >"));
  ::Reflex::Type type_2524 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const long,int> >,bool>"));
  ::Reflex::Type type_2720 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::pair<long,long>,unsigned long> >"));
  ::Reflex::Type type_3510 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<std::pair<long,long>,unsigned long> >"));
  ::Reflex::Type type_5390 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const hit_entry*,std::vector<hit_entry> >"));
  ::Reflex::Type type_2703 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const long,std::vector<long> > >"));
  ::Reflex::Type type_3513 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<std::map<long,std::vector<long> > > >"));
  ::Reflex::Type type_1053 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >"));
  ::Reflex::Type type_2824 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const long,int> > >"));
  ::Reflex::Type type_2394 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<std::map<std::pair<long,long>,unsigned long> > >"));
  ::Reflex::Type type_2608 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >"));
  ::Reflex::Type type_2836 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> > >"));
  ::Reflex::Type type_2823 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const long,int> > >"));
  ::Reflex::Type type_2528 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >,bool>"));
  ::Reflex::Type type_2704 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::pair<long,long>,unsigned long> >"));
  ::Reflex::Type type_3514 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<std::map<std::pair<long,long>,unsigned long> > >"));
  ::Reflex::Type type_2835 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const T2Hit*,std::vector<T2Hit> > >"));
  ::Reflex::Type type_2838 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> > >"));
  ::Reflex::Type type_2828 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > > >"));
  ::Reflex::Type type_2531 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >,bool>"));
  ::Reflex::Type type_2837 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const hit_entry*,std::vector<hit_entry> > >"));
  ::Reflex::Type type_2827 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const long,std::vector<long> > > >"));
  ::Reflex::Type type_2832 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> > >"));
  ::Reflex::Type type_2831 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::pair<long,long>,unsigned long> > >"));
  ::Reflex::Type type_2523 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const long,int> >,std::_Rb_tree_iterator<std::pair<const long,int> > >"));
  ::Reflex::Type type_2522 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const long,int> >,std::_Rb_tree_const_iterator<std::pair<const long,int> > >"));
  ::Reflex::Type type_2527 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >,std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > > >"));
  ::Reflex::Type type_2346 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<long,std::pair<const long,int>,std::_Select1st<std::pair<const long,int> >,std::less<long>,std::allocator<std::pair<const long,int> > >"));
  ::Reflex::Type type_2526 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const long,std::vector<long> > >,std::_Rb_tree_const_iterator<std::pair<const long,std::vector<long> > > >"));
  ::Reflex::Type type_2530 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >,std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> > >"));
  ::Reflex::Type type_2529 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::pair<long,long>,unsigned long> >,std::_Rb_tree_const_iterator<std::pair<const std::pair<long,long>,unsigned long> > >"));
  ::Reflex::Type type_2347 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<long,std::pair<const long,std::vector<long> >,std::_Select1st<std::pair<const long,std::vector<long> > >,std::less<long>,std::allocator<std::pair<const long,std::vector<long> > > >"));
  ::Reflex::Type type_2348 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::pair<long,long>,std::pair<const std::pair<long,long>,unsigned long>,std::_Select1st<std::pair<const std::pair<long,long>,unsigned long> >,std::less<std::pair<long,long> >,std::allocator<std::pair<const std::pair<long,long>,unsigned long> > >"));
  ::Reflex::Type type_269 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2HitCollection"), type_268);
  ::Reflex::Type type_742 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2PadStripAssociator"), type_741);
  ::Reflex::Type type_968 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2HitCollectionMapping"), type_967);
  ::Reflex::Type type_1054 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2HitCollectionMappingWrapper"), type_1053);
  ::Reflex::Type type_1143 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2Hit_to_Track_MapWrapper"), type_1142);
  ::Reflex::Type type_1475 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2HitCollectionWrapper"), type_1474);
  ::Reflex::Type type_1500 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2PadStripAssociatorWrapper"), type_1499);
  ::Reflex::Type type_1781 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2Hit_to_Track_Map"), type_1780);
  ::Reflex::Type type_1336 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_278);
  ::Reflex::Type type_3132 = ::Reflex::ReferenceBuilder(type_1379);
  ::Reflex::Type type_1379c = ::Reflex::ConstBuilder(type_1379);
  ::Reflex::Type type_3134 = ::Reflex::ReferenceBuilder(type_1379c);
  ::Reflex::Type type_2556c = ::Reflex::ConstBuilder(type_2556);
  ::Reflex::Type type_14483 = ::Reflex::ReferenceBuilder(type_2556c);
  ::Reflex::Type type_3128 = ::Reflex::PointerBuilder(type_1379);
  ::Reflex::Type type_3130 = ::Reflex::PointerBuilder(type_1379c);
  ::Reflex::Type type_2700 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_271);
  ::Reflex::Type type_2635 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_10);
  ::Reflex::Type type_2721c = ::Reflex::ConstBuilder(type_2721);
  ::Reflex::Type type_12445 = ::Reflex::ReferenceBuilder(type_2721c);
  ::Reflex::Type type_268c = ::Reflex::ConstBuilder(type_268);
  ::Reflex::Type type_9280 = ::Reflex::ReferenceBuilder(type_268c);
  ::Reflex::Type type_9278 = ::Reflex::ReferenceBuilder(type_268);
  ::Reflex::Type type_9343 = ::Reflex::ReferenceBuilder(type_1712);
  ::Reflex::Type type_1712c = ::Reflex::ConstBuilder(type_1712);
  ::Reflex::Type type_9345 = ::Reflex::ReferenceBuilder(type_1712c);
  ::Reflex::Type type_6527 = ::Reflex::PointerBuilder(type_1712);
  ::Reflex::Type type_9341 = ::Reflex::PointerBuilder(type_1712c);
  ::Reflex::Type type_2729c = ::Reflex::ConstBuilder(type_2729);
  ::Reflex::Type type_17579 = ::Reflex::ReferenceBuilder(type_2729c);
  ::Reflex::Type type_2555c = ::Reflex::ConstBuilder(type_2555);
  ::Reflex::Type type_18251 = ::Reflex::ReferenceBuilder(type_2555c);
  ::Reflex::Type type_18252 = ::Reflex::ReferenceBuilder(type_2555);
  ::Reflex::Type type_5526 = ::Reflex::PointerBuilder(type_2518);
  ::Reflex::Type type_2518c = ::Reflex::ConstBuilder(type_2518);
  ::Reflex::Type type_5528 = ::Reflex::PointerBuilder(type_2518c);
  ::Reflex::Type type_5530 = ::Reflex::ReferenceBuilder(type_2518);
  ::Reflex::Type type_5532 = ::Reflex::ReferenceBuilder(type_2518c);
  ::Reflex::Type type_2297c = ::Reflex::ConstBuilder(type_2297);
  ::Reflex::Type type_14416 = ::Reflex::ReferenceBuilder(type_2297c);
  ::Reflex::Type type_2717c = ::Reflex::ConstBuilder(type_2717);
  ::Reflex::Type type_16274 = ::Reflex::ReferenceBuilder(type_2717c);
  ::Reflex::Type type_1780c = ::Reflex::ConstBuilder(type_1780);
  ::Reflex::Type type_9085 = ::Reflex::ReferenceBuilder(type_1780c);
  ::Reflex::Type type_9083 = ::Reflex::ReferenceBuilder(type_1780);
  ::Reflex::Type type_14534 = ::Reflex::ReferenceBuilder(type_69);
  ::Reflex::Type type_10c = ::Reflex::ConstBuilder(type_10);
  ::Reflex::Type type_9020 = ::Reflex::ReferenceBuilder(type_10c);
  ::Reflex::Type type_69c = ::Reflex::ConstBuilder(type_69);
  ::Reflex::Type type_7622 = ::Reflex::ReferenceBuilder(type_69c);
  ::Reflex::Type type_9081 = ::Reflex::PointerBuilder(type_1780c);
  ::Reflex::Type type_394c = ::Reflex::ConstBuilder(type_394);
  ::Reflex::Type type_12408 = ::Reflex::ReferenceBuilder(type_394c);
  ::Reflex::Type type_6433 = ::Reflex::PointerBuilder(type_1780);
  ::Reflex::Type type_3508c = ::Reflex::ConstBuilder(type_3508);
  ::Reflex::Type type_20117 = ::Reflex::PointerBuilder(type_3508c);
  ::Reflex::Type type_3584c = ::Reflex::ConstBuilder(type_3584);
  ::Reflex::Type type_13702 = ::Reflex::ReferenceBuilder(type_3584c);
  ::Reflex::Type type_14463 = ::Reflex::ReferenceBuilder(type_2548);
  ::Reflex::Type type_14464 = ::Reflex::ReferenceBuilder(type_3400);
  ::Reflex::Type type_578c = ::Reflex::ConstBuilder(type_578);
  ::Reflex::Type type_3045 = ::Reflex::PointerBuilder(type_578c);
  ::Reflex::Type type_7269 = ::Reflex::ReferenceBuilder(type_3045);
  ::Reflex::Type type_2549c = ::Reflex::ConstBuilder(type_2549);
  ::Reflex::Type type_14465 = ::Reflex::ReferenceBuilder(type_2549c);
  ::Reflex::Type type_4325 = ::Reflex::PointerBuilder(type_2519);
  ::Reflex::Type type_2519c = ::Reflex::ConstBuilder(type_2519);
  ::Reflex::Type type_4327 = ::Reflex::PointerBuilder(type_2519c);
  ::Reflex::Type type_4329 = ::Reflex::ReferenceBuilder(type_2519);
  ::Reflex::Type type_4331 = ::Reflex::ReferenceBuilder(type_2519c);
  ::Reflex::Type type_2718c = ::Reflex::ConstBuilder(type_2718);
  ::Reflex::Type type_14417 = ::Reflex::ReferenceBuilder(type_2718c);
  ::Reflex::Type type_741c = ::Reflex::ConstBuilder(type_741);
  ::Reflex::Type type_9150 = ::Reflex::ReferenceBuilder(type_741c);
  ::Reflex::Type type_9148 = ::Reflex::ReferenceBuilder(type_741);
  ::Reflex::Type type_14418 = ::Reflex::ReferenceBuilder(type_2550);
  ::Reflex::Type type_2550c = ::Reflex::ConstBuilder(type_2550);
  ::Reflex::Type type_14419 = ::Reflex::ReferenceBuilder(type_2550c);
  ::Reflex::Type type_9146 = ::Reflex::PointerBuilder(type_741c);
  ::Reflex::Type type_6452 = ::Reflex::PointerBuilder(type_741);
  ::Reflex::Type type_3509c = ::Reflex::ConstBuilder(type_3509);
  ::Reflex::Type type_20120 = ::Reflex::PointerBuilder(type_3509c);
  ::Reflex::Type type_4535 = ::Reflex::PointerBuilder(type_2520);
  ::Reflex::Type type_2520c = ::Reflex::ConstBuilder(type_2520);
  ::Reflex::Type type_4537 = ::Reflex::PointerBuilder(type_2520c);
  ::Reflex::Type type_4539 = ::Reflex::ReferenceBuilder(type_2520);
  ::Reflex::Type type_4541 = ::Reflex::ReferenceBuilder(type_2520c);
  ::Reflex::Type type_2298c = ::Reflex::ConstBuilder(type_2298);
  ::Reflex::Type type_14453 = ::Reflex::ReferenceBuilder(type_2298c);
  ::Reflex::Type type_2720c = ::Reflex::ConstBuilder(type_2720);
  ::Reflex::Type type_14454 = ::Reflex::ReferenceBuilder(type_2720c);
  ::Reflex::Type type_967c = ::Reflex::ConstBuilder(type_967);
  ::Reflex::Type type_9215 = ::Reflex::ReferenceBuilder(type_967c);
  ::Reflex::Type type_9213 = ::Reflex::ReferenceBuilder(type_967);
  ::Reflex::Type type_8954 = ::Reflex::ReferenceBuilder(type_271);
  ::Reflex::Type type_2521c = ::Reflex::ConstBuilder(type_2521);
  ::Reflex::Type type_14455 = ::Reflex::ReferenceBuilder(type_2521c);
  ::Reflex::Type type_271c = ::Reflex::ConstBuilder(type_271);
  ::Reflex::Type type_7069 = ::Reflex::ReferenceBuilder(type_271c);
  ::Reflex::Type type_9211 = ::Reflex::PointerBuilder(type_967c);
  ::Reflex::Type type_6471 = ::Reflex::PointerBuilder(type_967);
  ::Reflex::Type type_3510c = ::Reflex::ConstBuilder(type_3510);
  ::Reflex::Type type_20123 = ::Reflex::PointerBuilder(type_3510c);
  ::Reflex::Type type_9276 = ::Reflex::PointerBuilder(type_268c);
  ::Reflex::Type type_6490 = ::Reflex::PointerBuilder(type_268);
  ::Reflex::Type type_3511c = ::Reflex::ConstBuilder(type_3511);
  ::Reflex::Type type_20126 = ::Reflex::PointerBuilder(type_3511c);
  ::Reflex::Type type_2553c = ::Reflex::ConstBuilder(type_2553);
  ::Reflex::Type type_14460 = ::Reflex::PointerBuilder(type_2553c);
  ::Reflex::Type type_14461 = ::Reflex::PointerBuilder(type_2553);
  ::Reflex::Type type_3514c = ::Reflex::ConstBuilder(type_3514);
  ::Reflex::Type type_14462 = ::Reflex::PointerBuilder(type_3514c);
  ::Reflex::Type type_2551c = ::Reflex::ConstBuilder(type_2551);
  ::Reflex::Type type_14471 = ::Reflex::PointerBuilder(type_2551c);
  ::Reflex::Type type_14472 = ::Reflex::PointerBuilder(type_2551);
  ::Reflex::Type type_3512c = ::Reflex::ConstBuilder(type_3512);
  ::Reflex::Type type_14473 = ::Reflex::PointerBuilder(type_3512c);
  ::Reflex::Type type_2554c = ::Reflex::ConstBuilder(type_2554);
  ::Reflex::Type type_14491 = ::Reflex::PointerBuilder(type_2554c);
  ::Reflex::Type type_14492 = ::Reflex::PointerBuilder(type_2554);
  ::Reflex::Type type_3515c = ::Reflex::ConstBuilder(type_3515);
  ::Reflex::Type type_14493 = ::Reflex::PointerBuilder(type_3515c);
  ::Reflex::Type type_2552c = ::Reflex::ConstBuilder(type_2552);
  ::Reflex::Type type_14497 = ::Reflex::PointerBuilder(type_2552c);
  ::Reflex::Type type_14498 = ::Reflex::PointerBuilder(type_2552);
  ::Reflex::Type type_3513c = ::Reflex::ConstBuilder(type_3513);
  ::Reflex::Type type_14499 = ::Reflex::PointerBuilder(type_3513c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __T2Hit
#undef __T2Hit
#endif
class __T2Hit {
  public:
  __T2Hit();
  virtual ~__T2Hit() throw();
  ::std::vector<cluster_entry> ClusterStrip_entries;
  ::std::vector<cluster_entry> ClusterPad_entries;
  ::std::pair<long,long> HitUniqueId;
  ::std::vector<long> StripVectorBelowThePadId;
  unsigned int Hit_PosInCollection;
  float hitR_;
  float hitPhi_;
  float hitZ_;
  float hitDR_;
  float hitDPhi_;
  float hitDZ_;
  float hitX_;
  float hitY_;
  float hitDX_;
  float hitDY_;
  bool VtxHits;
  bool HitInTrk;
  unsigned int hithalftele_;
  unsigned int hitplane_;
  unsigned int hitplaneside_;
  unsigned int hitarm_;
  ::uint32_t detrawid_;
  unsigned int hitClass_;
  unsigned int hit_numstrip_;
  unsigned int hit_numpad_;
  unsigned int hit_numpadcol_;
  ::std::vector<hit_entry> thehitentries;
};
#ifdef __std__vector_T2Hit_
#undef __std__vector_T2Hit_
#endif
class __std__vector_T2Hit_ : protected ::std::_Vector_base<T2Hit,std::allocator<T2Hit> > {
  public:
  __std__vector_T2Hit_();
};
#ifdef __hit_entry
#undef __hit_entry
#endif
class __hit_entry {
  public:
  __hit_entry();
  float rCl_;
  float phiCl_;
  float dphiCl_;
  float drCl_;
  float zCl_;
  float dzCl_;
  bool isPad_;
  unsigned int nument_;
};
#ifdef __std__vector_hit_entry_
#undef __std__vector_hit_entry_
#endif
class __std__vector_hit_entry_ : protected ::std::_Vector_base<hit_entry,std::allocator<hit_entry> > {
  public:
  __std__vector_hit_entry_();
};
#ifdef __std__map_long_int_
#undef __std__map_long_int_
#endif
class __std__map_long_int_ {
  public:
  __std__map_long_int_();
  ::std::_Rb_tree<long,std::pair<const long,int>,std::_Select1st<std::pair<const long,int> >,std::less<long>,std::allocator<std::pair<const long,int> > > _M_t;
};
#ifdef __edm__Wrapper_std__map_long_int_s_
#undef __edm__Wrapper_std__map_long_int_s_
#endif
class __edm__Wrapper_std__map_long_int_s_ {
  public:
  __edm__Wrapper_std__map_long_int_s_();
  bool present;
  ::std::map<long,int> obj;
};
#ifdef __std__map_long_std__vector_long_s_
#undef __std__map_long_std__vector_long_s_
#endif
class __std__map_long_std__vector_long_s_ {
  public:
  __std__map_long_std__vector_long_s_();
  ::std::_Rb_tree<long,std::pair<const long,std::vector<long> >,std::_Select1st<std::pair<const long,std::vector<long> > >,std::less<long>,std::allocator<std::pair<const long,std::vector<long> > > > _M_t;
};
#ifdef __edm__Wrapper_std__map_long_std__vector_long_s_s_
#undef __edm__Wrapper_std__map_long_std__vector_long_s_s_
#endif
class __edm__Wrapper_std__map_long_std__vector_long_s_s_ {
  public:
  __edm__Wrapper_std__map_long_std__vector_long_s_s_();
  bool present;
  ::std::map<long,std::vector<long> > obj;
};
#ifdef __std__map_std__pair_long_long__unsignedslong_
#undef __std__map_std__pair_long_long__unsignedslong_
#endif
class __std__map_std__pair_long_long__unsignedslong_ {
  public:
  __std__map_std__pair_long_long__unsignedslong_();
  ::std::_Rb_tree<std::pair<long,long>,std::pair<const std::pair<long,long>,unsigned long>,std::_Select1st<std::pair<const std::pair<long,long>,unsigned long> >,std::less<std::pair<long,long> >,std::allocator<std::pair<const std::pair<long,long>,unsigned long> > > _M_t;
};
#ifdef __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s_
#undef __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s_
#endif
class __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s_ {
  public:
  __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s_();
  bool present;
  ::std::map<std::pair<long,long>,unsigned long> obj;
};
#ifdef __edm__Wrapper_std__vector_T2Hit_s_
#undef __edm__Wrapper_std__vector_T2Hit_s_
#endif
class __edm__Wrapper_std__vector_T2Hit_s_ {
  public:
  __edm__Wrapper_std__vector_T2Hit_s_();
  bool present;
  ::std::vector<T2Hit> obj;
};
#ifdef __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s_
#undef __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s_
#endif
class __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s_ {
  public:
  __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s_();
  bool present;
  ::std::vector<std::map<std::pair<long,long>,unsigned long> > obj;
};
#ifdef __edm__Wrapper_std__vector_std__map_long_int_s_s_
#undef __edm__Wrapper_std__vector_std__map_long_int_s_s_
#endif
class __edm__Wrapper_std__vector_std__map_long_int_s_s_ {
  public:
  __edm__Wrapper_std__vector_std__map_long_int_s_s_();
  bool present;
  ::std::vector<std::map<long,int> > obj;
};
#ifdef __edm__Wrapper_std__vector_std__vector_T2Hit_s_s_
#undef __edm__Wrapper_std__vector_std__vector_T2Hit_s_s_
#endif
class __edm__Wrapper_std__vector_std__vector_T2Hit_s_s_ {
  public:
  __edm__Wrapper_std__vector_std__vector_T2Hit_s_s_();
  bool present;
  ::std::vector<std::vector<T2Hit> > obj;
};
#ifdef __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s_
#undef __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s_
#endif
class __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s_ {
  public:
  __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s_();
  bool present;
  ::std::vector<std::map<long,std::vector<long> > > obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class T2Hit -------------------------------
static  void operator_4779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T2Hit*)o)->operator=)(*(const ::T2Hit*)arg[0]);
  else   (((::T2Hit*)o)->operator=)(*(const ::T2Hit*)arg[0]);
}

static void constructor_4780( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Hit(*(const ::T2Hit*)arg[0]);
  else ::new(mem) ::T2Hit(*(const ::T2Hit*)arg[0]);
}

static void constructor_4781( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Hit();
  else ::new(mem) ::T2Hit();
}

static void constructor_4782( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Hit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::uint32_t*)arg[3]);
  else ::new(mem) ::T2Hit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::uint32_t*)arg[3]);
}

static void constructor_4783( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Hit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(::uint32_t*)arg[6]);
  else ::new(mem) ::T2Hit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(::uint32_t*)arg[6]);
}

static void destructor_4784(void*, void * o, const std::vector<void*>&, void *) {
(((::T2Hit*)o)->::T2Hit::~T2Hit)();
}
static  void method_4785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitR)());
  else   (((const ::T2Hit*)o)->GetHitR)();
}

static  void method_4786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitPhi)());
  else   (((const ::T2Hit*)o)->GetHitPhi)();
}

static  void method_4787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitZ)());
  else   (((const ::T2Hit*)o)->GetHitZ)();
}

static  void method_4788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitDR)());
  else   (((const ::T2Hit*)o)->GetHitDR)();
}

static  void method_4789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitDPhi)());
  else   (((const ::T2Hit*)o)->GetHitDPhi)();
}

static  void method_4790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitDZ)());
  else   (((const ::T2Hit*)o)->GetHitDZ)();
}

static  void method_4791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitX)());
  else   (((const ::T2Hit*)o)->GetHitX)();
}

static  void method_4792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitDX)());
  else   (((const ::T2Hit*)o)->GetHitDX)();
}

static  void method_4793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitY)());
  else   (((const ::T2Hit*)o)->GetHitY)();
}

static  void method_4794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitDY)());
  else   (((const ::T2Hit*)o)->GetHitDY)();
}

static  void method_4795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitClass)());
  else   (((const ::T2Hit*)o)->GetHitClass)();
}

static  void method_4796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitNumStrip)());
  else   (((const ::T2Hit*)o)->GetHitNumStrip)();
}

static  void method_4797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitNumPad)());
  else   (((const ::T2Hit*)o)->GetHitNumPad)();
}

static  void method_4798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitPadCol)());
  else   (((const ::T2Hit*)o)->GetHitPadCol)();
}

static  void method_4799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitArm)());
  else   (((const ::T2Hit*)o)->GetHitArm)();
}

static  void method_4800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitHalftele)());
  else   (((const ::T2Hit*)o)->GetHitHalftele)();
}

static  void method_4801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitPlane)());
  else   (((const ::T2Hit*)o)->GetHitPlane)();
}

static  void method_4802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitPlaneSide)());
  else   (((const ::T2Hit*)o)->GetHitPlaneSide)();
}

static  void method_4803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::T2Hit*)o)->GetHitDetRawId)());
  else   (((const ::T2Hit*)o)->GetHitDetRawId)();
}

static  void method_4804( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitArm)(*(unsigned int*)arg[0]);
}

static  void method_4805( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitHalftele)(*(unsigned int*)arg[0]);
}

static  void method_4806( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitPlane)(*(unsigned int*)arg[0]);
}

static  void method_4807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitPlaneSide)(*(unsigned int*)arg[0]);
}

static  void method_4808( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDetRawId)(*(::uint32_t*)arg[0]);
}

static  void method_4809( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitR)(*(float*)arg[0]);
}

static  void method_4810( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitPhi)(*(float*)arg[0]);
}

static  void method_4811( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitZ)(*(float*)arg[0]);
}

static  void method_4812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDR)(*(float*)arg[0]);
}

static  void method_4813( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDPhi)(*(float*)arg[0]);
}

static  void method_4814( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDZ)(*(float*)arg[0]);
}

static  void method_4815( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitX)(*(float*)arg[0]);
}

static  void method_4816( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDX)(*(float*)arg[0]);
}

static  void method_4817( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitY)(*(float*)arg[0]);
}

static  void method_4818( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDY)(*(float*)arg[0]);
}

static  void method_4819( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitClass)(*(unsigned int*)arg[0]);
}

static  void method_4820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitNumStrip)(*(unsigned int*)arg[0]);
}

static  void method_4821( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitNumPad)(*(unsigned int*)arg[0]);
}

static  void method_4822( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitNumPadCol)(*(unsigned int*)arg[0]);
}

static  void method_4823( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->AddFormingCluster)(*(::hit_entry*)arg[0]);
}

static  void method_4824( void*, void* o, const std::vector<void*>&, void*)
{
  (((::T2Hit*)o)->ComputeHit)();
}

static  void method_4825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::T2Hit*)o)->GetCluStripEntries)();
  else   (((const ::T2Hit*)o)->GetCluStripEntries)();
}

static  void method_4826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::T2Hit*)o)->GetCluPadEntries)();
  else   (((const ::T2Hit*)o)->GetCluPadEntries)();
}

static  void method_4827( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->AddCluPadEntries)(*(::std::vector<cluster_entry>*)arg[0]);
}

static  void method_4828( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->AddCluStripEntries)(*(::std::vector<cluster_entry>*)arg[0]);
}

static void method_newdel_1379( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T2Hit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T2Hit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T2Hit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T2Hit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T2Hit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T2Hit -------------------------------
void __T2Hit_db_datamem(Reflex::Class*);
void __T2Hit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T2Hit_datamem_bld(&__T2Hit_db_datamem);
Reflex::GenreflexMemberBuilder __T2Hit_funcmem_bld(&__T2Hit_db_funcmem);
void __T2Hit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T2Hit"), typeid(::T2Hit), sizeof(::T2Hit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddTypedef(type_2555, Reflex::Literal("T2Hit::vecthit_entries"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132, type_3134), Reflex::Literal("operator="), operator_4779, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3134), Reflex::Literal("T2Hit"), constructor_4780, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T2Hit"), constructor_4781, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_99, type_99, type_99, type_1336), Reflex::Literal("T2Hit"), constructor_4782, 0, "expX;expY;Z;cmsswid", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_99, type_99, type_99, type_99, type_99, type_99, type_1336), Reflex::Literal("T2Hit"), constructor_4783, 0, "X;Y;Z;EX;EY;EZ;cmsswid", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T2Hit"), destructor_4784, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1379, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T2Hit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T2Hit_funcmem_bld);
}

//------Delayed data member builder for class T2Hit -------------------
void __T2Hit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2556, Reflex::Literal("ClusterStrip_entries"), OffsetOf(__shadow__::__T2Hit, ClusterStrip_entries), ::Reflex::PUBLIC)
  .AddDataMember(type_2556, Reflex::Literal("ClusterPad_entries"), OffsetOf(__shadow__::__T2Hit, ClusterPad_entries), ::Reflex::PUBLIC)
  .AddDataMember(type_2521, Reflex::Literal("HitUniqueId"), OffsetOf(__shadow__::__T2Hit, HitUniqueId), ::Reflex::PUBLIC)
  .AddDataMember(type_2550, Reflex::Literal("StripVectorBelowThePadId"), OffsetOf(__shadow__::__T2Hit, StripVectorBelowThePadId), ::Reflex::PUBLIC)
  .AddDataMember(type_278, Reflex::Literal("Hit_PosInCollection"), OffsetOf(__shadow__::__T2Hit, Hit_PosInCollection), ::Reflex::PUBLIC)
  .AddDataMember(type_754, Reflex::Literal("hitR_"), OffsetOf(__shadow__::__T2Hit, hitR_), ::Reflex::PRIVATE)
  .AddDataMember(type_754, Reflex::Literal("hitPhi_"), OffsetOf(__shadow__::__T2Hit, hitPhi_), ::Reflex::PRIVATE)
  .AddDataMember(type_754, Reflex::Literal("hitZ_"), OffsetOf(__shadow__::__T2Hit, hitZ_), ::Reflex::PRIVATE)
  .AddDataMember(type_754, Reflex::Literal("hitDR_"), OffsetOf(__shadow__::__T2Hit, hitDR_), ::Reflex::PRIVATE)
  .AddDataMember(type_754, Reflex::Literal("hitDPhi_"), OffsetOf(__shadow__::__T2Hit, hitDPhi_), ::Reflex::PRIVATE)
  .AddDataMember(type_754, Reflex::Literal("hitDZ_"), OffsetOf(__shadow__::__T2Hit, hitDZ_), ::Reflex::PRIVATE)
  .AddDataMember(type_754, Reflex::Literal("hitX_"), OffsetOf(__shadow__::__T2Hit, hitX_), ::Reflex::PRIVATE)
  .AddDataMember(type_754, Reflex::Literal("hitY_"), OffsetOf(__shadow__::__T2Hit, hitY_), ::Reflex::PRIVATE)
  .AddDataMember(type_754, Reflex::Literal("hitDX_"), OffsetOf(__shadow__::__T2Hit, hitDX_), ::Reflex::PRIVATE)
  .AddDataMember(type_754, Reflex::Literal("hitDY_"), OffsetOf(__shadow__::__T2Hit, hitDY_), ::Reflex::PRIVATE)
  .AddDataMember(type_1372, Reflex::Literal("VtxHits"), OffsetOf(__shadow__::__T2Hit, VtxHits), ::Reflex::PRIVATE)
  .AddDataMember(type_1372, Reflex::Literal("HitInTrk"), OffsetOf(__shadow__::__T2Hit, HitInTrk), ::Reflex::PRIVATE)
  .AddDataMember(type_278, Reflex::Literal("hithalftele_"), OffsetOf(__shadow__::__T2Hit, hithalftele_), ::Reflex::PRIVATE)
  .AddDataMember(type_278, Reflex::Literal("hitplane_"), OffsetOf(__shadow__::__T2Hit, hitplane_), ::Reflex::PRIVATE)
  .AddDataMember(type_278, Reflex::Literal("hitplaneside_"), OffsetOf(__shadow__::__T2Hit, hitplaneside_), ::Reflex::PRIVATE)
  .AddDataMember(type_278, Reflex::Literal("hitarm_"), OffsetOf(__shadow__::__T2Hit, hitarm_), ::Reflex::PRIVATE)
  .AddDataMember(type_1336, Reflex::Literal("detrawid_"), OffsetOf(__shadow__::__T2Hit, detrawid_), ::Reflex::PRIVATE)
  .AddDataMember(type_278, Reflex::Literal("hitClass_"), OffsetOf(__shadow__::__T2Hit, hitClass_), ::Reflex::PRIVATE)
  .AddDataMember(type_278, Reflex::Literal("hit_numstrip_"), OffsetOf(__shadow__::__T2Hit, hit_numstrip_), ::Reflex::PRIVATE)
  .AddDataMember(type_278, Reflex::Literal("hit_numpad_"), OffsetOf(__shadow__::__T2Hit, hit_numpad_), ::Reflex::PRIVATE)
  .AddDataMember(type_278, Reflex::Literal("hit_numpadcol_"), OffsetOf(__shadow__::__T2Hit, hit_numpadcol_), ::Reflex::PRIVATE)
  .AddDataMember(type_2555, Reflex::Literal("thehitentries"), OffsetOf(__shadow__::__T2Hit, thehitentries), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T2Hit -------------------
void __T2Hit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_754), Reflex::Literal("GetHitR"), method_4785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_754), Reflex::Literal("GetHitPhi"), method_4786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_754), Reflex::Literal("GetHitZ"), method_4787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_754), Reflex::Literal("GetHitDR"), method_4788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_754), Reflex::Literal("GetHitDPhi"), method_4789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_754), Reflex::Literal("GetHitDZ"), method_4790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_754), Reflex::Literal("GetHitX"), method_4791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_754), Reflex::Literal("GetHitDX"), method_4792, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_754), Reflex::Literal("GetHitY"), method_4793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_754), Reflex::Literal("GetHitDY"), method_4794, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("GetHitClass"), method_4795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("GetHitNumStrip"), method_4796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("GetHitNumPad"), method_4797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("GetHitPadCol"), method_4798, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("GetHitArm"), method_4799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("GetHitHalftele"), method_4800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("GetHitPlane"), method_4801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_278), Reflex::Literal("GetHitPlaneSide"), method_4802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1336), Reflex::Literal("GetHitDetRawId"), method_4803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_278), Reflex::Literal("SetHitArm"), method_4804, 0, "harm", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_278), Reflex::Literal("SetHitHalftele"), method_4805, 0, "hht", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_278), Reflex::Literal("SetHitPlane"), method_4806, 0, "hpl", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_278), Reflex::Literal("SetHitPlaneSide"), method_4807, 0, "hpls", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_1336), Reflex::Literal("SetHitDetRawId"), method_4808, 0, "drid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_754), Reflex::Literal("SetHitR"), method_4809, 0, "hitR", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_754), Reflex::Literal("SetHitPhi"), method_4810, 0, "hitPhi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_754), Reflex::Literal("SetHitZ"), method_4811, 0, "hitZ", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_754), Reflex::Literal("SetHitDR"), method_4812, 0, "hitDR", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_754), Reflex::Literal("SetHitDPhi"), method_4813, 0, "hitDPhi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_754), Reflex::Literal("SetHitDZ"), method_4814, 0, "hitDZ", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_754), Reflex::Literal("SetHitX"), method_4815, 0, "hitX", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_754), Reflex::Literal("SetHitDX"), method_4816, 0, "hitDX", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_754), Reflex::Literal("SetHitY"), method_4817, 0, "hitY", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_754), Reflex::Literal("SetHitDY"), method_4818, 0, "hitDY", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_278), Reflex::Literal("SetHitClass"), method_4819, 0, "hitClass", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_278), Reflex::Literal("SetHitNumStrip"), method_4820, 0, "hit_numstrip", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_278), Reflex::Literal("SetHitNumPad"), method_4821, 0, "hit_numpad", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_278), Reflex::Literal("SetHitNumPadCol"), method_4822, 0, "hit_numpadcol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_1712), Reflex::Literal("AddFormingCluster"), method_4823, 0, "ahit_entry", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("ComputeHit"), method_4824, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14483), Reflex::Literal("GetCluStripEntries"), method_4825, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14483), Reflex::Literal("GetCluPadEntries"), method_4826, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2556), Reflex::Literal("AddCluPadEntries"), method_4827, 0, "tocpp", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2556), Reflex::Literal("AddCluStripEntries"), method_4828, 0, "tocps", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<T2Hit,std::allocator<T2Hit> > -------------------------------
static void constructor_3145( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Hit>();
  else ::new(mem) ::std::vector<T2Hit>();
}

static void constructor_3146( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Hit>(*(const ::std::allocator<T2Hit>*)arg[0]);
  else ::new(mem) ::std::vector<T2Hit>(*(const ::std::allocator<T2Hit>*)arg[0]);
}

static void constructor_3147( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Hit>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<T2Hit>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Hit>(*(::std::size_t*)arg[0],
      *(const ::T2Hit*)arg[1]);
  else ::new(mem) ::std::vector<T2Hit>(*(::std::size_t*)arg[0],
      *(const ::T2Hit*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Hit>(*(::std::size_t*)arg[0],
      *(const ::T2Hit*)arg[1],
      *(const ::std::allocator<T2Hit>*)arg[2]);
  else ::new(mem) ::std::vector<T2Hit>(*(::std::size_t*)arg[0],
      *(const ::T2Hit*)arg[1],
      *(const ::std::allocator<T2Hit>*)arg[2]);
  }
}

static void constructor_3148( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Hit>(*(const ::std::vector<T2Hit>*)arg[0]);
  else ::new(mem) ::std::vector<T2Hit>(*(const ::std::vector<T2Hit>*)arg[0]);
}

static void destructor_3149(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<T2Hit>*)o)->::std::vector<T2Hit>::~vector)();
}
static  void operator_3150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2Hit>*)o)->operator=)(*(const ::std::vector<T2Hit>*)arg[0]);
  else   (((::std::vector<T2Hit>*)o)->operator=)(*(const ::std::vector<T2Hit>*)arg[0]);
}

static  void method_3151( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2Hit>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::T2Hit*)arg[1]);
}

static  void method_3152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >)((((::std::vector<T2Hit>*)o)->begin)());
  else   (((::std::vector<T2Hit>*)o)->begin)();
}

static  void method_3153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2Hit*,std::vector<T2Hit> >)((((const ::std::vector<T2Hit>*)o)->begin)());
  else   (((const ::std::vector<T2Hit>*)o)->begin)();
}

static  void method_3154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >)((((::std::vector<T2Hit>*)o)->end)());
  else   (((::std::vector<T2Hit>*)o)->end)();
}

static  void method_3155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2Hit*,std::vector<T2Hit> >)((((const ::std::vector<T2Hit>*)o)->end)());
  else   (((const ::std::vector<T2Hit>*)o)->end)();
}

static  void method_3160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2Hit>*)o)->size)());
  else   (((const ::std::vector<T2Hit>*)o)->size)();
}

static  void method_3161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2Hit>*)o)->max_size)());
  else   (((const ::std::vector<T2Hit>*)o)->max_size)();
}

static  void method_3162( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<T2Hit>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<T2Hit>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::T2Hit*)arg[1]);
  }
}

static  void method_3163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2Hit>*)o)->capacity)());
  else   (((const ::std::vector<T2Hit>*)o)->capacity)();
}

static  void method_3164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<T2Hit>*)o)->empty)());
  else   (((const ::std::vector<T2Hit>*)o)->empty)();
}

static  void method_3165( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2Hit>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2Hit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2Hit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2Hit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2Hit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3169( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2Hit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2Hit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2Hit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2Hit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2Hit>*)o)->front)();
  else   (((::std::vector<T2Hit>*)o)->front)();
}

static  void method_3172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2Hit>*)o)->front)();
  else   (((const ::std::vector<T2Hit>*)o)->front)();
}

static  void method_3173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2Hit>*)o)->back)();
  else   (((::std::vector<T2Hit>*)o)->back)();
}

static  void method_3174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2Hit>*)o)->back)();
  else   (((const ::std::vector<T2Hit>*)o)->back)();
}

static  void method_3175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<T2Hit>*)o)->data)());
  else   (((::std::vector<T2Hit>*)o)->data)();
}

static  void method_3176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<T2Hit>*)o)->data)());
  else   (((const ::std::vector<T2Hit>*)o)->data)();
}

static  void method_3177( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2Hit>*)o)->push_back)(*(const ::T2Hit*)arg[0]);
}

static  void method_3178( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2Hit>*)o)->pop_back)();
}

static  void method_3179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >)((((::std::vector<T2Hit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >*)arg[0],
    *(const ::T2Hit*)arg[1]));
  else   (((::std::vector<T2Hit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >*)arg[0],
    *(const ::T2Hit*)arg[1]);
}

static  void method_3180( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2Hit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::T2Hit*)arg[2]);
}

static  void method_3181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >)((((::std::vector<T2Hit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >*)arg[0]));
  else   (((::std::vector<T2Hit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >*)arg[0]);
}

static  void method_3182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >)((((::std::vector<T2Hit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >*)arg[1]));
  else   (((::std::vector<T2Hit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2Hit*,std::vector<T2Hit> >*)arg[1]);
}

static  void method_3183( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2Hit>*)o)->swap)(*(::std::vector<T2Hit>*)arg[0]);
}

static  void method_3184( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2Hit>*)o)->clear)();
}

static void method_newdel_268( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<T2Hit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<T2Hit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<T2Hit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<T2Hit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<T2Hit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2Hit,std::allocator<T2Hit> >")), ::Reflex::BaseOffset< ::std::vector<T2Hit>,::std::_Vector_base<T2Hit,std::allocator<T2Hit> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<T2Hit> >::Generate();
  else ::Reflex::Proxy< ::std::vector<T2Hit> >::Generate();
}

//------Dictionary for class vector<T2Hit,std::allocator<T2Hit> > -------------------------------
void __std__vector_T2Hit__db_datamem(Reflex::Class*);
void __std__vector_T2Hit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_T2Hit__datamem_bld(&__std__vector_T2Hit__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_T2Hit__funcmem_bld(&__std__vector_T2Hit__db_funcmem);
void __std__vector_T2Hit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<T2Hit>"), typeid(::std::vector<T2Hit>), sizeof(::std::vector<T2Hit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2166, ::Reflex::BaseOffset< ::std::vector<T2Hit>, ::std::_Vector_base<T2Hit,std::allocator<T2Hit> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1379, Reflex::Literal("std::vector<T2Hit>::_Alloc_value_type"))
  .AddTypedef(type_2166, Reflex::Literal("std::vector<T2Hit>::_Base"))
  .AddTypedef(type_2721, Reflex::Literal("std::vector<T2Hit>::_Tp_alloc_type"))
  .AddTypedef(type_3125, Reflex::Literal("std::vector<T2Hit>::_Alloc_traits"))
  .AddTypedef(type_1379, Reflex::Literal("std::vector<T2Hit>::value_type"))
  .AddTypedef(type_3128, Reflex::Literal("std::vector<T2Hit>::pointer"))
  .AddTypedef(type_3130, Reflex::Literal("std::vector<T2Hit>::const_pointer"))
  .AddTypedef(type_3132, Reflex::Literal("std::vector<T2Hit>::reference"))
  .AddTypedef(type_3134, Reflex::Literal("std::vector<T2Hit>::const_reference"))
  .AddTypedef(type_3136, Reflex::Literal("std::vector<T2Hit>::iterator"))
  .AddTypedef(type_3138, Reflex::Literal("std::vector<T2Hit>::const_iterator"))
  .AddTypedef(type_2835, Reflex::Literal("std::vector<T2Hit>::const_reverse_iterator"))
  .AddTypedef(type_2836, Reflex::Literal("std::vector<T2Hit>::reverse_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::vector<T2Hit>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::vector<T2Hit>::difference_type"))
  .AddTypedef(type_2721, Reflex::Literal("std::vector<T2Hit>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3145, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12445), Reflex::Literal("vector"), constructor_3146, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2700, type_3134, type_12445), Reflex::Literal("vector"), constructor_3147, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9280), Reflex::Literal("vector"), constructor_3148, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3149, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_268, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_T2Hit__funcmem_bld);
}

//------Delayed data member builder for class vector<T2Hit,std::allocator<T2Hit> > -------------------
void __std__vector_T2Hit__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<T2Hit,std::allocator<T2Hit> > -------------------
void __std__vector_T2Hit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9278, type_9280), Reflex::Literal("operator="), operator_3150, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2700, type_3134), Reflex::Literal("assign"), method_3151, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3136), Reflex::Literal("begin"), method_3152, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3138), Reflex::Literal("begin"), method_3153, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3136), Reflex::Literal("end"), method_3154, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3138), Reflex::Literal("end"), method_3155, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_3160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_3161, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2700, type_1379), Reflex::Literal("resize"), method_3162, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("capacity"), method_3163, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_3164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2700), Reflex::Literal("reserve"), method_3165, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132, type_2700), Reflex::Literal("operator[]"), operator_3166, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3134, type_2700), Reflex::Literal("operator[]"), operator_3167, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132, type_2700), Reflex::Literal("at"), method_3169, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3134, type_2700), Reflex::Literal("at"), method_3170, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132), Reflex::Literal("front"), method_3171, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3134), Reflex::Literal("front"), method_3172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3132), Reflex::Literal("back"), method_3173, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3134), Reflex::Literal("back"), method_3174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3128), Reflex::Literal("data"), method_3175, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3130), Reflex::Literal("data"), method_3176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_3134), Reflex::Literal("push_back"), method_3177, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("pop_back"), method_3178, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3136, type_3136, type_3134), Reflex::Literal("insert"), method_3179, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_3136, type_2700, type_3134), Reflex::Literal("insert"), method_3180, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3136, type_3136), Reflex::Literal("erase"), method_3181, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3136, type_3136, type_3136), Reflex::Literal("erase"), method_3182, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_9278), Reflex::Literal("swap"), method_3183, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("clear"), method_3184, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class hit_entry -------------------------------
static void destructor_5314(void*, void * o, const std::vector<void*>&, void *) {
(((::hit_entry*)o)->::hit_entry::~hit_entry)();
}
static  void operator_5315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::hit_entry*)o)->operator=)(*(const ::hit_entry*)arg[0]);
  else   (((::hit_entry*)o)->operator=)(*(const ::hit_entry*)arg[0]);
}

static void constructor_5316( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::hit_entry(*(const ::hit_entry*)arg[0]);
  else ::new(mem) ::hit_entry(*(const ::hit_entry*)arg[0]);
}

static void constructor_5317( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::hit_entry();
  else ::new(mem) ::hit_entry();
}

static void constructor_5318( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::hit_entry(*(float*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4],
      *(float*)arg[5],
      *(bool*)arg[6],
      *(unsigned int*)arg[7]);
  else ::new(mem) ::hit_entry(*(float*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4],
      *(float*)arg[5],
      *(bool*)arg[6],
      *(unsigned int*)arg[7]);
}

static void method_newdel_1712( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::hit_entry >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::hit_entry >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::hit_entry >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::hit_entry >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::hit_entry >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class hit_entry -------------------------------
void __hit_entry_db_datamem(Reflex::Class*);
void __hit_entry_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __hit_entry_datamem_bld(&__hit_entry_db_datamem);
Reflex::GenreflexMemberBuilder __hit_entry_funcmem_bld(&__hit_entry_db_funcmem);
void __hit_entry_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("hit_entry"), typeid(::hit_entry), sizeof(::hit_entry), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~hit_entry"), destructor_5314, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9343, type_9345), Reflex::Literal("operator="), operator_5315, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9345), Reflex::Literal("hit_entry"), constructor_5316, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("hit_entry"), constructor_5317, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_754, type_754, type_754, type_754, type_754, type_754, type_1372, type_278), Reflex::Literal("hit_entry"), constructor_5318, 0, "rCl;phiCl;drCl;dphiCl;zCl;dzCl;isPad;numentry", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1712, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__hit_entry_datamem_bld);
}

//------Delayed data member builder for class hit_entry -------------------
void __hit_entry_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_754, Reflex::Literal("rCl_"), OffsetOf(__shadow__::__hit_entry, rCl_), ::Reflex::PUBLIC)
  .AddDataMember(type_754, Reflex::Literal("phiCl_"), OffsetOf(__shadow__::__hit_entry, phiCl_), ::Reflex::PUBLIC)
  .AddDataMember(type_754, Reflex::Literal("dphiCl_"), OffsetOf(__shadow__::__hit_entry, dphiCl_), ::Reflex::PUBLIC)
  .AddDataMember(type_754, Reflex::Literal("drCl_"), OffsetOf(__shadow__::__hit_entry, drCl_), ::Reflex::PUBLIC)
  .AddDataMember(type_754, Reflex::Literal("zCl_"), OffsetOf(__shadow__::__hit_entry, zCl_), ::Reflex::PUBLIC)
  .AddDataMember(type_754, Reflex::Literal("dzCl_"), OffsetOf(__shadow__::__hit_entry, dzCl_), ::Reflex::PUBLIC)
  .AddDataMember(type_1372, Reflex::Literal("isPad_"), OffsetOf(__shadow__::__hit_entry, isPad_), ::Reflex::PUBLIC)
  .AddDataMember(type_278, Reflex::Literal("nument_"), OffsetOf(__shadow__::__hit_entry, nument_), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class hit_entry -------------------
void __hit_entry_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<hit_entry,std::allocator<hit_entry> > -------------------------------
static void constructor_9354( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<hit_entry>();
  else ::new(mem) ::std::vector<hit_entry>();
}

static void constructor_9355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<hit_entry>(*(const ::std::allocator<hit_entry>*)arg[0]);
  else ::new(mem) ::std::vector<hit_entry>(*(const ::std::allocator<hit_entry>*)arg[0]);
}

static void constructor_9356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<hit_entry>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<hit_entry>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<hit_entry>(*(::std::size_t*)arg[0],
      *(const ::hit_entry*)arg[1]);
  else ::new(mem) ::std::vector<hit_entry>(*(::std::size_t*)arg[0],
      *(const ::hit_entry*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<hit_entry>(*(::std::size_t*)arg[0],
      *(const ::hit_entry*)arg[1],
      *(const ::std::allocator<hit_entry>*)arg[2]);
  else ::new(mem) ::std::vector<hit_entry>(*(::std::size_t*)arg[0],
      *(const ::hit_entry*)arg[1],
      *(const ::std::allocator<hit_entry>*)arg[2]);
  }
}

static void constructor_9357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<hit_entry>(*(const ::std::vector<hit_entry>*)arg[0]);
  else ::new(mem) ::std::vector<hit_entry>(*(const ::std::vector<hit_entry>*)arg[0]);
}

static void destructor_9358(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<hit_entry>*)o)->::std::vector<hit_entry>::~vector)();
}
static  void operator_9359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<hit_entry>*)o)->operator=)(*(const ::std::vector<hit_entry>*)arg[0]);
  else   (((::std::vector<hit_entry>*)o)->operator=)(*(const ::std::vector<hit_entry>*)arg[0]);
}

static  void method_9360( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<hit_entry>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::hit_entry*)arg[1]);
}

static  void method_9361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >)((((::std::vector<hit_entry>*)o)->begin)());
  else   (((::std::vector<hit_entry>*)o)->begin)();
}

static  void method_9362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const hit_entry*,std::vector<hit_entry> >)((((const ::std::vector<hit_entry>*)o)->begin)());
  else   (((const ::std::vector<hit_entry>*)o)->begin)();
}

static  void method_9363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >)((((::std::vector<hit_entry>*)o)->end)());
  else   (((::std::vector<hit_entry>*)o)->end)();
}

static  void method_9364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const hit_entry*,std::vector<hit_entry> >)((((const ::std::vector<hit_entry>*)o)->end)());
  else   (((const ::std::vector<hit_entry>*)o)->end)();
}

static  void method_9369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<hit_entry>*)o)->size)());
  else   (((const ::std::vector<hit_entry>*)o)->size)();
}

static  void method_9370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<hit_entry>*)o)->max_size)());
  else   (((const ::std::vector<hit_entry>*)o)->max_size)();
}

static  void method_9371( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<hit_entry>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<hit_entry>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::hit_entry*)arg[1]);
  }
}

static  void method_9372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<hit_entry>*)o)->capacity)());
  else   (((const ::std::vector<hit_entry>*)o)->capacity)();
}

static  void method_9373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<hit_entry>*)o)->empty)());
  else   (((const ::std::vector<hit_entry>*)o)->empty)();
}

static  void method_9374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<hit_entry>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<hit_entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<hit_entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<hit_entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<hit_entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<hit_entry>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<hit_entry>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<hit_entry>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<hit_entry>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<hit_entry>*)o)->front)();
  else   (((::std::vector<hit_entry>*)o)->front)();
}

static  void method_9381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<hit_entry>*)o)->front)();
  else   (((const ::std::vector<hit_entry>*)o)->front)();
}

static  void method_9382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<hit_entry>*)o)->back)();
  else   (((::std::vector<hit_entry>*)o)->back)();
}

static  void method_9383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<hit_entry>*)o)->back)();
  else   (((const ::std::vector<hit_entry>*)o)->back)();
}

static  void method_9384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<hit_entry>*)o)->data)());
  else   (((::std::vector<hit_entry>*)o)->data)();
}

static  void method_9385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<hit_entry>*)o)->data)());
  else   (((const ::std::vector<hit_entry>*)o)->data)();
}

static  void method_9386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<hit_entry>*)o)->push_back)(*(const ::hit_entry*)arg[0]);
}

static  void method_9387( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<hit_entry>*)o)->pop_back)();
}

static  void method_9388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >)((((::std::vector<hit_entry>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >*)arg[0],
    *(const ::hit_entry*)arg[1]));
  else   (((::std::vector<hit_entry>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >*)arg[0],
    *(const ::hit_entry*)arg[1]);
}

static  void method_9389( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<hit_entry>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::hit_entry*)arg[2]);
}

static  void method_9390( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >)((((::std::vector<hit_entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >*)arg[0]));
  else   (((::std::vector<hit_entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >*)arg[0]);
}

static  void method_9391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >)((((::std::vector<hit_entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >*)arg[1]));
  else   (((::std::vector<hit_entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<hit_entry*,std::vector<hit_entry> >*)arg[1]);
}

static  void method_9392( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<hit_entry>*)o)->swap)(*(::std::vector<hit_entry>*)arg[0]);
}

static  void method_9393( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<hit_entry>*)o)->clear)();
}

static void method_newdel_2555( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<hit_entry> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<hit_entry> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<hit_entry> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<hit_entry> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<hit_entry> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<hit_entry,std::allocator<hit_entry> >")), ::Reflex::BaseOffset< ::std::vector<hit_entry>,::std::_Vector_base<hit_entry,std::allocator<hit_entry> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<hit_entry> >::Generate();
  else ::Reflex::Proxy< ::std::vector<hit_entry> >::Generate();
}

//------Dictionary for class vector<hit_entry,std::allocator<hit_entry> > -------------------------------
void __std__vector_hit_entry__db_datamem(Reflex::Class*);
void __std__vector_hit_entry__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_hit_entry__datamem_bld(&__std__vector_hit_entry__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_hit_entry__funcmem_bld(&__std__vector_hit_entry__db_funcmem);
void __std__vector_hit_entry__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<hit_entry>"), typeid(::std::vector<hit_entry>), sizeof(::std::vector<hit_entry>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2167, ::Reflex::BaseOffset< ::std::vector<hit_entry>, ::std::_Vector_base<hit_entry,std::allocator<hit_entry> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1712, Reflex::Literal("std::vector<hit_entry>::_Alloc_value_type"))
  .AddTypedef(type_2167, Reflex::Literal("std::vector<hit_entry>::_Base"))
  .AddTypedef(type_2729, Reflex::Literal("std::vector<hit_entry>::_Tp_alloc_type"))
  .AddTypedef(type_5463, Reflex::Literal("std::vector<hit_entry>::_Alloc_traits"))
  .AddTypedef(type_1712, Reflex::Literal("std::vector<hit_entry>::value_type"))
  .AddTypedef(type_6527, Reflex::Literal("std::vector<hit_entry>::pointer"))
  .AddTypedef(type_9341, Reflex::Literal("std::vector<hit_entry>::const_pointer"))
  .AddTypedef(type_9343, Reflex::Literal("std::vector<hit_entry>::reference"))
  .AddTypedef(type_9345, Reflex::Literal("std::vector<hit_entry>::const_reference"))
  .AddTypedef(type_5389, Reflex::Literal("std::vector<hit_entry>::iterator"))
  .AddTypedef(type_5390, Reflex::Literal("std::vector<hit_entry>::const_iterator"))
  .AddTypedef(type_2837, Reflex::Literal("std::vector<hit_entry>::const_reverse_iterator"))
  .AddTypedef(type_2838, Reflex::Literal("std::vector<hit_entry>::reverse_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::vector<hit_entry>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::vector<hit_entry>::difference_type"))
  .AddTypedef(type_2729, Reflex::Literal("std::vector<hit_entry>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9354, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17579), Reflex::Literal("vector"), constructor_9355, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2700, type_9345, type_17579), Reflex::Literal("vector"), constructor_9356, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18251), Reflex::Literal("vector"), constructor_9357, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9358, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2555, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_hit_entry__funcmem_bld);
}

//------Delayed data member builder for class vector<hit_entry,std::allocator<hit_entry> > -------------------
void __std__vector_hit_entry__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<hit_entry,std::allocator<hit_entry> > -------------------
void __std__vector_hit_entry__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18252, type_18251), Reflex::Literal("operator="), operator_9359, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2700, type_9345), Reflex::Literal("assign"), method_9360, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5389), Reflex::Literal("begin"), method_9361, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5390), Reflex::Literal("begin"), method_9362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5389), Reflex::Literal("end"), method_9363, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5390), Reflex::Literal("end"), method_9364, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_9369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_9370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2700, type_1712), Reflex::Literal("resize"), method_9371, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("capacity"), method_9372, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_9373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2700), Reflex::Literal("reserve"), method_9374, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9343, type_2700), Reflex::Literal("operator[]"), operator_9375, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9345, type_2700), Reflex::Literal("operator[]"), operator_9376, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9343, type_2700), Reflex::Literal("at"), method_9378, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9345, type_2700), Reflex::Literal("at"), method_9379, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9343), Reflex::Literal("front"), method_9380, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9345), Reflex::Literal("front"), method_9381, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9343), Reflex::Literal("back"), method_9382, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9345), Reflex::Literal("back"), method_9383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6527), Reflex::Literal("data"), method_9384, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9341), Reflex::Literal("data"), method_9385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_9345), Reflex::Literal("push_back"), method_9386, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("pop_back"), method_9387, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5389, type_5389, type_9345), Reflex::Literal("insert"), method_9388, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_5389, type_2700, type_9345), Reflex::Literal("insert"), method_9389, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5389, type_5389), Reflex::Literal("erase"), method_9390, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5389, type_5389, type_5389), Reflex::Literal("erase"), method_9391, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_18252), Reflex::Literal("swap"), method_9392, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("clear"), method_9393, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<long int,int,std::less<long int>,std::allocator<std::pair<const long int, int> > > -------------------------------
static void destructor_5540(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<long,int>*)o)->::std::map<long,int>::~map)();
}
static void constructor_5541( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<long,int>();
  else ::new(mem) ::std::map<long,int>();
}

static void constructor_5542( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<long,int>(*(const ::std::less<long>*)arg[0]);
  else ::new(mem) ::std::map<long,int>(*(const ::std::less<long>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<long,int>(*(const ::std::less<long>*)arg[0],
      *(const ::std::allocator<std::pair<const long,int> >*)arg[1]);
  else ::new(mem) ::std::map<long,int>(*(const ::std::less<long>*)arg[0],
      *(const ::std::allocator<std::pair<const long,int> >*)arg[1]);
  }
}

static void constructor_5543( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<long,int>(*(const ::std::map<long,int>*)arg[0]);
  else ::new(mem) ::std::map<long,int>(*(const ::std::map<long,int>*)arg[0]);
}

static  void operator_5544( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<long,int>*)o)->operator=)(*(const ::std::map<long,int>*)arg[0]);
  else   (((::std::map<long,int>*)o)->operator=)(*(const ::std::map<long,int>*)arg[0]);
}

static  void method_5545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const long,int> >)((((const ::std::map<long,int>*)o)->get_allocator)());
  else   (((const ::std::map<long,int>*)o)->get_allocator)();
}

static  void method_5546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,int> >)((((::std::map<long,int>*)o)->begin)());
  else   (((::std::map<long,int>*)o)->begin)();
}

static  void method_5547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const long,int> >)((((const ::std::map<long,int>*)o)->begin)());
  else   (((const ::std::map<long,int>*)o)->begin)();
}

static  void method_5548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,int> >)((((::std::map<long,int>*)o)->end)());
  else   (((::std::map<long,int>*)o)->end)();
}

static  void method_5549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const long,int> >)((((const ::std::map<long,int>*)o)->end)());
  else   (((const ::std::map<long,int>*)o)->end)();
}

static  void method_5554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<long,int>*)o)->empty)());
  else   (((const ::std::map<long,int>*)o)->empty)();
}

static  void method_5555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<long,int>*)o)->size)());
  else   (((const ::std::map<long,int>*)o)->size)();
}

static  void method_5556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<long,int>*)o)->max_size)());
  else   (((const ::std::map<long,int>*)o)->max_size)();
}

static  void operator_5557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<long,int>*)o)->operator[])(*(const long*)arg[0]);
  else   (((::std::map<long,int>*)o)->operator[])(*(const long*)arg[0]);
}

static  void method_5558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<long,int>*)o)->at)(*(const long*)arg[0]);
  else   (((::std::map<long,int>*)o)->at)(*(const long*)arg[0]);
}

static  void method_5559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<long,int>*)o)->at)(*(const long*)arg[0]);
  else   (((const ::std::map<long,int>*)o)->at)(*(const long*)arg[0]);
}

static  void method_5560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const long,int> >,bool>)((((::std::map<long,int>*)o)->insert)(*(const ::std::pair<const long,int>*)arg[0]));
  else   (((::std::map<long,int>*)o)->insert)(*(const ::std::pair<const long,int>*)arg[0]);
}

static  void method_5561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,int> >)((((::std::map<long,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const long,int> >*)arg[0],
    *(const ::std::pair<const long,int>*)arg[1]));
  else   (((::std::map<long,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const long,int> >*)arg[0],
    *(const ::std::pair<const long,int>*)arg[1]);
}

static  void method_5562( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<long,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const long,int> >*)arg[0]);
}

static  void method_5563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<long,int>*)o)->erase)(*(const long*)arg[0]));
  else   (((::std::map<long,int>*)o)->erase)(*(const long*)arg[0]);
}

static  void method_5564( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<long,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const long,int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const long,int> >*)arg[1]);
}

static  void method_5565( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<long,int>*)o)->swap)(*(::std::map<long,int>*)arg[0]);
}

static  void method_5566( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<long,int>*)o)->clear)();
}

static  void method_5567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<long>)((((const ::std::map<long,int>*)o)->key_comp)());
  else   (((const ::std::map<long,int>*)o)->key_comp)();
}

static  void method_5569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,int> >)((((::std::map<long,int>*)o)->find)(*(const long*)arg[0]));
  else   (((::std::map<long,int>*)o)->find)(*(const long*)arg[0]);
}

static  void method_5570( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const long,int> >)((((const ::std::map<long,int>*)o)->find)(*(const long*)arg[0]));
  else   (((const ::std::map<long,int>*)o)->find)(*(const long*)arg[0]);
}

static  void method_5571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<long,int>*)o)->count)(*(const long*)arg[0]));
  else   (((const ::std::map<long,int>*)o)->count)(*(const long*)arg[0]);
}

static  void method_5572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,int> >)((((::std::map<long,int>*)o)->lower_bound)(*(const long*)arg[0]));
  else   (((::std::map<long,int>*)o)->lower_bound)(*(const long*)arg[0]);
}

static  void method_5573( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const long,int> >)((((const ::std::map<long,int>*)o)->lower_bound)(*(const long*)arg[0]));
  else   (((const ::std::map<long,int>*)o)->lower_bound)(*(const long*)arg[0]);
}

static  void method_5574( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,int> >)((((::std::map<long,int>*)o)->upper_bound)(*(const long*)arg[0]));
  else   (((::std::map<long,int>*)o)->upper_bound)(*(const long*)arg[0]);
}

static  void method_5575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const long,int> >)((((const ::std::map<long,int>*)o)->upper_bound)(*(const long*)arg[0]));
  else   (((const ::std::map<long,int>*)o)->upper_bound)(*(const long*)arg[0]);
}

static  void method_5576( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const long,int> >,std::_Rb_tree_iterator<std::pair<const long,int> > >)((((::std::map<long,int>*)o)->equal_range)(*(const long*)arg[0]));
  else   (((::std::map<long,int>*)o)->equal_range)(*(const long*)arg[0]);
}

static  void method_5577( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const long,int> >,std::_Rb_tree_const_iterator<std::pair<const long,int> > >)((((const ::std::map<long,int>*)o)->equal_range)(*(const long*)arg[0]));
  else   (((const ::std::map<long,int>*)o)->equal_range)(*(const long*)arg[0]);
}

static void method_newdel_1780( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<long,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<long,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<long,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<long,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<long,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<long,int> >::Generate();
  else ::Reflex::Proxy< ::std::map<long,int> >::Generate();
}

//------Dictionary for class map<long int,int,std::less<long int>,std::allocator<std::pair<const long int, int> > > -------------------------------
void __std__map_long_int__db_datamem(Reflex::Class*);
void __std__map_long_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_long_int__datamem_bld(&__std__map_long_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_long_int__funcmem_bld(&__std__map_long_int__db_funcmem);
void __std__map_long_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<long,int>"), typeid(::std::map<long,int>), sizeof(::std::map<long,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_10, Reflex::Literal("std::map<long,int>::key_type"))
  .AddTypedef(type_69, Reflex::Literal("std::map<long,int>::mapped_type"))
  .AddTypedef(type_2518, Reflex::Literal("std::map<long,int>::value_type"))
  .AddTypedef(type_2297, Reflex::Literal("std::map<long,int>::key_compare"))
  .AddTypedef(type_2717, Reflex::Literal("std::map<long,int>::allocator_type"))
  .AddTypedef(type_2518, Reflex::Literal("std::map<long,int>::_Alloc_value_type"))
  .AddTypedef(type_2717, Reflex::Literal("std::map<long,int>::_Pair_alloc_type"))
  .AddTypedef(type_2346, Reflex::Literal("std::map<long,int>::_Rep_type"))
  .AddTypedef(type_5526, Reflex::Literal("std::map<long,int>::pointer"))
  .AddTypedef(type_5528, Reflex::Literal("std::map<long,int>::const_pointer"))
  .AddTypedef(type_5530, Reflex::Literal("std::map<long,int>::reference"))
  .AddTypedef(type_5532, Reflex::Literal("std::map<long,int>::const_reference"))
  .AddTypedef(type_2606, Reflex::Literal("std::map<long,int>::iterator"))
  .AddTypedef(type_2702, Reflex::Literal("std::map<long,int>::const_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::map<long,int>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::map<long,int>::difference_type"))
  .AddTypedef(type_2824, Reflex::Literal("std::map<long,int>::reverse_iterator"))
  .AddTypedef(type_2823, Reflex::Literal("std::map<long,int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_5540, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_5541, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14416, type_16274), Reflex::Literal("map"), constructor_5542, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9085), Reflex::Literal("map"), constructor_5543, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1780, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_long_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_long_int__funcmem_bld);
}

//------Delayed data member builder for class map<long int,int,std::less<long int>,std::allocator<std::pair<const long int, int> > > -------------------
void __std__map_long_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2346, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_long_int_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<long int,int,std::less<long int>,std::allocator<std::pair<const long int, int> > > -------------------
void __std__map_long_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9083, type_9085), Reflex::Literal("operator="), operator_5544, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2717), Reflex::Literal("get_allocator"), method_5545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606), Reflex::Literal("begin"), method_5546, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702), Reflex::Literal("begin"), method_5547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606), Reflex::Literal("end"), method_5548, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702), Reflex::Literal("end"), method_5549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_5554, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_5555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_5556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14534, type_9020), Reflex::Literal("operator[]"), operator_5557, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14534, type_9020), Reflex::Literal("at"), method_5558, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7622, type_9020), Reflex::Literal("at"), method_5559, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2524, type_5532), Reflex::Literal("insert"), method_5560, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606, type_2606, type_5532), Reflex::Literal("insert"), method_5561, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2606), Reflex::Literal("erase"), method_5562, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_9020), Reflex::Literal("erase"), method_5563, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2606, type_2606), Reflex::Literal("erase"), method_5564, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_9083), Reflex::Literal("swap"), method_5565, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("clear"), method_5566, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2297), Reflex::Literal("key_comp"), method_5567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606, type_9020), Reflex::Literal("find"), method_5569, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702, type_9020), Reflex::Literal("find"), method_5570, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_9020), Reflex::Literal("count"), method_5571, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606, type_9020), Reflex::Literal("lower_bound"), method_5572, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702, type_9020), Reflex::Literal("lower_bound"), method_5573, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606, type_9020), Reflex::Literal("upper_bound"), method_5574, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702, type_9020), Reflex::Literal("upper_bound"), method_5575, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2523, type_9020), Reflex::Literal("equal_range"), method_5576, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2522, type_9020), Reflex::Literal("equal_range"), method_5577, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > > > -------------------------------
static void constructor_13592( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<long,int> >();
  else ::new(mem) ::edm::Wrapper<std::map<long,int> >();
}

static void constructor_13593( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<long,int> >(*(::std::auto_ptr<std::map<long,int> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<long,int> >(*(::std::auto_ptr<std::map<long,int> >*)arg[0]);
}

static void destructor_13594(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<long,int> >*)o)->::edm::Wrapper<std::map<long,int> >::~Wrapper)();
}
static  void method_13595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<long,int> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<long,int> >*)o)->product)();
}

static  void operator_13596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<long,int> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<long,int> >*)o)->operator->)();
}

static  void method_13597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<long,int> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<long,int> >*)o)->productTypeInfo)();
}

static  void method_13598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<long,int> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<long,int> >*)o)->typeInfo)();
}

static void constructor_13599( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<long,int> >((::std::map<long,int>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<long,int> >((::std::map<long,int>*)arg[0]);
}

static  void method_13600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<long,int> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<long,int> >*)o)->getInterface)();
}

static  void method_13601( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<long,int> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<long,int> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13603( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<long,int> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<long,int> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<long,int> >*)o)->dynamicTypeInfo)();
}

static  void method_13605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<long,int> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<long,int> >*)o)->isPresent)();
}

static  void method_13606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<long,int> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<long,int> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3476( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<long,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<long,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<long,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<long,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<long,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > > > -------------------------------
void __edm__Wrapper_std__map_long_int_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_long_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_long_int_s__datamem_bld(&__edm__Wrapper_std__map_long_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_long_int_s__funcmem_bld(&__edm__Wrapper_std__map_long_int_s__db_funcmem);
void __edm__Wrapper_std__map_long_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<long,int> >"), typeid(::edm::Wrapper<std::map<long,int> >), sizeof(::edm::Wrapper<std::map<long,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1780, Reflex::Literal("edm::Wrapper<std::map<long,int> >::value_type"))
  .AddTypedef(type_1780, Reflex::Literal("edm::Wrapper<std::map<long,int> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13592, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2388), Reflex::Literal("Wrapper"), constructor_13593, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13594, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6433), Reflex::Literal("Wrapper"), constructor_13599, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3476, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_long_int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_long_int_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > > > -------------------
void __edm__Wrapper_std__map_long_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_long_int_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1780, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_long_int_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > > > -------------------
void __edm__Wrapper_std__map_long_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9081), Reflex::Literal("product"), method_13595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9081), Reflex::Literal("operator->"), operator_13596, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("productTypeInfo"), method_13597, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("typeInfo"), method_13598, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20117), Reflex::Literal("getInterface"), method_13600, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_13702, type_14463, type_14464), Reflex::Literal("fillView"), method_13601, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_271, type_7269), Reflex::Literal("setPtr"), method_13602, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_14465, type_14463), Reflex::Literal("fillPtrVector"), method_13603, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo"), method_13604, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_13605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo_"), method_13606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<long int,std::vector<long int, std::allocator<long int> >,std::less<long int>,std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > -------------------------------
static void destructor_4339(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<long,std::vector<long> >*)o)->::std::map<long,std::vector<long> >::~map)();
}
static void constructor_4340( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<long,std::vector<long> >();
  else ::new(mem) ::std::map<long,std::vector<long> >();
}

static void constructor_4341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<long,std::vector<long> >(*(const ::std::less<long>*)arg[0]);
  else ::new(mem) ::std::map<long,std::vector<long> >(*(const ::std::less<long>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<long,std::vector<long> >(*(const ::std::less<long>*)arg[0],
      *(const ::std::allocator<std::pair<const long,std::vector<long> > >*)arg[1]);
  else ::new(mem) ::std::map<long,std::vector<long> >(*(const ::std::less<long>*)arg[0],
      *(const ::std::allocator<std::pair<const long,std::vector<long> > >*)arg[1]);
  }
}

static void constructor_4342( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<long,std::vector<long> >(*(const ::std::map<long,std::vector<long> >*)arg[0]);
  else ::new(mem) ::std::map<long,std::vector<long> >(*(const ::std::map<long,std::vector<long> >*)arg[0]);
}

static  void operator_4343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<long,std::vector<long> >*)o)->operator=)(*(const ::std::map<long,std::vector<long> >*)arg[0]);
  else   (((::std::map<long,std::vector<long> >*)o)->operator=)(*(const ::std::map<long,std::vector<long> >*)arg[0]);
}

static  void method_4344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const long,std::vector<long> > >)((((const ::std::map<long,std::vector<long> >*)o)->get_allocator)());
  else   (((const ::std::map<long,std::vector<long> >*)o)->get_allocator)();
}

static  void method_4345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >)((((::std::map<long,std::vector<long> >*)o)->begin)());
  else   (((::std::map<long,std::vector<long> >*)o)->begin)();
}

static  void method_4346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const long,std::vector<long> > >)((((const ::std::map<long,std::vector<long> >*)o)->begin)());
  else   (((const ::std::map<long,std::vector<long> >*)o)->begin)();
}

static  void method_4347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >)((((::std::map<long,std::vector<long> >*)o)->end)());
  else   (((::std::map<long,std::vector<long> >*)o)->end)();
}

static  void method_4348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const long,std::vector<long> > >)((((const ::std::map<long,std::vector<long> >*)o)->end)());
  else   (((const ::std::map<long,std::vector<long> >*)o)->end)();
}

static  void method_4353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<long,std::vector<long> >*)o)->empty)());
  else   (((const ::std::map<long,std::vector<long> >*)o)->empty)();
}

static  void method_4354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<long,std::vector<long> >*)o)->size)());
  else   (((const ::std::map<long,std::vector<long> >*)o)->size)();
}

static  void method_4355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<long,std::vector<long> >*)o)->max_size)());
  else   (((const ::std::map<long,std::vector<long> >*)o)->max_size)();
}

static  void operator_4356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<long,std::vector<long> >*)o)->operator[])(*(const long*)arg[0]);
  else   (((::std::map<long,std::vector<long> >*)o)->operator[])(*(const long*)arg[0]);
}

static  void method_4357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<long,std::vector<long> >*)o)->at)(*(const long*)arg[0]);
  else   (((::std::map<long,std::vector<long> >*)o)->at)(*(const long*)arg[0]);
}

static  void method_4358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<long,std::vector<long> >*)o)->at)(*(const long*)arg[0]);
  else   (((const ::std::map<long,std::vector<long> >*)o)->at)(*(const long*)arg[0]);
}

static  void method_4359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >,bool>)((((::std::map<long,std::vector<long> >*)o)->insert)(*(const ::std::pair<const long,std::vector<long> >*)arg[0]));
  else   (((::std::map<long,std::vector<long> >*)o)->insert)(*(const ::std::pair<const long,std::vector<long> >*)arg[0]);
}

static  void method_4360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >)((((::std::map<long,std::vector<long> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >*)arg[0],
    *(const ::std::pair<const long,std::vector<long> >*)arg[1]));
  else   (((::std::map<long,std::vector<long> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >*)arg[0],
    *(const ::std::pair<const long,std::vector<long> >*)arg[1]);
}

static  void method_4361( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<long,std::vector<long> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >*)arg[0]);
}

static  void method_4362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<long,std::vector<long> >*)o)->erase)(*(const long*)arg[0]));
  else   (((::std::map<long,std::vector<long> >*)o)->erase)(*(const long*)arg[0]);
}

static  void method_4363( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<long,std::vector<long> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >*)arg[1]);
}

static  void method_4364( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<long,std::vector<long> >*)o)->swap)(*(::std::map<long,std::vector<long> >*)arg[0]);
}

static  void method_4365( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<long,std::vector<long> >*)o)->clear)();
}

static  void method_4366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<long>)((((const ::std::map<long,std::vector<long> >*)o)->key_comp)());
  else   (((const ::std::map<long,std::vector<long> >*)o)->key_comp)();
}

static  void method_4368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >)((((::std::map<long,std::vector<long> >*)o)->find)(*(const long*)arg[0]));
  else   (((::std::map<long,std::vector<long> >*)o)->find)(*(const long*)arg[0]);
}

static  void method_4369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const long,std::vector<long> > >)((((const ::std::map<long,std::vector<long> >*)o)->find)(*(const long*)arg[0]));
  else   (((const ::std::map<long,std::vector<long> >*)o)->find)(*(const long*)arg[0]);
}

static  void method_4370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<long,std::vector<long> >*)o)->count)(*(const long*)arg[0]));
  else   (((const ::std::map<long,std::vector<long> >*)o)->count)(*(const long*)arg[0]);
}

static  void method_4371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >)((((::std::map<long,std::vector<long> >*)o)->lower_bound)(*(const long*)arg[0]));
  else   (((::std::map<long,std::vector<long> >*)o)->lower_bound)(*(const long*)arg[0]);
}

static  void method_4372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const long,std::vector<long> > >)((((const ::std::map<long,std::vector<long> >*)o)->lower_bound)(*(const long*)arg[0]));
  else   (((const ::std::map<long,std::vector<long> >*)o)->lower_bound)(*(const long*)arg[0]);
}

static  void method_4373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >)((((::std::map<long,std::vector<long> >*)o)->upper_bound)(*(const long*)arg[0]));
  else   (((::std::map<long,std::vector<long> >*)o)->upper_bound)(*(const long*)arg[0]);
}

static  void method_4374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const long,std::vector<long> > >)((((const ::std::map<long,std::vector<long> >*)o)->upper_bound)(*(const long*)arg[0]));
  else   (((const ::std::map<long,std::vector<long> >*)o)->upper_bound)(*(const long*)arg[0]);
}

static  void method_4375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > >,std::_Rb_tree_iterator<std::pair<const long,std::vector<long> > > >)((((::std::map<long,std::vector<long> >*)o)->equal_range)(*(const long*)arg[0]));
  else   (((::std::map<long,std::vector<long> >*)o)->equal_range)(*(const long*)arg[0]);
}

static  void method_4376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const long,std::vector<long> > >,std::_Rb_tree_const_iterator<std::pair<const long,std::vector<long> > > >)((((const ::std::map<long,std::vector<long> >*)o)->equal_range)(*(const long*)arg[0]));
  else   (((const ::std::map<long,std::vector<long> >*)o)->equal_range)(*(const long*)arg[0]);
}

static void method_newdel_741( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<long,std::vector<long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<long,std::vector<long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<long,std::vector<long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<long,std::vector<long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<long,std::vector<long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<long,std::vector<long> > >::Generate();
  else ::Reflex::Proxy< ::std::map<long,std::vector<long> > >::Generate();
}

//------Dictionary for class map<long int,std::vector<long int, std::allocator<long int> >,std::less<long int>,std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > -------------------------------
void __std__map_long_std__vector_long_s__db_datamem(Reflex::Class*);
void __std__map_long_std__vector_long_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_long_std__vector_long_s__datamem_bld(&__std__map_long_std__vector_long_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_long_std__vector_long_s__funcmem_bld(&__std__map_long_std__vector_long_s__db_funcmem);
void __std__map_long_std__vector_long_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<long,std::vector<long> >"), typeid(::std::map<long,std::vector<long> >), sizeof(::std::map<long,std::vector<long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_10, Reflex::Literal("std::map<long,std::vector<long> >::key_type"))
  .AddTypedef(type_2550, Reflex::Literal("std::map<long,std::vector<long> >::mapped_type"))
  .AddTypedef(type_2519, Reflex::Literal("std::map<long,std::vector<long> >::value_type"))
  .AddTypedef(type_2297, Reflex::Literal("std::map<long,std::vector<long> >::key_compare"))
  .AddTypedef(type_2718, Reflex::Literal("std::map<long,std::vector<long> >::allocator_type"))
  .AddTypedef(type_2519, Reflex::Literal("std::map<long,std::vector<long> >::_Alloc_value_type"))
  .AddTypedef(type_2718, Reflex::Literal("std::map<long,std::vector<long> >::_Pair_alloc_type"))
  .AddTypedef(type_2347, Reflex::Literal("std::map<long,std::vector<long> >::_Rep_type"))
  .AddTypedef(type_4325, Reflex::Literal("std::map<long,std::vector<long> >::pointer"))
  .AddTypedef(type_4327, Reflex::Literal("std::map<long,std::vector<long> >::const_pointer"))
  .AddTypedef(type_4329, Reflex::Literal("std::map<long,std::vector<long> >::reference"))
  .AddTypedef(type_4331, Reflex::Literal("std::map<long,std::vector<long> >::const_reference"))
  .AddTypedef(type_2607, Reflex::Literal("std::map<long,std::vector<long> >::iterator"))
  .AddTypedef(type_2703, Reflex::Literal("std::map<long,std::vector<long> >::const_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::map<long,std::vector<long> >::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::map<long,std::vector<long> >::difference_type"))
  .AddTypedef(type_2828, Reflex::Literal("std::map<long,std::vector<long> >::reverse_iterator"))
  .AddTypedef(type_2827, Reflex::Literal("std::map<long,std::vector<long> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_4339, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_4340, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14416, type_14417), Reflex::Literal("map"), constructor_4341, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9150), Reflex::Literal("map"), constructor_4342, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_741, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_long_std__vector_long_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_long_std__vector_long_s__funcmem_bld);
}

//------Delayed data member builder for class map<long int,std::vector<long int, std::allocator<long int> >,std::less<long int>,std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > -------------------
void __std__map_long_std__vector_long_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2347, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_long_std__vector_long_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<long int,std::vector<long int, std::allocator<long int> >,std::less<long int>,std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > -------------------
void __std__map_long_std__vector_long_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9148, type_9150), Reflex::Literal("operator="), operator_4343, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2718), Reflex::Literal("get_allocator"), method_4344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607), Reflex::Literal("begin"), method_4345, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703), Reflex::Literal("begin"), method_4346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607), Reflex::Literal("end"), method_4347, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703), Reflex::Literal("end"), method_4348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_4353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_4354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_4355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14418, type_9020), Reflex::Literal("operator[]"), operator_4356, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14418, type_9020), Reflex::Literal("at"), method_4357, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14419, type_9020), Reflex::Literal("at"), method_4358, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2528, type_4331), Reflex::Literal("insert"), method_4359, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607, type_2607, type_4331), Reflex::Literal("insert"), method_4360, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2607), Reflex::Literal("erase"), method_4361, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_9020), Reflex::Literal("erase"), method_4362, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2607, type_2607), Reflex::Literal("erase"), method_4363, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_9148), Reflex::Literal("swap"), method_4364, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("clear"), method_4365, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2297), Reflex::Literal("key_comp"), method_4366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607, type_9020), Reflex::Literal("find"), method_4368, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703, type_9020), Reflex::Literal("find"), method_4369, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_9020), Reflex::Literal("count"), method_4370, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607, type_9020), Reflex::Literal("lower_bound"), method_4371, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703, type_9020), Reflex::Literal("lower_bound"), method_4372, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607, type_9020), Reflex::Literal("upper_bound"), method_4373, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703, type_9020), Reflex::Literal("upper_bound"), method_4374, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2527, type_9020), Reflex::Literal("equal_range"), method_4375, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2526, type_9020), Reflex::Literal("equal_range"), method_4376, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > > -------------------------------
static void constructor_13613( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<long,std::vector<long> > >();
  else ::new(mem) ::edm::Wrapper<std::map<long,std::vector<long> > >();
}

static void constructor_13614( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<long,std::vector<long> > >(*(::std::auto_ptr<std::map<long,std::vector<long> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<long,std::vector<long> > >(*(::std::auto_ptr<std::map<long,std::vector<long> > >*)arg[0]);
}

static void destructor_13615(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->::edm::Wrapper<std::map<long,std::vector<long> > >::~Wrapper)();
}
static  void method_13616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->product)();
}

static  void operator_13617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->operator->)();
}

static  void method_13618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->productTypeInfo)();
}

static  void method_13619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->typeInfo)();
}

static void constructor_13620( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<long,std::vector<long> > >((::std::map<long,std::vector<long> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<long,std::vector<long> > >((::std::map<long,std::vector<long> >*)arg[0]);
}

static  void method_13621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->getInterface)();
}

static  void method_13622( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13623( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13624( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->dynamicTypeInfo)();
}

static  void method_13626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->isPresent)();
}

static  void method_13627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<long,std::vector<long> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3477( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<long,std::vector<long> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<long,std::vector<long> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<long,std::vector<long> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<long,std::vector<long> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<long,std::vector<long> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > > -------------------------------
void __edm__Wrapper_std__map_long_std__vector_long_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_long_std__vector_long_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_long_std__vector_long_s_s__datamem_bld(&__edm__Wrapper_std__map_long_std__vector_long_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_long_std__vector_long_s_s__funcmem_bld(&__edm__Wrapper_std__map_long_std__vector_long_s_s__db_funcmem);
void __edm__Wrapper_std__map_long_std__vector_long_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<long,std::vector<long> > >"), typeid(::edm::Wrapper<std::map<long,std::vector<long> > >), sizeof(::edm::Wrapper<std::map<long,std::vector<long> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_741, Reflex::Literal("edm::Wrapper<std::map<long,std::vector<long> > >::value_type"))
  .AddTypedef(type_741, Reflex::Literal("edm::Wrapper<std::map<long,std::vector<long> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13613, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2389), Reflex::Literal("Wrapper"), constructor_13614, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13615, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6452), Reflex::Literal("Wrapper"), constructor_13620, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3477, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_long_std__vector_long_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_long_std__vector_long_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > > -------------------
void __edm__Wrapper_std__map_long_std__vector_long_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_long_std__vector_long_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_741, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_long_std__vector_long_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > > -------------------
void __edm__Wrapper_std__map_long_std__vector_long_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9146), Reflex::Literal("product"), method_13616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9146), Reflex::Literal("operator->"), operator_13617, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("productTypeInfo"), method_13618, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("typeInfo"), method_13619, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20120), Reflex::Literal("getInterface"), method_13621, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_13702, type_14463, type_14464), Reflex::Literal("fillView"), method_13622, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_271, type_7269), Reflex::Literal("setPtr"), method_13623, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_14465, type_14463), Reflex::Literal("fillPtrVector"), method_13624, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo"), method_13625, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_13626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo_"), method_13627, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::pair<long int, long int>,long unsigned int,std::less<std::pair<long int, long int> >,std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > -------------------------------
static void destructor_4549(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::pair<long,long>,unsigned long>*)o)->::std::map<std::pair<long,long>,unsigned long>::~map)();
}
static void constructor_4550( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<long,long>,unsigned long>();
  else ::new(mem) ::std::map<std::pair<long,long>,unsigned long>();
}

static void constructor_4551( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<long,long>,unsigned long>(*(const ::std::less<std::pair<long,long> >*)arg[0]);
  else ::new(mem) ::std::map<std::pair<long,long>,unsigned long>(*(const ::std::less<std::pair<long,long> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<long,long>,unsigned long>(*(const ::std::less<std::pair<long,long> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::pair<long,long>,unsigned long> >*)arg[1]);
  else ::new(mem) ::std::map<std::pair<long,long>,unsigned long>(*(const ::std::less<std::pair<long,long> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::pair<long,long>,unsigned long> >*)arg[1]);
  }
}

static void constructor_4552( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<long,long>,unsigned long>(*(const ::std::map<std::pair<long,long>,unsigned long>*)arg[0]);
  else ::new(mem) ::std::map<std::pair<long,long>,unsigned long>(*(const ::std::map<std::pair<long,long>,unsigned long>*)arg[0]);
}

static  void operator_4553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<long,long>,unsigned long>*)o)->operator=)(*(const ::std::map<std::pair<long,long>,unsigned long>*)arg[0]);
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->operator=)(*(const ::std::map<std::pair<long,long>,unsigned long>*)arg[0]);
}

static  void method_4554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::pair<long,long>,unsigned long> >)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->get_allocator)());
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->get_allocator)();
}

static  void method_4555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >)((((::std::map<std::pair<long,long>,unsigned long>*)o)->begin)());
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->begin)();
}

static  void method_4556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<long,long>,unsigned long> >)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->begin)());
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->begin)();
}

static  void method_4557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >)((((::std::map<std::pair<long,long>,unsigned long>*)o)->end)());
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->end)();
}

static  void method_4558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<long,long>,unsigned long> >)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->end)());
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->end)();
}

static  void method_4563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->empty)());
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->empty)();
}

static  void method_4564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->size)());
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->size)();
}

static  void method_4565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->max_size)());
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->max_size)();
}

static  void operator_4566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<long,long>,unsigned long>*)o)->operator[])(*(const ::std::pair<long,long>*)arg[0]);
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->operator[])(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<long,long>,unsigned long>*)o)->at)(*(const ::std::pair<long,long>*)arg[0]);
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->at)(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::pair<long,long>,unsigned long>*)o)->at)(*(const ::std::pair<long,long>*)arg[0]);
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->at)(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >,bool>)((((::std::map<std::pair<long,long>,unsigned long>*)o)->insert)(*(const ::std::pair<const std::pair<long,long>,unsigned long>*)arg[0]));
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->insert)(*(const ::std::pair<const std::pair<long,long>,unsigned long>*)arg[0]);
}

static  void method_4570( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >)((((::std::map<std::pair<long,long>,unsigned long>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >*)arg[0],
    *(const ::std::pair<const std::pair<long,long>,unsigned long>*)arg[1]));
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >*)arg[0],
    *(const ::std::pair<const std::pair<long,long>,unsigned long>*)arg[1]);
}

static  void method_4571( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<long,long>,unsigned long>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >*)arg[0]);
}

static  void method_4572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::pair<long,long>,unsigned long>*)o)->erase)(*(const ::std::pair<long,long>*)arg[0]));
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->erase)(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4573( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<long,long>,unsigned long>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >*)arg[1]);
}

static  void method_4574( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<long,long>,unsigned long>*)o)->swap)(*(::std::map<std::pair<long,long>,unsigned long>*)arg[0]);
}

static  void method_4575( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::pair<long,long>,unsigned long>*)o)->clear)();
}

static  void method_4576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::pair<long,long> >)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->key_comp)());
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->key_comp)();
}

static  void method_4578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >)((((::std::map<std::pair<long,long>,unsigned long>*)o)->find)(*(const ::std::pair<long,long>*)arg[0]));
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->find)(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4579( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<long,long>,unsigned long> >)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->find)(*(const ::std::pair<long,long>*)arg[0]));
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->find)(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->count)(*(const ::std::pair<long,long>*)arg[0]));
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->count)(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >)((((::std::map<std::pair<long,long>,unsigned long>*)o)->lower_bound)(*(const ::std::pair<long,long>*)arg[0]));
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->lower_bound)(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<long,long>,unsigned long> >)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->lower_bound)(*(const ::std::pair<long,long>*)arg[0]));
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->lower_bound)(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >)((((::std::map<std::pair<long,long>,unsigned long>*)o)->upper_bound)(*(const ::std::pair<long,long>*)arg[0]));
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->upper_bound)(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<long,long>,unsigned long> >)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->upper_bound)(*(const ::std::pair<long,long>*)arg[0]));
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->upper_bound)(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> >,std::_Rb_tree_iterator<std::pair<const std::pair<long,long>,unsigned long> > >)((((::std::map<std::pair<long,long>,unsigned long>*)o)->equal_range)(*(const ::std::pair<long,long>*)arg[0]));
  else   (((::std::map<std::pair<long,long>,unsigned long>*)o)->equal_range)(*(const ::std::pair<long,long>*)arg[0]);
}

static  void method_4586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::pair<long,long>,unsigned long> >,std::_Rb_tree_const_iterator<std::pair<const std::pair<long,long>,unsigned long> > >)((((const ::std::map<std::pair<long,long>,unsigned long>*)o)->equal_range)(*(const ::std::pair<long,long>*)arg[0]));
  else   (((const ::std::map<std::pair<long,long>,unsigned long>*)o)->equal_range)(*(const ::std::pair<long,long>*)arg[0]);
}

static void method_newdel_967( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<long,long>,unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<long,long>,unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<long,long>,unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<long,long>,unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<long,long>,unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::pair<long,long>,unsigned long> >::Generate();
  else ::Reflex::Proxy< ::std::map<std::pair<long,long>,unsigned long> >::Generate();
}

//------Dictionary for class map<std::pair<long int, long int>,long unsigned int,std::less<std::pair<long int, long int> >,std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > -------------------------------
void __std__map_std__pair_long_long__unsignedslong__db_datamem(Reflex::Class*);
void __std__map_std__pair_long_long__unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__pair_long_long__unsignedslong__datamem_bld(&__std__map_std__pair_long_long__unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__pair_long_long__unsignedslong__funcmem_bld(&__std__map_std__pair_long_long__unsignedslong__db_funcmem);
void __std__map_std__pair_long_long__unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::pair<long,long>,unsigned long>"), typeid(::std::map<std::pair<long,long>,unsigned long>), sizeof(::std::map<std::pair<long,long>,unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2521, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::key_type"))
  .AddTypedef(type_271, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::mapped_type"))
  .AddTypedef(type_2520, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::value_type"))
  .AddTypedef(type_2298, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::key_compare"))
  .AddTypedef(type_2720, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::allocator_type"))
  .AddTypedef(type_2520, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::_Alloc_value_type"))
  .AddTypedef(type_2720, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::_Pair_alloc_type"))
  .AddTypedef(type_2348, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::_Rep_type"))
  .AddTypedef(type_4535, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::pointer"))
  .AddTypedef(type_4537, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::const_pointer"))
  .AddTypedef(type_4539, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::reference"))
  .AddTypedef(type_4541, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::const_reference"))
  .AddTypedef(type_2608, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::iterator"))
  .AddTypedef(type_2704, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::const_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::difference_type"))
  .AddTypedef(type_2832, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::reverse_iterator"))
  .AddTypedef(type_2831, Reflex::Literal("std::map<std::pair<long,long>,unsigned long>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_4549, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_4550, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14453, type_14454), Reflex::Literal("map"), constructor_4551, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9215), Reflex::Literal("map"), constructor_4552, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_967, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__pair_long_long__unsignedslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__pair_long_long__unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class map<std::pair<long int, long int>,long unsigned int,std::less<std::pair<long int, long int> >,std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > -------------------
void __std__map_std__pair_long_long__unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2348, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__pair_long_long__unsignedslong_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::pair<long int, long int>,long unsigned int,std::less<std::pair<long int, long int> >,std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > -------------------
void __std__map_std__pair_long_long__unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9213, type_9215), Reflex::Literal("operator="), operator_4553, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2720), Reflex::Literal("get_allocator"), method_4554, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608), Reflex::Literal("begin"), method_4555, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704), Reflex::Literal("begin"), method_4556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608), Reflex::Literal("end"), method_4557, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704), Reflex::Literal("end"), method_4558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_4563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_4564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_4565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8954, type_14455), Reflex::Literal("operator[]"), operator_4566, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8954, type_14455), Reflex::Literal("at"), method_4567, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7069, type_14455), Reflex::Literal("at"), method_4568, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2531, type_4541), Reflex::Literal("insert"), method_4569, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608, type_2608, type_4541), Reflex::Literal("insert"), method_4570, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2608), Reflex::Literal("erase"), method_4571, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_14455), Reflex::Literal("erase"), method_4572, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2608, type_2608), Reflex::Literal("erase"), method_4573, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_9213), Reflex::Literal("swap"), method_4574, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("clear"), method_4575, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2298), Reflex::Literal("key_comp"), method_4576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608, type_14455), Reflex::Literal("find"), method_4578, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704, type_14455), Reflex::Literal("find"), method_4579, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_14455), Reflex::Literal("count"), method_4580, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608, type_14455), Reflex::Literal("lower_bound"), method_4581, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704, type_14455), Reflex::Literal("lower_bound"), method_4582, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608, type_14455), Reflex::Literal("upper_bound"), method_4583, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704, type_14455), Reflex::Literal("upper_bound"), method_4584, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2530, type_14455), Reflex::Literal("equal_range"), method_4585, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2529, type_14455), Reflex::Literal("equal_range"), method_4586, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > > -------------------------------
static void constructor_13634( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >();
  else ::new(mem) ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >();
}

static void constructor_13635( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >(*(::std::auto_ptr<std::map<std::pair<long,long>,unsigned long> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >(*(::std::auto_ptr<std::map<std::pair<long,long>,unsigned long> >*)arg[0]);
}

static void destructor_13636(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >::~Wrapper)();
}
static  void method_13637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->product)();
}

static  void operator_13638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->operator->)();
}

static  void method_13639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->productTypeInfo)();
}

static  void method_13640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->typeInfo)();
}

static void constructor_13641( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >((::std::map<std::pair<long,long>,unsigned long>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >((::std::map<std::pair<long,long>,unsigned long>*)arg[0]);
}

static  void method_13642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->getInterface)();
}

static  void method_13643( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13644( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13645( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->dynamicTypeInfo)();
}

static  void method_13647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->isPresent)();
}

static  void method_13648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3478( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > > -------------------------------
void __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__datamem_bld(&__edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__funcmem_bld(&__edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__db_funcmem);
void __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >"), typeid(::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >), sizeof(::edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_967, Reflex::Literal("edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >::value_type"))
  .AddTypedef(type_967, Reflex::Literal("edm::Wrapper<std::map<std::pair<long,long>,unsigned long> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13634, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2390), Reflex::Literal("Wrapper"), constructor_13635, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13636, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6471), Reflex::Literal("Wrapper"), constructor_13641, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3478, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > > -------------------
void __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_967, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > > -------------------
void __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9211), Reflex::Literal("product"), method_13637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9211), Reflex::Literal("operator->"), operator_13638, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("productTypeInfo"), method_13639, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("typeInfo"), method_13640, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20123), Reflex::Literal("getInterface"), method_13642, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_13702, type_14463, type_14464), Reflex::Literal("fillView"), method_13643, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_271, type_7269), Reflex::Literal("setPtr"), method_13644, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_14465, type_14463), Reflex::Literal("fillPtrVector"), method_13645, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo"), method_13646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_13647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo_"), method_13648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<T2Hit, std::allocator<T2Hit> > > -------------------------------
static void constructor_13655( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T2Hit> >();
  else ::new(mem) ::edm::Wrapper<std::vector<T2Hit> >();
}

static void constructor_13656( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T2Hit> >(*(::std::auto_ptr<std::vector<T2Hit> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<T2Hit> >(*(::std::auto_ptr<std::vector<T2Hit> >*)arg[0]);
}

static void destructor_13657(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<T2Hit> >*)o)->::edm::Wrapper<std::vector<T2Hit> >::~Wrapper)();
}
static  void method_13658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->product)();
}

static  void operator_13659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->operator->)();
}

static  void method_13660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<T2Hit> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<T2Hit> >*)o)->productTypeInfo)();
}

static  void method_13661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<T2Hit> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<T2Hit> >*)o)->typeInfo)();
}

static void constructor_13662( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T2Hit> >((::std::vector<T2Hit>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<T2Hit> >((::std::vector<T2Hit>*)arg[0]);
}

static  void method_13663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<T2Hit> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<T2Hit> >*)o)->getInterface)();
}

static  void method_13664( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13665( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->dynamicTypeInfo)();
}

static  void method_13668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->isPresent)();
}

static  void method_13669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<T2Hit> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3479( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T2Hit> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T2Hit> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T2Hit> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T2Hit> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T2Hit> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<T2Hit, std::allocator<T2Hit> > > -------------------------------
void __edm__Wrapper_std__vector_T2Hit_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_T2Hit_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_T2Hit_s__datamem_bld(&__edm__Wrapper_std__vector_T2Hit_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_T2Hit_s__funcmem_bld(&__edm__Wrapper_std__vector_T2Hit_s__db_funcmem);
void __edm__Wrapper_std__vector_T2Hit_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<T2Hit> >"), typeid(::edm::Wrapper<std::vector<T2Hit> >), sizeof(::edm::Wrapper<std::vector<T2Hit> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_268, Reflex::Literal("edm::Wrapper<std::vector<T2Hit> >::value_type"))
  .AddTypedef(type_268, Reflex::Literal("edm::Wrapper<std::vector<T2Hit> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13655, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2391), Reflex::Literal("Wrapper"), constructor_13656, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13657, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6490), Reflex::Literal("Wrapper"), constructor_13662, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3479, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_T2Hit_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_T2Hit_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<T2Hit, std::allocator<T2Hit> > > -------------------
void __edm__Wrapper_std__vector_T2Hit_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_T2Hit_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_268, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_T2Hit_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<T2Hit, std::allocator<T2Hit> > > -------------------
void __edm__Wrapper_std__vector_T2Hit_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9276), Reflex::Literal("product"), method_13658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9276), Reflex::Literal("operator->"), operator_13659, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("productTypeInfo"), method_13660, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("typeInfo"), method_13661, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20126), Reflex::Literal("getInterface"), method_13663, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_13702, type_14463, type_14464), Reflex::Literal("fillView"), method_13664, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_271, type_7269), Reflex::Literal("setPtr"), method_13665, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_14465, type_14463), Reflex::Literal("fillPtrVector"), method_13666, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo"), method_13667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_13668, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo_"), method_13669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > >, std::allocator<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > > > > -------------------------------
static void constructor_4621( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >();
}

static void constructor_4622( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >(*(::std::auto_ptr<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >(*(::std::auto_ptr<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)arg[0]);
}

static void destructor_4623(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >::~Wrapper)();
}
static  void method_4624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->product)();
}

static  void operator_4625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->operator->)();
}

static  void method_4626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->productTypeInfo)();
}

static  void method_4627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->typeInfo)();
}

static void constructor_4628( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >((::std::vector<std::map<std::pair<long,long>,unsigned long> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >((::std::vector<std::map<std::pair<long,long>,unsigned long> >*)arg[0]);
}

static  void method_4629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->getInterface)();
}

static  void method_4630( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_4631( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_4632( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_4633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->dynamicTypeInfo)();
}

static  void method_4634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->isPresent)();
}

static  void method_4635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_1053( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > >, std::allocator<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > > > > -------------------------------
void __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__datamem_bld(&__edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__funcmem_bld(&__edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__db_funcmem);
void __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >"), typeid(::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >), sizeof(::edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2553, Reflex::Literal("edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >::value_type"))
  .AddTypedef(type_2553, Reflex::Literal("edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_4621, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2394), Reflex::Literal("Wrapper"), constructor_4622, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_4623, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14461), Reflex::Literal("Wrapper"), constructor_4628, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1053, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > >, std::allocator<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > > > > -------------------
void __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2553, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > >, std::allocator<std::map<std::pair<long int, long int>, long unsigned int, std::less<std::pair<long int, long int> >, std::allocator<std::pair<const std::pair<long int, long int>, long unsigned int> > > > > > -------------------
void __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14460), Reflex::Literal("product"), method_4624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14460), Reflex::Literal("operator->"), operator_4625, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("productTypeInfo"), method_4626, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("typeInfo"), method_4627, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14462), Reflex::Literal("getInterface"), method_4629, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_13702, type_14463, type_14464), Reflex::Literal("fillView"), method_4630, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_271, type_7269), Reflex::Literal("setPtr"), method_4631, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_14465, type_14463), Reflex::Literal("fillPtrVector"), method_4632, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo"), method_4633, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_4634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo_"), method_4635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > >, std::allocator<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > > > > > -------------------------------
static void constructor_4678( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<long,int> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<long,int> > >();
}

static void constructor_4679( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<long,int> > >(*(::std::auto_ptr<std::vector<std::map<long,int> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<long,int> > >(*(::std::auto_ptr<std::vector<std::map<long,int> > >*)arg[0]);
}

static void destructor_4680(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->::edm::Wrapper<std::vector<std::map<long,int> > >::~Wrapper)();
}
static  void method_4681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->product)();
}

static  void operator_4682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->operator->)();
}

static  void method_4683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->productTypeInfo)();
}

static  void method_4684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->typeInfo)();
}

static void constructor_4685( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<long,int> > >((::std::vector<std::map<long,int> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<long,int> > >((::std::vector<std::map<long,int> >*)arg[0]);
}

static  void method_4686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->getInterface)();
}

static  void method_4687( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_4688( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_4689( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_4690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->dynamicTypeInfo)();
}

static  void method_4691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->isPresent)();
}

static  void method_4692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<std::map<long,int> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_1142( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<long,int> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<long,int> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<long,int> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<long,int> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<long,int> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > >, std::allocator<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > > > > > -------------------------------
void __edm__Wrapper_std__vector_std__map_long_int_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_std__map_long_int_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__map_long_int_s_s__datamem_bld(&__edm__Wrapper_std__vector_std__map_long_int_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__map_long_int_s_s__funcmem_bld(&__edm__Wrapper_std__vector_std__map_long_int_s_s__db_funcmem);
void __edm__Wrapper_std__vector_std__map_long_int_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::map<long,int> > >"), typeid(::edm::Wrapper<std::vector<std::map<long,int> > >), sizeof(::edm::Wrapper<std::vector<std::map<long,int> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2551, Reflex::Literal("edm::Wrapper<std::vector<std::map<long,int> > >::value_type"))
  .AddTypedef(type_2551, Reflex::Literal("edm::Wrapper<std::vector<std::map<long,int> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_4678, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2392), Reflex::Literal("Wrapper"), constructor_4679, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_4680, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14472), Reflex::Literal("Wrapper"), constructor_4685, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1142, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_std__map_long_int_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_std__map_long_int_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > >, std::allocator<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > > > > > -------------------
void __edm__Wrapper_std__vector_std__map_long_int_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__map_long_int_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2551, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__map_long_int_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > >, std::allocator<std::map<long int, int, std::less<long int>, std::allocator<std::pair<const long int, int> > > > > > -------------------
void __edm__Wrapper_std__vector_std__map_long_int_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14471), Reflex::Literal("product"), method_4681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14471), Reflex::Literal("operator->"), operator_4682, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("productTypeInfo"), method_4683, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("typeInfo"), method_4684, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14473), Reflex::Literal("getInterface"), method_4686, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_13702, type_14463, type_14464), Reflex::Literal("fillView"), method_4687, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_271, type_7269), Reflex::Literal("setPtr"), method_4688, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_14465, type_14463), Reflex::Literal("fillPtrVector"), method_4689, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo"), method_4690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_4691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo_"), method_4692, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<std::vector<T2Hit, std::allocator<T2Hit> >, std::allocator<std::vector<T2Hit, std::allocator<T2Hit> > > > > -------------------------------
static void constructor_4886( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<T2Hit> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<T2Hit> > >();
}

static void constructor_4887( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<T2Hit> > >(*(::std::auto_ptr<std::vector<std::vector<T2Hit> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<T2Hit> > >(*(::std::auto_ptr<std::vector<std::vector<T2Hit> > >*)arg[0]);
}

static void destructor_4888(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->::edm::Wrapper<std::vector<std::vector<T2Hit> > >::~Wrapper)();
}
static  void method_4889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->product)();
}

static  void operator_4890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->operator->)();
}

static  void method_4891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->productTypeInfo)();
}

static  void method_4892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->typeInfo)();
}

static void constructor_4893( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<T2Hit> > >((::std::vector<std::vector<T2Hit> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<T2Hit> > >((::std::vector<std::vector<T2Hit> >*)arg[0]);
}

static  void method_4894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->getInterface)();
}

static  void method_4895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_4896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_4897( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_4898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->dynamicTypeInfo)();
}

static  void method_4899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->isPresent)();
}

static  void method_4900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<std::vector<T2Hit> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_1474( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<T2Hit> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<T2Hit> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<T2Hit> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<T2Hit> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<T2Hit> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<std::vector<T2Hit, std::allocator<T2Hit> >, std::allocator<std::vector<T2Hit, std::allocator<T2Hit> > > > > -------------------------------
void __edm__Wrapper_std__vector_std__vector_T2Hit_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_std__vector_T2Hit_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__vector_T2Hit_s_s__datamem_bld(&__edm__Wrapper_std__vector_std__vector_T2Hit_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__vector_T2Hit_s_s__funcmem_bld(&__edm__Wrapper_std__vector_std__vector_T2Hit_s_s__db_funcmem);
void __edm__Wrapper_std__vector_std__vector_T2Hit_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::vector<T2Hit> > >"), typeid(::edm::Wrapper<std::vector<std::vector<T2Hit> > >), sizeof(::edm::Wrapper<std::vector<std::vector<T2Hit> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2554, Reflex::Literal("edm::Wrapper<std::vector<std::vector<T2Hit> > >::value_type"))
  .AddTypedef(type_2554, Reflex::Literal("edm::Wrapper<std::vector<std::vector<T2Hit> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_4886, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2395), Reflex::Literal("Wrapper"), constructor_4887, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_4888, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14492), Reflex::Literal("Wrapper"), constructor_4893, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1474, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_std__vector_T2Hit_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_std__vector_T2Hit_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<std::vector<T2Hit, std::allocator<T2Hit> >, std::allocator<std::vector<T2Hit, std::allocator<T2Hit> > > > > -------------------
void __edm__Wrapper_std__vector_std__vector_T2Hit_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__vector_T2Hit_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2554, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__vector_T2Hit_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<std::vector<T2Hit, std::allocator<T2Hit> >, std::allocator<std::vector<T2Hit, std::allocator<T2Hit> > > > > -------------------
void __edm__Wrapper_std__vector_std__vector_T2Hit_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14491), Reflex::Literal("product"), method_4889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14491), Reflex::Literal("operator->"), operator_4890, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("productTypeInfo"), method_4891, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("typeInfo"), method_4892, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14493), Reflex::Literal("getInterface"), method_4894, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_13702, type_14463, type_14464), Reflex::Literal("fillView"), method_4895, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_271, type_7269), Reflex::Literal("setPtr"), method_4896, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_14465, type_14463), Reflex::Literal("fillPtrVector"), method_4897, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo"), method_4898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_4899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo_"), method_4900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > >, std::allocator<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > > > > -------------------------------
static void constructor_4930( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >();
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >();
}

static void constructor_4931( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >(*(::std::auto_ptr<std::vector<std::map<long,std::vector<long> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >(*(::std::auto_ptr<std::vector<std::map<long,std::vector<long> > > >*)arg[0]);
}

static void destructor_4932(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >::~Wrapper)();
}
static  void method_4933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->product)();
}

static  void operator_4934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->operator->)();
}

static  void method_4935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->productTypeInfo)();
}

static  void method_4936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->typeInfo)();
}

static void constructor_4937( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >((::std::vector<std::map<long,std::vector<long> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >((::std::vector<std::map<long,std::vector<long> > >*)arg[0]);
}

static  void method_4938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->getInterface)();
}

static  void method_4939( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_4940( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_4941( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_4942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->dynamicTypeInfo)();
}

static  void method_4943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->isPresent)();
}

static  void method_4944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_1499( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > >, std::allocator<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > > > > -------------------------------
void __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__datamem_bld(&__edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__funcmem_bld(&__edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__db_funcmem);
void __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >"), typeid(::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >), sizeof(::edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2552, Reflex::Literal("edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >::value_type"))
  .AddTypedef(type_2552, Reflex::Literal("edm::Wrapper<std::vector<std::map<long,std::vector<long> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_4930, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2393), Reflex::Literal("Wrapper"), constructor_4931, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_4932, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14498), Reflex::Literal("Wrapper"), constructor_4937, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1499, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > >, std::allocator<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > > > > -------------------
void __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2552, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > >, std::allocator<std::map<long int, std::vector<long int, std::allocator<long int> >, std::less<long int>, std::allocator<std::pair<const long int, std::vector<long int, std::allocator<long int> > > > > > > > -------------------
void __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14497), Reflex::Literal("product"), method_4933, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14497), Reflex::Literal("operator->"), operator_4934, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("productTypeInfo"), method_4935, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("typeInfo"), method_4936, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14499), Reflex::Literal("getInterface"), method_4938, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_13702, type_14463, type_14464), Reflex::Literal("fillView"), method_4939, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_271, type_7269), Reflex::Literal("setPtr"), method_4940, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12408, type_14465, type_14463), Reflex::Literal("fillPtrVector"), method_4941, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo"), method_4942, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_4943, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12408), Reflex::Literal("dynamicTypeInfo_"), method_4944, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __T2Hit_dict(); 
      __std__vector_T2Hit__dict(); 
      __hit_entry_dict(); 
      __std__vector_hit_entry__dict(); 
      __std__map_long_int__dict(); 
      __edm__Wrapper_std__map_long_int_s__dict(); 
      __std__map_long_std__vector_long_s__dict(); 
      __edm__Wrapper_std__map_long_std__vector_long_s_s__dict(); 
      __std__map_std__pair_long_long__unsignedslong__dict(); 
      __edm__Wrapper_std__map_std__pair_long_long__unsignedslong_s__dict(); 
      __edm__Wrapper_std__vector_T2Hit_s__dict(); 
      __edm__Wrapper_std__vector_std__map_std__pair_long_long__unsignedslong_s_s__dict(); 
      __edm__Wrapper_std__vector_std__map_long_int_s_s__dict(); 
      __edm__Wrapper_std__vector_std__vector_T2Hit_s_s__dict(); 
      __edm__Wrapper_std__vector_std__map_long_std__vector_long_s_s_s__dict(); 
    }
    ~Dictionaries() {
      type_1379.Unload(); // class T2Hit 
      type_268.Unload(); // class std::vector<T2Hit> 
      type_1712.Unload(); // class hit_entry 
      type_2555.Unload(); // class std::vector<hit_entry> 
      type_1780.Unload(); // class std::map<long,int> 
      type_3476.Unload(); // class edm::Wrapper<std::map<long,int> > 
      type_741.Unload(); // class std::map<long,std::vector<long> > 
      type_3477.Unload(); // class edm::Wrapper<std::map<long,std::vector<long> > > 
      type_967.Unload(); // class std::map<std::pair<long,long>,unsigned long> 
      type_3478.Unload(); // class edm::Wrapper<std::map<std::pair<long,long>,unsigned long> > 
      type_3479.Unload(); // class edm::Wrapper<std::vector<T2Hit> > 
      type_1053.Unload(); // class edm::Wrapper<std::vector<std::map<std::pair<long,long>,unsigned long> > > 
      type_1142.Unload(); // class edm::Wrapper<std::vector<std::map<long,int> > > 
      type_1474.Unload(); // class edm::Wrapper<std::vector<std::vector<T2Hit> > > 
      type_1499.Unload(); // class edm::Wrapper<std::vector<std::map<long,std::vector<long> > > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
