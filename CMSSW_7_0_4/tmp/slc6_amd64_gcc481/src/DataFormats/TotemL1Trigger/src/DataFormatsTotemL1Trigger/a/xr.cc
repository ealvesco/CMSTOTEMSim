// Generated at Mon Jul 11 23:20:03 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/TotemL1Trigger/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_68 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_62 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_578 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1372 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_690 = ::Reflex::TypeBuilder(Reflex::Literal("RPCCId"));
  ::Reflex::Type type_773 = ::Reflex::TypeBuilder(Reflex::Literal("T2DetId"));
  ::Reflex::Type type_246 = ::Reflex::TypeBuilder(Reflex::Literal("RPCCBits"));
  ::Reflex::Type type_280 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_272 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1474 = ::Reflex::TypeBuilder(Reflex::Literal("T1TriggerBits"));
  ::Reflex::Type type_2111 = ::Reflex::TypeBuilder(Reflex::Literal("T2TriggerBits"));
  ::Reflex::Type type_397 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_2801 = ::Reflex::TypeBuilder(Reflex::Literal("std::bitset<8>"));
  ::Reflex::Type type_3465 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2803 = ::Reflex::TypeBuilder(Reflex::Literal("std::bitset<16>"));
  ::Reflex::Type type_2802 = ::Reflex::TypeBuilder(Reflex::Literal("std::bitset<32>"));
  ::Reflex::Type type_2522 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPCCBits>"));
  ::Reflex::Type type_3371 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPCCBits>"));
  ::Reflex::Type type_2360 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPCCBits>"));
  ::Reflex::Type type_2674 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPCCBits>"));
  ::Reflex::Type type_2518 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2520 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T2TriggerBits>"));
  ::Reflex::Type type_2521 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T1TriggerBits>"));
  ::Reflex::Type type_2519 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3367 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<T2TriggerBits>"));
  ::Reflex::Type type_3369 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<T1TriggerBits>"));
  ::Reflex::Type type_2356 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<T2TriggerBits>"));
  ::Reflex::Type type_2358 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<T1TriggerBits>"));
  ::Reflex::Type type_2672 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<T2TriggerBits>"));
  ::Reflex::Type type_2673 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<T1TriggerBits>"));
  ::Reflex::Type type_3421 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPCCBits>"));
  ::Reflex::Type type_3417 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<T2TriggerBits>"));
  ::Reflex::Type type_3419 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<T1TriggerBits>"));
  ::Reflex::Type type_3370 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPCCBits> >"));
  ::Reflex::Type type_2359 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<RPCCBits> >"));
  ::Reflex::Type type_3366 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<T2TriggerBits> >"));
  ::Reflex::Type type_3368 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<T1TriggerBits> >"));
  ::Reflex::Type type_2355 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<T2TriggerBits> >"));
  ::Reflex::Type type_2357 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<T1TriggerBits> >"));
  ::Reflex::Type type_3420 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<RPCCBits> >"));
  ::Reflex::Type type_3416 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<T2TriggerBits> >"));
  ::Reflex::Type type_3418 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<T1TriggerBits> >"));
  ::Reflex::Type type_5192 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPCCBits> >"));
  ::Reflex::Type type_2158 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPCCBits,std::allocator<RPCCBits> >"));
  ::Reflex::Type type_3274 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_5190 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<T2TriggerBits> >"));
  ::Reflex::Type type_5191 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<T1TriggerBits> >"));
  ::Reflex::Type type_5103 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >"));
  ::Reflex::Type type_2156 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2TriggerBits,std::allocator<T2TriggerBits> >"));
  ::Reflex::Type type_2157 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T1TriggerBits,std::allocator<T1TriggerBits> >"));
  ::Reflex::Type type_5104 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPCCBits*,std::vector<RPCCBits> >"));
  ::Reflex::Type type_5099 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >"));
  ::Reflex::Type type_5101 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >"));
  ::Reflex::Type type_5100 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const T2TriggerBits*,std::vector<T2TriggerBits> >"));
  ::Reflex::Type type_5102 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const T1TriggerBits*,std::vector<T1TriggerBits> >"));
  ::Reflex::Type type_2758 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> > >"));
  ::Reflex::Type type_2757 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPCCBits*,std::vector<RPCCBits> > >"));
  ::Reflex::Type type_2754 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> > >"));
  ::Reflex::Type type_2756 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> > >"));
  ::Reflex::Type type_2753 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const T2TriggerBits*,std::vector<T2TriggerBits> > >"));
  ::Reflex::Type type_2755 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const T1TriggerBits*,std::vector<T1TriggerBits> > >"));
  ::Reflex::Type type_1338 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_280);
  ::Reflex::Type type_1518 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("RPCCIdRaw"), type_1338);
  ::Reflex::Type type_11308 = ::Reflex::ArrayBuilder(type_1372, 16);
  ::Reflex::Type type_8422 = ::Reflex::ReferenceBuilder(type_246);
  ::Reflex::Type type_246c = ::Reflex::ConstBuilder(type_246);
  ::Reflex::Type type_5626 = ::Reflex::ReferenceBuilder(type_246c);
  ::Reflex::Type type_1372c = ::Reflex::ConstBuilder(type_1372);
  ::Reflex::Type type_6814 = ::Reflex::PointerBuilder(type_1372c);
  ::Reflex::Type type_13616 = ::Reflex::ArrayBuilder(type_1372, 32);
  ::Reflex::Type type_8357 = ::Reflex::ReferenceBuilder(type_1474);
  ::Reflex::Type type_1474c = ::Reflex::ConstBuilder(type_1474);
  ::Reflex::Type type_8359 = ::Reflex::ReferenceBuilder(type_1474c);
  ::Reflex::Type type_16276 = ::Reflex::ArrayBuilder(type_1372, 8);
  ::Reflex::Type type_8292 = ::Reflex::ReferenceBuilder(type_2111);
  ::Reflex::Type type_2111c = ::Reflex::ConstBuilder(type_2111);
  ::Reflex::Type type_8294 = ::Reflex::ReferenceBuilder(type_2111c);
  ::Reflex::Type type_6036 = ::Reflex::PointerBuilder(type_2111);
  ::Reflex::Type type_8290 = ::Reflex::PointerBuilder(type_2111c);
  ::Reflex::Type type_2657 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_272);
  ::Reflex::Type type_2595 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_62);
  ::Reflex::Type type_2672c = ::Reflex::ConstBuilder(type_2672);
  ::Reflex::Type type_16346 = ::Reflex::ReferenceBuilder(type_2672c);
  ::Reflex::Type type_2520c = ::Reflex::ConstBuilder(type_2520);
  ::Reflex::Type type_16997 = ::Reflex::ReferenceBuilder(type_2520c);
  ::Reflex::Type type_16998 = ::Reflex::ReferenceBuilder(type_2520);
  ::Reflex::Type type_6055 = ::Reflex::PointerBuilder(type_1474);
  ::Reflex::Type type_8355 = ::Reflex::PointerBuilder(type_1474c);
  ::Reflex::Type type_2673c = ::Reflex::ConstBuilder(type_2673);
  ::Reflex::Type type_16359 = ::Reflex::ReferenceBuilder(type_2673c);
  ::Reflex::Type type_2521c = ::Reflex::ConstBuilder(type_2521);
  ::Reflex::Type type_17000 = ::Reflex::ReferenceBuilder(type_2521c);
  ::Reflex::Type type_17001 = ::Reflex::ReferenceBuilder(type_2521);
  ::Reflex::Type type_6074 = ::Reflex::PointerBuilder(type_246);
  ::Reflex::Type type_8420 = ::Reflex::PointerBuilder(type_246c);
  ::Reflex::Type type_2674c = ::Reflex::ConstBuilder(type_2674);
  ::Reflex::Type type_16372 = ::Reflex::ReferenceBuilder(type_2674c);
  ::Reflex::Type type_2522c = ::Reflex::ConstBuilder(type_2522);
  ::Reflex::Type type_17002 = ::Reflex::ReferenceBuilder(type_2522c);
  ::Reflex::Type type_17003 = ::Reflex::ReferenceBuilder(type_2522);
  ::Reflex::Type type_18911 = ::Reflex::PointerBuilder(type_2520c);
  ::Reflex::Type type_397c = ::Reflex::ConstBuilder(type_397);
  ::Reflex::Type type_11300 = ::Reflex::ReferenceBuilder(type_397c);
  ::Reflex::Type type_18912 = ::Reflex::PointerBuilder(type_2520);
  ::Reflex::Type type_3416c = ::Reflex::ConstBuilder(type_3416);
  ::Reflex::Type type_18913 = ::Reflex::PointerBuilder(type_3416c);
  ::Reflex::Type type_3465c = ::Reflex::ConstBuilder(type_3465);
  ::Reflex::Type type_12758 = ::Reflex::ReferenceBuilder(type_3465c);
  ::Reflex::Type type_16993 = ::Reflex::ReferenceBuilder(type_2518);
  ::Reflex::Type type_18802 = ::Reflex::ReferenceBuilder(type_3274);
  ::Reflex::Type type_578c = ::Reflex::ConstBuilder(type_578);
  ::Reflex::Type type_2969 = ::Reflex::PointerBuilder(type_578c);
  ::Reflex::Type type_6794 = ::Reflex::ReferenceBuilder(type_2969);
  ::Reflex::Type type_2519c = ::Reflex::ConstBuilder(type_2519);
  ::Reflex::Type type_16994 = ::Reflex::ReferenceBuilder(type_2519c);
  ::Reflex::Type type_3417c = ::Reflex::ConstBuilder(type_3417);
  ::Reflex::Type type_18916 = ::Reflex::PointerBuilder(type_3417c);
  ::Reflex::Type type_18919 = ::Reflex::PointerBuilder(type_2521c);
  ::Reflex::Type type_18920 = ::Reflex::PointerBuilder(type_2521);
  ::Reflex::Type type_3418c = ::Reflex::ConstBuilder(type_3418);
  ::Reflex::Type type_18921 = ::Reflex::PointerBuilder(type_3418c);
  ::Reflex::Type type_3419c = ::Reflex::ConstBuilder(type_3419);
  ::Reflex::Type type_18924 = ::Reflex::PointerBuilder(type_3419c);
  ::Reflex::Type type_18927 = ::Reflex::PointerBuilder(type_2522c);
  ::Reflex::Type type_18928 = ::Reflex::PointerBuilder(type_2522);
  ::Reflex::Type type_3420c = ::Reflex::ConstBuilder(type_3420);
  ::Reflex::Type type_18929 = ::Reflex::PointerBuilder(type_3420c);
  ::Reflex::Type type_3421c = ::Reflex::ConstBuilder(type_3421);
  ::Reflex::Type type_18932 = ::Reflex::PointerBuilder(type_3421c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __RPCCBits
#undef __RPCCBits
#endif
class __RPCCBits {
  public:
  __RPCCBits();
  ::RPCCIdRaw id_;
  bool bs_[16];
};
#ifdef __T1TriggerBits
#undef __T1TriggerBits
#endif
class __T1TriggerBits {
  public:
  __T1TriggerBits();
  int _arm;
  bool _bs[32];
};
#ifdef __T2TriggerBits
#undef __T2TriggerBits
#endif
class __T2TriggerBits {
  public:
  __T2TriggerBits();
  ::uint32_t id_;
  bool _bs[8];
  int row_;
};
#ifdef __std__vector_T2TriggerBits_
#undef __std__vector_T2TriggerBits_
#endif
class __std__vector_T2TriggerBits_ : protected ::std::_Vector_base<T2TriggerBits,std::allocator<T2TriggerBits> > {
  public:
  __std__vector_T2TriggerBits_();
};
#ifdef __std__vector_T1TriggerBits_
#undef __std__vector_T1TriggerBits_
#endif
class __std__vector_T1TriggerBits_ : protected ::std::_Vector_base<T1TriggerBits,std::allocator<T1TriggerBits> > {
  public:
  __std__vector_T1TriggerBits_();
};
#ifdef __std__vector_RPCCBits_
#undef __std__vector_RPCCBits_
#endif
class __std__vector_RPCCBits_ : protected ::std::_Vector_base<RPCCBits,std::allocator<RPCCBits> > {
  public:
  __std__vector_RPCCBits_();
};
#ifdef __edm__Wrapper_std__vector_T2TriggerBits_s_
#undef __edm__Wrapper_std__vector_T2TriggerBits_s_
#endif
class __edm__Wrapper_std__vector_T2TriggerBits_s_ {
  public:
  __edm__Wrapper_std__vector_T2TriggerBits_s_();
  bool present;
  ::std::vector<T2TriggerBits> obj;
};
#ifdef __edm__Wrapper_T2TriggerBits_
#undef __edm__Wrapper_T2TriggerBits_
#endif
class __edm__Wrapper_T2TriggerBits_ {
  public:
  __edm__Wrapper_T2TriggerBits_();
  bool present;
  ::T2TriggerBits obj;
};
#ifdef __edm__Wrapper_std__vector_T1TriggerBits_s_
#undef __edm__Wrapper_std__vector_T1TriggerBits_s_
#endif
class __edm__Wrapper_std__vector_T1TriggerBits_s_ {
  public:
  __edm__Wrapper_std__vector_T1TriggerBits_s_();
  bool present;
  ::std::vector<T1TriggerBits> obj;
};
#ifdef __edm__Wrapper_T1TriggerBits_
#undef __edm__Wrapper_T1TriggerBits_
#endif
class __edm__Wrapper_T1TriggerBits_ {
  public:
  __edm__Wrapper_T1TriggerBits_();
  bool present;
  ::T1TriggerBits obj;
};
#ifdef __edm__Wrapper_std__vector_RPCCBits_s_
#undef __edm__Wrapper_std__vector_RPCCBits_s_
#endif
class __edm__Wrapper_std__vector_RPCCBits_s_ {
  public:
  __edm__Wrapper_std__vector_RPCCBits_s_();
  bool present;
  ::std::vector<RPCCBits> obj;
};
#ifdef __edm__Wrapper_RPCCBits_
#undef __edm__Wrapper_RPCCBits_
#endif
class __edm__Wrapper_RPCCBits_ {
  public:
  __edm__Wrapper_RPCCBits_();
  bool present;
  ::RPCCBits obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class RPCCBits -------------------------------
static void destructor_3040(void*, void * o, const std::vector<void*>&, void *) {
(((::RPCCBits*)o)->::RPCCBits::~RPCCBits)();
}
static  void operator_3041( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPCCBits*)o)->operator=)(*(const ::RPCCBits*)arg[0]);
  else   (((::RPCCBits*)o)->operator=)(*(const ::RPCCBits*)arg[0]);
}

static void constructor_3042( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPCCBits(*(const ::RPCCBits*)arg[0]);
  else ::new(mem) ::RPCCBits(*(const ::RPCCBits*)arg[0]);
}

static void constructor_3043( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPCCBits(*(::RPCCIdRaw*)arg[0],
      *(::std::bitset<16>*)arg[1]);
  else ::new(mem) ::RPCCBits(*(::RPCCIdRaw*)arg[0],
      *(::std::bitset<16>*)arg[1]);
}

static void constructor_3044( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPCCBits(*(::RPCCId*)arg[0],
      *(::std::bitset<16>*)arg[1]);
  else ::new(mem) ::RPCCBits(*(::RPCCId*)arg[0],
      *(::std::bitset<16>*)arg[1]);
}

static void constructor_3045( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPCCBits();
  else ::new(mem) ::RPCCBits();
}

static  void method_3046( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RPCCBits*)o)->reset)();
}

static  void method_3047( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPCCBits*)o)->setId)(*(::RPCCIdRaw*)arg[0]);
}

static  void method_3048( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPCCBits*)o)->setId)(*(::RPCCId*)arg[0]);
}

static  void method_3049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (RPCCIdRaw)((((const ::RPCCBits*)o)->getId)());
  else   (((const ::RPCCBits*)o)->getId)();
}

static  void method_3050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::bitset<16>)((((const ::RPCCBits*)o)->getBS)());
  else   (((const ::RPCCBits*)o)->getBS)();
}

static  void method_3051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RPCCBits*)o)->getRawBS)());
  else   (((const ::RPCCBits*)o)->getRawBS)();
}

static  void method_3052( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPCCBits*)o)->setBS)(*(::std::bitset<16>*)arg[0]);
}

static void method_newdel_246( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPCCBits >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPCCBits >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPCCBits >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPCCBits >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPCCBits >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPCCBits -------------------------------
void __RPCCBits_db_datamem(Reflex::Class*);
void __RPCCBits_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPCCBits_datamem_bld(&__RPCCBits_db_datamem);
Reflex::GenreflexMemberBuilder __RPCCBits_funcmem_bld(&__RPCCBits_db_funcmem);
void __RPCCBits_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPCCBits"), typeid(::RPCCBits), sizeof(::RPCCBits), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPCCBits"), destructor_3040, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8422, type_5626), Reflex::Literal("operator="), operator_3041, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5626), Reflex::Literal("RPCCBits"), constructor_3042, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1518, type_2803), Reflex::Literal("RPCCBits"), constructor_3043, 0, "id;bs", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_690, type_2803), Reflex::Literal("RPCCBits"), constructor_3044, 0, "id;bs", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPCCBits"), constructor_3045, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_246, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPCCBits_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPCCBits_funcmem_bld);
}

//------Delayed data member builder for class RPCCBits -------------------
void __RPCCBits_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1518, Reflex::Literal("id_"), OffsetOf(__shadow__::__RPCCBits, id_), ::Reflex::PRIVATE)
  .AddDataMember(type_11308, Reflex::Literal("bs_"), OffsetOf(__shadow__::__RPCCBits, bs_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPCCBits -------------------
void __RPCCBits_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("reset"), method_3046, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_1518), Reflex::Literal("setId"), method_3047, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_690), Reflex::Literal("setId"), method_3048, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1518), Reflex::Literal("getId"), method_3049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2803), Reflex::Literal("getBS"), method_3050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6814), Reflex::Literal("getRawBS"), method_3051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2803), Reflex::Literal("setBS"), method_3052, 0, "bs", ::Reflex::PUBLIC);
}
//------Stub functions for class T1TriggerBits -------------------------------
static void destructor_4670(void*, void * o, const std::vector<void*>&, void *) {
(((::T1TriggerBits*)o)->::T1TriggerBits::~T1TriggerBits)();
}
static  void operator_4671( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T1TriggerBits*)o)->operator=)(*(const ::T1TriggerBits*)arg[0]);
  else   (((::T1TriggerBits*)o)->operator=)(*(const ::T1TriggerBits*)arg[0]);
}

static void constructor_4672( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1TriggerBits(*(const ::T1TriggerBits*)arg[0]);
  else ::new(mem) ::T1TriggerBits(*(const ::T1TriggerBits*)arg[0]);
}

static void constructor_4673( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1TriggerBits(*(int*)arg[0],
      *(::std::bitset<32>*)arg[1]);
  else ::new(mem) ::T1TriggerBits(*(int*)arg[0],
      *(::std::bitset<32>*)arg[1]);
}

static void constructor_4674( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1TriggerBits();
  else ::new(mem) ::T1TriggerBits();
}

static  void method_4675( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1TriggerBits*)o)->setArm)(*(int*)arg[0]);
}

static  void method_4676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T1TriggerBits*)o)->getArm)());
  else   (((const ::T1TriggerBits*)o)->getArm)();
}

static  void method_4677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::bitset<32>)((((const ::T1TriggerBits*)o)->getBS)());
  else   (((const ::T1TriggerBits*)o)->getBS)();
}

static  void method_4678( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::T1TriggerBits*)o)->getBit)(*(int*)arg[0]));
  else   (((::T1TriggerBits*)o)->getBit)(*(int*)arg[0]);
}

static  void method_4679( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1TriggerBits*)o)->setBS)(*(::std::bitset<32>*)arg[0]);
}

static void method_newdel_1474( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T1TriggerBits >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T1TriggerBits >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T1TriggerBits >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T1TriggerBits >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T1TriggerBits >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T1TriggerBits -------------------------------
void __T1TriggerBits_db_datamem(Reflex::Class*);
void __T1TriggerBits_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T1TriggerBits_datamem_bld(&__T1TriggerBits_db_datamem);
Reflex::GenreflexMemberBuilder __T1TriggerBits_funcmem_bld(&__T1TriggerBits_db_funcmem);
void __T1TriggerBits_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T1TriggerBits"), typeid(::T1TriggerBits), sizeof(::T1TriggerBits), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T1TriggerBits"), destructor_4670, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8357, type_8359), Reflex::Literal("operator="), operator_4671, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8359), Reflex::Literal("T1TriggerBits"), constructor_4672, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_68, type_2802), Reflex::Literal("T1TriggerBits"), constructor_4673, 0, "arm;bs", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T1TriggerBits"), constructor_4674, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1474, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T1TriggerBits_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T1TriggerBits_funcmem_bld);
}

//------Delayed data member builder for class T1TriggerBits -------------------
void __T1TriggerBits_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_68, Reflex::Literal("_arm"), OffsetOf(__shadow__::__T1TriggerBits, _arm), ::Reflex::PRIVATE)
  .AddDataMember(type_13616, Reflex::Literal("_bs"), OffsetOf(__shadow__::__T1TriggerBits, _bs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T1TriggerBits -------------------
void __T1TriggerBits_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_68), Reflex::Literal("setArm"), method_4675, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getArm"), method_4676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2802), Reflex::Literal("getBS"), method_4677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372, type_68), Reflex::Literal("getBit"), method_4678, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2802), Reflex::Literal("setBS"), method_4679, 0, "bs", ::Reflex::PUBLIC);
}
//------Stub functions for class T2TriggerBits -------------------------------
static void destructor_5655(void*, void * o, const std::vector<void*>&, void *) {
(((::T2TriggerBits*)o)->::T2TriggerBits::~T2TriggerBits)();
}
static  void operator_5656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T2TriggerBits*)o)->operator=)(*(const ::T2TriggerBits*)arg[0]);
  else   (((::T2TriggerBits*)o)->operator=)(*(const ::T2TriggerBits*)arg[0]);
}

static void constructor_5657( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2TriggerBits(*(const ::T2TriggerBits*)arg[0]);
  else ::new(mem) ::T2TriggerBits(*(const ::T2TriggerBits*)arg[0]);
}

static void constructor_5658( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2TriggerBits(*(::uint32_t*)arg[0],
      *(int*)arg[1],
      *(::std::bitset<8>*)arg[2]);
  else ::new(mem) ::T2TriggerBits(*(::uint32_t*)arg[0],
      *(int*)arg[1],
      *(::std::bitset<8>*)arg[2]);
}

static void constructor_5659( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2TriggerBits(*(::T2DetId*)arg[0],
      *(int*)arg[1],
      *(::std::bitset<8>*)arg[2]);
  else ::new(mem) ::T2TriggerBits(*(::T2DetId*)arg[0],
      *(int*)arg[1],
      *(::std::bitset<8>*)arg[2]);
}

static void constructor_5660( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2TriggerBits();
  else ::new(mem) ::T2TriggerBits();
}

static  void method_5661( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2TriggerBits*)o)->setId)(*(::T2DetId*)arg[0]);
}

static  void method_5662( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2TriggerBits*)o)->setSector)(*(int*)arg[0]);
}

static  void method_5663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::T2TriggerBits*)o)->getId)());
  else   (((const ::T2TriggerBits*)o)->getId)();
}

static  void method_5664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2TriggerBits*)o)->getSector)());
  else   (((const ::T2TriggerBits*)o)->getSector)();
}

static  void method_5665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::bitset<8>)((((const ::T2TriggerBits*)o)->getBS)());
  else   (((const ::T2TriggerBits*)o)->getBS)();
}

static  void method_5666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::T2TriggerBits*)o)->getBit)(*(int*)arg[0]));
  else   (((::T2TriggerBits*)o)->getBit)(*(int*)arg[0]);
}

static  void method_5667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2TriggerBits*)o)->setBS)(*(::std::bitset<8>*)arg[0]);
}

static void method_newdel_2111( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T2TriggerBits >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T2TriggerBits >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T2TriggerBits >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T2TriggerBits >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T2TriggerBits >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T2TriggerBits -------------------------------
void __T2TriggerBits_db_datamem(Reflex::Class*);
void __T2TriggerBits_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T2TriggerBits_datamem_bld(&__T2TriggerBits_db_datamem);
Reflex::GenreflexMemberBuilder __T2TriggerBits_funcmem_bld(&__T2TriggerBits_db_funcmem);
void __T2TriggerBits_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T2TriggerBits"), typeid(::T2TriggerBits), sizeof(::T2TriggerBits), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T2TriggerBits"), destructor_5655, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8292, type_8294), Reflex::Literal("operator="), operator_5656, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8294), Reflex::Literal("T2TriggerBits"), constructor_5657, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1338, type_68, type_2801), Reflex::Literal("T2TriggerBits"), constructor_5658, 0, "id;row;bs", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_773, type_68, type_2801), Reflex::Literal("T2TriggerBits"), constructor_5659, 0, "id;row;bs", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T2TriggerBits"), constructor_5660, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2111, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T2TriggerBits_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T2TriggerBits_funcmem_bld);
}

//------Delayed data member builder for class T2TriggerBits -------------------
void __T2TriggerBits_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1338, Reflex::Literal("id_"), OffsetOf(__shadow__::__T2TriggerBits, id_), ::Reflex::PRIVATE)
  .AddDataMember(type_16276, Reflex::Literal("_bs"), OffsetOf(__shadow__::__T2TriggerBits, _bs), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("row_"), OffsetOf(__shadow__::__T2TriggerBits, row_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T2TriggerBits -------------------
void __T2TriggerBits_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_773), Reflex::Literal("setId"), method_5661, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_68), Reflex::Literal("setSector"), method_5662, 0, "row", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1338), Reflex::Literal("getId"), method_5663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getSector"), method_5664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2801), Reflex::Literal("getBS"), method_5665, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372, type_68), Reflex::Literal("getBit"), method_5666, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2801), Reflex::Literal("setBS"), method_5667, 0, "bs", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<T2TriggerBits,std::allocator<T2TriggerBits> > -------------------------------
static void constructor_8303( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2TriggerBits>();
  else ::new(mem) ::std::vector<T2TriggerBits>();
}

static void constructor_8304( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2TriggerBits>(*(const ::std::allocator<T2TriggerBits>*)arg[0]);
  else ::new(mem) ::std::vector<T2TriggerBits>(*(const ::std::allocator<T2TriggerBits>*)arg[0]);
}

static void constructor_8305( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2TriggerBits>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<T2TriggerBits>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2TriggerBits>(*(::std::size_t*)arg[0],
      *(const ::T2TriggerBits*)arg[1]);
  else ::new(mem) ::std::vector<T2TriggerBits>(*(::std::size_t*)arg[0],
      *(const ::T2TriggerBits*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2TriggerBits>(*(::std::size_t*)arg[0],
      *(const ::T2TriggerBits*)arg[1],
      *(const ::std::allocator<T2TriggerBits>*)arg[2]);
  else ::new(mem) ::std::vector<T2TriggerBits>(*(::std::size_t*)arg[0],
      *(const ::T2TriggerBits*)arg[1],
      *(const ::std::allocator<T2TriggerBits>*)arg[2]);
  }
}

static void constructor_8306( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2TriggerBits>(*(const ::std::vector<T2TriggerBits>*)arg[0]);
  else ::new(mem) ::std::vector<T2TriggerBits>(*(const ::std::vector<T2TriggerBits>*)arg[0]);
}

static void destructor_8307(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<T2TriggerBits>*)o)->::std::vector<T2TriggerBits>::~vector)();
}
static  void operator_8308( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2TriggerBits>*)o)->operator=)(*(const ::std::vector<T2TriggerBits>*)arg[0]);
  else   (((::std::vector<T2TriggerBits>*)o)->operator=)(*(const ::std::vector<T2TriggerBits>*)arg[0]);
}

static  void method_8309( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2TriggerBits>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::T2TriggerBits*)arg[1]);
}

static  void method_8310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >)((((::std::vector<T2TriggerBits>*)o)->begin)());
  else   (((::std::vector<T2TriggerBits>*)o)->begin)();
}

static  void method_8311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2TriggerBits*,std::vector<T2TriggerBits> >)((((const ::std::vector<T2TriggerBits>*)o)->begin)());
  else   (((const ::std::vector<T2TriggerBits>*)o)->begin)();
}

static  void method_8312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >)((((::std::vector<T2TriggerBits>*)o)->end)());
  else   (((::std::vector<T2TriggerBits>*)o)->end)();
}

static  void method_8313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2TriggerBits*,std::vector<T2TriggerBits> >)((((const ::std::vector<T2TriggerBits>*)o)->end)());
  else   (((const ::std::vector<T2TriggerBits>*)o)->end)();
}

static  void method_8318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2TriggerBits>*)o)->size)());
  else   (((const ::std::vector<T2TriggerBits>*)o)->size)();
}

static  void method_8319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2TriggerBits>*)o)->max_size)());
  else   (((const ::std::vector<T2TriggerBits>*)o)->max_size)();
}

static  void method_8320( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<T2TriggerBits>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<T2TriggerBits>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::T2TriggerBits*)arg[1]);
  }
}

static  void method_8321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2TriggerBits>*)o)->capacity)());
  else   (((const ::std::vector<T2TriggerBits>*)o)->capacity)();
}

static  void method_8322( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<T2TriggerBits>*)o)->empty)());
  else   (((const ::std::vector<T2TriggerBits>*)o)->empty)();
}

static  void method_8323( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2TriggerBits>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2TriggerBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2TriggerBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2TriggerBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2TriggerBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8327( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2TriggerBits>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2TriggerBits>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8328( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2TriggerBits>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2TriggerBits>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2TriggerBits>*)o)->front)();
  else   (((::std::vector<T2TriggerBits>*)o)->front)();
}

static  void method_8330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2TriggerBits>*)o)->front)();
  else   (((const ::std::vector<T2TriggerBits>*)o)->front)();
}

static  void method_8331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2TriggerBits>*)o)->back)();
  else   (((::std::vector<T2TriggerBits>*)o)->back)();
}

static  void method_8332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2TriggerBits>*)o)->back)();
  else   (((const ::std::vector<T2TriggerBits>*)o)->back)();
}

static  void method_8333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<T2TriggerBits>*)o)->data)());
  else   (((::std::vector<T2TriggerBits>*)o)->data)();
}

static  void method_8334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<T2TriggerBits>*)o)->data)());
  else   (((const ::std::vector<T2TriggerBits>*)o)->data)();
}

static  void method_8335( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2TriggerBits>*)o)->push_back)(*(const ::T2TriggerBits*)arg[0]);
}

static  void method_8336( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2TriggerBits>*)o)->pop_back)();
}

static  void method_8337( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >)((((::std::vector<T2TriggerBits>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >*)arg[0],
    *(const ::T2TriggerBits*)arg[1]));
  else   (((::std::vector<T2TriggerBits>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >*)arg[0],
    *(const ::T2TriggerBits*)arg[1]);
}

static  void method_8338( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2TriggerBits>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::T2TriggerBits*)arg[2]);
}

static  void method_8339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >)((((::std::vector<T2TriggerBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >*)arg[0]));
  else   (((::std::vector<T2TriggerBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >*)arg[0]);
}

static  void method_8340( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >)((((::std::vector<T2TriggerBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >*)arg[1]));
  else   (((::std::vector<T2TriggerBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2TriggerBits*,std::vector<T2TriggerBits> >*)arg[1]);
}

static  void method_8341( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2TriggerBits>*)o)->swap)(*(::std::vector<T2TriggerBits>*)arg[0]);
}

static  void method_8342( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2TriggerBits>*)o)->clear)();
}

static void method_newdel_2520( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<T2TriggerBits> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<T2TriggerBits> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<T2TriggerBits> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<T2TriggerBits> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<T2TriggerBits> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2TriggerBits,std::allocator<T2TriggerBits> >")), ::Reflex::BaseOffset< ::std::vector<T2TriggerBits>,::std::_Vector_base<T2TriggerBits,std::allocator<T2TriggerBits> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<T2TriggerBits> >::Generate();
  else ::Reflex::Proxy< ::std::vector<T2TriggerBits> >::Generate();
}

//------Dictionary for class vector<T2TriggerBits,std::allocator<T2TriggerBits> > -------------------------------
void __std__vector_T2TriggerBits__db_datamem(Reflex::Class*);
void __std__vector_T2TriggerBits__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_T2TriggerBits__datamem_bld(&__std__vector_T2TriggerBits__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_T2TriggerBits__funcmem_bld(&__std__vector_T2TriggerBits__db_funcmem);
void __std__vector_T2TriggerBits__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<T2TriggerBits>"), typeid(::std::vector<T2TriggerBits>), sizeof(::std::vector<T2TriggerBits>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2156, ::Reflex::BaseOffset< ::std::vector<T2TriggerBits>, ::std::_Vector_base<T2TriggerBits,std::allocator<T2TriggerBits> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2111, Reflex::Literal("std::vector<T2TriggerBits>::_Alloc_value_type"))
  .AddTypedef(type_2156, Reflex::Literal("std::vector<T2TriggerBits>::_Base"))
  .AddTypedef(type_2672, Reflex::Literal("std::vector<T2TriggerBits>::_Tp_alloc_type"))
  .AddTypedef(type_5190, Reflex::Literal("std::vector<T2TriggerBits>::_Alloc_traits"))
  .AddTypedef(type_2111, Reflex::Literal("std::vector<T2TriggerBits>::value_type"))
  .AddTypedef(type_6036, Reflex::Literal("std::vector<T2TriggerBits>::pointer"))
  .AddTypedef(type_8290, Reflex::Literal("std::vector<T2TriggerBits>::const_pointer"))
  .AddTypedef(type_8292, Reflex::Literal("std::vector<T2TriggerBits>::reference"))
  .AddTypedef(type_8294, Reflex::Literal("std::vector<T2TriggerBits>::const_reference"))
  .AddTypedef(type_5099, Reflex::Literal("std::vector<T2TriggerBits>::iterator"))
  .AddTypedef(type_5100, Reflex::Literal("std::vector<T2TriggerBits>::const_iterator"))
  .AddTypedef(type_2753, Reflex::Literal("std::vector<T2TriggerBits>::const_reverse_iterator"))
  .AddTypedef(type_2754, Reflex::Literal("std::vector<T2TriggerBits>::reverse_iterator"))
  .AddTypedef(type_2657, Reflex::Literal("std::vector<T2TriggerBits>::size_type"))
  .AddTypedef(type_2595, Reflex::Literal("std::vector<T2TriggerBits>::difference_type"))
  .AddTypedef(type_2672, Reflex::Literal("std::vector<T2TriggerBits>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8303, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16346), Reflex::Literal("vector"), constructor_8304, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2657, type_8294, type_16346), Reflex::Literal("vector"), constructor_8305, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16997), Reflex::Literal("vector"), constructor_8306, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8307, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2520, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_T2TriggerBits__funcmem_bld);
}

//------Delayed data member builder for class vector<T2TriggerBits,std::allocator<T2TriggerBits> > -------------------
void __std__vector_T2TriggerBits__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<T2TriggerBits,std::allocator<T2TriggerBits> > -------------------
void __std__vector_T2TriggerBits__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16998, type_16997), Reflex::Literal("operator="), operator_8308, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2657, type_8294), Reflex::Literal("assign"), method_8309, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5099), Reflex::Literal("begin"), method_8310, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5100), Reflex::Literal("begin"), method_8311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5099), Reflex::Literal("end"), method_8312, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5100), Reflex::Literal("end"), method_8313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("size"), method_8318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("max_size"), method_8319, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2657, type_2111), Reflex::Literal("resize"), method_8320, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("capacity"), method_8321, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_8322, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2657), Reflex::Literal("reserve"), method_8323, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8292, type_2657), Reflex::Literal("operator[]"), operator_8324, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8294, type_2657), Reflex::Literal("operator[]"), operator_8325, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8292, type_2657), Reflex::Literal("at"), method_8327, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8294, type_2657), Reflex::Literal("at"), method_8328, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8292), Reflex::Literal("front"), method_8329, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8294), Reflex::Literal("front"), method_8330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8292), Reflex::Literal("back"), method_8331, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8294), Reflex::Literal("back"), method_8332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6036), Reflex::Literal("data"), method_8333, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8290), Reflex::Literal("data"), method_8334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_8294), Reflex::Literal("push_back"), method_8335, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("pop_back"), method_8336, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5099, type_5099, type_8294), Reflex::Literal("insert"), method_8337, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_5099, type_2657, type_8294), Reflex::Literal("insert"), method_8338, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5099, type_5099), Reflex::Literal("erase"), method_8339, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5099, type_5099, type_5099), Reflex::Literal("erase"), method_8340, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_16998), Reflex::Literal("swap"), method_8341, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("clear"), method_8342, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<T1TriggerBits,std::allocator<T1TriggerBits> > -------------------------------
static void constructor_8368( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1TriggerBits>();
  else ::new(mem) ::std::vector<T1TriggerBits>();
}

static void constructor_8369( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1TriggerBits>(*(const ::std::allocator<T1TriggerBits>*)arg[0]);
  else ::new(mem) ::std::vector<T1TriggerBits>(*(const ::std::allocator<T1TriggerBits>*)arg[0]);
}

static void constructor_8370( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1TriggerBits>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<T1TriggerBits>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1TriggerBits>(*(::std::size_t*)arg[0],
      *(const ::T1TriggerBits*)arg[1]);
  else ::new(mem) ::std::vector<T1TriggerBits>(*(::std::size_t*)arg[0],
      *(const ::T1TriggerBits*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1TriggerBits>(*(::std::size_t*)arg[0],
      *(const ::T1TriggerBits*)arg[1],
      *(const ::std::allocator<T1TriggerBits>*)arg[2]);
  else ::new(mem) ::std::vector<T1TriggerBits>(*(::std::size_t*)arg[0],
      *(const ::T1TriggerBits*)arg[1],
      *(const ::std::allocator<T1TriggerBits>*)arg[2]);
  }
}

static void constructor_8371( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1TriggerBits>(*(const ::std::vector<T1TriggerBits>*)arg[0]);
  else ::new(mem) ::std::vector<T1TriggerBits>(*(const ::std::vector<T1TriggerBits>*)arg[0]);
}

static void destructor_8372(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<T1TriggerBits>*)o)->::std::vector<T1TriggerBits>::~vector)();
}
static  void operator_8373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1TriggerBits>*)o)->operator=)(*(const ::std::vector<T1TriggerBits>*)arg[0]);
  else   (((::std::vector<T1TriggerBits>*)o)->operator=)(*(const ::std::vector<T1TriggerBits>*)arg[0]);
}

static  void method_8374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1TriggerBits>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::T1TriggerBits*)arg[1]);
}

static  void method_8375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >)((((::std::vector<T1TriggerBits>*)o)->begin)());
  else   (((::std::vector<T1TriggerBits>*)o)->begin)();
}

static  void method_8376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T1TriggerBits*,std::vector<T1TriggerBits> >)((((const ::std::vector<T1TriggerBits>*)o)->begin)());
  else   (((const ::std::vector<T1TriggerBits>*)o)->begin)();
}

static  void method_8377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >)((((::std::vector<T1TriggerBits>*)o)->end)());
  else   (((::std::vector<T1TriggerBits>*)o)->end)();
}

static  void method_8378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T1TriggerBits*,std::vector<T1TriggerBits> >)((((const ::std::vector<T1TriggerBits>*)o)->end)());
  else   (((const ::std::vector<T1TriggerBits>*)o)->end)();
}

static  void method_8383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1TriggerBits>*)o)->size)());
  else   (((const ::std::vector<T1TriggerBits>*)o)->size)();
}

static  void method_8384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1TriggerBits>*)o)->max_size)());
  else   (((const ::std::vector<T1TriggerBits>*)o)->max_size)();
}

static  void method_8385( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<T1TriggerBits>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<T1TriggerBits>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::T1TriggerBits*)arg[1]);
  }
}

static  void method_8386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1TriggerBits>*)o)->capacity)());
  else   (((const ::std::vector<T1TriggerBits>*)o)->capacity)();
}

static  void method_8387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<T1TriggerBits>*)o)->empty)());
  else   (((const ::std::vector<T1TriggerBits>*)o)->empty)();
}

static  void method_8388( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1TriggerBits>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1TriggerBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T1TriggerBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8390( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1TriggerBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T1TriggerBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1TriggerBits>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T1TriggerBits>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8393( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1TriggerBits>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T1TriggerBits>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1TriggerBits>*)o)->front)();
  else   (((::std::vector<T1TriggerBits>*)o)->front)();
}

static  void method_8395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1TriggerBits>*)o)->front)();
  else   (((const ::std::vector<T1TriggerBits>*)o)->front)();
}

static  void method_8396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1TriggerBits>*)o)->back)();
  else   (((::std::vector<T1TriggerBits>*)o)->back)();
}

static  void method_8397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1TriggerBits>*)o)->back)();
  else   (((const ::std::vector<T1TriggerBits>*)o)->back)();
}

static  void method_8398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<T1TriggerBits>*)o)->data)());
  else   (((::std::vector<T1TriggerBits>*)o)->data)();
}

static  void method_8399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<T1TriggerBits>*)o)->data)());
  else   (((const ::std::vector<T1TriggerBits>*)o)->data)();
}

static  void method_8400( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1TriggerBits>*)o)->push_back)(*(const ::T1TriggerBits*)arg[0]);
}

static  void method_8401( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T1TriggerBits>*)o)->pop_back)();
}

static  void method_8402( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >)((((::std::vector<T1TriggerBits>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >*)arg[0],
    *(const ::T1TriggerBits*)arg[1]));
  else   (((::std::vector<T1TriggerBits>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >*)arg[0],
    *(const ::T1TriggerBits*)arg[1]);
}

static  void method_8403( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1TriggerBits>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::T1TriggerBits*)arg[2]);
}

static  void method_8404( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >)((((::std::vector<T1TriggerBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >*)arg[0]));
  else   (((::std::vector<T1TriggerBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >*)arg[0]);
}

static  void method_8405( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >)((((::std::vector<T1TriggerBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >*)arg[1]));
  else   (((::std::vector<T1TriggerBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T1TriggerBits*,std::vector<T1TriggerBits> >*)arg[1]);
}

static  void method_8406( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1TriggerBits>*)o)->swap)(*(::std::vector<T1TriggerBits>*)arg[0]);
}

static  void method_8407( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T1TriggerBits>*)o)->clear)();
}

static void method_newdel_2521( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<T1TriggerBits> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<T1TriggerBits> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<T1TriggerBits> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<T1TriggerBits> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<T1TriggerBits> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T1TriggerBits,std::allocator<T1TriggerBits> >")), ::Reflex::BaseOffset< ::std::vector<T1TriggerBits>,::std::_Vector_base<T1TriggerBits,std::allocator<T1TriggerBits> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<T1TriggerBits> >::Generate();
  else ::Reflex::Proxy< ::std::vector<T1TriggerBits> >::Generate();
}

//------Dictionary for class vector<T1TriggerBits,std::allocator<T1TriggerBits> > -------------------------------
void __std__vector_T1TriggerBits__db_datamem(Reflex::Class*);
void __std__vector_T1TriggerBits__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_T1TriggerBits__datamem_bld(&__std__vector_T1TriggerBits__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_T1TriggerBits__funcmem_bld(&__std__vector_T1TriggerBits__db_funcmem);
void __std__vector_T1TriggerBits__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<T1TriggerBits>"), typeid(::std::vector<T1TriggerBits>), sizeof(::std::vector<T1TriggerBits>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2157, ::Reflex::BaseOffset< ::std::vector<T1TriggerBits>, ::std::_Vector_base<T1TriggerBits,std::allocator<T1TriggerBits> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1474, Reflex::Literal("std::vector<T1TriggerBits>::_Alloc_value_type"))
  .AddTypedef(type_2157, Reflex::Literal("std::vector<T1TriggerBits>::_Base"))
  .AddTypedef(type_2673, Reflex::Literal("std::vector<T1TriggerBits>::_Tp_alloc_type"))
  .AddTypedef(type_5191, Reflex::Literal("std::vector<T1TriggerBits>::_Alloc_traits"))
  .AddTypedef(type_1474, Reflex::Literal("std::vector<T1TriggerBits>::value_type"))
  .AddTypedef(type_6055, Reflex::Literal("std::vector<T1TriggerBits>::pointer"))
  .AddTypedef(type_8355, Reflex::Literal("std::vector<T1TriggerBits>::const_pointer"))
  .AddTypedef(type_8357, Reflex::Literal("std::vector<T1TriggerBits>::reference"))
  .AddTypedef(type_8359, Reflex::Literal("std::vector<T1TriggerBits>::const_reference"))
  .AddTypedef(type_5101, Reflex::Literal("std::vector<T1TriggerBits>::iterator"))
  .AddTypedef(type_5102, Reflex::Literal("std::vector<T1TriggerBits>::const_iterator"))
  .AddTypedef(type_2755, Reflex::Literal("std::vector<T1TriggerBits>::const_reverse_iterator"))
  .AddTypedef(type_2756, Reflex::Literal("std::vector<T1TriggerBits>::reverse_iterator"))
  .AddTypedef(type_2657, Reflex::Literal("std::vector<T1TriggerBits>::size_type"))
  .AddTypedef(type_2595, Reflex::Literal("std::vector<T1TriggerBits>::difference_type"))
  .AddTypedef(type_2673, Reflex::Literal("std::vector<T1TriggerBits>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8368, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16359), Reflex::Literal("vector"), constructor_8369, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2657, type_8359, type_16359), Reflex::Literal("vector"), constructor_8370, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17000), Reflex::Literal("vector"), constructor_8371, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8372, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2521, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_T1TriggerBits__funcmem_bld);
}

//------Delayed data member builder for class vector<T1TriggerBits,std::allocator<T1TriggerBits> > -------------------
void __std__vector_T1TriggerBits__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<T1TriggerBits,std::allocator<T1TriggerBits> > -------------------
void __std__vector_T1TriggerBits__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17001, type_17000), Reflex::Literal("operator="), operator_8373, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2657, type_8359), Reflex::Literal("assign"), method_8374, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5101), Reflex::Literal("begin"), method_8375, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5102), Reflex::Literal("begin"), method_8376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5101), Reflex::Literal("end"), method_8377, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5102), Reflex::Literal("end"), method_8378, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("size"), method_8383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("max_size"), method_8384, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2657, type_1474), Reflex::Literal("resize"), method_8385, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("capacity"), method_8386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_8387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2657), Reflex::Literal("reserve"), method_8388, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8357, type_2657), Reflex::Literal("operator[]"), operator_8389, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8359, type_2657), Reflex::Literal("operator[]"), operator_8390, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8357, type_2657), Reflex::Literal("at"), method_8392, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8359, type_2657), Reflex::Literal("at"), method_8393, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8357), Reflex::Literal("front"), method_8394, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8359), Reflex::Literal("front"), method_8395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8357), Reflex::Literal("back"), method_8396, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8359), Reflex::Literal("back"), method_8397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6055), Reflex::Literal("data"), method_8398, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8355), Reflex::Literal("data"), method_8399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_8359), Reflex::Literal("push_back"), method_8400, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("pop_back"), method_8401, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5101, type_5101, type_8359), Reflex::Literal("insert"), method_8402, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_5101, type_2657, type_8359), Reflex::Literal("insert"), method_8403, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5101, type_5101), Reflex::Literal("erase"), method_8404, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5101, type_5101, type_5101), Reflex::Literal("erase"), method_8405, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_17001), Reflex::Literal("swap"), method_8406, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("clear"), method_8407, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPCCBits,std::allocator<RPCCBits> > -------------------------------
static void constructor_8432( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPCCBits>();
  else ::new(mem) ::std::vector<RPCCBits>();
}

static void constructor_8433( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPCCBits>(*(const ::std::allocator<RPCCBits>*)arg[0]);
  else ::new(mem) ::std::vector<RPCCBits>(*(const ::std::allocator<RPCCBits>*)arg[0]);
}

static void constructor_8434( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPCCBits>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPCCBits>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPCCBits>(*(::std::size_t*)arg[0],
      *(const ::RPCCBits*)arg[1]);
  else ::new(mem) ::std::vector<RPCCBits>(*(::std::size_t*)arg[0],
      *(const ::RPCCBits*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPCCBits>(*(::std::size_t*)arg[0],
      *(const ::RPCCBits*)arg[1],
      *(const ::std::allocator<RPCCBits>*)arg[2]);
  else ::new(mem) ::std::vector<RPCCBits>(*(::std::size_t*)arg[0],
      *(const ::RPCCBits*)arg[1],
      *(const ::std::allocator<RPCCBits>*)arg[2]);
  }
}

static void constructor_8435( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPCCBits>(*(const ::std::vector<RPCCBits>*)arg[0]);
  else ::new(mem) ::std::vector<RPCCBits>(*(const ::std::vector<RPCCBits>*)arg[0]);
}

static void destructor_8436(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPCCBits>*)o)->::std::vector<RPCCBits>::~vector)();
}
static  void operator_8437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPCCBits>*)o)->operator=)(*(const ::std::vector<RPCCBits>*)arg[0]);
  else   (((::std::vector<RPCCBits>*)o)->operator=)(*(const ::std::vector<RPCCBits>*)arg[0]);
}

static  void method_8438( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPCCBits>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPCCBits*)arg[1]);
}

static  void method_8439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >)((((::std::vector<RPCCBits>*)o)->begin)());
  else   (((::std::vector<RPCCBits>*)o)->begin)();
}

static  void method_8440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPCCBits*,std::vector<RPCCBits> >)((((const ::std::vector<RPCCBits>*)o)->begin)());
  else   (((const ::std::vector<RPCCBits>*)o)->begin)();
}

static  void method_8441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >)((((::std::vector<RPCCBits>*)o)->end)());
  else   (((::std::vector<RPCCBits>*)o)->end)();
}

static  void method_8442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPCCBits*,std::vector<RPCCBits> >)((((const ::std::vector<RPCCBits>*)o)->end)());
  else   (((const ::std::vector<RPCCBits>*)o)->end)();
}

static  void method_8447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPCCBits>*)o)->size)());
  else   (((const ::std::vector<RPCCBits>*)o)->size)();
}

static  void method_8448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPCCBits>*)o)->max_size)());
  else   (((const ::std::vector<RPCCBits>*)o)->max_size)();
}

static  void method_8449( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPCCBits>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPCCBits>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPCCBits*)arg[1]);
  }
}

static  void method_8450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPCCBits>*)o)->capacity)());
  else   (((const ::std::vector<RPCCBits>*)o)->capacity)();
}

static  void method_8451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPCCBits>*)o)->empty)());
  else   (((const ::std::vector<RPCCBits>*)o)->empty)();
}

static  void method_8452( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPCCBits>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPCCBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPCCBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPCCBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPCCBits>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPCCBits>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPCCBits>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPCCBits>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPCCBits>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPCCBits>*)o)->front)();
  else   (((::std::vector<RPCCBits>*)o)->front)();
}

static  void method_8459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPCCBits>*)o)->front)();
  else   (((const ::std::vector<RPCCBits>*)o)->front)();
}

static  void method_8460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPCCBits>*)o)->back)();
  else   (((::std::vector<RPCCBits>*)o)->back)();
}

static  void method_8461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPCCBits>*)o)->back)();
  else   (((const ::std::vector<RPCCBits>*)o)->back)();
}

static  void method_8462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPCCBits>*)o)->data)());
  else   (((::std::vector<RPCCBits>*)o)->data)();
}

static  void method_8463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPCCBits>*)o)->data)());
  else   (((const ::std::vector<RPCCBits>*)o)->data)();
}

static  void method_8464( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPCCBits>*)o)->push_back)(*(const ::RPCCBits*)arg[0]);
}

static  void method_8465( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPCCBits>*)o)->pop_back)();
}

static  void method_8466( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >)((((::std::vector<RPCCBits>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >*)arg[0],
    *(const ::RPCCBits*)arg[1]));
  else   (((::std::vector<RPCCBits>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >*)arg[0],
    *(const ::RPCCBits*)arg[1]);
}

static  void method_8467( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPCCBits>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPCCBits*)arg[2]);
}

static  void method_8468( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >)((((::std::vector<RPCCBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >*)arg[0]));
  else   (((::std::vector<RPCCBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >*)arg[0]);
}

static  void method_8469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >)((((::std::vector<RPCCBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >*)arg[1]));
  else   (((::std::vector<RPCCBits>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPCCBits*,std::vector<RPCCBits> >*)arg[1]);
}

static  void method_8470( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPCCBits>*)o)->swap)(*(::std::vector<RPCCBits>*)arg[0]);
}

static  void method_8471( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPCCBits>*)o)->clear)();
}

static void method_newdel_2522( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPCCBits> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPCCBits> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPCCBits> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPCCBits> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPCCBits> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPCCBits,std::allocator<RPCCBits> >")), ::Reflex::BaseOffset< ::std::vector<RPCCBits>,::std::_Vector_base<RPCCBits,std::allocator<RPCCBits> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPCCBits> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPCCBits> >::Generate();
}

//------Dictionary for class vector<RPCCBits,std::allocator<RPCCBits> > -------------------------------
void __std__vector_RPCCBits__db_datamem(Reflex::Class*);
void __std__vector_RPCCBits__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPCCBits__datamem_bld(&__std__vector_RPCCBits__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPCCBits__funcmem_bld(&__std__vector_RPCCBits__db_funcmem);
void __std__vector_RPCCBits__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPCCBits>"), typeid(::std::vector<RPCCBits>), sizeof(::std::vector<RPCCBits>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2158, ::Reflex::BaseOffset< ::std::vector<RPCCBits>, ::std::_Vector_base<RPCCBits,std::allocator<RPCCBits> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_246, Reflex::Literal("std::vector<RPCCBits>::_Alloc_value_type"))
  .AddTypedef(type_2158, Reflex::Literal("std::vector<RPCCBits>::_Base"))
  .AddTypedef(type_2674, Reflex::Literal("std::vector<RPCCBits>::_Tp_alloc_type"))
  .AddTypedef(type_5192, Reflex::Literal("std::vector<RPCCBits>::_Alloc_traits"))
  .AddTypedef(type_246, Reflex::Literal("std::vector<RPCCBits>::value_type"))
  .AddTypedef(type_6074, Reflex::Literal("std::vector<RPCCBits>::pointer"))
  .AddTypedef(type_8420, Reflex::Literal("std::vector<RPCCBits>::const_pointer"))
  .AddTypedef(type_8422, Reflex::Literal("std::vector<RPCCBits>::reference"))
  .AddTypedef(type_5626, Reflex::Literal("std::vector<RPCCBits>::const_reference"))
  .AddTypedef(type_5103, Reflex::Literal("std::vector<RPCCBits>::iterator"))
  .AddTypedef(type_5104, Reflex::Literal("std::vector<RPCCBits>::const_iterator"))
  .AddTypedef(type_2757, Reflex::Literal("std::vector<RPCCBits>::const_reverse_iterator"))
  .AddTypedef(type_2758, Reflex::Literal("std::vector<RPCCBits>::reverse_iterator"))
  .AddTypedef(type_2657, Reflex::Literal("std::vector<RPCCBits>::size_type"))
  .AddTypedef(type_2595, Reflex::Literal("std::vector<RPCCBits>::difference_type"))
  .AddTypedef(type_2674, Reflex::Literal("std::vector<RPCCBits>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8432, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16372), Reflex::Literal("vector"), constructor_8433, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2657, type_5626, type_16372), Reflex::Literal("vector"), constructor_8434, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17002), Reflex::Literal("vector"), constructor_8435, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8436, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2522, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPCCBits__funcmem_bld);
}

//------Delayed data member builder for class vector<RPCCBits,std::allocator<RPCCBits> > -------------------
void __std__vector_RPCCBits__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPCCBits,std::allocator<RPCCBits> > -------------------
void __std__vector_RPCCBits__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17003, type_17002), Reflex::Literal("operator="), operator_8437, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2657, type_5626), Reflex::Literal("assign"), method_8438, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5103), Reflex::Literal("begin"), method_8439, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5104), Reflex::Literal("begin"), method_8440, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5103), Reflex::Literal("end"), method_8441, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5104), Reflex::Literal("end"), method_8442, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("size"), method_8447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("max_size"), method_8448, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2657, type_246), Reflex::Literal("resize"), method_8449, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2657), Reflex::Literal("capacity"), method_8450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_8451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_2657), Reflex::Literal("reserve"), method_8452, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8422, type_2657), Reflex::Literal("operator[]"), operator_8453, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5626, type_2657), Reflex::Literal("operator[]"), operator_8454, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8422, type_2657), Reflex::Literal("at"), method_8456, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5626, type_2657), Reflex::Literal("at"), method_8457, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8422), Reflex::Literal("front"), method_8458, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5626), Reflex::Literal("front"), method_8459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8422), Reflex::Literal("back"), method_8460, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5626), Reflex::Literal("back"), method_8461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6074), Reflex::Literal("data"), method_8462, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8420), Reflex::Literal("data"), method_8463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_5626), Reflex::Literal("push_back"), method_8464, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("pop_back"), method_8465, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5103, type_5103, type_5626), Reflex::Literal("insert"), method_8466, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_5103, type_2657, type_5626), Reflex::Literal("insert"), method_8467, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5103, type_5103), Reflex::Literal("erase"), method_8468, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5103, type_5103, type_5103), Reflex::Literal("erase"), method_8469, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_17003), Reflex::Literal("swap"), method_8470, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578), Reflex::Literal("clear"), method_8471, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<std::vector<T2TriggerBits, std::allocator<T2TriggerBits> > > -------------------------------
static void constructor_12562( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T2TriggerBits> >();
  else ::new(mem) ::edm::Wrapper<std::vector<T2TriggerBits> >();
}

static void constructor_12563( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T2TriggerBits> >(*(::std::auto_ptr<std::vector<T2TriggerBits> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<T2TriggerBits> >(*(::std::auto_ptr<std::vector<T2TriggerBits> >*)arg[0]);
}

static void destructor_12564(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->::edm::Wrapper<std::vector<T2TriggerBits> >::~Wrapper)();
}
static  void method_12565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->product)();
}

static  void operator_12566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->operator->)();
}

static  void method_12567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->productTypeInfo)();
}

static  void method_12568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->typeInfo)();
}

static void constructor_12569( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T2TriggerBits> >((::std::vector<T2TriggerBits>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<T2TriggerBits> >((::std::vector<T2TriggerBits>*)arg[0]);
}

static  void method_12570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->getInterface)();
}

static  void method_12571( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12572( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12573( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->dynamicTypeInfo)();
}

static  void method_12575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->isPresent)();
}

static  void method_12576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<T2TriggerBits> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3366( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T2TriggerBits> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T2TriggerBits> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T2TriggerBits> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T2TriggerBits> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T2TriggerBits> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<T2TriggerBits, std::allocator<T2TriggerBits> > > -------------------------------
void __edm__Wrapper_std__vector_T2TriggerBits_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_T2TriggerBits_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_T2TriggerBits_s__datamem_bld(&__edm__Wrapper_std__vector_T2TriggerBits_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_T2TriggerBits_s__funcmem_bld(&__edm__Wrapper_std__vector_T2TriggerBits_s__db_funcmem);
void __edm__Wrapper_std__vector_T2TriggerBits_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<T2TriggerBits> >"), typeid(::edm::Wrapper<std::vector<T2TriggerBits> >), sizeof(::edm::Wrapper<std::vector<T2TriggerBits> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2520, Reflex::Literal("edm::Wrapper<std::vector<T2TriggerBits> >::value_type"))
  .AddTypedef(type_2520, Reflex::Literal("edm::Wrapper<std::vector<T2TriggerBits> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12562, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2355), Reflex::Literal("Wrapper"), constructor_12563, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12564, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18912), Reflex::Literal("Wrapper"), constructor_12569, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3366, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_T2TriggerBits_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_T2TriggerBits_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<T2TriggerBits, std::allocator<T2TriggerBits> > > -------------------
void __edm__Wrapper_std__vector_T2TriggerBits_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_T2TriggerBits_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2520, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_T2TriggerBits_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<T2TriggerBits, std::allocator<T2TriggerBits> > > -------------------
void __edm__Wrapper_std__vector_T2TriggerBits_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18911), Reflex::Literal("product"), method_12565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18911), Reflex::Literal("operator->"), operator_12566, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("productTypeInfo"), method_12567, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("typeInfo"), method_12568, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18913), Reflex::Literal("getInterface"), method_12570, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12758, type_16993, type_18802), Reflex::Literal("fillView"), method_12571, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_272, type_6794), Reflex::Literal("setPtr"), method_12572, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_16994, type_16993), Reflex::Literal("fillPtrVector"), method_12573, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo"), method_12574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_12575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo_"), method_12576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<T2TriggerBits> -------------------------------
static void constructor_12583( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<T2TriggerBits>();
  else ::new(mem) ::edm::Wrapper<T2TriggerBits>();
}

static void constructor_12584( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<T2TriggerBits>(*(::std::auto_ptr<T2TriggerBits>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<T2TriggerBits>(*(::std::auto_ptr<T2TriggerBits>*)arg[0]);
}

static void destructor_12585(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<T2TriggerBits>*)o)->::edm::Wrapper<T2TriggerBits>::~Wrapper)();
}
static  void method_12586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<T2TriggerBits>*)o)->product)());
  else   (((const ::edm::Wrapper<T2TriggerBits>*)o)->product)();
}

static  void operator_12587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<T2TriggerBits>*)o)->operator->)());
  else   (((const ::edm::Wrapper<T2TriggerBits>*)o)->operator->)();
}

static  void method_12588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<T2TriggerBits>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<T2TriggerBits>*)o)->productTypeInfo)();
}

static  void method_12589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<T2TriggerBits>*)o)->typeInfo)();
  else   (((::edm::Wrapper<T2TriggerBits>*)o)->typeInfo)();
}

static void constructor_12590( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<T2TriggerBits>((::T2TriggerBits*)arg[0]);
  else ::new(mem) ::edm::Wrapper<T2TriggerBits>((::T2TriggerBits*)arg[0]);
}

static  void method_12591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<T2TriggerBits>*)o)->getInterface)());
  else   (((::edm::Wrapper<T2TriggerBits>*)o)->getInterface)();
}

static  void method_12592( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<T2TriggerBits>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12593( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<T2TriggerBits>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12594( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<T2TriggerBits>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<T2TriggerBits>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<T2TriggerBits>*)o)->dynamicTypeInfo)();
}

static  void method_12596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<T2TriggerBits>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<T2TriggerBits>*)o)->isPresent)();
}

static  void method_12597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<T2TriggerBits>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<T2TriggerBits>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3367( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T2TriggerBits> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T2TriggerBits> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T2TriggerBits> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T2TriggerBits> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T2TriggerBits> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<T2TriggerBits> -------------------------------
void __edm__Wrapper_T2TriggerBits__db_datamem(Reflex::Class*);
void __edm__Wrapper_T2TriggerBits__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_T2TriggerBits__datamem_bld(&__edm__Wrapper_T2TriggerBits__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_T2TriggerBits__funcmem_bld(&__edm__Wrapper_T2TriggerBits__db_funcmem);
void __edm__Wrapper_T2TriggerBits__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<T2TriggerBits>"), typeid(::edm::Wrapper<T2TriggerBits>), sizeof(::edm::Wrapper<T2TriggerBits>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2111, Reflex::Literal("edm::Wrapper<T2TriggerBits>::value_type"))
  .AddTypedef(type_2111, Reflex::Literal("edm::Wrapper<T2TriggerBits>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12583, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2356), Reflex::Literal("Wrapper"), constructor_12584, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12585, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6036), Reflex::Literal("Wrapper"), constructor_12590, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3367, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_T2TriggerBits__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_T2TriggerBits__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<T2TriggerBits> -------------------
void __edm__Wrapper_T2TriggerBits__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_T2TriggerBits_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2111, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_T2TriggerBits_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<T2TriggerBits> -------------------
void __edm__Wrapper_T2TriggerBits__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8290), Reflex::Literal("product"), method_12586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8290), Reflex::Literal("operator->"), operator_12587, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("productTypeInfo"), method_12588, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("typeInfo"), method_12589, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18916), Reflex::Literal("getInterface"), method_12591, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12758, type_16993, type_18802), Reflex::Literal("fillView"), method_12592, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_272, type_6794), Reflex::Literal("setPtr"), method_12593, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_16994, type_16993), Reflex::Literal("fillPtrVector"), method_12594, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo"), method_12595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_12596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo_"), method_12597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<T1TriggerBits, std::allocator<T1TriggerBits> > > -------------------------------
static void constructor_12604( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T1TriggerBits> >();
  else ::new(mem) ::edm::Wrapper<std::vector<T1TriggerBits> >();
}

static void constructor_12605( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T1TriggerBits> >(*(::std::auto_ptr<std::vector<T1TriggerBits> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<T1TriggerBits> >(*(::std::auto_ptr<std::vector<T1TriggerBits> >*)arg[0]);
}

static void destructor_12606(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->::edm::Wrapper<std::vector<T1TriggerBits> >::~Wrapper)();
}
static  void method_12607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->product)();
}

static  void operator_12608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->operator->)();
}

static  void method_12609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->productTypeInfo)();
}

static  void method_12610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->typeInfo)();
}

static void constructor_12611( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T1TriggerBits> >((::std::vector<T1TriggerBits>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<T1TriggerBits> >((::std::vector<T1TriggerBits>*)arg[0]);
}

static  void method_12612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->getInterface)();
}

static  void method_12613( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12614( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12615( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->dynamicTypeInfo)();
}

static  void method_12617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->isPresent)();
}

static  void method_12618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<T1TriggerBits> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3368( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1TriggerBits> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1TriggerBits> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1TriggerBits> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1TriggerBits> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1TriggerBits> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<T1TriggerBits, std::allocator<T1TriggerBits> > > -------------------------------
void __edm__Wrapper_std__vector_T1TriggerBits_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_T1TriggerBits_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_T1TriggerBits_s__datamem_bld(&__edm__Wrapper_std__vector_T1TriggerBits_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_T1TriggerBits_s__funcmem_bld(&__edm__Wrapper_std__vector_T1TriggerBits_s__db_funcmem);
void __edm__Wrapper_std__vector_T1TriggerBits_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<T1TriggerBits> >"), typeid(::edm::Wrapper<std::vector<T1TriggerBits> >), sizeof(::edm::Wrapper<std::vector<T1TriggerBits> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2521, Reflex::Literal("edm::Wrapper<std::vector<T1TriggerBits> >::value_type"))
  .AddTypedef(type_2521, Reflex::Literal("edm::Wrapper<std::vector<T1TriggerBits> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12604, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2357), Reflex::Literal("Wrapper"), constructor_12605, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12606, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18920), Reflex::Literal("Wrapper"), constructor_12611, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3368, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_T1TriggerBits_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_T1TriggerBits_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<T1TriggerBits, std::allocator<T1TriggerBits> > > -------------------
void __edm__Wrapper_std__vector_T1TriggerBits_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_T1TriggerBits_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2521, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_T1TriggerBits_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<T1TriggerBits, std::allocator<T1TriggerBits> > > -------------------
void __edm__Wrapper_std__vector_T1TriggerBits_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18919), Reflex::Literal("product"), method_12607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18919), Reflex::Literal("operator->"), operator_12608, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("productTypeInfo"), method_12609, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("typeInfo"), method_12610, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18921), Reflex::Literal("getInterface"), method_12612, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12758, type_16993, type_18802), Reflex::Literal("fillView"), method_12613, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_272, type_6794), Reflex::Literal("setPtr"), method_12614, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_16994, type_16993), Reflex::Literal("fillPtrVector"), method_12615, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo"), method_12616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_12617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo_"), method_12618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<T1TriggerBits> -------------------------------
static void constructor_12625( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<T1TriggerBits>();
  else ::new(mem) ::edm::Wrapper<T1TriggerBits>();
}

static void constructor_12626( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<T1TriggerBits>(*(::std::auto_ptr<T1TriggerBits>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<T1TriggerBits>(*(::std::auto_ptr<T1TriggerBits>*)arg[0]);
}

static void destructor_12627(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<T1TriggerBits>*)o)->::edm::Wrapper<T1TriggerBits>::~Wrapper)();
}
static  void method_12628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<T1TriggerBits>*)o)->product)());
  else   (((const ::edm::Wrapper<T1TriggerBits>*)o)->product)();
}

static  void operator_12629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<T1TriggerBits>*)o)->operator->)());
  else   (((const ::edm::Wrapper<T1TriggerBits>*)o)->operator->)();
}

static  void method_12630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<T1TriggerBits>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<T1TriggerBits>*)o)->productTypeInfo)();
}

static  void method_12631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<T1TriggerBits>*)o)->typeInfo)();
  else   (((::edm::Wrapper<T1TriggerBits>*)o)->typeInfo)();
}

static void constructor_12632( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<T1TriggerBits>((::T1TriggerBits*)arg[0]);
  else ::new(mem) ::edm::Wrapper<T1TriggerBits>((::T1TriggerBits*)arg[0]);
}

static  void method_12633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<T1TriggerBits>*)o)->getInterface)());
  else   (((::edm::Wrapper<T1TriggerBits>*)o)->getInterface)();
}

static  void method_12634( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<T1TriggerBits>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12635( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<T1TriggerBits>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12636( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<T1TriggerBits>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<T1TriggerBits>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<T1TriggerBits>*)o)->dynamicTypeInfo)();
}

static  void method_12638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<T1TriggerBits>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<T1TriggerBits>*)o)->isPresent)();
}

static  void method_12639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<T1TriggerBits>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<T1TriggerBits>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3369( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T1TriggerBits> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T1TriggerBits> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T1TriggerBits> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T1TriggerBits> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<T1TriggerBits> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<T1TriggerBits> -------------------------------
void __edm__Wrapper_T1TriggerBits__db_datamem(Reflex::Class*);
void __edm__Wrapper_T1TriggerBits__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_T1TriggerBits__datamem_bld(&__edm__Wrapper_T1TriggerBits__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_T1TriggerBits__funcmem_bld(&__edm__Wrapper_T1TriggerBits__db_funcmem);
void __edm__Wrapper_T1TriggerBits__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<T1TriggerBits>"), typeid(::edm::Wrapper<T1TriggerBits>), sizeof(::edm::Wrapper<T1TriggerBits>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1474, Reflex::Literal("edm::Wrapper<T1TriggerBits>::value_type"))
  .AddTypedef(type_1474, Reflex::Literal("edm::Wrapper<T1TriggerBits>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12625, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2358), Reflex::Literal("Wrapper"), constructor_12626, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12627, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6055), Reflex::Literal("Wrapper"), constructor_12632, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3369, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_T1TriggerBits__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_T1TriggerBits__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<T1TriggerBits> -------------------
void __edm__Wrapper_T1TriggerBits__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_T1TriggerBits_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1474, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_T1TriggerBits_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<T1TriggerBits> -------------------
void __edm__Wrapper_T1TriggerBits__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8355), Reflex::Literal("product"), method_12628, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8355), Reflex::Literal("operator->"), operator_12629, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("productTypeInfo"), method_12630, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("typeInfo"), method_12631, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18924), Reflex::Literal("getInterface"), method_12633, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12758, type_16993, type_18802), Reflex::Literal("fillView"), method_12634, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_272, type_6794), Reflex::Literal("setPtr"), method_12635, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_16994, type_16993), Reflex::Literal("fillPtrVector"), method_12636, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo"), method_12637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_12638, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo_"), method_12639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<RPCCBits, std::allocator<RPCCBits> > > -------------------------------
static void constructor_12646( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPCCBits> >();
  else ::new(mem) ::edm::Wrapper<std::vector<RPCCBits> >();
}

static void constructor_12647( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPCCBits> >(*(::std::auto_ptr<std::vector<RPCCBits> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPCCBits> >(*(::std::auto_ptr<std::vector<RPCCBits> >*)arg[0]);
}

static void destructor_12648(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<RPCCBits> >*)o)->::edm::Wrapper<std::vector<RPCCBits> >::~Wrapper)();
}
static  void method_12649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->product)();
}

static  void operator_12650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->operator->)();
}

static  void method_12651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPCCBits> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<RPCCBits> >*)o)->productTypeInfo)();
}

static  void method_12652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPCCBits> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<RPCCBits> >*)o)->typeInfo)();
}

static void constructor_12653( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPCCBits> >((::std::vector<RPCCBits>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPCCBits> >((::std::vector<RPCCBits>*)arg[0]);
}

static  void method_12654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<RPCCBits> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<RPCCBits> >*)o)->getInterface)();
}

static  void method_12655( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12656( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12657( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->dynamicTypeInfo)();
}

static  void method_12659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->isPresent)();
}

static  void method_12660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<RPCCBits> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3370( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPCCBits> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPCCBits> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPCCBits> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPCCBits> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPCCBits> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<RPCCBits, std::allocator<RPCCBits> > > -------------------------------
void __edm__Wrapper_std__vector_RPCCBits_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_RPCCBits_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPCCBits_s__datamem_bld(&__edm__Wrapper_std__vector_RPCCBits_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPCCBits_s__funcmem_bld(&__edm__Wrapper_std__vector_RPCCBits_s__db_funcmem);
void __edm__Wrapper_std__vector_RPCCBits_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPCCBits> >"), typeid(::edm::Wrapper<std::vector<RPCCBits> >), sizeof(::edm::Wrapper<std::vector<RPCCBits> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2522, Reflex::Literal("edm::Wrapper<std::vector<RPCCBits> >::value_type"))
  .AddTypedef(type_2522, Reflex::Literal("edm::Wrapper<std::vector<RPCCBits> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12646, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2359), Reflex::Literal("Wrapper"), constructor_12647, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12648, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18928), Reflex::Literal("Wrapper"), constructor_12653, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3370, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_RPCCBits_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_RPCCBits_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<RPCCBits, std::allocator<RPCCBits> > > -------------------
void __edm__Wrapper_std__vector_RPCCBits_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPCCBits_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2522, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPCCBits_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<RPCCBits, std::allocator<RPCCBits> > > -------------------
void __edm__Wrapper_std__vector_RPCCBits_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18927), Reflex::Literal("product"), method_12649, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18927), Reflex::Literal("operator->"), operator_12650, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("productTypeInfo"), method_12651, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("typeInfo"), method_12652, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18929), Reflex::Literal("getInterface"), method_12654, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12758, type_16993, type_18802), Reflex::Literal("fillView"), method_12655, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_272, type_6794), Reflex::Literal("setPtr"), method_12656, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_16994, type_16993), Reflex::Literal("fillPtrVector"), method_12657, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo"), method_12658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_12659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo_"), method_12660, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPCCBits> -------------------------------
static void constructor_12667( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPCCBits>();
  else ::new(mem) ::edm::Wrapper<RPCCBits>();
}

static void constructor_12668( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPCCBits>(*(::std::auto_ptr<RPCCBits>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPCCBits>(*(::std::auto_ptr<RPCCBits>*)arg[0]);
}

static void destructor_12669(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPCCBits>*)o)->::edm::Wrapper<RPCCBits>::~Wrapper)();
}
static  void method_12670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPCCBits>*)o)->product)());
  else   (((const ::edm::Wrapper<RPCCBits>*)o)->product)();
}

static  void operator_12671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPCCBits>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPCCBits>*)o)->operator->)();
}

static  void method_12672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPCCBits>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPCCBits>*)o)->productTypeInfo)();
}

static  void method_12673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPCCBits>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPCCBits>*)o)->typeInfo)();
}

static void constructor_12674( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPCCBits>((::RPCCBits*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPCCBits>((::RPCCBits*)arg[0]);
}

static  void method_12675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPCCBits>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPCCBits>*)o)->getInterface)();
}

static  void method_12676( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPCCBits>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12677( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPCCBits>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12678( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPCCBits>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPCCBits>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPCCBits>*)o)->dynamicTypeInfo)();
}

static  void method_12680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPCCBits>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPCCBits>*)o)->isPresent)();
}

static  void method_12681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPCCBits>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPCCBits>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3371( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPCCBits> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPCCBits> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPCCBits> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPCCBits> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPCCBits> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPCCBits> -------------------------------
void __edm__Wrapper_RPCCBits__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPCCBits__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPCCBits__datamem_bld(&__edm__Wrapper_RPCCBits__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPCCBits__funcmem_bld(&__edm__Wrapper_RPCCBits__db_funcmem);
void __edm__Wrapper_RPCCBits__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPCCBits>"), typeid(::edm::Wrapper<RPCCBits>), sizeof(::edm::Wrapper<RPCCBits>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_246, Reflex::Literal("edm::Wrapper<RPCCBits>::value_type"))
  .AddTypedef(type_246, Reflex::Literal("edm::Wrapper<RPCCBits>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12667, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2360), Reflex::Literal("Wrapper"), constructor_12668, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12669, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6074), Reflex::Literal("Wrapper"), constructor_12674, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3371, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPCCBits__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPCCBits__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPCCBits> -------------------
void __edm__Wrapper_RPCCBits__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPCCBits_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_246, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPCCBits_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPCCBits> -------------------
void __edm__Wrapper_RPCCBits__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8420), Reflex::Literal("product"), method_12670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8420), Reflex::Literal("operator->"), operator_12671, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("productTypeInfo"), method_12672, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("typeInfo"), method_12673, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18932), Reflex::Literal("getInterface"), method_12675, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_12758, type_16993, type_18802), Reflex::Literal("fillView"), method_12676, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_272, type_6794), Reflex::Literal("setPtr"), method_12677, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_578, type_11300, type_16994, type_16993), Reflex::Literal("fillPtrVector"), method_12678, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo"), method_12679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_12680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11300), Reflex::Literal("dynamicTypeInfo_"), method_12681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __RPCCBits_dict(); 
      __T1TriggerBits_dict(); 
      __T2TriggerBits_dict(); 
      __std__vector_T2TriggerBits__dict(); 
      __std__vector_T1TriggerBits__dict(); 
      __std__vector_RPCCBits__dict(); 
      __edm__Wrapper_std__vector_T2TriggerBits_s__dict(); 
      __edm__Wrapper_T2TriggerBits__dict(); 
      __edm__Wrapper_std__vector_T1TriggerBits_s__dict(); 
      __edm__Wrapper_T1TriggerBits__dict(); 
      __edm__Wrapper_std__vector_RPCCBits_s__dict(); 
      __edm__Wrapper_RPCCBits__dict(); 
    }
    ~Dictionaries() {
      type_246.Unload(); // class RPCCBits 
      type_1474.Unload(); // class T1TriggerBits 
      type_2111.Unload(); // class T2TriggerBits 
      type_2520.Unload(); // class std::vector<T2TriggerBits> 
      type_2521.Unload(); // class std::vector<T1TriggerBits> 
      type_2522.Unload(); // class std::vector<RPCCBits> 
      type_3366.Unload(); // class edm::Wrapper<std::vector<T2TriggerBits> > 
      type_3367.Unload(); // class edm::Wrapper<T2TriggerBits> 
      type_3368.Unload(); // class edm::Wrapper<std::vector<T1TriggerBits> > 
      type_3369.Unload(); // class edm::Wrapper<T1TriggerBits> 
      type_3370.Unload(); // class edm::Wrapper<std::vector<RPCCBits> > 
      type_3371.Unload(); // class edm::Wrapper<RPCCBits> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
