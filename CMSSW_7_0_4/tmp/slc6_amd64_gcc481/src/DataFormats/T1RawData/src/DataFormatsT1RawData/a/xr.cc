// Generated at Mon Jul 11 23:28:23 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/T1RawData/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("__gnu_cxx") );
  ::Reflex::Type type_67 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_61 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_574 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1342 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1204 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_173 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned char"));
  ::Reflex::Type type_273 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_195 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_393 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3222 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_918 = ::Reflex::TypeBuilder(Reflex::Literal("TotemRawVFATFrame"));
  ::Reflex::Type type_1687 = ::Reflex::TypeBuilder(Reflex::Literal("TotemVFATFrameColl"));
  ::Reflex::Type type_2606 = ::Reflex::TypeBuilder(Reflex::Literal("std::equal_to<int>"));
  ::Reflex::Type type_4769 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::hash<int>"));
  ::Reflex::Type type_2464 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,int>"));
  ::Reflex::Type type_2488 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2512 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned char>"));
  ::Reflex::Type type_2489 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_2510 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned short*>"));
  ::Reflex::Type type_4793 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::hash_map<int,int>"));
  ::Reflex::Type type_2491 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TotemRawVFATFrame>"));
  ::Reflex::Type type_2667 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned short*>"));
  ::Reflex::Type type_3122 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TotemVFATFrameColl>"));
  ::Reflex::Type type_2639 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TotemRawVFATFrame>"));
  ::Reflex::Type type_2328 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TotemVFATFrameColl>"));
  ::Reflex::Type type_2592 = ::Reflex::TypeBuilder(Reflex::Literal("std::binary_function<int,int,bool>"));
  ::Reflex::Type type_3151 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TotemVFATFrameColl>"));
  ::Reflex::Type type_2666 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,int> >"));
  ::Reflex::Type type_2612 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Select1st<std::pair<const int,int> >"));
  ::Reflex::Type type_4696 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::_Hashtable_node<std::pair<const int,int> >"));
  ::Reflex::Type type_3202 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_2205 = ::Reflex::TypeBuilder(Reflex::Literal("std::unary_function<std::pair<const int,int>,const int>"));
  ::Reflex::Type type_4825 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned short*> >"));
  ::Reflex::Type type_4826 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<TotemRawVFATFrame> >"));
  ::Reflex::Type type_2136 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned short*,std::allocator<unsigned short*> >"));
  ::Reflex::Type type_2511 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>"));
  ::Reflex::Type type_2664 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>"));
  ::Reflex::Type type_2665 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >"));
  ::Reflex::Type type_2137 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TotemRawVFATFrame,std::allocator<TotemRawVFATFrame> >"));
  ::Reflex::Type type_4753 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >"));
  ::Reflex::Type type_4755 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >"));
  ::Reflex::Type type_4685 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >"));
  ::Reflex::Type type_4754 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned short* const*,std::vector<unsigned short*> >"));
  ::Reflex::Type type_4756 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >"));
  ::Reflex::Type type_4824 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >"));
  ::Reflex::Type type_2767 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> > >"));
  ::Reflex::Type type_2769 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> > >"));
  ::Reflex::Type type_2766 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned short* const*,std::vector<unsigned short*> > >"));
  ::Reflex::Type type_2768 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> > >"));
  ::Reflex::Type type_2135 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*,std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >"));
  ::Reflex::Type type_4751 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >"));
  ::Reflex::Type type_4768 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >"));
  ::Reflex::Type type_4752 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >"));
  ::Reflex::Type type_4761 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >"));
  ::Reflex::Type type_4787 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >"));
  ::Reflex::Type type_2765 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> > >"));
  ::Reflex::Type type_2467 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >,bool>"));
  ::Reflex::Type type_2764 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> > >"));
  ::Reflex::Type type_2466 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >,__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> > >"));
  ::Reflex::Type type_2465 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >,__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> > >"));
  ::Reflex::Type type_11975 = ::Reflex::ArrayBuilder(type_195, 12);
  ::Reflex::Type type_8163 = ::Reflex::ReferenceBuilder(type_918);
  ::Reflex::Type type_918c = ::Reflex::ConstBuilder(type_918);
  ::Reflex::Type type_8165 = ::Reflex::ReferenceBuilder(type_918c);
  ::Reflex::Type type_2866 = ::Reflex::PointerBuilder(type_195);
  ::Reflex::Type type_195c = ::Reflex::ConstBuilder(type_195);
  ::Reflex::Type type_11834 = ::Reflex::PointerBuilder(type_195c);
  ::Reflex::Type type_12063 = ::Reflex::ReferenceBuilder(type_1687);
  ::Reflex::Type type_1687c = ::Reflex::ConstBuilder(type_1687);
  ::Reflex::Type type_12064 = ::Reflex::ReferenceBuilder(type_1687c);
  ::Reflex::Type type_8098 = ::Reflex::ReferenceBuilder(type_2491);
  ::Reflex::Type type_2491c = ::Reflex::ConstBuilder(type_2491);
  ::Reflex::Type type_8100 = ::Reflex::ReferenceBuilder(type_2491c);
  ::Reflex::Type type_6244 = ::Reflex::PointerBuilder(type_918);
  ::Reflex::Type type_8161 = ::Reflex::PointerBuilder(type_918c);
  ::Reflex::Type type_2625 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_273);
  ::Reflex::Type type_2565 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_61);
  ::Reflex::Type type_2639c = ::Reflex::ConstBuilder(type_2639);
  ::Reflex::Type type_16338 = ::Reflex::ReferenceBuilder(type_2639c);
  ::Reflex::Type type_6225 = ::Reflex::PointerBuilder(type_2866);
  ::Reflex::Type type_2866c = ::Reflex::ConstBuilder(type_2866);
  ::Reflex::Type type_9117 = ::Reflex::PointerBuilder(type_2866c);
  ::Reflex::Type type_9119 = ::Reflex::ReferenceBuilder(type_2866);
  ::Reflex::Type type_9121 = ::Reflex::ReferenceBuilder(type_2866c);
  ::Reflex::Type type_2667c = ::Reflex::ConstBuilder(type_2667);
  ::Reflex::Type type_16325 = ::Reflex::ReferenceBuilder(type_2667c);
  ::Reflex::Type type_2510c = ::Reflex::ConstBuilder(type_2510);
  ::Reflex::Type type_16784 = ::Reflex::ReferenceBuilder(type_2510c);
  ::Reflex::Type type_16785 = ::Reflex::ReferenceBuilder(type_2510);
  ::Reflex::Type type_9176 = ::Reflex::PointerBuilder(type_4696);
  ::Reflex::Type type_6206 = ::Reflex::PointerBuilder(type_9176);
  ::Reflex::Type type_9176c = ::Reflex::ConstBuilder(type_9176);
  ::Reflex::Type type_9183 = ::Reflex::PointerBuilder(type_9176c);
  ::Reflex::Type type_9185 = ::Reflex::ReferenceBuilder(type_9176);
  ::Reflex::Type type_9187 = ::Reflex::ReferenceBuilder(type_9176c);
  ::Reflex::Type type_2664c = ::Reflex::ConstBuilder(type_2664);
  ::Reflex::Type type_16312 = ::Reflex::ReferenceBuilder(type_2664c);
  ::Reflex::Type type_2511c = ::Reflex::ConstBuilder(type_2511);
  ::Reflex::Type type_16787 = ::Reflex::ReferenceBuilder(type_2511c);
  ::Reflex::Type type_16788 = ::Reflex::ReferenceBuilder(type_2511);
  ::Reflex::Type type_16870 = ::Reflex::ReferenceBuilder(type_2606);
  ::Reflex::Type type_2606c = ::Reflex::ConstBuilder(type_2606);
  ::Reflex::Type type_16871 = ::Reflex::ReferenceBuilder(type_2606c);
  ::Reflex::Type type_67c = ::Reflex::ConstBuilder(type_67);
  ::Reflex::Type type_7023 = ::Reflex::ReferenceBuilder(type_67c);
  ::Reflex::Type type_16874 = ::Reflex::ReferenceBuilder(type_2612);
  ::Reflex::Type type_2612c = ::Reflex::ConstBuilder(type_2612);
  ::Reflex::Type type_16875 = ::Reflex::ReferenceBuilder(type_2612c);
  ::Reflex::Type type_13036 = ::Reflex::ReferenceBuilder(type_2464);
  ::Reflex::Type type_2464c = ::Reflex::ConstBuilder(type_2464);
  ::Reflex::Type type_13038 = ::Reflex::ReferenceBuilder(type_2464c);
  ::Reflex::Type type_4696c = ::Reflex::ConstBuilder(type_4696);
  ::Reflex::Type type_10061 = ::Reflex::PointerBuilder(type_4696c);
  ::Reflex::Type type_10063 = ::Reflex::ReferenceBuilder(type_4696);
  ::Reflex::Type type_10065 = ::Reflex::ReferenceBuilder(type_4696c);
  ::Reflex::Type type_16907 = ::Reflex::ReferenceBuilder(type_2665);
  ::Reflex::Type type_2665c = ::Reflex::ConstBuilder(type_2665);
  ::Reflex::Type type_16908 = ::Reflex::ReferenceBuilder(type_2665c);
  ::Reflex::Type type_17097 = ::Reflex::PointerBuilder(type_1687c);
  ::Reflex::Type type_393c = ::Reflex::ConstBuilder(type_393);
  ::Reflex::Type type_11127 = ::Reflex::ReferenceBuilder(type_393c);
  ::Reflex::Type type_17098 = ::Reflex::PointerBuilder(type_1687);
  ::Reflex::Type type_3151c = ::Reflex::ConstBuilder(type_3151);
  ::Reflex::Type type_17099 = ::Reflex::PointerBuilder(type_3151c);
  ::Reflex::Type type_3222c = ::Reflex::ConstBuilder(type_3222);
  ::Reflex::Type type_11395 = ::Reflex::ReferenceBuilder(type_3222c);
  ::Reflex::Type type_16741 = ::Reflex::ReferenceBuilder(type_2488);
  ::Reflex::Type type_17100 = ::Reflex::ReferenceBuilder(type_3202);
  ::Reflex::Type type_574c = ::Reflex::ConstBuilder(type_574);
  ::Reflex::Type type_2941 = ::Reflex::PointerBuilder(type_574c);
  ::Reflex::Type type_6662 = ::Reflex::ReferenceBuilder(type_2941);
  ::Reflex::Type type_2489c = ::Reflex::ConstBuilder(type_2489);
  ::Reflex::Type type_16742 = ::Reflex::ReferenceBuilder(type_2489c);
  ::Reflex::Type type_13032 = ::Reflex::PointerBuilder(type_2464);
  ::Reflex::Type type_13034 = ::Reflex::PointerBuilder(type_2464c);
  ::Reflex::Type type_4769c = ::Reflex::ConstBuilder(type_4769);
  ::Reflex::Type type_17433 = ::Reflex::ReferenceBuilder(type_4769c);
  ::Reflex::Type type_2666c = ::Reflex::ConstBuilder(type_2666);
  ::Reflex::Type type_17434 = ::Reflex::ReferenceBuilder(type_2666c);
  ::Reflex::Type type_4768c = ::Reflex::ConstBuilder(type_4768);
  ::Reflex::Type type_17435 = ::Reflex::ReferenceBuilder(type_4768c);
  ::Reflex::Type type_17436 = ::Reflex::ReferenceBuilder(type_4768);
  ::Reflex::Type type_4761c = ::Reflex::ConstBuilder(type_4761);
  ::Reflex::Type type_17437 = ::Reflex::ReferenceBuilder(type_4761c);
  ::Reflex::Type type_4787c = ::Reflex::ConstBuilder(type_4787);
  ::Reflex::Type type_17438 = ::Reflex::ReferenceBuilder(type_4787c);
  ::Reflex::Type type_17439 = ::Reflex::ReferenceBuilder(type_4769);
  ::Reflex::Type type_17472 = ::Reflex::ReferenceBuilder(type_4793);
  ::Reflex::Type type_4793c = ::Reflex::ConstBuilder(type_4793);
  ::Reflex::Type type_17473 = ::Reflex::ReferenceBuilder(type_4793c);
  ::Reflex::Type type_9848 = ::Reflex::ReferenceBuilder(type_67);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TotemRawVFATFrame
#undef __TotemRawVFATFrame
#endif
class __TotemRawVFATFrame {
  public:
  __TotemRawVFATFrame();
  unsigned short data[12];
};
#ifdef __TotemVFATFrameColl
#undef __TotemVFATFrameColl
#endif
class __TotemVFATFrameColl {
  public:
  __TotemVFATFrameColl();
  ::std::vector<TotemRawVFATFrame> frames;
  ::std::vector<unsigned short*> buffers;
  ::__gnu_cxx::hash_map<int,int> map;
};
#ifdef __std__vector_TotemRawVFATFrame_
#undef __std__vector_TotemRawVFATFrame_
#endif
class __std__vector_TotemRawVFATFrame_ : protected ::std::_Vector_base<TotemRawVFATFrame,std::allocator<TotemRawVFATFrame> > {
  public:
  __std__vector_TotemRawVFATFrame_();
};
#ifdef __std__vector_unsignedsshortp_
#undef __std__vector_unsignedsshortp_
#endif
class __std__vector_unsignedsshortp_ : protected ::std::_Vector_base<unsigned short*,std::allocator<unsigned short*> > {
  public:
  __std__vector_unsignedsshortp_();
};
#ifdef __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p_
#undef __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p_
#endif
class __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p_ : protected ::std::_Vector_base<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*,std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> > {
  public:
  __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p_();
};
#ifdef __std__equal_to_int_
#undef __std__equal_to_int_
#endif
struct __std__equal_to_int_ : public ::std::binary_function<int,int,bool> {
  public:
  __std__equal_to_int_();
};
#ifdef __std___Select1st_std__pair_constsint_int_s_
#undef __std___Select1st_std__pair_constsint_int_s_
#endif
struct __std___Select1st_std__pair_constsint_int_s_ : public ::std::unary_function<std::pair<const int,int>,const int> {
  public:
  __std___Select1st_std__pair_constsint_int_s_();
};
#ifdef __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s_
#undef __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s_
#endif
class __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s_ : public ::__gnu_cxx::new_allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > > {
  public:
  __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s_();
};
#ifdef __edm__Wrapper_TotemVFATFrameColl_
#undef __edm__Wrapper_TotemVFATFrameColl_
#endif
class __edm__Wrapper_TotemVFATFrameColl_ {
  public:
  __edm__Wrapper_TotemVFATFrameColl_();
  bool present;
  ::TotemVFATFrameColl obj;
};
#ifdef ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s_
#undef ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s_
#endif
class ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s_ {
  public:
  ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s_();
  ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > > _M_node_allocator;
  ::__gnu_cxx::hash<int> _M_hash;
  ::std::equal_to<int> _M_equals;
  ::std::_Select1st<std::pair<const int,int> > _M_get_key;
  ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> _M_buckets;
  ::std::size_t _M_num_elements;
};
#ifdef ____gnu_cxx__hash_int_
#undef ____gnu_cxx__hash_int_
#endif
struct ____gnu_cxx__hash_int_ {
  public:
  ____gnu_cxx__hash_int_();
};
#ifdef ____gnu_cxx__hash_map_int_int_
#undef ____gnu_cxx__hash_map_int_int_
#endif
class ____gnu_cxx__hash_map_int_int_ {
  public:
  ____gnu_cxx__hash_map_int_int_();
  ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> > _M_ht;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class TotemRawVFATFrame -------------------------------
static  void operator_3962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TotemRawVFATFrame*)o)->operator=)(*(const ::TotemRawVFATFrame*)arg[0]);
  else   (((::TotemRawVFATFrame*)o)->operator=)(*(const ::TotemRawVFATFrame*)arg[0]);
}

static void constructor_3963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRawVFATFrame();
  else ::new(mem) ::TotemRawVFATFrame();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRawVFATFrame((unsigned short*)arg[0]);
  else ::new(mem) ::TotemRawVFATFrame((unsigned short*)arg[0]);
  }
}

static void constructor_3964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRawVFATFrame(*(const ::TotemRawVFATFrame*)arg[0]);
  else ::new(mem) ::TotemRawVFATFrame(*(const ::TotemRawVFATFrame*)arg[0]);
}

static void destructor_3965(void*, void * o, const std::vector<void*>&, void *) {
(((::TotemRawVFATFrame*)o)->::TotemRawVFATFrame::~TotemRawVFATFrame)();
}
static  void method_3966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TotemRawVFATFrame*)o)->setData)((const unsigned short*)arg[0]);
}

static  void method_3967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TotemRawVFATFrame*)o)->getData)());
  else   (((::TotemRawVFATFrame*)o)->getData)();
}

static  void method_3968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((::TotemRawVFATFrame*)o)->getBC)());
  else   (((::TotemRawVFATFrame*)o)->getBC)();
}

static  void method_3969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((::TotemRawVFATFrame*)o)->getEC)());
  else   (((::TotemRawVFATFrame*)o)->getEC)();
}

static  void method_3970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((::TotemRawVFATFrame*)o)->getFlags)());
  else   (((::TotemRawVFATFrame*)o)->getFlags)();
}

static  void method_3971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((::TotemRawVFATFrame*)o)->getChipID)());
  else   (((::TotemRawVFATFrame*)o)->getChipID)();
}

static  void method_3972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((::TotemRawVFATFrame*)o)->getCRC)());
  else   (((::TotemRawVFATFrame*)o)->getCRC)();
}

static  void method_3973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::TotemRawVFATFrame*)o)->channelActive)(*(unsigned char*)arg[0]));
  else   (((::TotemRawVFATFrame*)o)->channelActive)(*(unsigned char*)arg[0]);
}

static  void method_3974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<unsigned char>)((((::TotemRawVFATFrame*)o)->getActiveChannels)());
  else   (((::TotemRawVFATFrame*)o)->getActiveChannels)();
}

static void constructor_x0( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRawVFATFrame();
  else ::new(mem) ::TotemRawVFATFrame();
}

static void method_newdel_918( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TotemRawVFATFrame >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TotemRawVFATFrame >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TotemRawVFATFrame >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TotemRawVFATFrame >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TotemRawVFATFrame >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TotemRawVFATFrame -------------------------------
void __TotemRawVFATFrame_db_datamem(Reflex::Class*);
void __TotemRawVFATFrame_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TotemRawVFATFrame_datamem_bld(&__TotemRawVFATFrame_db_datamem);
Reflex::GenreflexMemberBuilder __TotemRawVFATFrame_funcmem_bld(&__TotemRawVFATFrame_db_funcmem);
void __TotemRawVFATFrame_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TotemRawVFATFrame"), typeid(::TotemRawVFATFrame), sizeof(::TotemRawVFATFrame), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8163, type_8165), Reflex::Literal("operator="), operator_3962, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2866), Reflex::Literal("TotemRawVFATFrame"), constructor_3963, 0, "_data=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8165), Reflex::Literal("TotemRawVFATFrame"), constructor_3964, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TotemRawVFATFrame"), destructor_3965, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TotemRawVFATFrame"), constructor_x0, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_918, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TotemRawVFATFrame_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TotemRawVFATFrame_funcmem_bld);
}

//------Delayed data member builder for class TotemRawVFATFrame -------------------
void __TotemRawVFATFrame_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11975, Reflex::Literal("data"), OffsetOf(__shadow__::__TotemRawVFATFrame, data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TotemRawVFATFrame -------------------
void __TotemRawVFATFrame_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_11834), Reflex::Literal("setData"), method_3966, 0, "_data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2866), Reflex::Literal("getData"), method_3967, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getBC"), method_3968, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getEC"), method_3969, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getFlags"), method_3970, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getChipID"), method_3971, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_195), Reflex::Literal("getCRC"), method_3972, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1342, type_173), Reflex::Literal("channelActive"), method_3973, 0, "channel", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2512), Reflex::Literal("getActiveChannels"), method_3974, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class TotemVFATFrameColl -------------------------------
static  void operator_4650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TotemVFATFrameColl*)o)->operator=)(*(const ::TotemVFATFrameColl*)arg[0]);
  else   (((::TotemVFATFrameColl*)o)->operator=)(*(const ::TotemVFATFrameColl*)arg[0]);
}

static void constructor_4651( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemVFATFrameColl(*(const ::TotemVFATFrameColl*)arg[0]);
  else ::new(mem) ::TotemVFATFrameColl(*(const ::TotemVFATFrameColl*)arg[0]);
}

static void constructor_4652( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TotemVFATFrameColl();
  else ::new(mem) ::TotemVFATFrameColl();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TotemVFATFrameColl(*(char*)arg[0]);
  else ::new(mem) ::TotemVFATFrameColl(*(char*)arg[0]);
  }
}

static void destructor_4653(void*, void * o, const std::vector<void*>&, void *) {
(((::TotemVFATFrameColl*)o)->::TotemVFATFrameColl::~TotemVFATFrameColl)();
}
static  void method_4654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TotemVFATFrameColl*)o)->GetFrames)();
  else   (((::TotemVFATFrameColl*)o)->GetFrames)();
}

static  void method_4655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TotemVFATFrameColl*)o)->GetFrames)();
  else   (((const ::TotemVFATFrameColl*)o)->GetFrames)();
}

static  void operator_4656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TotemVFATFrameColl*)o)->operator[])(*(int*)arg[0]));
  else   (((::TotemVFATFrameColl*)o)->operator[])(*(int*)arg[0]);
}

static  void method_4657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TotemVFATFrameColl*)o)->GetVFATFrameByID)(*(int*)arg[0]));
  else   (((::TotemVFATFrameColl*)o)->GetVFATFrameByID)(*(int*)arg[0]);
}

static  void operator_4658( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TotemVFATFrameColl*)o)->operator())(*(int*)arg[0]));
  else   (((::TotemVFATFrameColl*)o)->operator())(*(int*)arg[0]);
}

static  void method_4659( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TotemVFATFrameColl*)o)->CreateBufferList)();
}

static  void method_4660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<unsigned short*>)((((::TotemVFATFrameColl*)o)->GetBufferList)());
  else   (((::TotemVFATFrameColl*)o)->GetBufferList)();
}

static void constructor_x2( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemVFATFrameColl();
  else ::new(mem) ::TotemVFATFrameColl();
}

static void method_newdel_1687( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TotemVFATFrameColl >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TotemVFATFrameColl >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TotemVFATFrameColl >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TotemVFATFrameColl >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TotemVFATFrameColl >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TotemVFATFrameColl -------------------------------
void __TotemVFATFrameColl_db_datamem(Reflex::Class*);
void __TotemVFATFrameColl_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TotemVFATFrameColl_datamem_bld(&__TotemVFATFrameColl_db_datamem);
Reflex::GenreflexMemberBuilder __TotemVFATFrameColl_funcmem_bld(&__TotemVFATFrameColl_db_funcmem);
void __TotemVFATFrameColl_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TotemVFATFrameColl"), typeid(::TotemVFATFrameColl), sizeof(::TotemVFATFrameColl), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12063, type_12064), Reflex::Literal("operator="), operator_4650, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12064), Reflex::Literal("TotemVFATFrameColl"), constructor_4651, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1204), Reflex::Literal("TotemVFATFrameColl"), constructor_4652, 0, "PlugVFATobjectsManualy=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TotemVFATFrameColl"), destructor_4653, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TotemVFATFrameColl"), constructor_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1687, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TotemVFATFrameColl_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TotemVFATFrameColl_funcmem_bld);
}

//------Delayed data member builder for class TotemVFATFrameColl -------------------
void __TotemVFATFrameColl_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2491, Reflex::Literal("frames"), OffsetOf(__shadow__::__TotemVFATFrameColl, frames), ::Reflex::PRIVATE)
  .AddDataMember(type_2510, Reflex::Literal("buffers"), OffsetOf(__shadow__::__TotemVFATFrameColl, buffers), ::Reflex::PRIVATE)
  .AddDataMember(type_4793, Reflex::Literal("map"), OffsetOf(__shadow__::__TotemVFATFrameColl, map), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TotemVFATFrameColl -------------------
void __TotemVFATFrameColl_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8098), Reflex::Literal("GetFrames"), method_4654, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8100), Reflex::Literal("GetFrames"), method_4655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6244, type_67), Reflex::Literal("operator[]"), operator_4656, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6244, type_67), Reflex::Literal("GetVFATFrameByID"), method_4657, 0, "ID", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6244, type_67), Reflex::Literal("operator()"), operator_4658, 0, "ID", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("CreateBufferList"), method_4659, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510), Reflex::Literal("GetBufferList"), method_4660, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<TotemRawVFATFrame,std::allocator<TotemRawVFATFrame> > -------------------------------
static void constructor_8174( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRawVFATFrame>();
  else ::new(mem) ::std::vector<TotemRawVFATFrame>();
}

static void constructor_8175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRawVFATFrame>(*(const ::std::allocator<TotemRawVFATFrame>*)arg[0]);
  else ::new(mem) ::std::vector<TotemRawVFATFrame>(*(const ::std::allocator<TotemRawVFATFrame>*)arg[0]);
}

static void constructor_8176( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRawVFATFrame>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TotemRawVFATFrame>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRawVFATFrame>(*(::std::size_t*)arg[0],
      *(const ::TotemRawVFATFrame*)arg[1]);
  else ::new(mem) ::std::vector<TotemRawVFATFrame>(*(::std::size_t*)arg[0],
      *(const ::TotemRawVFATFrame*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRawVFATFrame>(*(::std::size_t*)arg[0],
      *(const ::TotemRawVFATFrame*)arg[1],
      *(const ::std::allocator<TotemRawVFATFrame>*)arg[2]);
  else ::new(mem) ::std::vector<TotemRawVFATFrame>(*(::std::size_t*)arg[0],
      *(const ::TotemRawVFATFrame*)arg[1],
      *(const ::std::allocator<TotemRawVFATFrame>*)arg[2]);
  }
}

static void constructor_8177( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRawVFATFrame>(*(const ::std::vector<TotemRawVFATFrame>*)arg[0]);
  else ::new(mem) ::std::vector<TotemRawVFATFrame>(*(const ::std::vector<TotemRawVFATFrame>*)arg[0]);
}

static void destructor_8178(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TotemRawVFATFrame>*)o)->::std::vector<TotemRawVFATFrame>::~vector)();
}
static  void operator_8179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TotemRawVFATFrame>*)o)->operator=)(*(const ::std::vector<TotemRawVFATFrame>*)arg[0]);
  else   (((::std::vector<TotemRawVFATFrame>*)o)->operator=)(*(const ::std::vector<TotemRawVFATFrame>*)arg[0]);
}

static  void method_8180( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TotemRawVFATFrame>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::TotemRawVFATFrame*)arg[1]);
}

static  void method_8181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >)((((::std::vector<TotemRawVFATFrame>*)o)->begin)());
  else   (((::std::vector<TotemRawVFATFrame>*)o)->begin)();
}

static  void method_8182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >)((((const ::std::vector<TotemRawVFATFrame>*)o)->begin)());
  else   (((const ::std::vector<TotemRawVFATFrame>*)o)->begin)();
}

static  void method_8183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >)((((::std::vector<TotemRawVFATFrame>*)o)->end)());
  else   (((::std::vector<TotemRawVFATFrame>*)o)->end)();
}

static  void method_8184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >)((((const ::std::vector<TotemRawVFATFrame>*)o)->end)());
  else   (((const ::std::vector<TotemRawVFATFrame>*)o)->end)();
}

static  void method_8189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TotemRawVFATFrame>*)o)->size)());
  else   (((const ::std::vector<TotemRawVFATFrame>*)o)->size)();
}

static  void method_8190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TotemRawVFATFrame>*)o)->max_size)());
  else   (((const ::std::vector<TotemRawVFATFrame>*)o)->max_size)();
}

static  void method_8191( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TotemRawVFATFrame>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TotemRawVFATFrame>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::TotemRawVFATFrame*)arg[1]);
  }
}

static  void method_8192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TotemRawVFATFrame>*)o)->capacity)());
  else   (((const ::std::vector<TotemRawVFATFrame>*)o)->capacity)();
}

static  void method_8193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TotemRawVFATFrame>*)o)->empty)());
  else   (((const ::std::vector<TotemRawVFATFrame>*)o)->empty)();
}

static  void method_8194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TotemRawVFATFrame>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TotemRawVFATFrame>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TotemRawVFATFrame>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TotemRawVFATFrame>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TotemRawVFATFrame>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TotemRawVFATFrame>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TotemRawVFATFrame>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TotemRawVFATFrame>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TotemRawVFATFrame>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TotemRawVFATFrame>*)o)->front)();
  else   (((::std::vector<TotemRawVFATFrame>*)o)->front)();
}

static  void method_8201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TotemRawVFATFrame>*)o)->front)();
  else   (((const ::std::vector<TotemRawVFATFrame>*)o)->front)();
}

static  void method_8202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TotemRawVFATFrame>*)o)->back)();
  else   (((::std::vector<TotemRawVFATFrame>*)o)->back)();
}

static  void method_8203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TotemRawVFATFrame>*)o)->back)();
  else   (((const ::std::vector<TotemRawVFATFrame>*)o)->back)();
}

static  void method_8204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TotemRawVFATFrame>*)o)->data)());
  else   (((::std::vector<TotemRawVFATFrame>*)o)->data)();
}

static  void method_8205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TotemRawVFATFrame>*)o)->data)());
  else   (((const ::std::vector<TotemRawVFATFrame>*)o)->data)();
}

static  void method_8206( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TotemRawVFATFrame>*)o)->push_back)(*(const ::TotemRawVFATFrame*)arg[0]);
}

static  void method_8207( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TotemRawVFATFrame>*)o)->pop_back)();
}

static  void method_8208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >)((((::std::vector<TotemRawVFATFrame>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >*)arg[0],
    *(const ::TotemRawVFATFrame*)arg[1]));
  else   (((::std::vector<TotemRawVFATFrame>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >*)arg[0],
    *(const ::TotemRawVFATFrame*)arg[1]);
}

static  void method_8209( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TotemRawVFATFrame>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::TotemRawVFATFrame*)arg[2]);
}

static  void method_8210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >)((((::std::vector<TotemRawVFATFrame>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >*)arg[0]));
  else   (((::std::vector<TotemRawVFATFrame>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >*)arg[0]);
}

static  void method_8211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >)((((::std::vector<TotemRawVFATFrame>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >*)arg[1]));
  else   (((::std::vector<TotemRawVFATFrame>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TotemRawVFATFrame*,std::vector<TotemRawVFATFrame> >*)arg[1]);
}

static  void method_8212( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TotemRawVFATFrame>*)o)->swap)(*(::std::vector<TotemRawVFATFrame>*)arg[0]);
}

static  void method_8213( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TotemRawVFATFrame>*)o)->clear)();
}

static void method_newdel_2491( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TotemRawVFATFrame> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TotemRawVFATFrame> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TotemRawVFATFrame> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TotemRawVFATFrame> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TotemRawVFATFrame> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TotemRawVFATFrame,std::allocator<TotemRawVFATFrame> >")), ::Reflex::BaseOffset< ::std::vector<TotemRawVFATFrame>,::std::_Vector_base<TotemRawVFATFrame,std::allocator<TotemRawVFATFrame> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TotemRawVFATFrame> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TotemRawVFATFrame> >::Generate();
}

//------Dictionary for class vector<TotemRawVFATFrame,std::allocator<TotemRawVFATFrame> > -------------------------------
void __std__vector_TotemRawVFATFrame__db_datamem(Reflex::Class*);
void __std__vector_TotemRawVFATFrame__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TotemRawVFATFrame__datamem_bld(&__std__vector_TotemRawVFATFrame__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TotemRawVFATFrame__funcmem_bld(&__std__vector_TotemRawVFATFrame__db_funcmem);
void __std__vector_TotemRawVFATFrame__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TotemRawVFATFrame>"), typeid(::std::vector<TotemRawVFATFrame>), sizeof(::std::vector<TotemRawVFATFrame>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2137, ::Reflex::BaseOffset< ::std::vector<TotemRawVFATFrame>, ::std::_Vector_base<TotemRawVFATFrame,std::allocator<TotemRawVFATFrame> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_918, Reflex::Literal("std::vector<TotemRawVFATFrame>::_Alloc_value_type"))
  .AddTypedef(type_2137, Reflex::Literal("std::vector<TotemRawVFATFrame>::_Base"))
  .AddTypedef(type_2639, Reflex::Literal("std::vector<TotemRawVFATFrame>::_Tp_alloc_type"))
  .AddTypedef(type_4826, Reflex::Literal("std::vector<TotemRawVFATFrame>::_Alloc_traits"))
  .AddTypedef(type_918, Reflex::Literal("std::vector<TotemRawVFATFrame>::value_type"))
  .AddTypedef(type_6244, Reflex::Literal("std::vector<TotemRawVFATFrame>::pointer"))
  .AddTypedef(type_8161, Reflex::Literal("std::vector<TotemRawVFATFrame>::const_pointer"))
  .AddTypedef(type_8163, Reflex::Literal("std::vector<TotemRawVFATFrame>::reference"))
  .AddTypedef(type_8165, Reflex::Literal("std::vector<TotemRawVFATFrame>::const_reference"))
  .AddTypedef(type_4755, Reflex::Literal("std::vector<TotemRawVFATFrame>::iterator"))
  .AddTypedef(type_4756, Reflex::Literal("std::vector<TotemRawVFATFrame>::const_iterator"))
  .AddTypedef(type_2768, Reflex::Literal("std::vector<TotemRawVFATFrame>::const_reverse_iterator"))
  .AddTypedef(type_2769, Reflex::Literal("std::vector<TotemRawVFATFrame>::reverse_iterator"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<TotemRawVFATFrame>::size_type"))
  .AddTypedef(type_2565, Reflex::Literal("std::vector<TotemRawVFATFrame>::difference_type"))
  .AddTypedef(type_2639, Reflex::Literal("std::vector<TotemRawVFATFrame>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8174, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16338), Reflex::Literal("vector"), constructor_8175, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2625, type_8165, type_16338), Reflex::Literal("vector"), constructor_8176, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8100), Reflex::Literal("vector"), constructor_8177, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8178, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2491, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TotemRawVFATFrame__funcmem_bld);
}

//------Delayed data member builder for class vector<TotemRawVFATFrame,std::allocator<TotemRawVFATFrame> > -------------------
void __std__vector_TotemRawVFATFrame__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TotemRawVFATFrame,std::allocator<TotemRawVFATFrame> > -------------------
void __std__vector_TotemRawVFATFrame__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8098, type_8100), Reflex::Literal("operator="), operator_8179, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2625, type_8165), Reflex::Literal("assign"), method_8180, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4755), Reflex::Literal("begin"), method_8181, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4756), Reflex::Literal("begin"), method_8182, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4755), Reflex::Literal("end"), method_8183, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4756), Reflex::Literal("end"), method_8184, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("size"), method_8189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("max_size"), method_8190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2625, type_918), Reflex::Literal("resize"), method_8191, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("capacity"), method_8192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1342), Reflex::Literal("empty"), method_8193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2625), Reflex::Literal("reserve"), method_8194, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8163, type_2625), Reflex::Literal("operator[]"), operator_8195, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8165, type_2625), Reflex::Literal("operator[]"), operator_8196, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8163, type_2625), Reflex::Literal("at"), method_8198, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8165, type_2625), Reflex::Literal("at"), method_8199, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8163), Reflex::Literal("front"), method_8200, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8165), Reflex::Literal("front"), method_8201, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8163), Reflex::Literal("back"), method_8202, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8165), Reflex::Literal("back"), method_8203, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6244), Reflex::Literal("data"), method_8204, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8161), Reflex::Literal("data"), method_8205, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_8165), Reflex::Literal("push_back"), method_8206, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("pop_back"), method_8207, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4755, type_4755, type_8165), Reflex::Literal("insert"), method_8208, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_4755, type_2625, type_8165), Reflex::Literal("insert"), method_8209, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4755, type_4755), Reflex::Literal("erase"), method_8210, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4755, type_4755, type_4755), Reflex::Literal("erase"), method_8211, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_8098), Reflex::Literal("swap"), method_8212, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("clear"), method_8213, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<short unsigned int*,std::allocator<short unsigned int*> > -------------------------------
static void constructor_9130( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short*>();
  else ::new(mem) ::std::vector<unsigned short*>();
}

static void constructor_9131( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short*>(*(const ::std::allocator<unsigned short*>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short*>(*(const ::std::allocator<unsigned short*>*)arg[0]);
}

static void constructor_9132( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short*>(*(::std::size_t*)arg[0],
      *(unsigned short* const*)arg[1]);
  else ::new(mem) ::std::vector<unsigned short*>(*(::std::size_t*)arg[0],
      *(unsigned short* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short*>(*(::std::size_t*)arg[0],
      *(unsigned short* const*)arg[1],
      *(const ::std::allocator<unsigned short*>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned short*>(*(::std::size_t*)arg[0],
      *(unsigned short* const*)arg[1],
      *(const ::std::allocator<unsigned short*>*)arg[2]);
  }
}

static void constructor_9133( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short*>(*(const ::std::vector<unsigned short*>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short*>(*(const ::std::vector<unsigned short*>*)arg[0]);
}

static void destructor_9134(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned short*>*)o)->::std::vector<unsigned short*>::~vector)();
}
static  void operator_9135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short*>*)o)->operator=)(*(const ::std::vector<unsigned short*>*)arg[0]);
  else   (((::std::vector<unsigned short*>*)o)->operator=)(*(const ::std::vector<unsigned short*>*)arg[0]);
}

static  void method_9136( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(unsigned short* const*)arg[1]);
}

static  void method_9137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >)((((::std::vector<unsigned short*>*)o)->begin)());
  else   (((::std::vector<unsigned short*>*)o)->begin)();
}

static  void method_9138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short* const*,std::vector<unsigned short*> >)((((const ::std::vector<unsigned short*>*)o)->begin)());
  else   (((const ::std::vector<unsigned short*>*)o)->begin)();
}

static  void method_9139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >)((((::std::vector<unsigned short*>*)o)->end)());
  else   (((::std::vector<unsigned short*>*)o)->end)();
}

static  void method_9140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short* const*,std::vector<unsigned short*> >)((((const ::std::vector<unsigned short*>*)o)->end)());
  else   (((const ::std::vector<unsigned short*>*)o)->end)();
}

static  void method_9145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short*>*)o)->size)());
  else   (((const ::std::vector<unsigned short*>*)o)->size)();
}

static  void method_9146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short*>*)o)->max_size)());
  else   (((const ::std::vector<unsigned short*>*)o)->max_size)();
}

static  void method_9147( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned short*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned short*>*)o)->resize)(*(::std::size_t*)arg[0],
      (unsigned short*)arg[1]);
  }
}

static  void method_9148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short*>*)o)->capacity)());
  else   (((const ::std::vector<unsigned short*>*)o)->capacity)();
}

static  void method_9149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned short*>*)o)->empty)());
  else   (((const ::std::vector<unsigned short*>*)o)->empty)();
}

static  void method_9150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned short*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned short*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned short*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned short*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short*>*)o)->front)();
  else   (((::std::vector<unsigned short*>*)o)->front)();
}

static  void method_9157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short*>*)o)->front)();
  else   (((const ::std::vector<unsigned short*>*)o)->front)();
}

static  void method_9158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short*>*)o)->back)();
  else   (((::std::vector<unsigned short*>*)o)->back)();
}

static  void method_9159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short*>*)o)->back)();
  else   (((const ::std::vector<unsigned short*>*)o)->back)();
}

static  void method_9160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned short*>*)o)->data)());
  else   (((::std::vector<unsigned short*>*)o)->data)();
}

static  void method_9161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned short*>*)o)->data)());
  else   (((const ::std::vector<unsigned short*>*)o)->data)();
}

static  void method_9162( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short*>*)o)->push_back)(*(unsigned short* const*)arg[0]);
}

static  void method_9163( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned short*>*)o)->pop_back)();
}

static  void method_9164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >)((((::std::vector<unsigned short*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >*)arg[0],
    *(unsigned short* const*)arg[1]));
  else   (((::std::vector<unsigned short*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >*)arg[0],
    *(unsigned short* const*)arg[1]);
}

static  void method_9165( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(unsigned short* const*)arg[2]);
}

static  void method_9166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >)((((::std::vector<unsigned short*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >*)arg[0]));
  else   (((::std::vector<unsigned short*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >*)arg[0]);
}

static  void method_9167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >)((((::std::vector<unsigned short*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >*)arg[1]));
  else   (((::std::vector<unsigned short*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned short**,std::vector<unsigned short*> >*)arg[1]);
}

static  void method_9168( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short*>*)o)->swap)(*(::std::vector<unsigned short*>*)arg[0]);
}

static  void method_9169( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned short*>*)o)->clear)();
}

static void method_newdel_2510( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned short*,std::allocator<unsigned short*> >")), ::Reflex::BaseOffset< ::std::vector<unsigned short*>,::std::_Vector_base<unsigned short*,std::allocator<unsigned short*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned short*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned short*> >::Generate();
}

//------Dictionary for class vector<short unsigned int*,std::allocator<short unsigned int*> > -------------------------------
void __std__vector_unsignedsshortp__db_datamem(Reflex::Class*);
void __std__vector_unsignedsshortp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsshortp__datamem_bld(&__std__vector_unsignedsshortp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsshortp__funcmem_bld(&__std__vector_unsignedsshortp__db_funcmem);
void __std__vector_unsignedsshortp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned short*>"), typeid(::std::vector<unsigned short*>), sizeof(::std::vector<unsigned short*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2136, ::Reflex::BaseOffset< ::std::vector<unsigned short*>, ::std::_Vector_base<unsigned short*,std::allocator<unsigned short*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2866, Reflex::Literal("std::vector<unsigned short*>::_Alloc_value_type"))
  .AddTypedef(type_2136, Reflex::Literal("std::vector<unsigned short*>::_Base"))
  .AddTypedef(type_2667, Reflex::Literal("std::vector<unsigned short*>::_Tp_alloc_type"))
  .AddTypedef(type_4825, Reflex::Literal("std::vector<unsigned short*>::_Alloc_traits"))
  .AddTypedef(type_2866, Reflex::Literal("std::vector<unsigned short*>::value_type"))
  .AddTypedef(type_6225, Reflex::Literal("std::vector<unsigned short*>::pointer"))
  .AddTypedef(type_9117, Reflex::Literal("std::vector<unsigned short*>::const_pointer"))
  .AddTypedef(type_9119, Reflex::Literal("std::vector<unsigned short*>::reference"))
  .AddTypedef(type_9121, Reflex::Literal("std::vector<unsigned short*>::const_reference"))
  .AddTypedef(type_4753, Reflex::Literal("std::vector<unsigned short*>::iterator"))
  .AddTypedef(type_4754, Reflex::Literal("std::vector<unsigned short*>::const_iterator"))
  .AddTypedef(type_2766, Reflex::Literal("std::vector<unsigned short*>::const_reverse_iterator"))
  .AddTypedef(type_2767, Reflex::Literal("std::vector<unsigned short*>::reverse_iterator"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<unsigned short*>::size_type"))
  .AddTypedef(type_2565, Reflex::Literal("std::vector<unsigned short*>::difference_type"))
  .AddTypedef(type_2667, Reflex::Literal("std::vector<unsigned short*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9130, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16325), Reflex::Literal("vector"), constructor_9131, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2625, type_9121, type_16325), Reflex::Literal("vector"), constructor_9132, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16784), Reflex::Literal("vector"), constructor_9133, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9134, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2510, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedsshortp__funcmem_bld);
}

//------Delayed data member builder for class vector<short unsigned int*,std::allocator<short unsigned int*> > -------------------
void __std__vector_unsignedsshortp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<short unsigned int*,std::allocator<short unsigned int*> > -------------------
void __std__vector_unsignedsshortp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16785, type_16784), Reflex::Literal("operator="), operator_9135, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2625, type_9121), Reflex::Literal("assign"), method_9136, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4753), Reflex::Literal("begin"), method_9137, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4754), Reflex::Literal("begin"), method_9138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4753), Reflex::Literal("end"), method_9139, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4754), Reflex::Literal("end"), method_9140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("size"), method_9145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("max_size"), method_9146, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2625, type_2866), Reflex::Literal("resize"), method_9147, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("capacity"), method_9148, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1342), Reflex::Literal("empty"), method_9149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2625), Reflex::Literal("reserve"), method_9150, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9119, type_2625), Reflex::Literal("operator[]"), operator_9151, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9121, type_2625), Reflex::Literal("operator[]"), operator_9152, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9119, type_2625), Reflex::Literal("at"), method_9154, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9121, type_2625), Reflex::Literal("at"), method_9155, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9119), Reflex::Literal("front"), method_9156, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9121), Reflex::Literal("front"), method_9157, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9119), Reflex::Literal("back"), method_9158, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9121), Reflex::Literal("back"), method_9159, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6225), Reflex::Literal("data"), method_9160, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9117), Reflex::Literal("data"), method_9161, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_9121), Reflex::Literal("push_back"), method_9162, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("pop_back"), method_9163, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4753, type_4753, type_9121), Reflex::Literal("insert"), method_9164, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_4753, type_2625, type_9121), Reflex::Literal("insert"), method_9165, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4753, type_4753), Reflex::Literal("erase"), method_9166, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4753, type_4753, type_4753), Reflex::Literal("erase"), method_9167, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_16785), Reflex::Literal("swap"), method_9168, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("clear"), method_9169, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<__gnu_cxx::_Hashtable_node<std::pair<const int, int> >*,std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int, int> >*> > -------------------------------
static void constructor_9196( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>();
  else ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>();
}

static void constructor_9197( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>(*(const ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)arg[0]);
  else ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>(*(const ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)arg[0]);
}

static void constructor_9198( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>(*(::std::size_t*)arg[0],
      *(::__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*)arg[1]);
  else ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>(*(::std::size_t*)arg[0],
      *(::__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>(*(::std::size_t*)arg[0],
      *(::__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*)arg[1],
      *(const ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)arg[2]);
  else ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>(*(::std::size_t*)arg[0],
      *(::__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*)arg[1],
      *(const ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)arg[2]);
  }
}

static void constructor_9199( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>(*(const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)arg[0]);
  else ::new(mem) ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>(*(const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)arg[0]);
}

static void destructor_9200(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::~vector)();
}
static  void operator_9201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->operator=)(*(const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)arg[0]);
  else   (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->operator=)(*(const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)arg[0]);
}

static  void method_9202( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*)arg[1]);
}

static  void method_9203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >)((((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->begin)());
  else   (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->begin)();
}

static  void method_9204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >)((((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->begin)());
  else   (((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->begin)();
}

static  void method_9205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >)((((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->end)());
  else   (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->end)();
}

static  void method_9206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >)((((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->end)());
  else   (((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->end)();
}

static  void method_9211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->size)());
  else   (((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->size)();
}

static  void method_9212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->max_size)());
  else   (((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->max_size)();
}

static  void method_9213( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*)arg[1]);
  }
}

static  void method_9214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->capacity)());
  else   (((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->capacity)();
}

static  void method_9215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->empty)());
  else   (((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->empty)();
}

static  void method_9216( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9218( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->front)();
  else   (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->front)();
}

static  void method_9223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->front)();
  else   (((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->front)();
}

static  void method_9224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->back)();
  else   (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->back)();
}

static  void method_9225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->back)();
  else   (((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->back)();
}

static  void method_9226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->data)());
  else   (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->data)();
}

static  void method_9227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->data)());
  else   (((const ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->data)();
}

static  void method_9228( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->push_back)(*(::__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*)arg[0]);
}

static  void method_9229( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->pop_back)();
}

static  void method_9230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >)((((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >*)arg[0],
    *(::__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*)arg[1]));
  else   (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >*)arg[0],
    *(::__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*)arg[1]);
}

static  void method_9231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::__gnu_cxx::_Hashtable_node<std::pair<const int,int> >* const*)arg[2]);
}

static  void method_9232( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >)((((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >*)arg[0]));
  else   (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >*)arg[0]);
}

static  void method_9233( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >)((((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >*)arg[1]));
  else   (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >**,std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >*)arg[1]);
}

static  void method_9234( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->swap)(*(::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)arg[0]);
}

static  void method_9235( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>*)o)->clear)();
}

static void method_newdel_2511( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*,std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >")), ::Reflex::BaseOffset< ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>,::std::_Vector_base<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*,std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> >::Generate();
}

//------Dictionary for class vector<__gnu_cxx::_Hashtable_node<std::pair<const int, int> >*,std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int, int> >*> > -------------------------------
void __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p__db_datamem(Reflex::Class*);
void __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p__datamem_bld(&__std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p__funcmem_bld(&__std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p__db_funcmem);
void __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>"), typeid(::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>), sizeof(::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2135, ::Reflex::BaseOffset< ::std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>, ::std::_Vector_base<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*,std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_9176, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::_Alloc_value_type"))
  .AddTypedef(type_2135, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::_Base"))
  .AddTypedef(type_2664, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::_Tp_alloc_type"))
  .AddTypedef(type_4824, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::_Alloc_traits"))
  .AddTypedef(type_9176, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::value_type"))
  .AddTypedef(type_6206, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::pointer"))
  .AddTypedef(type_9183, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::const_pointer"))
  .AddTypedef(type_9185, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::reference"))
  .AddTypedef(type_9187, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::const_reference"))
  .AddTypedef(type_4751, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::iterator"))
  .AddTypedef(type_4752, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::const_iterator"))
  .AddTypedef(type_2764, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::const_reverse_iterator"))
  .AddTypedef(type_2765, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::reverse_iterator"))
  .AddTypedef(type_2625, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::size_type"))
  .AddTypedef(type_2565, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::difference_type"))
  .AddTypedef(type_2664, Reflex::Literal("std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9196, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16312), Reflex::Literal("vector"), constructor_9197, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2625, type_9187, type_16312), Reflex::Literal("vector"), constructor_9198, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16787), Reflex::Literal("vector"), constructor_9199, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9200, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2511, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p__funcmem_bld);
}

//------Delayed data member builder for class vector<__gnu_cxx::_Hashtable_node<std::pair<const int, int> >*,std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int, int> >*> > -------------------
void __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<__gnu_cxx::_Hashtable_node<std::pair<const int, int> >*,std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int, int> >*> > -------------------
void __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16788, type_16787), Reflex::Literal("operator="), operator_9201, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2625, type_9187), Reflex::Literal("assign"), method_9202, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4751), Reflex::Literal("begin"), method_9203, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4752), Reflex::Literal("begin"), method_9204, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4751), Reflex::Literal("end"), method_9205, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4752), Reflex::Literal("end"), method_9206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("size"), method_9211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("max_size"), method_9212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2625, type_9176), Reflex::Literal("resize"), method_9213, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("capacity"), method_9214, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1342), Reflex::Literal("empty"), method_9215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2625), Reflex::Literal("reserve"), method_9216, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9185, type_2625), Reflex::Literal("operator[]"), operator_9217, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9187, type_2625), Reflex::Literal("operator[]"), operator_9218, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9185, type_2625), Reflex::Literal("at"), method_9220, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9187, type_2625), Reflex::Literal("at"), method_9221, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9185), Reflex::Literal("front"), method_9222, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9187), Reflex::Literal("front"), method_9223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9185), Reflex::Literal("back"), method_9224, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9187), Reflex::Literal("back"), method_9225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6206), Reflex::Literal("data"), method_9226, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9183), Reflex::Literal("data"), method_9227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_9187), Reflex::Literal("push_back"), method_9228, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("pop_back"), method_9229, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4751, type_4751, type_9187), Reflex::Literal("insert"), method_9230, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_4751, type_2625, type_9187), Reflex::Literal("insert"), method_9231, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4751, type_4751), Reflex::Literal("erase"), method_9232, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4751, type_4751, type_4751), Reflex::Literal("erase"), method_9233, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_16788), Reflex::Literal("swap"), method_9234, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("clear"), method_9235, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class equal_to<int> -------------------------------
static void destructor_9611(void*, void * o, const std::vector<void*>&, void *) {
(((::std::equal_to<int>*)o)->::std::equal_to<int>::~equal_to)();
}
static  void operator_9612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::equal_to<int>*)o)->operator=)(*(const ::std::equal_to<int>*)arg[0]);
  else   (((::std::equal_to<int>*)o)->operator=)(*(const ::std::equal_to<int>*)arg[0]);
}

static void constructor_9613( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::equal_to<int>(*(const ::std::equal_to<int>*)arg[0]);
  else ::new(mem) ::std::equal_to<int>(*(const ::std::equal_to<int>*)arg[0]);
}

static void constructor_9614( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::equal_to<int>();
  else ::new(mem) ::std::equal_to<int>();
}

static  void operator_9615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::equal_to<int>*)o)->operator())(*(const int*)arg[0],
    *(const int*)arg[1]));
  else   (((const ::std::equal_to<int>*)o)->operator())(*(const int*)arg[0],
    *(const int*)arg[1]);
}

static void method_newdel_2606( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::equal_to<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::equal_to<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::equal_to<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::equal_to<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::equal_to<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::binary_function<int,int,bool>")), ::Reflex::BaseOffset< ::std::equal_to<int>,::std::binary_function<int,int,bool> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class equal_to<int> -------------------------------
void __std__equal_to_int__db_datamem(Reflex::Class*);
void __std__equal_to_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__equal_to_int__datamem_bld(&__std__equal_to_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__equal_to_int__funcmem_bld(&__std__equal_to_int__db_funcmem);
void __std__equal_to_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::equal_to<int>"), typeid(::std::equal_to<int>), sizeof(::std::equal_to<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddBase(type_2592, ::Reflex::BaseOffset< ::std::equal_to<int>, ::std::binary_function<int,int,bool> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~equal_to"), destructor_9611, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16870, type_16871), Reflex::Literal("operator="), operator_9612, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16871), Reflex::Literal("equal_to"), constructor_9613, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("equal_to"), constructor_9614, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2606, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__equal_to_int__funcmem_bld);
}

//------Delayed data member builder for class equal_to<int> -------------------
void __std__equal_to_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class equal_to<int> -------------------
void __std__equal_to_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1342, type_7023, type_7023), Reflex::Literal("operator()"), operator_9615, 0, "__x;__y", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class _Select1st<std::pair<const int, int> > -------------------------------
static void destructor_9620(void*, void * o, const std::vector<void*>&, void *) {
(((::std::_Select1st<std::pair<const int,int> >*)o)->::std::_Select1st<std::pair<const int,int> >::~_Select1st)();
}
static  void operator_9621( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::_Select1st<std::pair<const int,int> >*)o)->operator=)(*(const ::std::_Select1st<std::pair<const int,int> >*)arg[0]);
  else   (((::std::_Select1st<std::pair<const int,int> >*)o)->operator=)(*(const ::std::_Select1st<std::pair<const int,int> >*)arg[0]);
}

static void constructor_9622( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Select1st<std::pair<const int,int> >(*(const ::std::_Select1st<std::pair<const int,int> >*)arg[0]);
  else ::new(mem) ::std::_Select1st<std::pair<const int,int> >(*(const ::std::_Select1st<std::pair<const int,int> >*)arg[0]);
}

static void constructor_9623( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::_Select1st<std::pair<const int,int> >();
  else ::new(mem) ::std::_Select1st<std::pair<const int,int> >();
}

static  void operator_9624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Select1st<std::pair<const int,int> >*)o)->operator())(*(::std::pair<const int,int>*)arg[0]);
  else   (((const ::std::_Select1st<std::pair<const int,int> >*)o)->operator())(*(::std::pair<const int,int>*)arg[0]);
}

static  void operator_9625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::_Select1st<std::pair<const int,int> >*)o)->operator())(*(const ::std::pair<const int,int>*)arg[0]);
  else   (((const ::std::_Select1st<std::pair<const int,int> >*)o)->operator())(*(const ::std::pair<const int,int>*)arg[0]);
}

static void method_newdel_2612( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::_Select1st<std::pair<const int,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::_Select1st<std::pair<const int,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::_Select1st<std::pair<const int,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::_Select1st<std::pair<const int,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::_Select1st<std::pair<const int,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::unary_function<std::pair<const int,int>,const int>")), ::Reflex::BaseOffset< ::std::_Select1st<std::pair<const int,int> >,::std::unary_function<std::pair<const int,int>,const int> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class _Select1st<std::pair<const int, int> > -------------------------------
void __std___Select1st_std__pair_constsint_int_s__db_datamem(Reflex::Class*);
void __std___Select1st_std__pair_constsint_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std___Select1st_std__pair_constsint_int_s__datamem_bld(&__std___Select1st_std__pair_constsint_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std___Select1st_std__pair_constsint_int_s__funcmem_bld(&__std___Select1st_std__pair_constsint_int_s__db_funcmem);
void __std___Select1st_std__pair_constsint_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::_Select1st<std::pair<const int,int> >"), typeid(::std::_Select1st<std::pair<const int,int> >), sizeof(::std::_Select1st<std::pair<const int,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddBase(type_2205, ::Reflex::BaseOffset< ::std::_Select1st<std::pair<const int,int> >, ::std::unary_function<std::pair<const int,int>,const int> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~_Select1st"), destructor_9620, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16874, type_16875), Reflex::Literal("operator="), operator_9621, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16875), Reflex::Literal("_Select1st"), constructor_9622, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("_Select1st"), constructor_9623, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2612, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std___Select1st_std__pair_constsint_int_s__funcmem_bld);
}

//------Delayed data member builder for class _Select1st<std::pair<const int, int> > -------------------
void __std___Select1st_std__pair_constsint_int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class _Select1st<std::pair<const int, int> > -------------------
void __std___Select1st_std__pair_constsint_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7023, type_13036), Reflex::Literal("operator()"), operator_9624, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7023, type_13038), Reflex::Literal("operator()"), operator_9625, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class allocator<__gnu_cxx::_Hashtable_node<std::pair<const int, int> > > -------------------------------
static  void operator_10068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >*)o)->operator=)(*(const ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >*)arg[0]);
  else   (((::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >*)o)->operator=)(*(const ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >*)arg[0]);
}

static void constructor_10069( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >();
  else ::new(mem) ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >();
}

static void constructor_10070( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >(*(const ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >*)arg[0]);
  else ::new(mem) ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >(*(const ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >*)arg[0]);
}

static void destructor_10071(void*, void * o, const std::vector<void*>&, void *) {
(((::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >*)o)->::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >::~allocator)();
}
static void method_newdel_2665( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >")), ::Reflex::BaseOffset< ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >,::__gnu_cxx::new_allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > > >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<__gnu_cxx::_Hashtable_node<std::pair<const int, int> > > -------------------------------
void __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s__db_datamem(Reflex::Class*);
void __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s__datamem_bld(&__std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s__funcmem_bld(&__std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s__db_funcmem);
void __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >"), typeid(::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >), sizeof(::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_4685, ::Reflex::BaseOffset< ::std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >, ::__gnu_cxx::new_allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > > >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2625, Reflex::Literal("std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >::size_type"))
  .AddTypedef(type_2565, Reflex::Literal("std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >::difference_type"))
  .AddTypedef(type_9176, Reflex::Literal("std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >::pointer"))
  .AddTypedef(type_10061, Reflex::Literal("std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >::const_pointer"))
  .AddTypedef(type_10063, Reflex::Literal("std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >::reference"))
  .AddTypedef(type_10065, Reflex::Literal("std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >::const_reference"))
  .AddTypedef(type_4696, Reflex::Literal("std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16907, type_16908), Reflex::Literal("operator="), operator_10068, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_10069, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16908), Reflex::Literal("allocator"), constructor_10070, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_10071, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2665, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<__gnu_cxx::_Hashtable_node<std::pair<const int, int> > > -------------------
void __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<__gnu_cxx::_Hashtable_node<std::pair<const int, int> > > -------------------
void __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Wrapper<TotemVFATFrameColl> -------------------------------
static void constructor_11348( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemVFATFrameColl>();
  else ::new(mem) ::edm::Wrapper<TotemVFATFrameColl>();
}

static void constructor_11349( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemVFATFrameColl>(*(::std::auto_ptr<TotemVFATFrameColl>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemVFATFrameColl>(*(::std::auto_ptr<TotemVFATFrameColl>*)arg[0]);
}

static void destructor_11350(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TotemVFATFrameColl>*)o)->::edm::Wrapper<TotemVFATFrameColl>::~Wrapper)();
}
static  void method_11351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->product)());
  else   (((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->product)();
}

static  void operator_11352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->operator->)());
  else   (((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->operator->)();
}

static  void method_11353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemVFATFrameColl>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TotemVFATFrameColl>*)o)->productTypeInfo)();
}

static  void method_11354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemVFATFrameColl>*)o)->typeInfo)();
  else   (((::edm::Wrapper<TotemVFATFrameColl>*)o)->typeInfo)();
}

static void constructor_11355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemVFATFrameColl>((::TotemVFATFrameColl*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemVFATFrameColl>((::TotemVFATFrameColl*)arg[0]);
}

static  void method_11356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TotemVFATFrameColl>*)o)->getInterface)());
  else   (((::edm::Wrapper<TotemVFATFrameColl>*)o)->getInterface)();
}

static  void method_11357( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_11358( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_11359( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_11360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->dynamicTypeInfo)();
}

static  void method_11361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->isPresent)();
}

static  void method_11362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TotemVFATFrameColl>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemVFATFrameColl> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemVFATFrameColl> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemVFATFrameColl> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemVFATFrameColl> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemVFATFrameColl> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TotemVFATFrameColl> -------------------------------
void __edm__Wrapper_TotemVFATFrameColl__db_datamem(Reflex::Class*);
void __edm__Wrapper_TotemVFATFrameColl__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemVFATFrameColl__datamem_bld(&__edm__Wrapper_TotemVFATFrameColl__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemVFATFrameColl__funcmem_bld(&__edm__Wrapper_TotemVFATFrameColl__db_funcmem);
void __edm__Wrapper_TotemVFATFrameColl__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TotemVFATFrameColl>"), typeid(::edm::Wrapper<TotemVFATFrameColl>), sizeof(::edm::Wrapper<TotemVFATFrameColl>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1687, Reflex::Literal("edm::Wrapper<TotemVFATFrameColl>::value_type"))
  .AddTypedef(type_1687, Reflex::Literal("edm::Wrapper<TotemVFATFrameColl>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_11348, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2328), Reflex::Literal("Wrapper"), constructor_11349, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_11350, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17098), Reflex::Literal("Wrapper"), constructor_11355, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TotemVFATFrameColl__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TotemVFATFrameColl__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TotemVFATFrameColl> -------------------
void __edm__Wrapper_TotemVFATFrameColl__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1342, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TotemVFATFrameColl_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1687, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TotemVFATFrameColl_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TotemVFATFrameColl> -------------------
void __edm__Wrapper_TotemVFATFrameColl__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17097), Reflex::Literal("product"), method_11351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17097), Reflex::Literal("operator->"), operator_11352, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11127), Reflex::Literal("productTypeInfo"), method_11353, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11127), Reflex::Literal("typeInfo"), method_11354, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17099), Reflex::Literal("getInterface"), method_11356, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_11395, type_16741, type_17100), Reflex::Literal("fillView"), method_11357, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_11127, type_273, type_6662), Reflex::Literal("setPtr"), method_11358, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_11127, type_16742, type_16741), Reflex::Literal("fillPtrVector"), method_11359, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11127), Reflex::Literal("dynamicTypeInfo"), method_11360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1342), Reflex::Literal("isPresent"), method_11361, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11127), Reflex::Literal("dynamicTypeInfo_"), method_11362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class hashtable<std::pair<const int, int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int, int> >,std::equal_to<int>,std::allocator<int> > -------------------------------
static  void method_13047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::hash<int>)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->hash_funct)());
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->hash_funct)();
}

static  void method_13048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::equal_to<int>)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->key_eq)());
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->key_eq)();
}

static  void method_13049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,int> >)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->get_allocator)());
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->get_allocator)();
}

static void constructor_13052( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2],
      *(const ::std::_Select1st<std::pair<const int,int> >*)arg[3]);
  else ::new(mem) ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2],
      *(const ::std::_Select1st<std::pair<const int,int> >*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2],
      *(const ::std::_Select1st<std::pair<const int,int> >*)arg[3],
      *(const ::std::allocator<std::pair<const int,int> >*)arg[4]);
  else ::new(mem) ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2],
      *(const ::std::_Select1st<std::pair<const int,int> >*)arg[3],
      *(const ::std::allocator<std::pair<const int,int> >*)arg[4]);
  }
}

static void constructor_13053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2]);
  else ::new(mem) ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2],
      *(const ::std::allocator<std::pair<const int,int> >*)arg[3]);
  else ::new(mem) ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2],
      *(const ::std::allocator<std::pair<const int,int> >*)arg[3]);
  }
}

static void constructor_13054( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >(*(const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >(*(const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[0]);
}

static  void operator_13055( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->operator=)(*(const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[0]);
  else   (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->operator=)(*(const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[0]);
}

static void destructor_13056(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::~hashtable)();
}
static  void method_13057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->size)());
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->size)();
}

static  void method_13058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->max_size)());
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->max_size)();
}

static  void method_13059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->empty)());
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->empty)();
}

static  void method_13060( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->swap)(*(::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[0]);
}

static  void method_13061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->begin)());
  else   (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->begin)();
}

static  void method_13062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->end)());
  else   (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->end)();
}

static  void method_13063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->begin)());
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->begin)();
}

static  void method_13064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->end)());
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->end)();
}

static  void method_13065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->bucket_count)());
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->bucket_count)();
}

static  void method_13066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->max_bucket_count)());
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->max_bucket_count)();
}

static  void method_13067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->elems_in_bucket)(*(::std::size_t*)arg[0]));
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->elems_in_bucket)(*(::std::size_t*)arg[0]);
}

static  void method_13068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >,bool>)((((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->insert_unique)(*(const ::std::pair<const int,int>*)arg[0]));
  else   (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->insert_unique)(*(const ::std::pair<const int,int>*)arg[0]);
}

static  void method_13069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->insert_equal)(*(const ::std::pair<const int,int>*)arg[0]));
  else   (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->insert_equal)(*(const ::std::pair<const int,int>*)arg[0]);
}

static  void method_13070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >,bool>)((((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->insert_unique_noresize)(*(const ::std::pair<const int,int>*)arg[0]));
  else   (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->insert_unique_noresize)(*(const ::std::pair<const int,int>*)arg[0]);
}

static  void method_13071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->insert_equal_noresize)(*(const ::std::pair<const int,int>*)arg[0]));
  else   (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->insert_equal_noresize)(*(const ::std::pair<const int,int>*)arg[0]);
}

static  void method_13072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->find_or_insert)(*(const ::std::pair<const int,int>*)arg[0]);
  else   (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->find_or_insert)(*(const ::std::pair<const int,int>*)arg[0]);
}

static  void method_13073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->find)(*(const int*)arg[0]));
  else   (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_13074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->find)(*(const int*)arg[0]));
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_13075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->count)(*(const int*)arg[0]));
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->count)(*(const int*)arg[0]);
}

static  void method_13076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >,__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> > >)((((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_13077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >,__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> > >)((((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_13078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->erase)(*(const int*)arg[0]));
  else   (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->erase)(*(const int*)arg[0]);
}

static  void method_13079( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->erase)(*(const ::__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[0]);
}

static  void method_13080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->erase)(*(::__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[0],
    *(::__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[1]);
}

static  void method_13081( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->erase)(*(const ::__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[0]);
}

static  void method_13082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->erase)(*(::__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[0],
    *(::__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[1]);
}

static  void method_13083( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->resize)(*(::std::size_t*)arg[0]);
}

static  void method_13084( void*, void* o, const std::vector<void*>&, void*)
{
  (((::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)o)->clear)();
}

//------Dictionary for class hashtable<std::pair<const int, int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int, int> >,std::equal_to<int>,std::allocator<int> > -------------------------------
void ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__db_datamem(Reflex::Class*);
void ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__datamem_bld(&____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__funcmem_bld(&____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__db_funcmem);
void ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >"), typeid(::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >), sizeof(::__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_67, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::key_type"))
  .AddTypedef(type_2464, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::value_type"))
  .AddTypedef(type_4769, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::hasher"))
  .AddTypedef(type_2606, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::key_equal"))
  .AddTypedef(type_2625, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::size_type"))
  .AddTypedef(type_2565, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::difference_type"))
  .AddTypedef(type_13032, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::pointer"))
  .AddTypedef(type_13034, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::const_pointer"))
  .AddTypedef(type_13036, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::reference"))
  .AddTypedef(type_13038, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::const_reference"))
  .AddTypedef(type_4696, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::_Node"))
  .AddTypedef(type_2666, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::allocator_type"))
  .AddTypedef(type_2665, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::_Node_Alloc"))
  .AddTypedef(type_2664, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::_Nodeptr_Alloc"))
  .AddTypedef(type_2511, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::_Vector_type"))
  .AddTypedef(type_4761, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::iterator"))
  .AddTypedef(type_4787, Reflex::Literal("__gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >::const_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2625, type_17433, type_16871, type_16875, type_17434), Reflex::Literal("hashtable"), constructor_13052, 0, "__n;__hf;__eql;__ext;__a=typename _Alloc::rebind<_Val>::other()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2625, type_17433, type_16871, type_17434), Reflex::Literal("hashtable"), constructor_13053, 0, "__n;__hf;__eql;__a=typename _Alloc::rebind<_Val>::other()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17435), Reflex::Literal("hashtable"), constructor_13054, 0, "__ht", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~hashtable"), destructor_13056, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__funcmem_bld);
}

//------Delayed data member builder for class hashtable<std::pair<const int, int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int, int> >,std::equal_to<int>,std::allocator<int> > -------------------
void ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2665, Reflex::Literal("_M_node_allocator"), OffsetOf(__shadow__::____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s_, _M_node_allocator), ::Reflex::PRIVATE)
  .AddDataMember(type_4769, Reflex::Literal("_M_hash"), OffsetOf(__shadow__::____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s_, _M_hash), ::Reflex::PRIVATE)
  .AddDataMember(type_2606, Reflex::Literal("_M_equals"), OffsetOf(__shadow__::____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s_, _M_equals), ::Reflex::PRIVATE)
  .AddDataMember(type_2612, Reflex::Literal("_M_get_key"), OffsetOf(__shadow__::____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s_, _M_get_key), ::Reflex::PRIVATE)
  .AddDataMember(type_2511, Reflex::Literal("_M_buckets"), OffsetOf(__shadow__::____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s_, _M_buckets), ::Reflex::PRIVATE)
  .AddDataMember(type_2625, Reflex::Literal("_M_num_elements"), OffsetOf(__shadow__::____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s_, _M_num_elements), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class hashtable<std::pair<const int, int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int, int> >,std::equal_to<int>,std::allocator<int> > -------------------
void ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4769), Reflex::Literal("hash_funct"), method_13047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606), Reflex::Literal("key_eq"), method_13048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666), Reflex::Literal("get_allocator"), method_13049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17436, type_17435), Reflex::Literal("operator="), operator_13055, 0, "__ht", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("size"), method_13057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("max_size"), method_13058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1342), Reflex::Literal("empty"), method_13059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_17436), Reflex::Literal("swap"), method_13060, 0, "__ht", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4761), Reflex::Literal("begin"), method_13061, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4761), Reflex::Literal("end"), method_13062, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4787), Reflex::Literal("begin"), method_13063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4787), Reflex::Literal("end"), method_13064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("bucket_count"), method_13065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("max_bucket_count"), method_13066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625, type_2625), Reflex::Literal("elems_in_bucket"), method_13067, 0, "__bucket", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467, type_13038), Reflex::Literal("insert_unique"), method_13068, 0, "__obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4761, type_13038), Reflex::Literal("insert_equal"), method_13069, 0, "__obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467, type_13038), Reflex::Literal("insert_unique_noresize"), method_13070, 0, "__obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4761, type_13038), Reflex::Literal("insert_equal_noresize"), method_13071, 0, "__obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13036, type_13038), Reflex::Literal("find_or_insert"), method_13072, 0, "__obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4761, type_7023), Reflex::Literal("find"), method_13073, 0, "__key", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4787, type_7023), Reflex::Literal("find"), method_13074, 0, "__key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625, type_7023), Reflex::Literal("count"), method_13075, 0, "__key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2466, type_7023), Reflex::Literal("equal_range"), method_13076, 0, "__key", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2465, type_7023), Reflex::Literal("equal_range"), method_13077, 0, "__key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625, type_7023), Reflex::Literal("erase"), method_13078, 0, "__key", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_17437), Reflex::Literal("erase"), method_13079, 0, "__it", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_4761, type_4761), Reflex::Literal("erase"), method_13080, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_17438), Reflex::Literal("erase"), method_13081, 0, "__it", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_4787, type_4787), Reflex::Literal("erase"), method_13082, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2625), Reflex::Literal("resize"), method_13083, 0, "__num_elements_hint", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("clear"), method_13084, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class hash<int> -------------------------------
static void destructor_13096(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::hash<int>*)o)->::__gnu_cxx::hash<int>::~hash)();
}
static  void operator_13097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::hash<int>*)o)->operator=)(*(const ::__gnu_cxx::hash<int>*)arg[0]);
  else   (((::__gnu_cxx::hash<int>*)o)->operator=)(*(const ::__gnu_cxx::hash<int>*)arg[0]);
}

static void constructor_13098( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hash<int>(*(const ::__gnu_cxx::hash<int>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::hash<int>(*(const ::__gnu_cxx::hash<int>*)arg[0]);
}

static void constructor_13099( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hash<int>();
  else ::new(mem) ::__gnu_cxx::hash<int>();
}

static  void operator_13100( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hash<int>*)o)->operator())(*(int*)arg[0]));
  else   (((const ::__gnu_cxx::hash<int>*)o)->operator())(*(int*)arg[0]);
}

static void method_newdel_4769( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::hash<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::hash<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::hash<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::hash<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::hash<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class hash<int> -------------------------------
void ____gnu_cxx__hash_int__db_datamem(Reflex::Class*);
void ____gnu_cxx__hash_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__hash_int__datamem_bld(&____gnu_cxx__hash_int__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__hash_int__funcmem_bld(&____gnu_cxx__hash_int__db_funcmem);
void ____gnu_cxx__hash_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::hash<int>"), typeid(::__gnu_cxx::hash<int>), sizeof(::__gnu_cxx::hash<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~hash"), destructor_13096, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17439, type_17433), Reflex::Literal("operator="), operator_13097, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17433), Reflex::Literal("hash"), constructor_13098, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("hash"), constructor_13099, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4769, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__hash_int__funcmem_bld);
}

//------Delayed data member builder for class hash<int> -------------------
void ____gnu_cxx__hash_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class hash<int> -------------------
void ____gnu_cxx__hash_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625, type_67), Reflex::Literal("operator()"), operator_13100, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class hash_map<int,int,__gnu_cxx::hash<int>,std::equal_to<int>,std::allocator<int> > -------------------------------
static void destructor_13208(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::hash_map<int,int>*)o)->::__gnu_cxx::hash_map<int,int>::~hash_map)();
}
static  void operator_13209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::hash_map<int,int>*)o)->operator=)(*(const ::__gnu_cxx::hash_map<int,int>*)arg[0]);
  else   (((::__gnu_cxx::hash_map<int,int>*)o)->operator=)(*(const ::__gnu_cxx::hash_map<int,int>*)arg[0]);
}

static void constructor_13210( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hash_map<int,int>(*(const ::__gnu_cxx::hash_map<int,int>*)arg[0]);
  else ::new(mem) ::__gnu_cxx::hash_map<int,int>(*(const ::__gnu_cxx::hash_map<int,int>*)arg[0]);
}

static  void method_13211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::hash<int>)((((const ::__gnu_cxx::hash_map<int,int>*)o)->hash_funct)());
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->hash_funct)();
}

static  void method_13212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::equal_to<int>)((((const ::__gnu_cxx::hash_map<int,int>*)o)->key_eq)());
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->key_eq)();
}

static  void method_13213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,int> >)((((const ::__gnu_cxx::hash_map<int,int>*)o)->get_allocator)());
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->get_allocator)();
}

static void constructor_13214( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hash_map<int,int>();
  else ::new(mem) ::__gnu_cxx::hash_map<int,int>();
}

static void constructor_13215( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hash_map<int,int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::__gnu_cxx::hash_map<int,int>(*(::std::size_t*)arg[0]);
}

static void constructor_13216( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hash_map<int,int>(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1]);
  else ::new(mem) ::__gnu_cxx::hash_map<int,int>(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1]);
}

static void constructor_13217( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hash_map<int,int>(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2]);
  else ::new(mem) ::__gnu_cxx::hash_map<int,int>(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::hash_map<int,int>(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2],
      *(const ::std::allocator<std::pair<const int,int> >*)arg[3]);
  else ::new(mem) ::__gnu_cxx::hash_map<int,int>(*(::std::size_t*)arg[0],
      *(const ::__gnu_cxx::hash<int>*)arg[1],
      *(const ::std::equal_to<int>*)arg[2],
      *(const ::std::allocator<std::pair<const int,int> >*)arg[3]);
  }
}

static  void method_13218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hash_map<int,int>*)o)->size)());
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->size)();
}

static  void method_13219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hash_map<int,int>*)o)->max_size)());
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->max_size)();
}

static  void method_13220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::__gnu_cxx::hash_map<int,int>*)o)->empty)());
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->empty)();
}

static  void method_13221( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::hash_map<int,int>*)o)->swap)(*(::__gnu_cxx::hash_map<int,int>*)arg[0]);
}

static  void method_13222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((::__gnu_cxx::hash_map<int,int>*)o)->begin)());
  else   (((::__gnu_cxx::hash_map<int,int>*)o)->begin)();
}

static  void method_13223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((::__gnu_cxx::hash_map<int,int>*)o)->end)());
  else   (((::__gnu_cxx::hash_map<int,int>*)o)->end)();
}

static  void method_13224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((const ::__gnu_cxx::hash_map<int,int>*)o)->begin)());
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->begin)();
}

static  void method_13225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((const ::__gnu_cxx::hash_map<int,int>*)o)->end)());
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->end)();
}

static  void method_13226( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >,bool>)((((::__gnu_cxx::hash_map<int,int>*)o)->insert)(*(const ::std::pair<const int,int>*)arg[0]));
  else   (((::__gnu_cxx::hash_map<int,int>*)o)->insert)(*(const ::std::pair<const int,int>*)arg[0]);
}

static  void method_13227( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >,bool>)((((::__gnu_cxx::hash_map<int,int>*)o)->insert_noresize)(*(const ::std::pair<const int,int>*)arg[0]));
  else   (((::__gnu_cxx::hash_map<int,int>*)o)->insert_noresize)(*(const ::std::pair<const int,int>*)arg[0]);
}

static  void method_13228( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((::__gnu_cxx::hash_map<int,int>*)o)->find)(*(const int*)arg[0]));
  else   (((::__gnu_cxx::hash_map<int,int>*)o)->find)(*(const int*)arg[0]);
}

static  void method_13229( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >)((((const ::__gnu_cxx::hash_map<int,int>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->find)(*(const int*)arg[0]);
}

static  void operator_13230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::hash_map<int,int>*)o)->operator[])(*(const int*)arg[0]);
  else   (((::__gnu_cxx::hash_map<int,int>*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_13231( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hash_map<int,int>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->count)(*(const int*)arg[0]);
}

static  void method_13232( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >,__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> > >)((((::__gnu_cxx::hash_map<int,int>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::__gnu_cxx::hash_map<int,int>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_13233( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >,__gnu_cxx::_Hashtable_const_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> > >)((((const ::__gnu_cxx::hash_map<int,int>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_13234( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::__gnu_cxx::hash_map<int,int>*)o)->erase)(*(const int*)arg[0]));
  else   (((::__gnu_cxx::hash_map<int,int>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_13235( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::hash_map<int,int>*)o)->erase)(*(::__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[0]);
}

static  void method_13236( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::hash_map<int,int>*)o)->erase)(*(::__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[0],
    *(::__gnu_cxx::_Hashtable_iterator<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> >*)arg[1]);
}

static  void method_13237( void*, void* o, const std::vector<void*>&, void*)
{
  (((::__gnu_cxx::hash_map<int,int>*)o)->clear)();
}

static  void method_13238( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::__gnu_cxx::hash_map<int,int>*)o)->resize)(*(::std::size_t*)arg[0]);
}

static  void method_13239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hash_map<int,int>*)o)->bucket_count)());
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->bucket_count)();
}

static  void method_13240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hash_map<int,int>*)o)->max_bucket_count)());
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->max_bucket_count)();
}

static  void method_13241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::__gnu_cxx::hash_map<int,int>*)o)->elems_in_bucket)(*(::std::size_t*)arg[0]));
  else   (((const ::__gnu_cxx::hash_map<int,int>*)o)->elems_in_bucket)(*(::std::size_t*)arg[0]);
}

static void method_newdel_4793( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::hash_map<int,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::hash_map<int,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::hash_map<int,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::hash_map<int,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::hash_map<int,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::__gnu_cxx::hash_map<int,int> >::Generate();
  else ::Reflex::Proxy< ::__gnu_cxx::hash_map<int,int> >::Generate();
}

//------Dictionary for class hash_map<int,int,__gnu_cxx::hash<int>,std::equal_to<int>,std::allocator<int> > -------------------------------
void ____gnu_cxx__hash_map_int_int__db_datamem(Reflex::Class*);
void ____gnu_cxx__hash_map_int_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx__hash_map_int_int__datamem_bld(&____gnu_cxx__hash_map_int_int__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx__hash_map_int_int__funcmem_bld(&____gnu_cxx__hash_map_int_int__db_funcmem);
void ____gnu_cxx__hash_map_int_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::hash_map<int,int>"), typeid(::__gnu_cxx::hash_map<int,int>), sizeof(::__gnu_cxx::hash_map<int,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4768, Reflex::Literal("__gnu_cxx::hash_map<int,int>::_Ht"))
  .AddTypedef(type_67, Reflex::Literal("__gnu_cxx::hash_map<int,int>::key_type"))
  .AddTypedef(type_67, Reflex::Literal("__gnu_cxx::hash_map<int,int>::data_type"))
  .AddTypedef(type_67, Reflex::Literal("__gnu_cxx::hash_map<int,int>::mapped_type"))
  .AddTypedef(type_2464, Reflex::Literal("__gnu_cxx::hash_map<int,int>::value_type"))
  .AddTypedef(type_4769, Reflex::Literal("__gnu_cxx::hash_map<int,int>::hasher"))
  .AddTypedef(type_2606, Reflex::Literal("__gnu_cxx::hash_map<int,int>::key_equal"))
  .AddTypedef(type_2625, Reflex::Literal("__gnu_cxx::hash_map<int,int>::size_type"))
  .AddTypedef(type_2565, Reflex::Literal("__gnu_cxx::hash_map<int,int>::difference_type"))
  .AddTypedef(type_13032, Reflex::Literal("__gnu_cxx::hash_map<int,int>::pointer"))
  .AddTypedef(type_13034, Reflex::Literal("__gnu_cxx::hash_map<int,int>::const_pointer"))
  .AddTypedef(type_13036, Reflex::Literal("__gnu_cxx::hash_map<int,int>::reference"))
  .AddTypedef(type_13038, Reflex::Literal("__gnu_cxx::hash_map<int,int>::const_reference"))
  .AddTypedef(type_4761, Reflex::Literal("__gnu_cxx::hash_map<int,int>::iterator"))
  .AddTypedef(type_4787, Reflex::Literal("__gnu_cxx::hash_map<int,int>::const_iterator"))
  .AddTypedef(type_2666, Reflex::Literal("__gnu_cxx::hash_map<int,int>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~hash_map"), destructor_13208, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17472, type_17473), Reflex::Literal("operator="), operator_13209, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17473), Reflex::Literal("hash_map"), constructor_13210, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("hash_map"), constructor_13214, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2625), Reflex::Literal("hash_map"), constructor_13215, 0, "__n", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2625, type_17433), Reflex::Literal("hash_map"), constructor_13216, 0, "__n;__hf", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2625, type_17433, type_16871, type_17434), Reflex::Literal("hash_map"), constructor_13217, 0, "__n;__hf;__eql;__a=typename __gnu_cxx::hashtable<std::pair<const _Key, _Tp>, _Key, _HashFn, std::_Select1st<std::pair<const _Key, _Tp> >, _EqualKey, _Alloc>::allocator_type()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4793, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx__hash_map_int_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx__hash_map_int_int__funcmem_bld);
}

//------Delayed data member builder for class hash_map<int,int,__gnu_cxx::hash<int>,std::equal_to<int>,std::allocator<int> > -------------------
void ____gnu_cxx__hash_map_int_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4768, Reflex::Literal("_M_ht"), OffsetOf(__shadow__::____gnu_cxx__hash_map_int_int_, _M_ht), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class hash_map<int,int,__gnu_cxx::hash<int>,std::equal_to<int>,std::allocator<int> > -------------------
void ____gnu_cxx__hash_map_int_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4769), Reflex::Literal("hash_funct"), method_13211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606), Reflex::Literal("key_eq"), method_13212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666), Reflex::Literal("get_allocator"), method_13213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("size"), method_13218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("max_size"), method_13219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1342), Reflex::Literal("empty"), method_13220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_17472), Reflex::Literal("swap"), method_13221, 0, "__hs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4761), Reflex::Literal("begin"), method_13222, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4761), Reflex::Literal("end"), method_13223, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4787), Reflex::Literal("begin"), method_13224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4787), Reflex::Literal("end"), method_13225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467, type_13038), Reflex::Literal("insert"), method_13226, 0, "__obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2467, type_13038), Reflex::Literal("insert_noresize"), method_13227, 0, "__obj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4761, type_7023), Reflex::Literal("find"), method_13228, 0, "__key", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4787, type_7023), Reflex::Literal("find"), method_13229, 0, "__key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9848, type_7023), Reflex::Literal("operator[]"), operator_13230, 0, "__key", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625, type_7023), Reflex::Literal("count"), method_13231, 0, "__key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2466, type_7023), Reflex::Literal("equal_range"), method_13232, 0, "__key", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2465, type_7023), Reflex::Literal("equal_range"), method_13233, 0, "__key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625, type_7023), Reflex::Literal("erase"), method_13234, 0, "__key", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_4761), Reflex::Literal("erase"), method_13235, 0, "__it", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_4761, type_4761), Reflex::Literal("erase"), method_13236, 0, "__f;__l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("clear"), method_13237, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2625), Reflex::Literal("resize"), method_13238, 0, "__hint", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("bucket_count"), method_13239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625), Reflex::Literal("max_bucket_count"), method_13240, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2625, type_2625), Reflex::Literal("elems_in_bucket"), method_13241, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TotemRawVFATFrame_dict(); 
      __TotemVFATFrameColl_dict(); 
      __std__vector_TotemRawVFATFrame__dict(); 
      __std__vector_unsignedsshortp__dict(); 
      __std__vector___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_p__dict(); 
      __std__equal_to_int__dict(); 
      __std___Select1st_std__pair_constsint_int_s__dict(); 
      __std__allocator___gnu_cxx___Hashtable_node_std__pair_constsint_int_s_s__dict(); 
      __edm__Wrapper_TotemVFATFrameColl__dict(); 
      ____gnu_cxx__hashtable_std__pair_constsint_int__int___gnu_cxx__hash_int__std___Select1st_std__pair_constsint_int_s__std__equal_to_int__std__allocator_int_s__dict(); 
      ____gnu_cxx__hash_int__dict(); 
      ____gnu_cxx__hash_map_int_int__dict(); 
    }
    ~Dictionaries() {
      type_918.Unload(); // class TotemRawVFATFrame 
      type_1687.Unload(); // class TotemVFATFrameColl 
      type_2491.Unload(); // class std::vector<TotemRawVFATFrame> 
      type_2510.Unload(); // class std::vector<unsigned short*> 
      type_2511.Unload(); // class std::vector<__gnu_cxx::_Hashtable_node<std::pair<const int,int> >*> 
      type_2606.Unload(); // class std::equal_to<int> 
      type_2612.Unload(); // class std::_Select1st<std::pair<const int,int> > 
      type_2665.Unload(); // class std::allocator<__gnu_cxx::_Hashtable_node<std::pair<const int,int> > > 
      type_3122.Unload(); // class edm::Wrapper<TotemVFATFrameColl> 
      type_4768.Unload(); // class __gnu_cxx::hashtable<std::pair<const int,int>,int,__gnu_cxx::hash<int>,std::_Select1st<std::pair<const int,int> >,std::equal_to<int>,std::allocator<int> > 
      type_4769.Unload(); // class __gnu_cxx::hash<int> 
      type_4793.Unload(); // class __gnu_cxx::hash_map<int,int> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
