// Generated at Mon Jul 11 22:59:25 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/DetId/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_68 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_62 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_575 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_906 = ::Reflex::TypeBuilder(Reflex::Literal("DetId"));
  ::Reflex::Type type_1363 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_750 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_277 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_269 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_392 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3447 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2274 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<DetId>"));
  ::Reflex::Type type_2531 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<DetId>"));
  ::Reflex::Type type_4206 = ::Reflex::EnumTypeBuilder(Reflex::Literal("DetId::Detector"));
  ::Reflex::Type type_2690 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<DetId>"));
  ::Reflex::Type type_2506 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<DetId,float>"));
  ::Reflex::Type type_807 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDCollection<DetId>"));
  ::Reflex::Type type_2529 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2530 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_2528 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<DetId,float> >"));
  ::Reflex::Type type_2505 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,unsigned int>"));
  ::Reflex::Type type_2500 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned long,unsigned long>"));
  ::Reflex::Type type_2687 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<DetId,float> >"));
  ::Reflex::Type type_3349 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::EDCollection<DetId> >"));
  ::Reflex::Type type_2362 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::EDCollection<DetId> >"));
  ::Reflex::Type type_2151 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<DetId,std::allocator<DetId> >"));
  ::Reflex::Type type_3378 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::EDCollection<DetId> >"));
  ::Reflex::Type type_5024 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<DetId> >"));
  ::Reflex::Type type_2627 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_3273 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_2626 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >"));
  ::Reflex::Type type_4958 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >"));
  ::Reflex::Type type_2502 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const DetId,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_4179 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const DetId*,std::vector<DetId> >"));
  ::Reflex::Type type_2496 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const DetId,std::pair<unsigned long,unsigned long> >"));
  ::Reflex::Type type_5023 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<DetId,float> > >"));
  ::Reflex::Type type_2686 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_2684 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >"));
  ::Reflex::Type type_2777 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> > >"));
  ::Reflex::Type type_2150 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<DetId,float>,std::allocator<std::pair<DetId,float> > >"));
  ::Reflex::Type type_2582 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_2776 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const DetId*,std::vector<DetId> > >"));
  ::Reflex::Type type_2581 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >"));
  ::Reflex::Type type_4956 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >"));
  ::Reflex::Type type_2672 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_2671 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >"));
  ::Reflex::Type type_4957 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >"));
  ::Reflex::Type type_2504 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >,bool>"));
  ::Reflex::Type type_2498 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >,bool>"));
  ::Reflex::Type type_2773 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_2771 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > > >"));
  ::Reflex::Type type_2775 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > > >"));
  ::Reflex::Type type_2772 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_2770 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > > >"));
  ::Reflex::Type type_2774 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > > >"));
  ::Reflex::Type type_2503 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_2497 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >,std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > > >"));
  ::Reflex::Type type_2501 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_2495 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >,std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > > >"));
  ::Reflex::Type type_2321 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<DetId,std::pair<const DetId,std::pair<unsigned int,unsigned int> >,std::_Select1st<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >,std::less<DetId>,std::allocator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_2320 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<DetId,std::pair<const DetId,std::pair<unsigned long,unsigned long> >,std::_Select1st<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >,std::less<DetId>,std::allocator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > > >"));
  ::Reflex::Type type_808 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("DetIdCollection"), type_807);
  ::Reflex::Type type_1327 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_277);
  ::Reflex::Type type_8378 = ::Reflex::ReferenceBuilder(type_906);
  ::Reflex::Type type_906c = ::Reflex::ConstBuilder(type_906);
  ::Reflex::Type type_8380 = ::Reflex::ReferenceBuilder(type_906c);
  ::Reflex::Type type_2668 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_269);
  ::Reflex::Type type_2531c = ::Reflex::ConstBuilder(type_2531);
  ::Reflex::Type type_13062 = ::Reflex::ReferenceBuilder(type_2531c);
  ::Reflex::Type type_807c = ::Reflex::ConstBuilder(type_807);
  ::Reflex::Type type_13063 = ::Reflex::ReferenceBuilder(type_807c);
  ::Reflex::Type type_13064 = ::Reflex::ReferenceBuilder(type_807);
  ::Reflex::Type type_8188 = ::Reflex::ReferenceBuilder(type_2506);
  ::Reflex::Type type_2506c = ::Reflex::ConstBuilder(type_2506);
  ::Reflex::Type type_8190 = ::Reflex::ReferenceBuilder(type_2506c);
  ::Reflex::Type type_750c = ::Reflex::ConstBuilder(type_750);
  ::Reflex::Type type_16689 = ::Reflex::ReferenceBuilder(type_750c);
  ::Reflex::Type type_5912 = ::Reflex::PointerBuilder(type_2506);
  ::Reflex::Type type_8186 = ::Reflex::PointerBuilder(type_2506c);
  ::Reflex::Type type_2606 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_62);
  ::Reflex::Type type_2687c = ::Reflex::ConstBuilder(type_2687);
  ::Reflex::Type type_16056 = ::Reflex::ReferenceBuilder(type_2687c);
  ::Reflex::Type type_2528c = ::Reflex::ConstBuilder(type_2528);
  ::Reflex::Type type_16698 = ::Reflex::ReferenceBuilder(type_2528c);
  ::Reflex::Type type_16699 = ::Reflex::ReferenceBuilder(type_2528);
  ::Reflex::Type type_5931 = ::Reflex::PointerBuilder(type_906);
  ::Reflex::Type type_8376 = ::Reflex::PointerBuilder(type_906c);
  ::Reflex::Type type_2690c = ::Reflex::ConstBuilder(type_2690);
  ::Reflex::Type type_16069 = ::Reflex::ReferenceBuilder(type_2690c);
  ::Reflex::Type type_16705 = ::Reflex::ReferenceBuilder(type_2531);
  ::Reflex::Type type_7210 = ::Reflex::PointerBuilder(type_2496);
  ::Reflex::Type type_2496c = ::Reflex::ConstBuilder(type_2496);
  ::Reflex::Type type_7212 = ::Reflex::PointerBuilder(type_2496c);
  ::Reflex::Type type_7214 = ::Reflex::ReferenceBuilder(type_2496);
  ::Reflex::Type type_7216 = ::Reflex::ReferenceBuilder(type_2496c);
  ::Reflex::Type type_2274c = ::Reflex::ConstBuilder(type_2274);
  ::Reflex::Type type_16466 = ::Reflex::ReferenceBuilder(type_2274c);
  ::Reflex::Type type_2684c = ::Reflex::ConstBuilder(type_2684);
  ::Reflex::Type type_16543 = ::Reflex::ReferenceBuilder(type_2684c);
  ::Reflex::Type type_2626c = ::Reflex::ConstBuilder(type_2626);
  ::Reflex::Type type_16821 = ::Reflex::ReferenceBuilder(type_2626c);
  ::Reflex::Type type_16822 = ::Reflex::ReferenceBuilder(type_2626);
  ::Reflex::Type type_16823 = ::Reflex::ReferenceBuilder(type_2500);
  ::Reflex::Type type_2500c = ::Reflex::ConstBuilder(type_2500);
  ::Reflex::Type type_16824 = ::Reflex::ReferenceBuilder(type_2500c);
  ::Reflex::Type type_7319 = ::Reflex::PointerBuilder(type_2502);
  ::Reflex::Type type_2502c = ::Reflex::ConstBuilder(type_2502);
  ::Reflex::Type type_7321 = ::Reflex::PointerBuilder(type_2502c);
  ::Reflex::Type type_7323 = ::Reflex::ReferenceBuilder(type_2502);
  ::Reflex::Type type_7325 = ::Reflex::ReferenceBuilder(type_2502c);
  ::Reflex::Type type_2686c = ::Reflex::ConstBuilder(type_2686);
  ::Reflex::Type type_16550 = ::Reflex::ReferenceBuilder(type_2686c);
  ::Reflex::Type type_2627c = ::Reflex::ConstBuilder(type_2627);
  ::Reflex::Type type_16825 = ::Reflex::ReferenceBuilder(type_2627c);
  ::Reflex::Type type_16826 = ::Reflex::ReferenceBuilder(type_2627);
  ::Reflex::Type type_16827 = ::Reflex::ReferenceBuilder(type_2505);
  ::Reflex::Type type_2505c = ::Reflex::ConstBuilder(type_2505);
  ::Reflex::Type type_16828 = ::Reflex::ReferenceBuilder(type_2505c);
  ::Reflex::Type type_18556 = ::Reflex::PointerBuilder(type_807c);
  ::Reflex::Type type_392c = ::Reflex::ConstBuilder(type_392);
  ::Reflex::Type type_11319 = ::Reflex::ReferenceBuilder(type_392c);
  ::Reflex::Type type_18557 = ::Reflex::PointerBuilder(type_807);
  ::Reflex::Type type_3378c = ::Reflex::ConstBuilder(type_3378);
  ::Reflex::Type type_18558 = ::Reflex::PointerBuilder(type_3378c);
  ::Reflex::Type type_3447c = ::Reflex::ConstBuilder(type_3447);
  ::Reflex::Type type_12539 = ::Reflex::ReferenceBuilder(type_3447c);
  ::Reflex::Type type_16701 = ::Reflex::ReferenceBuilder(type_2529);
  ::Reflex::Type type_18482 = ::Reflex::ReferenceBuilder(type_3273);
  ::Reflex::Type type_575c = ::Reflex::ConstBuilder(type_575);
  ::Reflex::Type type_2982 = ::Reflex::PointerBuilder(type_575c);
  ::Reflex::Type type_6651 = ::Reflex::ReferenceBuilder(type_2982);
  ::Reflex::Type type_2530c = ::Reflex::ConstBuilder(type_2530);
  ::Reflex::Type type_16702 = ::Reflex::ReferenceBuilder(type_2530c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __DetId
#undef __DetId
#endif
class __DetId {
  public:
  __DetId();
  ::uint32_t id_;
};
#ifdef __edm__EDCollection_DetId_
#undef __edm__EDCollection_DetId_
#endif
class __edm__EDCollection_DetId_ {
  public:
  __edm__EDCollection_DetId_();
  virtual ~__edm__EDCollection_DetId_() throw();
  ::std::vector<DetId> obj;
};
#ifdef __std__pair_DetId_float_
#undef __std__pair_DetId_float_
#endif
struct __std__pair_DetId_float_ {
  public:
  __std__pair_DetId_float_();
  ::DetId first;
  float second;
};
#ifdef __std__vector_std__pair_DetId_float_s_
#undef __std__vector_std__pair_DetId_float_s_
#endif
class __std__vector_std__pair_DetId_float_s_ : protected ::std::_Vector_base<std::pair<DetId,float>,std::allocator<std::pair<DetId,float> > > {
  public:
  __std__vector_std__pair_DetId_float_s_();
};
#ifdef __std__vector_DetId_
#undef __std__vector_DetId_
#endif
class __std__vector_DetId_ : protected ::std::_Vector_base<DetId,std::allocator<DetId> > {
  public:
  __std__vector_DetId_();
};
#ifdef __std__map_DetId_std__pair_unsignedslong_unsignedslong_s_
#undef __std__map_DetId_std__pair_unsignedslong_unsignedslong_s_
#endif
class __std__map_DetId_std__pair_unsignedslong_unsignedslong_s_ {
  public:
  __std__map_DetId_std__pair_unsignedslong_unsignedslong_s_();
  ::std::_Rb_tree<DetId,std::pair<const DetId,std::pair<unsigned long,unsigned long> >,std::_Select1st<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >,std::less<DetId>,std::allocator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > > > _M_t;
};
#ifdef __std__map_DetId_std__pair_unsignedsint_unsignedsint_s_
#undef __std__map_DetId_std__pair_unsignedsint_unsignedsint_s_
#endif
class __std__map_DetId_std__pair_unsignedsint_unsignedsint_s_ {
  public:
  __std__map_DetId_std__pair_unsignedsint_unsignedsint_s_();
  ::std::_Rb_tree<DetId,std::pair<const DetId,std::pair<unsigned int,unsigned int> >,std::_Select1st<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >,std::less<DetId>,std::allocator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > > > _M_t;
};
#ifdef __edm__Wrapper_edm__EDCollection_DetId_s_
#undef __edm__Wrapper_edm__EDCollection_DetId_s_
#endif
class __edm__Wrapper_edm__EDCollection_DetId_s_ {
  public:
  __edm__Wrapper_edm__EDCollection_DetId_s_();
  bool present;
  ::edm::EDCollection<DetId> obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class DetId -------------------------------
static void destructor_4207(void*, void * o, const std::vector<void*>&, void *) {
(((::DetId*)o)->::DetId::~DetId)();
}
static  void operator_4208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::DetId*)o)->operator=)(*(const ::DetId*)arg[0]);
  else   (((::DetId*)o)->operator=)(*(const ::DetId*)arg[0]);
}

static void constructor_4209( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DetId(*(const ::DetId*)arg[0]);
  else ::new(mem) ::DetId(*(const ::DetId*)arg[0]);
}

static void constructor_4210( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DetId();
  else ::new(mem) ::DetId();
}

static void constructor_4211( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DetId(*(::uint32_t*)arg[0]);
  else ::new(mem) ::DetId(*(::uint32_t*)arg[0]);
}

static void constructor_4212( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DetId(*(::DetId::Detector*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::DetId(*(::DetId::Detector*)arg[0],
      *(int*)arg[1]);
}

static  void method_4213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::DetId*)o)->det)());
  else   (((const ::DetId*)o)->det)();
}

static  void method_4214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::DetId*)o)->subdetId)());
  else   (((const ::DetId*)o)->subdetId)();
}

static  void operator_4215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::DetId*)o)->operator())());
  else   (((const ::DetId*)o)->operator())();
}

static  void converter_4216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::DetId*)o)->operator uint32_t)());
  else   (((const ::DetId*)o)->operator uint32_t)();
}

static  void method_4217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::DetId*)o)->rawId)());
  else   (((const ::DetId*)o)->rawId)();
}

static  void method_4218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::DetId*)o)->null)());
  else   (((const ::DetId*)o)->null)();
}

static  void operator_4219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::DetId*)o)->operator==)(*(::DetId*)arg[0]));
  else   (((const ::DetId*)o)->operator==)(*(::DetId*)arg[0]);
}

static  void operator_4220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::DetId*)o)->operator!=)(*(::DetId*)arg[0]));
  else   (((const ::DetId*)o)->operator!=)(*(::DetId*)arg[0]);
}

static  void operator_4221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::DetId*)o)->operator<)(*(::DetId*)arg[0]));
  else   (((const ::DetId*)o)->operator<)(*(::DetId*)arg[0]);
}

static void method_newdel_906( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::DetId >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::DetId >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::DetId >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::DetId >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::DetId >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DetId -------------------------------
void __DetId_db_datamem(Reflex::Class*);
void __DetId_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __DetId_datamem_bld(&__DetId_db_datamem);
Reflex::GenreflexMemberBuilder __DetId_funcmem_bld(&__DetId_db_funcmem);
void __DetId_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("DetId"), typeid(::DetId), sizeof(::DetId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddEnum(Reflex::Literal("DetId::Detector"), Reflex::Literal("Tracker=1;Muon=2;Ecal=3;Hcal=4;Calo=5;Totem=7"), &typeid(DetId::Detector), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetId"), destructor_4207, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8378, type_8380), Reflex::Literal("operator="), operator_4208, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8380), Reflex::Literal("DetId"), constructor_4209, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetId"), constructor_4210, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1327), Reflex::Literal("DetId"), constructor_4211, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4206, type_68), Reflex::Literal("DetId"), constructor_4212, 0, "det;subdet", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_906, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__DetId_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__DetId_funcmem_bld);
}

//------Delayed data member builder for class DetId -------------------
void __DetId_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1327, Reflex::Literal("id_"), OffsetOf(__shadow__::__DetId, id_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class DetId -------------------
void __DetId_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4206), Reflex::Literal("det"), method_4213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("subdetId"), method_4214, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1327), Reflex::Literal("operator()"), operator_4215, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1327), Reflex::Literal("operator uint32_t"), converter_4216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1327), Reflex::Literal("rawId"), method_4217, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1363), Reflex::Literal("null"), method_4218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1363, type_906), Reflex::Literal("operator=="), operator_4219, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1363, type_906), Reflex::Literal("operator!="), operator_4220, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1363, type_906), Reflex::Literal("operator<"), operator_4221, 0, "id", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class EDCollection<DetId> -------------------------------
static void constructor_4182( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::EDCollection<DetId>();
  else ::new(mem) ::edm::EDCollection<DetId>();
}

static void constructor_4183( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::EDCollection<DetId>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::edm::EDCollection<DetId>(*(::std::size_t*)arg[0]);
}

static void constructor_4184( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::EDCollection<DetId>(*(const ::std::vector<DetId>*)arg[0]);
  else ::new(mem) ::edm::EDCollection<DetId>(*(const ::std::vector<DetId>*)arg[0]);
}

static void constructor_4185( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::EDCollection<DetId>(*(const ::edm::EDCollection<DetId>*)arg[0]);
  else ::new(mem) ::edm::EDCollection<DetId>(*(const ::edm::EDCollection<DetId>*)arg[0]);
}

static void destructor_4186(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::EDCollection<DetId>*)o)->::edm::EDCollection<DetId>::~EDCollection)();
}
static  void method_4187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::EDCollection<DetId>*)o)->push_back)(*(const ::DetId*)arg[0]);
}

static  void method_4188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::EDCollection<DetId>*)o)->swap)(*(::edm::EDCollection<DetId>*)arg[0]);
}

static  void operator_4189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::EDCollection<DetId>*)o)->operator=)(*(const ::edm::EDCollection<DetId>*)arg[0]);
  else   (((::edm::EDCollection<DetId>*)o)->operator=)(*(const ::edm::EDCollection<DetId>*)arg[0]);
}

static  void method_4190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::EDCollection<DetId>*)o)->empty)());
  else   (((const ::edm::EDCollection<DetId>*)o)->empty)();
}

static  void method_4191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::EDCollection<DetId>*)o)->size)());
  else   (((const ::edm::EDCollection<DetId>*)o)->size)();
}

static  void method_4192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::EDCollection<DetId>*)o)->capacity)());
  else   (((const ::edm::EDCollection<DetId>*)o)->capacity)();
}

static  void method_4193( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::EDCollection<DetId>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::EDCollection<DetId>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::edm::EDCollection<DetId>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::EDCollection<DetId>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::edm::EDCollection<DetId>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::EDCollection<DetId>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::edm::EDCollection<DetId>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::EDCollection<DetId>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::edm::EDCollection<DetId>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const DetId*,std::vector<DetId> >)((((const ::edm::EDCollection<DetId>*)o)->begin)());
  else   (((const ::edm::EDCollection<DetId>*)o)->begin)();
}

static  void method_4199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const DetId*,std::vector<DetId> >)((((const ::edm::EDCollection<DetId>*)o)->end)());
  else   (((const ::edm::EDCollection<DetId>*)o)->end)();
}

static void method_newdel_807( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::EDCollection<DetId> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::EDCollection<DetId> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::EDCollection<DetId> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::EDCollection<DetId> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::EDCollection<DetId> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class EDCollection<DetId> -------------------------------
void __edm__EDCollection_DetId__db_datamem(Reflex::Class*);
void __edm__EDCollection_DetId__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__EDCollection_DetId__datamem_bld(&__edm__EDCollection_DetId__db_datamem);
Reflex::GenreflexMemberBuilder __edm__EDCollection_DetId__funcmem_bld(&__edm__EDCollection_DetId__db_funcmem);
void __edm__EDCollection_DetId__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::EDCollection<DetId>"), typeid(::edm::EDCollection<DetId>), sizeof(::edm::EDCollection<DetId>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddTypedef(type_906, Reflex::Literal("edm::EDCollection<DetId>::value_type"))
  .AddTypedef(type_4179, Reflex::Literal("edm::EDCollection<DetId>::const_iterator"))
  .AddTypedef(type_2668, Reflex::Literal("edm::EDCollection<DetId>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("EDCollection"), constructor_4182, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2668), Reflex::Literal("EDCollection"), constructor_4183, 0, "n", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13062), Reflex::Literal("EDCollection"), constructor_4184, 0, "vec", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13063), Reflex::Literal("EDCollection"), constructor_4185, 0, "h", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~EDCollection"), destructor_4186, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_807, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__EDCollection_DetId__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__EDCollection_DetId__funcmem_bld);
}

//------Delayed data member builder for class EDCollection<DetId> -------------------
void __edm__EDCollection_DetId__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2531, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__EDCollection_DetId_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class EDCollection<DetId> -------------------
void __edm__EDCollection_DetId__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_8380), Reflex::Literal("push_back"), method_4187, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_13064), Reflex::Literal("swap"), method_4188, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13064, type_13063), Reflex::Literal("operator="), operator_4189, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1363), Reflex::Literal("empty"), method_4190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("size"), method_4191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("capacity"), method_4192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2668), Reflex::Literal("reserve"), method_4193, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8378, type_2668), Reflex::Literal("operator[]"), operator_4194, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8380, type_2668), Reflex::Literal("operator[]"), operator_4195, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8378, type_2668), Reflex::Literal("at"), method_4196, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8380, type_2668), Reflex::Literal("at"), method_4197, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4179), Reflex::Literal("begin"), method_4198, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4179), Reflex::Literal("end"), method_4199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class pair<DetId,float> -------------------------------
static void destructor_8106(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<DetId,float>*)o)->::std::pair<DetId,float>::~pair)();
}
static  void operator_8107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<DetId,float>*)o)->operator=)(*(const ::std::pair<DetId,float>*)arg[0]);
  else   (((::std::pair<DetId,float>*)o)->operator=)(*(const ::std::pair<DetId,float>*)arg[0]);
}

static void constructor_8108( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<DetId,float>(*(const ::std::pair<DetId,float>*)arg[0]);
  else ::new(mem) ::std::pair<DetId,float>(*(const ::std::pair<DetId,float>*)arg[0]);
}

static void constructor_8109( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<DetId,float>();
  else ::new(mem) ::std::pair<DetId,float>();
}

static void constructor_8110( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<DetId,float>(*(const ::DetId*)arg[0],
      *(const float*)arg[1]);
  else ::new(mem) ::std::pair<DetId,float>(*(const ::DetId*)arg[0],
      *(const float*)arg[1]);
}

static void method_newdel_2506( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<DetId,float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<DetId,float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<DetId,float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<DetId,float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<DetId,float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<DetId,float> -------------------------------
void __std__pair_DetId_float__db_datamem(Reflex::Class*);
void __std__pair_DetId_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_DetId_float__datamem_bld(&__std__pair_DetId_float__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_DetId_float__funcmem_bld(&__std__pair_DetId_float__db_funcmem);
void __std__pair_DetId_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<DetId,float>"), typeid(::std::pair<DetId,float>), sizeof(::std::pair<DetId,float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_906, Reflex::Literal("std::pair<DetId,float>::first_type"))
  .AddTypedef(type_750, Reflex::Literal("std::pair<DetId,float>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_8106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8188, type_8190), Reflex::Literal("operator="), operator_8107, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8190), Reflex::Literal("pair"), constructor_8108, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_8109, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8380, type_16689), Reflex::Literal("pair"), constructor_8110, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2506, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_DetId_float__datamem_bld);
}

//------Delayed data member builder for class pair<DetId,float> -------------------
void __std__pair_DetId_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_906, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_DetId_float_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_750, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_DetId_float_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<DetId,float> -------------------
void __std__pair_DetId_float__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<std::pair<DetId, float>,std::allocator<std::pair<DetId, float> > > -------------------------------
static void constructor_8199( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<DetId,float> >();
  else ::new(mem) ::std::vector<std::pair<DetId,float> >();
}

static void constructor_8200( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<DetId,float> >(*(const ::std::allocator<std::pair<DetId,float> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<DetId,float> >(*(const ::std::allocator<std::pair<DetId,float> >*)arg[0]);
}

static void constructor_8201( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<DetId,float> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<DetId,float> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<DetId,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<DetId,float>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<DetId,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<DetId,float>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<DetId,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<DetId,float>*)arg[1],
      *(const ::std::allocator<std::pair<DetId,float> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<DetId,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<DetId,float>*)arg[1],
      *(const ::std::allocator<std::pair<DetId,float> >*)arg[2]);
  }
}

static void constructor_8202( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<DetId,float> >(*(const ::std::vector<std::pair<DetId,float> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<DetId,float> >(*(const ::std::vector<std::pair<DetId,float> >*)arg[0]);
}

static void destructor_8203(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<DetId,float> >*)o)->::std::vector<std::pair<DetId,float> >::~vector)();
}
static  void operator_8204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<DetId,float> >*)o)->operator=)(*(const ::std::vector<std::pair<DetId,float> >*)arg[0]);
  else   (((::std::vector<std::pair<DetId,float> >*)o)->operator=)(*(const ::std::vector<std::pair<DetId,float> >*)arg[0]);
}

static  void method_8205( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<DetId,float> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<DetId,float>*)arg[1]);
}

static  void method_8206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >)((((::std::vector<std::pair<DetId,float> >*)o)->begin)());
  else   (((::std::vector<std::pair<DetId,float> >*)o)->begin)();
}

static  void method_8207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >)((((const ::std::vector<std::pair<DetId,float> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<DetId,float> >*)o)->begin)();
}

static  void method_8208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >)((((::std::vector<std::pair<DetId,float> >*)o)->end)());
  else   (((::std::vector<std::pair<DetId,float> >*)o)->end)();
}

static  void method_8209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >)((((const ::std::vector<std::pair<DetId,float> >*)o)->end)());
  else   (((const ::std::vector<std::pair<DetId,float> >*)o)->end)();
}

static  void method_8214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<DetId,float> >*)o)->size)());
  else   (((const ::std::vector<std::pair<DetId,float> >*)o)->size)();
}

static  void method_8215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<DetId,float> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<DetId,float> >*)o)->max_size)();
}

static  void method_8216( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<DetId,float> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<DetId,float> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<DetId,float>*)arg[1]);
  }
}

static  void method_8217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<DetId,float> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<DetId,float> >*)o)->capacity)();
}

static  void method_8218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<DetId,float> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<DetId,float> >*)o)->empty)();
}

static  void method_8219( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<DetId,float> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<DetId,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<DetId,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<DetId,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<DetId,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8223( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<DetId,float> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<DetId,float> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8224( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<DetId,float> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<DetId,float> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<DetId,float> >*)o)->front)();
  else   (((::std::vector<std::pair<DetId,float> >*)o)->front)();
}

static  void method_8226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<DetId,float> >*)o)->front)();
  else   (((const ::std::vector<std::pair<DetId,float> >*)o)->front)();
}

static  void method_8227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<DetId,float> >*)o)->back)();
  else   (((::std::vector<std::pair<DetId,float> >*)o)->back)();
}

static  void method_8228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<DetId,float> >*)o)->back)();
  else   (((const ::std::vector<std::pair<DetId,float> >*)o)->back)();
}

static  void method_8229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<DetId,float> >*)o)->data)());
  else   (((::std::vector<std::pair<DetId,float> >*)o)->data)();
}

static  void method_8230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<DetId,float> >*)o)->data)());
  else   (((const ::std::vector<std::pair<DetId,float> >*)o)->data)();
}

static  void method_8231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<DetId,float> >*)o)->push_back)(*(const ::std::pair<DetId,float>*)arg[0]);
}

static  void method_8232( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<DetId,float> >*)o)->pop_back)();
}

static  void method_8233( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >)((((::std::vector<std::pair<DetId,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >*)arg[0],
    *(const ::std::pair<DetId,float>*)arg[1]));
  else   (((::std::vector<std::pair<DetId,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >*)arg[0],
    *(const ::std::pair<DetId,float>*)arg[1]);
}

static  void method_8234( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<DetId,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<DetId,float>*)arg[2]);
}

static  void method_8235( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >)((((::std::vector<std::pair<DetId,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >*)arg[0]));
  else   (((::std::vector<std::pair<DetId,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >*)arg[0]);
}

static  void method_8236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >)((((::std::vector<std::pair<DetId,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >*)arg[1]));
  else   (((::std::vector<std::pair<DetId,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<DetId,float>*,std::vector<std::pair<DetId,float> > >*)arg[1]);
}

static  void method_8237( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<DetId,float> >*)o)->swap)(*(::std::vector<std::pair<DetId,float> >*)arg[0]);
}

static  void method_8238( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<DetId,float> >*)o)->clear)();
}

static void method_newdel_2528( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<DetId,float> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<DetId,float> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<DetId,float> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<DetId,float> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<DetId,float> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<DetId,float>,std::allocator<std::pair<DetId,float> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<DetId,float> >,::std::_Vector_base<std::pair<DetId,float>,std::allocator<std::pair<DetId,float> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<DetId,float> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<DetId,float> > >::Generate();
}

//------Dictionary for class vector<std::pair<DetId, float>,std::allocator<std::pair<DetId, float> > > -------------------------------
void __std__vector_std__pair_DetId_float_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_DetId_float_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_DetId_float_s__datamem_bld(&__std__vector_std__pair_DetId_float_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_DetId_float_s__funcmem_bld(&__std__vector_std__pair_DetId_float_s__db_funcmem);
void __std__vector_std__pair_DetId_float_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<DetId,float> >"), typeid(::std::vector<std::pair<DetId,float> >), sizeof(::std::vector<std::pair<DetId,float> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2150, ::Reflex::BaseOffset< ::std::vector<std::pair<DetId,float> >, ::std::_Vector_base<std::pair<DetId,float>,std::allocator<std::pair<DetId,float> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2506, Reflex::Literal("std::vector<std::pair<DetId,float> >::_Alloc_value_type"))
  .AddTypedef(type_2150, Reflex::Literal("std::vector<std::pair<DetId,float> >::_Base"))
  .AddTypedef(type_2687, Reflex::Literal("std::vector<std::pair<DetId,float> >::_Tp_alloc_type"))
  .AddTypedef(type_5023, Reflex::Literal("std::vector<std::pair<DetId,float> >::_Alloc_traits"))
  .AddTypedef(type_2506, Reflex::Literal("std::vector<std::pair<DetId,float> >::value_type"))
  .AddTypedef(type_5912, Reflex::Literal("std::vector<std::pair<DetId,float> >::pointer"))
  .AddTypedef(type_8186, Reflex::Literal("std::vector<std::pair<DetId,float> >::const_pointer"))
  .AddTypedef(type_8188, Reflex::Literal("std::vector<std::pair<DetId,float> >::reference"))
  .AddTypedef(type_8190, Reflex::Literal("std::vector<std::pair<DetId,float> >::const_reference"))
  .AddTypedef(type_4956, Reflex::Literal("std::vector<std::pair<DetId,float> >::iterator"))
  .AddTypedef(type_4957, Reflex::Literal("std::vector<std::pair<DetId,float> >::const_iterator"))
  .AddTypedef(type_2774, Reflex::Literal("std::vector<std::pair<DetId,float> >::const_reverse_iterator"))
  .AddTypedef(type_2775, Reflex::Literal("std::vector<std::pair<DetId,float> >::reverse_iterator"))
  .AddTypedef(type_2668, Reflex::Literal("std::vector<std::pair<DetId,float> >::size_type"))
  .AddTypedef(type_2606, Reflex::Literal("std::vector<std::pair<DetId,float> >::difference_type"))
  .AddTypedef(type_2687, Reflex::Literal("std::vector<std::pair<DetId,float> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8199, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16056), Reflex::Literal("vector"), constructor_8200, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2668, type_8190, type_16056), Reflex::Literal("vector"), constructor_8201, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16698), Reflex::Literal("vector"), constructor_8202, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8203, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2528, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_DetId_float_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<DetId, float>,std::allocator<std::pair<DetId, float> > > -------------------
void __std__vector_std__pair_DetId_float_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<DetId, float>,std::allocator<std::pair<DetId, float> > > -------------------
void __std__vector_std__pair_DetId_float_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16699, type_16698), Reflex::Literal("operator="), operator_8204, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2668, type_8190), Reflex::Literal("assign"), method_8205, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4956), Reflex::Literal("begin"), method_8206, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4957), Reflex::Literal("begin"), method_8207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4956), Reflex::Literal("end"), method_8208, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4957), Reflex::Literal("end"), method_8209, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("size"), method_8214, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("max_size"), method_8215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2668, type_2506), Reflex::Literal("resize"), method_8216, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("capacity"), method_8217, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1363), Reflex::Literal("empty"), method_8218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2668), Reflex::Literal("reserve"), method_8219, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8188, type_2668), Reflex::Literal("operator[]"), operator_8220, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190, type_2668), Reflex::Literal("operator[]"), operator_8221, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8188, type_2668), Reflex::Literal("at"), method_8223, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190, type_2668), Reflex::Literal("at"), method_8224, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8188), Reflex::Literal("front"), method_8225, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190), Reflex::Literal("front"), method_8226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8188), Reflex::Literal("back"), method_8227, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190), Reflex::Literal("back"), method_8228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5912), Reflex::Literal("data"), method_8229, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8186), Reflex::Literal("data"), method_8230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_8190), Reflex::Literal("push_back"), method_8231, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("pop_back"), method_8232, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4956, type_4956, type_8190), Reflex::Literal("insert"), method_8233, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_4956, type_2668, type_8190), Reflex::Literal("insert"), method_8234, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4956, type_4956), Reflex::Literal("erase"), method_8235, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4956, type_4956, type_4956), Reflex::Literal("erase"), method_8236, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_16699), Reflex::Literal("swap"), method_8237, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_8238, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<DetId,std::allocator<DetId> > -------------------------------
static void constructor_8389( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<DetId>();
  else ::new(mem) ::std::vector<DetId>();
}

static void constructor_8390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<DetId>(*(const ::std::allocator<DetId>*)arg[0]);
  else ::new(mem) ::std::vector<DetId>(*(const ::std::allocator<DetId>*)arg[0]);
}

static void constructor_8391( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<DetId>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<DetId>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<DetId>(*(::std::size_t*)arg[0],
      *(const ::DetId*)arg[1]);
  else ::new(mem) ::std::vector<DetId>(*(::std::size_t*)arg[0],
      *(const ::DetId*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<DetId>(*(::std::size_t*)arg[0],
      *(const ::DetId*)arg[1],
      *(const ::std::allocator<DetId>*)arg[2]);
  else ::new(mem) ::std::vector<DetId>(*(::std::size_t*)arg[0],
      *(const ::DetId*)arg[1],
      *(const ::std::allocator<DetId>*)arg[2]);
  }
}

static void constructor_8392( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<DetId>(*(const ::std::vector<DetId>*)arg[0]);
  else ::new(mem) ::std::vector<DetId>(*(const ::std::vector<DetId>*)arg[0]);
}

static void destructor_8393(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<DetId>*)o)->::std::vector<DetId>::~vector)();
}
static  void operator_8394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<DetId>*)o)->operator=)(*(const ::std::vector<DetId>*)arg[0]);
  else   (((::std::vector<DetId>*)o)->operator=)(*(const ::std::vector<DetId>*)arg[0]);
}

static  void method_8395( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<DetId>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::DetId*)arg[1]);
}

static  void method_8396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >)((((::std::vector<DetId>*)o)->begin)());
  else   (((::std::vector<DetId>*)o)->begin)();
}

static  void method_8397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const DetId*,std::vector<DetId> >)((((const ::std::vector<DetId>*)o)->begin)());
  else   (((const ::std::vector<DetId>*)o)->begin)();
}

static  void method_8398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >)((((::std::vector<DetId>*)o)->end)());
  else   (((::std::vector<DetId>*)o)->end)();
}

static  void method_8399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const DetId*,std::vector<DetId> >)((((const ::std::vector<DetId>*)o)->end)());
  else   (((const ::std::vector<DetId>*)o)->end)();
}

static  void method_8404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<DetId>*)o)->size)());
  else   (((const ::std::vector<DetId>*)o)->size)();
}

static  void method_8405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<DetId>*)o)->max_size)());
  else   (((const ::std::vector<DetId>*)o)->max_size)();
}

static  void method_8406( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<DetId>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<DetId>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::DetId*)arg[1]);
  }
}

static  void method_8407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<DetId>*)o)->capacity)());
  else   (((const ::std::vector<DetId>*)o)->capacity)();
}

static  void method_8408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<DetId>*)o)->empty)());
  else   (((const ::std::vector<DetId>*)o)->empty)();
}

static  void method_8409( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<DetId>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8410( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<DetId>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<DetId>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8411( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<DetId>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<DetId>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8413( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<DetId>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<DetId>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<DetId>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<DetId>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<DetId>*)o)->front)();
  else   (((::std::vector<DetId>*)o)->front)();
}

static  void method_8416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<DetId>*)o)->front)();
  else   (((const ::std::vector<DetId>*)o)->front)();
}

static  void method_8417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<DetId>*)o)->back)();
  else   (((::std::vector<DetId>*)o)->back)();
}

static  void method_8418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<DetId>*)o)->back)();
  else   (((const ::std::vector<DetId>*)o)->back)();
}

static  void method_8419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<DetId>*)o)->data)());
  else   (((::std::vector<DetId>*)o)->data)();
}

static  void method_8420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<DetId>*)o)->data)());
  else   (((const ::std::vector<DetId>*)o)->data)();
}

static  void method_8421( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<DetId>*)o)->push_back)(*(const ::DetId*)arg[0]);
}

static  void method_8422( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<DetId>*)o)->pop_back)();
}

static  void method_8423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >)((((::std::vector<DetId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >*)arg[0],
    *(const ::DetId*)arg[1]));
  else   (((::std::vector<DetId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >*)arg[0],
    *(const ::DetId*)arg[1]);
}

static  void method_8424( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<DetId>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::DetId*)arg[2]);
}

static  void method_8425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >)((((::std::vector<DetId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >*)arg[0]));
  else   (((::std::vector<DetId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >*)arg[0]);
}

static  void method_8426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >)((((::std::vector<DetId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >*)arg[1]));
  else   (((::std::vector<DetId>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<DetId*,std::vector<DetId> >*)arg[1]);
}

static  void method_8427( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<DetId>*)o)->swap)(*(::std::vector<DetId>*)arg[0]);
}

static  void method_8428( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<DetId>*)o)->clear)();
}

static void method_newdel_2531( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<DetId> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<DetId> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<DetId> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<DetId> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<DetId> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<DetId,std::allocator<DetId> >")), ::Reflex::BaseOffset< ::std::vector<DetId>,::std::_Vector_base<DetId,std::allocator<DetId> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<DetId> >::Generate();
  else ::Reflex::Proxy< ::std::vector<DetId> >::Generate();
}

//------Dictionary for class vector<DetId,std::allocator<DetId> > -------------------------------
void __std__vector_DetId__db_datamem(Reflex::Class*);
void __std__vector_DetId__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_DetId__datamem_bld(&__std__vector_DetId__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_DetId__funcmem_bld(&__std__vector_DetId__db_funcmem);
void __std__vector_DetId__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<DetId>"), typeid(::std::vector<DetId>), sizeof(::std::vector<DetId>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2151, ::Reflex::BaseOffset< ::std::vector<DetId>, ::std::_Vector_base<DetId,std::allocator<DetId> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_906, Reflex::Literal("std::vector<DetId>::_Alloc_value_type"))
  .AddTypedef(type_2151, Reflex::Literal("std::vector<DetId>::_Base"))
  .AddTypedef(type_2690, Reflex::Literal("std::vector<DetId>::_Tp_alloc_type"))
  .AddTypedef(type_5024, Reflex::Literal("std::vector<DetId>::_Alloc_traits"))
  .AddTypedef(type_906, Reflex::Literal("std::vector<DetId>::value_type"))
  .AddTypedef(type_5931, Reflex::Literal("std::vector<DetId>::pointer"))
  .AddTypedef(type_8376, Reflex::Literal("std::vector<DetId>::const_pointer"))
  .AddTypedef(type_8378, Reflex::Literal("std::vector<DetId>::reference"))
  .AddTypedef(type_8380, Reflex::Literal("std::vector<DetId>::const_reference"))
  .AddTypedef(type_4958, Reflex::Literal("std::vector<DetId>::iterator"))
  .AddTypedef(type_4179, Reflex::Literal("std::vector<DetId>::const_iterator"))
  .AddTypedef(type_2776, Reflex::Literal("std::vector<DetId>::const_reverse_iterator"))
  .AddTypedef(type_2777, Reflex::Literal("std::vector<DetId>::reverse_iterator"))
  .AddTypedef(type_2668, Reflex::Literal("std::vector<DetId>::size_type"))
  .AddTypedef(type_2606, Reflex::Literal("std::vector<DetId>::difference_type"))
  .AddTypedef(type_2690, Reflex::Literal("std::vector<DetId>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8389, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16069), Reflex::Literal("vector"), constructor_8390, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2668, type_8380, type_16069), Reflex::Literal("vector"), constructor_8391, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13062), Reflex::Literal("vector"), constructor_8392, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8393, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2531, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_DetId__funcmem_bld);
}

//------Delayed data member builder for class vector<DetId,std::allocator<DetId> > -------------------
void __std__vector_DetId__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<DetId,std::allocator<DetId> > -------------------
void __std__vector_DetId__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16705, type_13062), Reflex::Literal("operator="), operator_8394, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2668, type_8380), Reflex::Literal("assign"), method_8395, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4958), Reflex::Literal("begin"), method_8396, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4179), Reflex::Literal("begin"), method_8397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4958), Reflex::Literal("end"), method_8398, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4179), Reflex::Literal("end"), method_8399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("size"), method_8404, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("max_size"), method_8405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2668, type_906), Reflex::Literal("resize"), method_8406, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("capacity"), method_8407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1363), Reflex::Literal("empty"), method_8408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2668), Reflex::Literal("reserve"), method_8409, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8378, type_2668), Reflex::Literal("operator[]"), operator_8410, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8380, type_2668), Reflex::Literal("operator[]"), operator_8411, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8378, type_2668), Reflex::Literal("at"), method_8413, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8380, type_2668), Reflex::Literal("at"), method_8414, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8378), Reflex::Literal("front"), method_8415, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8380), Reflex::Literal("front"), method_8416, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8378), Reflex::Literal("back"), method_8417, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8380), Reflex::Literal("back"), method_8418, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5931), Reflex::Literal("data"), method_8419, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8376), Reflex::Literal("data"), method_8420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_8380), Reflex::Literal("push_back"), method_8421, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("pop_back"), method_8422, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4958, type_4958, type_8380), Reflex::Literal("insert"), method_8423, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_4958, type_2668, type_8380), Reflex::Literal("insert"), method_8424, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4958, type_4958), Reflex::Literal("erase"), method_8425, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4958, type_4958, type_4958), Reflex::Literal("erase"), method_8426, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_16705), Reflex::Literal("swap"), method_8427, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_8428, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<DetId,std::pair<long unsigned int, long unsigned int>,std::less<DetId>,std::allocator<std::pair<const DetId, std::pair<long unsigned int, long unsigned int> > > > -------------------------------
static void destructor_9620(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->::std::map<DetId,std::pair<unsigned long,unsigned long> >::~map)();
}
static void constructor_9621( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<DetId,std::pair<unsigned long,unsigned long> >();
  else ::new(mem) ::std::map<DetId,std::pair<unsigned long,unsigned long> >();
}

static void constructor_9622( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<DetId,std::pair<unsigned long,unsigned long> >(*(const ::std::less<DetId>*)arg[0]);
  else ::new(mem) ::std::map<DetId,std::pair<unsigned long,unsigned long> >(*(const ::std::less<DetId>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<DetId,std::pair<unsigned long,unsigned long> >(*(const ::std::less<DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >*)arg[1]);
  else ::new(mem) ::std::map<DetId,std::pair<unsigned long,unsigned long> >(*(const ::std::less<DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >*)arg[1]);
  }
}

static void constructor_9623( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<DetId,std::pair<unsigned long,unsigned long> >(*(const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)arg[0]);
  else ::new(mem) ::std::map<DetId,std::pair<unsigned long,unsigned long> >(*(const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)arg[0]);
}

static  void operator_9624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->operator=)(*(const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)arg[0]);
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->operator=)(*(const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)arg[0]);
}

static  void method_9625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->get_allocator)());
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->get_allocator)();
}

static  void method_9626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->begin)());
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->begin)();
}

static  void method_9627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->begin)());
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->begin)();
}

static  void method_9628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->end)());
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->end)();
}

static  void method_9629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->end)());
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->end)();
}

static  void method_9634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->empty)());
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->empty)();
}

static  void method_9635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->size)());
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->size)();
}

static  void method_9636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->max_size)());
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->max_size)();
}

static  void operator_9637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->operator[])(*(const ::DetId*)arg[0]);
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->operator[])(*(const ::DetId*)arg[0]);
}

static  void method_9638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->at)(*(const ::DetId*)arg[0]);
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->at)(*(const ::DetId*)arg[0]);
}

static  void method_9639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->at)(*(const ::DetId*)arg[0]);
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->at)(*(const ::DetId*)arg[0]);
}

static  void method_9640( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >,bool>)((((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->insert)(*(const ::std::pair<const DetId,std::pair<unsigned long,unsigned long> >*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->insert)(*(const ::std::pair<const DetId,std::pair<unsigned long,unsigned long> >*)arg[0]);
}

static  void method_9641( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >*)arg[0],
    *(const ::std::pair<const DetId,std::pair<unsigned long,unsigned long> >*)arg[1]));
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >*)arg[0],
    *(const ::std::pair<const DetId,std::pair<unsigned long,unsigned long> >*)arg[1]);
}

static  void method_9642( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >*)arg[0]);
}

static  void method_9643( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->erase)(*(const ::DetId*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->erase)(*(const ::DetId*)arg[0]);
}

static  void method_9644( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >*)arg[1]);
}

static  void method_9645( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->swap)(*(::std::map<DetId,std::pair<unsigned long,unsigned long> >*)arg[0]);
}

static  void method_9646( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->clear)();
}

static  void method_9647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<DetId>)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->key_comp)());
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->key_comp)();
}

static  void method_9649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->find)(*(const ::DetId*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->find)(*(const ::DetId*)arg[0]);
}

static  void method_9650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->find)(*(const ::DetId*)arg[0]));
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->find)(*(const ::DetId*)arg[0]);
}

static  void method_9651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->count)(*(const ::DetId*)arg[0]));
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->count)(*(const ::DetId*)arg[0]);
}

static  void method_9652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->lower_bound)(*(const ::DetId*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->lower_bound)(*(const ::DetId*)arg[0]);
}

static  void method_9653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->lower_bound)(*(const ::DetId*)arg[0]));
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->lower_bound)(*(const ::DetId*)arg[0]);
}

static  void method_9654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->upper_bound)(*(const ::DetId*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->upper_bound)(*(const ::DetId*)arg[0]);
}

static  void method_9655( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->upper_bound)(*(const ::DetId*)arg[0]));
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->upper_bound)(*(const ::DetId*)arg[0]);
}

static  void method_9656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >,std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > > >)((((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->equal_range)(*(const ::DetId*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->equal_range)(*(const ::DetId*)arg[0]);
}

static  void method_9657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > >,std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned long,unsigned long> > > >)((((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->equal_range)(*(const ::DetId*)arg[0]));
  else   (((const ::std::map<DetId,std::pair<unsigned long,unsigned long> >*)o)->equal_range)(*(const ::DetId*)arg[0]);
}

static void method_newdel_2626( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<DetId,std::pair<unsigned long,unsigned long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<DetId,std::pair<unsigned long,unsigned long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<DetId,std::pair<unsigned long,unsigned long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<DetId,std::pair<unsigned long,unsigned long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<DetId,std::pair<unsigned long,unsigned long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<DetId,std::pair<unsigned long,unsigned long> > >::Generate();
  else ::Reflex::Proxy< ::std::map<DetId,std::pair<unsigned long,unsigned long> > >::Generate();
}

//------Dictionary for class map<DetId,std::pair<long unsigned int, long unsigned int>,std::less<DetId>,std::allocator<std::pair<const DetId, std::pair<long unsigned int, long unsigned int> > > > -------------------------------
void __std__map_DetId_std__pair_unsignedslong_unsignedslong_s__db_datamem(Reflex::Class*);
void __std__map_DetId_std__pair_unsignedslong_unsignedslong_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_DetId_std__pair_unsignedslong_unsignedslong_s__datamem_bld(&__std__map_DetId_std__pair_unsignedslong_unsignedslong_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_DetId_std__pair_unsignedslong_unsignedslong_s__funcmem_bld(&__std__map_DetId_std__pair_unsignedslong_unsignedslong_s__db_funcmem);
void __std__map_DetId_std__pair_unsignedslong_unsignedslong_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >"), typeid(::std::map<DetId,std::pair<unsigned long,unsigned long> >), sizeof(::std::map<DetId,std::pair<unsigned long,unsigned long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_906, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::key_type"))
  .AddTypedef(type_2500, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::mapped_type"))
  .AddTypedef(type_2496, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::value_type"))
  .AddTypedef(type_2274, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::key_compare"))
  .AddTypedef(type_2684, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::allocator_type"))
  .AddTypedef(type_2496, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::_Alloc_value_type"))
  .AddTypedef(type_2684, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::_Pair_alloc_type"))
  .AddTypedef(type_2320, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::_Rep_type"))
  .AddTypedef(type_7210, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::pointer"))
  .AddTypedef(type_7212, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::const_pointer"))
  .AddTypedef(type_7214, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::reference"))
  .AddTypedef(type_7216, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::const_reference"))
  .AddTypedef(type_2581, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::iterator"))
  .AddTypedef(type_2671, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::const_iterator"))
  .AddTypedef(type_2668, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::size_type"))
  .AddTypedef(type_2606, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::difference_type"))
  .AddTypedef(type_2771, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::reverse_iterator"))
  .AddTypedef(type_2770, Reflex::Literal("std::map<DetId,std::pair<unsigned long,unsigned long> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_9620, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_9621, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16466, type_16543), Reflex::Literal("map"), constructor_9622, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16821), Reflex::Literal("map"), constructor_9623, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2626, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_DetId_std__pair_unsignedslong_unsignedslong_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_DetId_std__pair_unsignedslong_unsignedslong_s__funcmem_bld);
}

//------Delayed data member builder for class map<DetId,std::pair<long unsigned int, long unsigned int>,std::less<DetId>,std::allocator<std::pair<const DetId, std::pair<long unsigned int, long unsigned int> > > > -------------------
void __std__map_DetId_std__pair_unsignedslong_unsignedslong_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2320, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_DetId_std__pair_unsignedslong_unsignedslong_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<DetId,std::pair<long unsigned int, long unsigned int>,std::less<DetId>,std::allocator<std::pair<const DetId, std::pair<long unsigned int, long unsigned int> > > > -------------------
void __std__map_DetId_std__pair_unsignedslong_unsignedslong_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16822, type_16821), Reflex::Literal("operator="), operator_9624, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2684), Reflex::Literal("get_allocator"), method_9625, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2581), Reflex::Literal("begin"), method_9626, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2671), Reflex::Literal("begin"), method_9627, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2581), Reflex::Literal("end"), method_9628, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2671), Reflex::Literal("end"), method_9629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1363), Reflex::Literal("empty"), method_9634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("size"), method_9635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("max_size"), method_9636, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16823, type_8380), Reflex::Literal("operator[]"), operator_9637, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16823, type_8380), Reflex::Literal("at"), method_9638, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16824, type_8380), Reflex::Literal("at"), method_9639, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2498, type_7216), Reflex::Literal("insert"), method_9640, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2581, type_2581, type_7216), Reflex::Literal("insert"), method_9641, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2581), Reflex::Literal("erase"), method_9642, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668, type_8380), Reflex::Literal("erase"), method_9643, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2581, type_2581), Reflex::Literal("erase"), method_9644, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_16822), Reflex::Literal("swap"), method_9645, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_9646, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2274), Reflex::Literal("key_comp"), method_9647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2581, type_8380), Reflex::Literal("find"), method_9649, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2671, type_8380), Reflex::Literal("find"), method_9650, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668, type_8380), Reflex::Literal("count"), method_9651, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2581, type_8380), Reflex::Literal("lower_bound"), method_9652, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2671, type_8380), Reflex::Literal("lower_bound"), method_9653, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2581, type_8380), Reflex::Literal("upper_bound"), method_9654, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2671, type_8380), Reflex::Literal("upper_bound"), method_9655, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2497, type_8380), Reflex::Literal("equal_range"), method_9656, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2495, type_8380), Reflex::Literal("equal_range"), method_9657, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<DetId,std::pair<unsigned int, unsigned int>,std::less<DetId>,std::allocator<std::pair<const DetId, std::pair<unsigned int, unsigned int> > > > -------------------------------
static void destructor_9678(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->::std::map<DetId,std::pair<unsigned int,unsigned int> >::~map)();
}
static void constructor_9679( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<DetId,std::pair<unsigned int,unsigned int> >();
  else ::new(mem) ::std::map<DetId,std::pair<unsigned int,unsigned int> >();
}

static void constructor_9680( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<DetId,std::pair<unsigned int,unsigned int> >(*(const ::std::less<DetId>*)arg[0]);
  else ::new(mem) ::std::map<DetId,std::pair<unsigned int,unsigned int> >(*(const ::std::less<DetId>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<DetId,std::pair<unsigned int,unsigned int> >(*(const ::std::less<DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >*)arg[1]);
  else ::new(mem) ::std::map<DetId,std::pair<unsigned int,unsigned int> >(*(const ::std::less<DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >*)arg[1]);
  }
}

static void constructor_9681( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<DetId,std::pair<unsigned int,unsigned int> >(*(const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::map<DetId,std::pair<unsigned int,unsigned int> >(*(const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void operator_9682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_9683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->get_allocator)());
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->get_allocator)();
}

static  void method_9684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->begin)());
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->begin)();
}

static  void method_9685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->begin)());
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->begin)();
}

static  void method_9686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->end)());
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->end)();
}

static  void method_9687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->end)());
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->end)();
}

static  void method_9692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->empty)());
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->empty)();
}

static  void method_9693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->size)());
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->size)();
}

static  void method_9694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->max_size)());
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->max_size)();
}

static  void operator_9695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(const ::DetId*)arg[0]);
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(const ::DetId*)arg[0]);
}

static  void method_9696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const ::DetId*)arg[0]);
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const ::DetId*)arg[0]);
}

static  void method_9697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const ::DetId*)arg[0]);
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const ::DetId*)arg[0]);
}

static  void method_9698( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >,bool>)((((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(const ::std::pair<const DetId,std::pair<unsigned int,unsigned int> >*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(const ::std::pair<const DetId,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_9699( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(const ::std::pair<const DetId,std::pair<unsigned int,unsigned int> >*)arg[1]));
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(const ::std::pair<const DetId,std::pair<unsigned int,unsigned int> >*)arg[1]);
}

static  void method_9700( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >*)arg[0]);
}

static  void method_9701( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(const ::DetId*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(const ::DetId*)arg[0]);
}

static  void method_9702( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >*)arg[1]);
}

static  void method_9703( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->swap)(*(::std::map<DetId,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_9704( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->clear)();
}

static  void method_9705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<DetId>)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->key_comp)());
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->key_comp)();
}

static  void method_9707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const ::DetId*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const ::DetId*)arg[0]);
}

static  void method_9708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const ::DetId*)arg[0]));
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const ::DetId*)arg[0]);
}

static  void method_9709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->count)(*(const ::DetId*)arg[0]));
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->count)(*(const ::DetId*)arg[0]);
}

static  void method_9710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const ::DetId*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const ::DetId*)arg[0]);
}

static  void method_9711( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const ::DetId*)arg[0]));
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const ::DetId*)arg[0]);
}

static  void method_9712( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const ::DetId*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const ::DetId*)arg[0]);
}

static  void method_9713( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const ::DetId*)arg[0]));
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const ::DetId*)arg[0]);
}

static  void method_9714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > > >)((((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const ::DetId*)arg[0]));
  else   (((::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const ::DetId*)arg[0]);
}

static  void method_9715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const DetId,std::pair<unsigned int,unsigned int> > > >)((((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const ::DetId*)arg[0]));
  else   (((const ::std::map<DetId,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const ::DetId*)arg[0]);
}

static void method_newdel_2627( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<DetId,std::pair<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<DetId,std::pair<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<DetId,std::pair<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<DetId,std::pair<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<DetId,std::pair<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<DetId,std::pair<unsigned int,unsigned int> > >::Generate();
  else ::Reflex::Proxy< ::std::map<DetId,std::pair<unsigned int,unsigned int> > >::Generate();
}

//------Dictionary for class map<DetId,std::pair<unsigned int, unsigned int>,std::less<DetId>,std::allocator<std::pair<const DetId, std::pair<unsigned int, unsigned int> > > > -------------------------------
void __std__map_DetId_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__map_DetId_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_DetId_std__pair_unsignedsint_unsignedsint_s__datamem_bld(&__std__map_DetId_std__pair_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_DetId_std__pair_unsignedsint_unsignedsint_s__funcmem_bld(&__std__map_DetId_std__pair_unsignedsint_unsignedsint_s__db_funcmem);
void __std__map_DetId_std__pair_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >"), typeid(::std::map<DetId,std::pair<unsigned int,unsigned int> >), sizeof(::std::map<DetId,std::pair<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_906, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::key_type"))
  .AddTypedef(type_2505, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::mapped_type"))
  .AddTypedef(type_2502, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::value_type"))
  .AddTypedef(type_2274, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::key_compare"))
  .AddTypedef(type_2686, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::allocator_type"))
  .AddTypedef(type_2502, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::_Alloc_value_type"))
  .AddTypedef(type_2686, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::_Pair_alloc_type"))
  .AddTypedef(type_2321, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::_Rep_type"))
  .AddTypedef(type_7319, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::pointer"))
  .AddTypedef(type_7321, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::const_pointer"))
  .AddTypedef(type_7323, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::reference"))
  .AddTypedef(type_7325, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::const_reference"))
  .AddTypedef(type_2582, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::iterator"))
  .AddTypedef(type_2672, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::const_iterator"))
  .AddTypedef(type_2668, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::size_type"))
  .AddTypedef(type_2606, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::difference_type"))
  .AddTypedef(type_2773, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::reverse_iterator"))
  .AddTypedef(type_2772, Reflex::Literal("std::map<DetId,std::pair<unsigned int,unsigned int> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_9678, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_9679, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16466, type_16550), Reflex::Literal("map"), constructor_9680, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16825), Reflex::Literal("map"), constructor_9681, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2627, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_DetId_std__pair_unsignedsint_unsignedsint_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_DetId_std__pair_unsignedsint_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class map<DetId,std::pair<unsigned int, unsigned int>,std::less<DetId>,std::allocator<std::pair<const DetId, std::pair<unsigned int, unsigned int> > > > -------------------
void __std__map_DetId_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2321, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_DetId_std__pair_unsignedsint_unsignedsint_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<DetId,std::pair<unsigned int, unsigned int>,std::less<DetId>,std::allocator<std::pair<const DetId, std::pair<unsigned int, unsigned int> > > > -------------------
void __std__map_DetId_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16826, type_16825), Reflex::Literal("operator="), operator_9682, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2686), Reflex::Literal("get_allocator"), method_9683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2582), Reflex::Literal("begin"), method_9684, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2672), Reflex::Literal("begin"), method_9685, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2582), Reflex::Literal("end"), method_9686, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2672), Reflex::Literal("end"), method_9687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1363), Reflex::Literal("empty"), method_9692, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("size"), method_9693, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668), Reflex::Literal("max_size"), method_9694, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16827, type_8380), Reflex::Literal("operator[]"), operator_9695, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16827, type_8380), Reflex::Literal("at"), method_9696, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16828, type_8380), Reflex::Literal("at"), method_9697, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504, type_7325), Reflex::Literal("insert"), method_9698, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2582, type_2582, type_7325), Reflex::Literal("insert"), method_9699, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2582), Reflex::Literal("erase"), method_9700, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668, type_8380), Reflex::Literal("erase"), method_9701, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2582, type_2582), Reflex::Literal("erase"), method_9702, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_16826), Reflex::Literal("swap"), method_9703, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_9704, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2274), Reflex::Literal("key_comp"), method_9705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2582, type_8380), Reflex::Literal("find"), method_9707, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2672, type_8380), Reflex::Literal("find"), method_9708, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2668, type_8380), Reflex::Literal("count"), method_9709, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2582, type_8380), Reflex::Literal("lower_bound"), method_9710, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2672, type_8380), Reflex::Literal("lower_bound"), method_9711, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2582, type_8380), Reflex::Literal("upper_bound"), method_9712, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2672, type_8380), Reflex::Literal("upper_bound"), method_9713, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2503, type_8380), Reflex::Literal("equal_range"), method_9714, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2501, type_8380), Reflex::Literal("equal_range"), method_9715, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::EDCollection<DetId> > -------------------------------
static void constructor_12492( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::EDCollection<DetId> >();
  else ::new(mem) ::edm::Wrapper<edm::EDCollection<DetId> >();
}

static void constructor_12493( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::EDCollection<DetId> >(*(::std::auto_ptr<edm::EDCollection<DetId> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::EDCollection<DetId> >(*(::std::auto_ptr<edm::EDCollection<DetId> >*)arg[0]);
}

static void destructor_12494(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::EDCollection<DetId> >*)o)->::edm::Wrapper<edm::EDCollection<DetId> >::~Wrapper)();
}
static  void method_12495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->product)();
}

static  void operator_12496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->operator->)();
}

static  void method_12497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::EDCollection<DetId> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::EDCollection<DetId> >*)o)->productTypeInfo)();
}

static  void method_12498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::EDCollection<DetId> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::EDCollection<DetId> >*)o)->typeInfo)();
}

static void constructor_12499( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::EDCollection<DetId> >((::edm::EDCollection<DetId>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::EDCollection<DetId> >((::edm::EDCollection<DetId>*)arg[0]);
}

static  void method_12500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::EDCollection<DetId> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::EDCollection<DetId> >*)o)->getInterface)();
}

static  void method_12501( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->dynamicTypeInfo)();
}

static  void method_12505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->isPresent)();
}

static  void method_12506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::EDCollection<DetId> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3349( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::EDCollection<DetId> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::EDCollection<DetId> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::EDCollection<DetId> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::EDCollection<DetId> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::EDCollection<DetId> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::EDCollection<DetId> > -------------------------------
void __edm__Wrapper_edm__EDCollection_DetId_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__EDCollection_DetId_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__EDCollection_DetId_s__datamem_bld(&__edm__Wrapper_edm__EDCollection_DetId_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__EDCollection_DetId_s__funcmem_bld(&__edm__Wrapper_edm__EDCollection_DetId_s__db_funcmem);
void __edm__Wrapper_edm__EDCollection_DetId_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::EDCollection<DetId> >"), typeid(::edm::Wrapper<edm::EDCollection<DetId> >), sizeof(::edm::Wrapper<edm::EDCollection<DetId> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_807, Reflex::Literal("edm::Wrapper<edm::EDCollection<DetId> >::value_type"))
  .AddTypedef(type_807, Reflex::Literal("edm::Wrapper<edm::EDCollection<DetId> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12492, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2362), Reflex::Literal("Wrapper"), constructor_12493, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12494, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18557), Reflex::Literal("Wrapper"), constructor_12499, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3349, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__EDCollection_DetId_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__EDCollection_DetId_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::EDCollection<DetId> > -------------------
void __edm__Wrapper_edm__EDCollection_DetId_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1363, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__EDCollection_DetId_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_807, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__EDCollection_DetId_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::EDCollection<DetId> > -------------------
void __edm__Wrapper_edm__EDCollection_DetId_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18556), Reflex::Literal("product"), method_12495, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18556), Reflex::Literal("operator->"), operator_12496, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11319), Reflex::Literal("productTypeInfo"), method_12497, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11319), Reflex::Literal("typeInfo"), method_12498, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18558), Reflex::Literal("getInterface"), method_12500, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12539, type_16701, type_18482), Reflex::Literal("fillView"), method_12501, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_11319, type_269, type_6651), Reflex::Literal("setPtr"), method_12502, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_11319, type_16702, type_16701), Reflex::Literal("fillPtrVector"), method_12503, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11319), Reflex::Literal("dynamicTypeInfo"), method_12504, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1363), Reflex::Literal("isPresent"), method_12505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11319), Reflex::Literal("dynamicTypeInfo_"), method_12506, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __DetId_dict(); 
      __edm__EDCollection_DetId__dict(); 
      __std__pair_DetId_float__dict(); 
      __std__vector_std__pair_DetId_float_s__dict(); 
      __std__vector_DetId__dict(); 
      __std__map_DetId_std__pair_unsignedslong_unsignedslong_s__dict(); 
      __std__map_DetId_std__pair_unsignedsint_unsignedsint_s__dict(); 
      __edm__Wrapper_edm__EDCollection_DetId_s__dict(); 
    }
    ~Dictionaries() {
      type_906.Unload(); // class DetId 
      type_807.Unload(); // class edm::EDCollection<DetId> 
      type_2506.Unload(); // class std::pair<DetId,float> 
      type_2528.Unload(); // class std::vector<std::pair<DetId,float> > 
      type_2531.Unload(); // class std::vector<DetId> 
      type_2626.Unload(); // class std::map<DetId,std::pair<unsigned long,unsigned long> > 
      type_2627.Unload(); // class std::map<DetId,std::pair<unsigned int,unsigned int> > 
      type_3349.Unload(); // class edm::Wrapper<edm::EDCollection<DetId> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
