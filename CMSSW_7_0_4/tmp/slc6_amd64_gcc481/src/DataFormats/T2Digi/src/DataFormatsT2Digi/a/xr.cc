// Generated at Mon Jul 11 23:12:38 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/T2Digi/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_68 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_62 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_580 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1372 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_774 = ::Reflex::TypeBuilder(Reflex::Literal("T2DetId"));
  ::Reflex::Type type_1591 = ::Reflex::TypeBuilder(Reflex::Literal("T2PadDigi"));
  ::Reflex::Type type_801 = ::Reflex::TypeBuilder(Reflex::Literal("T2StripDigi"));
  ::Reflex::Type type_274 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_395 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3477 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2279 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<T2DetId>"));
  ::Reflex::Type type_2536 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T2PadDigi>"));
  ::Reflex::Type type_2537 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T2StripDigi>"));
  ::Reflex::Type type_2534 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2696 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<T2PadDigi>"));
  ::Reflex::Type type_2535 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_2697 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<T2StripDigi>"));
  ::Reflex::Type type_804 = ::Reflex::TypeBuilder(Reflex::Literal("TotemDigiCollection<T2DetId,T2PadDigi>"));
  ::Reflex::Type type_423 = ::Reflex::TypeBuilder(Reflex::Literal("DigiContainerIterator<T2DetId,T2PadDigi>"));
  ::Reflex::Type type_1189 = ::Reflex::TypeBuilder(Reflex::Literal("TotemDigiCollection<T2DetId,T2StripDigi>"));
  ::Reflex::Type type_2637 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >"));
  ::Reflex::Type type_424 = ::Reflex::TypeBuilder(Reflex::Literal("DigiContainerIterator<T2DetId,T2StripDigi>"));
  ::Reflex::Type type_2500 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<T2DetId,std::vector<T2PadDigi> >"));
  ::Reflex::Type type_2638 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >"));
  ::Reflex::Type type_2501 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<T2DetId,std::vector<T2StripDigi> >"));
  ::Reflex::Type type_2503 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const T2DetId,std::vector<T2PadDigi> >"));
  ::Reflex::Type type_2509 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const T2DetId,std::vector<T2StripDigi> >"));
  ::Reflex::Type type_5124 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<T2PadDigi> >"));
  ::Reflex::Type type_3375 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >"));
  ::Reflex::Type type_3297 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_2367 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TotemDigiCollection<T2DetId,T2PadDigi> >"));
  ::Reflex::Type type_2157 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2PadDigi,std::allocator<T2PadDigi> >"));
  ::Reflex::Type type_5125 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<T2StripDigi> >"));
  ::Reflex::Type type_3377 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >"));
  ::Reflex::Type type_2369 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TotemDigiCollection<T2DetId,T2StripDigi> >"));
  ::Reflex::Type type_3374 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >"));
  ::Reflex::Type type_2366 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::pair<T2DetId,std::vector<T2PadDigi> > >"));
  ::Reflex::Type type_2158 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2StripDigi,std::allocator<T2StripDigi> >"));
  ::Reflex::Type type_3376 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >"));
  ::Reflex::Type type_2368 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::pair<T2DetId,std::vector<T2StripDigi> > >"));
  ::Reflex::Type type_3407 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TotemDigiCollection<T2DetId,T2PadDigi> >"));
  ::Reflex::Type type_5055 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >"));
  ::Reflex::Type type_3409 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TotemDigiCollection<T2DetId,T2StripDigi> >"));
  ::Reflex::Type type_2699 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const T2DetId,std::vector<T2PadDigi> > >"));
  ::Reflex::Type type_3406 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::pair<T2DetId,std::vector<T2PadDigi> > >"));
  ::Reflex::Type type_2701 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const T2DetId,std::vector<T2StripDigi> > >"));
  ::Reflex::Type type_5056 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >"));
  ::Reflex::Type type_3408 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::pair<T2DetId,std::vector<T2StripDigi> > >"));
  ::Reflex::Type type_4001 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const T2PadDigi*,std::vector<T2PadDigi> >"));
  ::Reflex::Type type_2589 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >"));
  ::Reflex::Type type_4432 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const T2StripDigi*,std::vector<T2StripDigi> >"));
  ::Reflex::Type type_2590 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >"));
  ::Reflex::Type type_2682 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >"));
  ::Reflex::Type type_2683 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >"));
  ::Reflex::Type type_2795 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> > >"));
  ::Reflex::Type type_2505 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >,bool>"));
  ::Reflex::Type type_2511 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >,bool>"));
  ::Reflex::Type type_2797 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> > >"));
  ::Reflex::Type type_2794 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const T2PadDigi*,std::vector<T2PadDigi> > >"));
  ::Reflex::Type type_2787 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > > >"));
  ::Reflex::Type type_2796 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const T2StripDigi*,std::vector<T2StripDigi> > >"));
  ::Reflex::Type type_2789 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > > >"));
  ::Reflex::Type type_2786 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > > >"));
  ::Reflex::Type type_2788 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > > >"));
  ::Reflex::Type type_2507 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<const T2PadDigi*,std::vector<T2PadDigi> >,__gnu_cxx::__normal_iterator<const T2PadDigi*,std::vector<T2PadDigi> > >"));
  ::Reflex::Type type_2504 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >,std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > > >"));
  ::Reflex::Type type_2512 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<const T2StripDigi*,std::vector<T2StripDigi> >,__gnu_cxx::__normal_iterator<const T2StripDigi*,std::vector<T2StripDigi> > >"));
  ::Reflex::Type type_2510 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >,std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > > >"));
  ::Reflex::Type type_2502 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >,std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > > >"));
  ::Reflex::Type type_2508 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >,std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > > >"));
  ::Reflex::Type type_2326 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<T2DetId,std::pair<const T2DetId,std::vector<T2PadDigi> >,std::_Select1st<std::pair<const T2DetId,std::vector<T2PadDigi> > >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId,std::vector<T2PadDigi> > > >"));
  ::Reflex::Type type_2327 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<T2DetId,std::pair<const T2DetId,std::vector<T2StripDigi> >,std::_Select1st<std::pair<const T2DetId,std::vector<T2StripDigi> > >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId,std::vector<T2StripDigi> > > >"));
  ::Reflex::Type type_805 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2PadDigiCollection"), type_804);
  ::Reflex::Type type_1190 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2StripDigiCollection"), type_1189);
  ::Reflex::Type type_8530 = ::Reflex::ReferenceBuilder(type_801);
  ::Reflex::Type type_801c = ::Reflex::ConstBuilder(type_801);
  ::Reflex::Type type_8532 = ::Reflex::ReferenceBuilder(type_801c);
  ::Reflex::Type type_13400 = ::Reflex::ReferenceBuilder(type_804);
  ::Reflex::Type type_804c = ::Reflex::ConstBuilder(type_804);
  ::Reflex::Type type_13401 = ::Reflex::ReferenceBuilder(type_804c);
  ::Reflex::Type type_774c = ::Reflex::ConstBuilder(type_774);
  ::Reflex::Type type_4168 = ::Reflex::ReferenceBuilder(type_774c);
  ::Reflex::Type type_1591c = ::Reflex::ConstBuilder(type_1591);
  ::Reflex::Type type_8467 = ::Reflex::ReferenceBuilder(type_1591c);
  ::Reflex::Type type_13474 = ::Reflex::ReferenceBuilder(type_1189);
  ::Reflex::Type type_1189c = ::Reflex::ConstBuilder(type_1189);
  ::Reflex::Type type_13475 = ::Reflex::ReferenceBuilder(type_1189c);
  ::Reflex::Type type_8465 = ::Reflex::ReferenceBuilder(type_1591);
  ::Reflex::Type type_17182 = ::Reflex::ReferenceBuilder(type_2500);
  ::Reflex::Type type_2500c = ::Reflex::ConstBuilder(type_2500);
  ::Reflex::Type type_17183 = ::Reflex::ReferenceBuilder(type_2500c);
  ::Reflex::Type type_2536c = ::Reflex::ConstBuilder(type_2536);
  ::Reflex::Type type_8597 = ::Reflex::ReferenceBuilder(type_2536c);
  ::Reflex::Type type_17184 = ::Reflex::ReferenceBuilder(type_2501);
  ::Reflex::Type type_2501c = ::Reflex::ConstBuilder(type_2501);
  ::Reflex::Type type_17185 = ::Reflex::ReferenceBuilder(type_2501c);
  ::Reflex::Type type_2537c = ::Reflex::ConstBuilder(type_2537);
  ::Reflex::Type type_8662 = ::Reflex::ReferenceBuilder(type_2537c);
  ::Reflex::Type type_6044 = ::Reflex::PointerBuilder(type_1591);
  ::Reflex::Type type_8463 = ::Reflex::PointerBuilder(type_1591c);
  ::Reflex::Type type_2680 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_274);
  ::Reflex::Type type_2614 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_62);
  ::Reflex::Type type_2696c = ::Reflex::ConstBuilder(type_2696);
  ::Reflex::Type type_16543 = ::Reflex::ReferenceBuilder(type_2696c);
  ::Reflex::Type type_8595 = ::Reflex::ReferenceBuilder(type_2536);
  ::Reflex::Type type_6063 = ::Reflex::PointerBuilder(type_801);
  ::Reflex::Type type_8528 = ::Reflex::PointerBuilder(type_801c);
  ::Reflex::Type type_2697c = ::Reflex::ConstBuilder(type_2697);
  ::Reflex::Type type_16556 = ::Reflex::ReferenceBuilder(type_2697c);
  ::Reflex::Type type_8660 = ::Reflex::ReferenceBuilder(type_2537);
  ::Reflex::Type type_7363 = ::Reflex::PointerBuilder(type_2503);
  ::Reflex::Type type_2503c = ::Reflex::ConstBuilder(type_2503);
  ::Reflex::Type type_7365 = ::Reflex::PointerBuilder(type_2503c);
  ::Reflex::Type type_7367 = ::Reflex::ReferenceBuilder(type_2503);
  ::Reflex::Type type_7369 = ::Reflex::ReferenceBuilder(type_2503c);
  ::Reflex::Type type_2279c = ::Reflex::ConstBuilder(type_2279);
  ::Reflex::Type type_16956 = ::Reflex::ReferenceBuilder(type_2279c);
  ::Reflex::Type type_2699c = ::Reflex::ConstBuilder(type_2699);
  ::Reflex::Type type_17035 = ::Reflex::ReferenceBuilder(type_2699c);
  ::Reflex::Type type_2637c = ::Reflex::ConstBuilder(type_2637);
  ::Reflex::Type type_17309 = ::Reflex::ReferenceBuilder(type_2637c);
  ::Reflex::Type type_17310 = ::Reflex::ReferenceBuilder(type_2637);
  ::Reflex::Type type_7472 = ::Reflex::PointerBuilder(type_2509);
  ::Reflex::Type type_2509c = ::Reflex::ConstBuilder(type_2509);
  ::Reflex::Type type_7474 = ::Reflex::PointerBuilder(type_2509c);
  ::Reflex::Type type_7476 = ::Reflex::ReferenceBuilder(type_2509);
  ::Reflex::Type type_7478 = ::Reflex::ReferenceBuilder(type_2509c);
  ::Reflex::Type type_2701c = ::Reflex::ConstBuilder(type_2701);
  ::Reflex::Type type_17043 = ::Reflex::ReferenceBuilder(type_2701c);
  ::Reflex::Type type_2638c = ::Reflex::ConstBuilder(type_2638);
  ::Reflex::Type type_17311 = ::Reflex::ReferenceBuilder(type_2638c);
  ::Reflex::Type type_17312 = ::Reflex::ReferenceBuilder(type_2638);
  ::Reflex::Type type_19055 = ::Reflex::PointerBuilder(type_2500c);
  ::Reflex::Type type_395c = ::Reflex::ConstBuilder(type_395);
  ::Reflex::Type type_11629 = ::Reflex::ReferenceBuilder(type_395c);
  ::Reflex::Type type_19056 = ::Reflex::PointerBuilder(type_2500);
  ::Reflex::Type type_3406c = ::Reflex::ConstBuilder(type_3406);
  ::Reflex::Type type_19057 = ::Reflex::PointerBuilder(type_3406c);
  ::Reflex::Type type_3477c = ::Reflex::ConstBuilder(type_3477);
  ::Reflex::Type type_12931 = ::Reflex::ReferenceBuilder(type_3477c);
  ::Reflex::Type type_17194 = ::Reflex::ReferenceBuilder(type_2534);
  ::Reflex::Type type_18980 = ::Reflex::ReferenceBuilder(type_3297);
  ::Reflex::Type type_580c = ::Reflex::ConstBuilder(type_580);
  ::Reflex::Type type_3005 = ::Reflex::PointerBuilder(type_580c);
  ::Reflex::Type type_6784 = ::Reflex::ReferenceBuilder(type_3005);
  ::Reflex::Type type_2535c = ::Reflex::ConstBuilder(type_2535);
  ::Reflex::Type type_17195 = ::Reflex::ReferenceBuilder(type_2535c);
  ::Reflex::Type type_19060 = ::Reflex::PointerBuilder(type_804c);
  ::Reflex::Type type_19061 = ::Reflex::PointerBuilder(type_804);
  ::Reflex::Type type_3407c = ::Reflex::ConstBuilder(type_3407);
  ::Reflex::Type type_19062 = ::Reflex::PointerBuilder(type_3407c);
  ::Reflex::Type type_19065 = ::Reflex::PointerBuilder(type_2501c);
  ::Reflex::Type type_19066 = ::Reflex::PointerBuilder(type_2501);
  ::Reflex::Type type_3408c = ::Reflex::ConstBuilder(type_3408);
  ::Reflex::Type type_19067 = ::Reflex::PointerBuilder(type_3408c);
  ::Reflex::Type type_19070 = ::Reflex::PointerBuilder(type_1189c);
  ::Reflex::Type type_19071 = ::Reflex::PointerBuilder(type_1189);
  ::Reflex::Type type_3409c = ::Reflex::ConstBuilder(type_3409);
  ::Reflex::Type type_19072 = ::Reflex::PointerBuilder(type_3409c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __T2StripDigi
#undef __T2StripDigi
#endif
class __T2StripDigi {
  public:
  __T2StripDigi();
  int hitCounter;
  int adc;
  int stripNr;
  int row;
  int col;
};
#ifdef __TotemDigiCollection_T2DetId_T2PadDigi_
#undef __TotemDigiCollection_T2DetId_T2PadDigi_
#endif
class __TotemDigiCollection_T2DetId_T2PadDigi_ {
  public:
  __TotemDigiCollection_T2DetId_T2PadDigi_();
  ::std::map<T2DetId,std::vector<T2PadDigi> > data_;
};
#ifdef __TotemDigiCollection_T2DetId_T2StripDigi_
#undef __TotemDigiCollection_T2DetId_T2StripDigi_
#endif
class __TotemDigiCollection_T2DetId_T2StripDigi_ {
  public:
  __TotemDigiCollection_T2DetId_T2StripDigi_();
  ::std::map<T2DetId,std::vector<T2StripDigi> > data_;
};
#ifdef __T2PadDigi
#undef __T2PadDigi
#endif
class __T2PadDigi {
  public:
  __T2PadDigi();
  int hitCounter;
  int adc;
  int padNr;
  int row;
  int col;
};
#ifdef __std__pair_T2DetId_std__vector_T2PadDigi_s_
#undef __std__pair_T2DetId_std__vector_T2PadDigi_s_
#endif
struct __std__pair_T2DetId_std__vector_T2PadDigi_s_ {
  public:
  __std__pair_T2DetId_std__vector_T2PadDigi_s_();
  ::T2DetId first;
  ::std::vector<T2PadDigi> second;
};
#ifdef __std__pair_T2DetId_std__vector_T2StripDigi_s_
#undef __std__pair_T2DetId_std__vector_T2StripDigi_s_
#endif
struct __std__pair_T2DetId_std__vector_T2StripDigi_s_ {
  public:
  __std__pair_T2DetId_std__vector_T2StripDigi_s_();
  ::T2DetId first;
  ::std::vector<T2StripDigi> second;
};
#ifdef __std__vector_T2PadDigi_
#undef __std__vector_T2PadDigi_
#endif
class __std__vector_T2PadDigi_ : protected ::std::_Vector_base<T2PadDigi,std::allocator<T2PadDigi> > {
  public:
  __std__vector_T2PadDigi_();
};
#ifdef __std__vector_T2StripDigi_
#undef __std__vector_T2StripDigi_
#endif
class __std__vector_T2StripDigi_ : protected ::std::_Vector_base<T2StripDigi,std::allocator<T2StripDigi> > {
  public:
  __std__vector_T2StripDigi_();
};
#ifdef __std__map_T2DetId_std__vector_T2PadDigi_s_
#undef __std__map_T2DetId_std__vector_T2PadDigi_s_
#endif
class __std__map_T2DetId_std__vector_T2PadDigi_s_ {
  public:
  __std__map_T2DetId_std__vector_T2PadDigi_s_();
  ::std::_Rb_tree<T2DetId,std::pair<const T2DetId,std::vector<T2PadDigi> >,std::_Select1st<std::pair<const T2DetId,std::vector<T2PadDigi> > >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId,std::vector<T2PadDigi> > > > _M_t;
};
#ifdef __std__map_T2DetId_std__vector_T2StripDigi_s_
#undef __std__map_T2DetId_std__vector_T2StripDigi_s_
#endif
class __std__map_T2DetId_std__vector_T2StripDigi_s_ {
  public:
  __std__map_T2DetId_std__vector_T2StripDigi_s_();
  ::std::_Rb_tree<T2DetId,std::pair<const T2DetId,std::vector<T2StripDigi> >,std::_Select1st<std::pair<const T2DetId,std::vector<T2StripDigi> > >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId,std::vector<T2StripDigi> > > > _M_t;
};
#ifdef __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s_
#undef __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s_
#endif
class __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s_ {
  public:
  __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s_();
  bool present;
  ::std::pair<T2DetId,std::vector<T2PadDigi> > obj;
};
#ifdef __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s_
#undef __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s_
#endif
class __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s_ {
  public:
  __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s_();
  bool present;
  ::TotemDigiCollection<T2DetId,T2PadDigi> obj;
};
#ifdef __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s_
#undef __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s_
#endif
class __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s_ {
  public:
  __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s_();
  bool present;
  ::std::pair<T2DetId,std::vector<T2StripDigi> > obj;
};
#ifdef __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s_
#undef __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s_
#endif
class __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s_ {
  public:
  __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s_();
  bool present;
  ::TotemDigiCollection<T2DetId,T2StripDigi> obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class T2StripDigi -------------------------------
static  void operator_3989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T2StripDigi*)o)->operator=)(*(const ::T2StripDigi*)arg[0]);
  else   (((::T2StripDigi*)o)->operator=)(*(const ::T2StripDigi*)arg[0]);
}

static void constructor_3990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2StripDigi(*(const ::T2StripDigi*)arg[0]);
  else ::new(mem) ::T2StripDigi(*(const ::T2StripDigi*)arg[0]);
}

static void constructor_3991( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2StripDigi(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  else ::new(mem) ::T2StripDigi(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
}

static void constructor_3992( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2StripDigi();
  else ::new(mem) ::T2StripDigi();
}

static void destructor_3993(void*, void * o, const std::vector<void*>&, void *) {
(((::T2StripDigi*)o)->::T2StripDigi::~T2StripDigi)();
}
static  void method_3994( void*, void* o, const std::vector<void*>&, void*)
{
  (((::T2StripDigi*)o)->reset)();
}

static  void method_3995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2StripDigi*)o)->getHitCounter)());
  else   (((const ::T2StripDigi*)o)->getHitCounter)();
}

static  void method_3996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2StripDigi*)o)->getAdc)());
  else   (((const ::T2StripDigi*)o)->getAdc)();
}

static  void method_3997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2StripDigi*)o)->getStripNr)());
  else   (((const ::T2StripDigi*)o)->getStripNr)();
}

static  void method_3998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2StripDigi*)o)->getRow)());
  else   (((const ::T2StripDigi*)o)->getRow)();
}

static  void method_3999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2StripDigi*)o)->getCol)());
  else   (((const ::T2StripDigi*)o)->getCol)();
}

static void method_newdel_801( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T2StripDigi >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T2StripDigi >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T2StripDigi >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T2StripDigi >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T2StripDigi >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T2StripDigi -------------------------------
void __T2StripDigi_db_datamem(Reflex::Class*);
void __T2StripDigi_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T2StripDigi_datamem_bld(&__T2StripDigi_db_datamem);
Reflex::GenreflexMemberBuilder __T2StripDigi_funcmem_bld(&__T2StripDigi_db_funcmem);
void __T2StripDigi_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T2StripDigi"), typeid(::T2StripDigi), sizeof(::T2StripDigi), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530, type_8532), Reflex::Literal("operator="), operator_3989, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8532), Reflex::Literal("T2StripDigi"), constructor_3990, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_68, type_68, type_68, type_68), Reflex::Literal("T2StripDigi"), constructor_3991, 0, "stripNr;row;col;adc", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T2StripDigi"), constructor_3992, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T2StripDigi"), destructor_3993, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_801, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T2StripDigi_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T2StripDigi_funcmem_bld);
}

//------Delayed data member builder for class T2StripDigi -------------------
void __T2StripDigi_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_68, Reflex::Literal("hitCounter"), OffsetOf(__shadow__::__T2StripDigi, hitCounter), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("adc"), OffsetOf(__shadow__::__T2StripDigi, adc), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("stripNr"), OffsetOf(__shadow__::__T2StripDigi, stripNr), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("row"), OffsetOf(__shadow__::__T2StripDigi, row), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("col"), OffsetOf(__shadow__::__T2StripDigi, col), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T2StripDigi -------------------
void __T2StripDigi_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("reset"), method_3994, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getHitCounter"), method_3995, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getAdc"), method_3996, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getStripNr"), method_3997, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getRow"), method_3998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getCol"), method_3999, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TotemDigiCollection<T2DetId,T2PadDigi> -------------------------------
static void destructor_4006(void*, void * o, const std::vector<void*>&, void *) {
(((::TotemDigiCollection<T2DetId,T2PadDigi>*)o)->::TotemDigiCollection<T2DetId,T2PadDigi>::~TotemDigiCollection)();
}
static  void operator_4007( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TotemDigiCollection<T2DetId,T2PadDigi>*)o)->operator=)(*(const ::TotemDigiCollection<T2DetId,T2PadDigi>*)arg[0]);
  else   (((::TotemDigiCollection<T2DetId,T2PadDigi>*)o)->operator=)(*(const ::TotemDigiCollection<T2DetId,T2PadDigi>*)arg[0]);
}

static void constructor_4008( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemDigiCollection<T2DetId,T2PadDigi>(*(const ::TotemDigiCollection<T2DetId,T2PadDigi>*)arg[0]);
  else ::new(mem) ::TotemDigiCollection<T2DetId,T2PadDigi>(*(const ::TotemDigiCollection<T2DetId,T2PadDigi>*)arg[0]);
}

static void constructor_4009( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemDigiCollection<T2DetId,T2PadDigi>();
  else ::new(mem) ::TotemDigiCollection<T2DetId,T2PadDigi>();
}

static  void method_4010( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TotemDigiCollection<T2DetId,T2PadDigi>*)o)->insertDigi)(*(const ::T2DetId*)arg[0],
    *(const ::T2PadDigi*)arg[1]);
}

static  void method_4011( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TotemDigiCollection<T2DetId,T2PadDigi>*)o)->put)(*(::std::pair<__gnu_cxx::__normal_iterator<const T2PadDigi*,std::vector<T2PadDigi> >,__gnu_cxx::__normal_iterator<const T2PadDigi*,std::vector<T2PadDigi> > >*)arg[0],
    *(const ::T2DetId*)arg[1]);
}

static  void method_4012( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::__normal_iterator<const T2PadDigi*,std::vector<T2PadDigi> >,__gnu_cxx::__normal_iterator<const T2PadDigi*,std::vector<T2PadDigi> > >)((((const ::TotemDigiCollection<T2DetId,T2PadDigi>*)o)->get)(*(const ::T2DetId*)arg[0]));
  else   (((const ::TotemDigiCollection<T2DetId,T2PadDigi>*)o)->get)(*(const ::T2DetId*)arg[0]);
}

static  void method_4013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (DigiContainerIterator<T2DetId,T2PadDigi>)((((const ::TotemDigiCollection<T2DetId,T2PadDigi>*)o)->begin)());
  else   (((const ::TotemDigiCollection<T2DetId,T2PadDigi>*)o)->begin)();
}

static  void method_4014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (DigiContainerIterator<T2DetId,T2PadDigi>)((((const ::TotemDigiCollection<T2DetId,T2PadDigi>*)o)->end)());
  else   (((const ::TotemDigiCollection<T2DetId,T2PadDigi>*)o)->end)();
}

static void method_newdel_804( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2PadDigi> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2PadDigi> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2PadDigi> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2PadDigi> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2PadDigi> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TotemDigiCollection<T2DetId,T2PadDigi> -------------------------------
void __TotemDigiCollection_T2DetId_T2PadDigi__db_datamem(Reflex::Class*);
void __TotemDigiCollection_T2DetId_T2PadDigi__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TotemDigiCollection_T2DetId_T2PadDigi__datamem_bld(&__TotemDigiCollection_T2DetId_T2PadDigi__db_datamem);
Reflex::GenreflexMemberBuilder __TotemDigiCollection_T2DetId_T2PadDigi__funcmem_bld(&__TotemDigiCollection_T2DetId_T2PadDigi__db_funcmem);
void __TotemDigiCollection_T2DetId_T2PadDigi__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TotemDigiCollection<T2DetId,T2PadDigi>"), typeid(::TotemDigiCollection<T2DetId,T2PadDigi>), sizeof(::TotemDigiCollection<T2DetId,T2PadDigi>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4001, Reflex::Literal("TotemDigiCollection<T2DetId,T2PadDigi>::const_iterator"))
  .AddTypedef(type_2507, Reflex::Literal("TotemDigiCollection<T2DetId,T2PadDigi>::Range"))
  .AddTypedef(type_423, Reflex::Literal("TotemDigiCollection<T2DetId,T2PadDigi>::DigiRangeIterator"))
  .AddTypedef(type_2637, Reflex::Literal("TotemDigiCollection<T2DetId,T2PadDigi>::container"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TotemDigiCollection"), destructor_4006, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13400, type_13401), Reflex::Literal("operator="), operator_4007, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13401), Reflex::Literal("TotemDigiCollection"), constructor_4008, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TotemDigiCollection"), constructor_4009, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_804, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TotemDigiCollection_T2DetId_T2PadDigi__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TotemDigiCollection_T2DetId_T2PadDigi__funcmem_bld);
}

//------Delayed data member builder for class TotemDigiCollection<T2DetId,T2PadDigi> -------------------
void __TotemDigiCollection_T2DetId_T2PadDigi__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2637, Reflex::Literal("data_"), OffsetOf(__shadow__::__TotemDigiCollection_T2DetId_T2PadDigi_, data_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TotemDigiCollection<T2DetId,T2PadDigi> -------------------
void __TotemDigiCollection_T2DetId_T2PadDigi__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_4168, type_8467), Reflex::Literal("insertDigi"), method_4010, 0, "index;digi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2507, type_4168), Reflex::Literal("put"), method_4011, 0, "range;index", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2507, type_4168), Reflex::Literal("get"), method_4012, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_423), Reflex::Literal("begin"), method_4013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_423), Reflex::Literal("end"), method_4014, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TotemDigiCollection<T2DetId,T2StripDigi> -------------------------------
static void destructor_4437(void*, void * o, const std::vector<void*>&, void *) {
(((::TotemDigiCollection<T2DetId,T2StripDigi>*)o)->::TotemDigiCollection<T2DetId,T2StripDigi>::~TotemDigiCollection)();
}
static  void operator_4438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TotemDigiCollection<T2DetId,T2StripDigi>*)o)->operator=)(*(const ::TotemDigiCollection<T2DetId,T2StripDigi>*)arg[0]);
  else   (((::TotemDigiCollection<T2DetId,T2StripDigi>*)o)->operator=)(*(const ::TotemDigiCollection<T2DetId,T2StripDigi>*)arg[0]);
}

static void constructor_4439( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemDigiCollection<T2DetId,T2StripDigi>(*(const ::TotemDigiCollection<T2DetId,T2StripDigi>*)arg[0]);
  else ::new(mem) ::TotemDigiCollection<T2DetId,T2StripDigi>(*(const ::TotemDigiCollection<T2DetId,T2StripDigi>*)arg[0]);
}

static void constructor_4440( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemDigiCollection<T2DetId,T2StripDigi>();
  else ::new(mem) ::TotemDigiCollection<T2DetId,T2StripDigi>();
}

static  void method_4441( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TotemDigiCollection<T2DetId,T2StripDigi>*)o)->insertDigi)(*(const ::T2DetId*)arg[0],
    *(const ::T2StripDigi*)arg[1]);
}

static  void method_4442( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TotemDigiCollection<T2DetId,T2StripDigi>*)o)->put)(*(::std::pair<__gnu_cxx::__normal_iterator<const T2StripDigi*,std::vector<T2StripDigi> >,__gnu_cxx::__normal_iterator<const T2StripDigi*,std::vector<T2StripDigi> > >*)arg[0],
    *(const ::T2DetId*)arg[1]);
}

static  void method_4443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::__normal_iterator<const T2StripDigi*,std::vector<T2StripDigi> >,__gnu_cxx::__normal_iterator<const T2StripDigi*,std::vector<T2StripDigi> > >)((((const ::TotemDigiCollection<T2DetId,T2StripDigi>*)o)->get)(*(const ::T2DetId*)arg[0]));
  else   (((const ::TotemDigiCollection<T2DetId,T2StripDigi>*)o)->get)(*(const ::T2DetId*)arg[0]);
}

static  void method_4444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (DigiContainerIterator<T2DetId,T2StripDigi>)((((const ::TotemDigiCollection<T2DetId,T2StripDigi>*)o)->begin)());
  else   (((const ::TotemDigiCollection<T2DetId,T2StripDigi>*)o)->begin)();
}

static  void method_4445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (DigiContainerIterator<T2DetId,T2StripDigi>)((((const ::TotemDigiCollection<T2DetId,T2StripDigi>*)o)->end)());
  else   (((const ::TotemDigiCollection<T2DetId,T2StripDigi>*)o)->end)();
}

static void method_newdel_1189( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2StripDigi> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2StripDigi> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2StripDigi> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2StripDigi> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T2DetId,T2StripDigi> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TotemDigiCollection<T2DetId,T2StripDigi> -------------------------------
void __TotemDigiCollection_T2DetId_T2StripDigi__db_datamem(Reflex::Class*);
void __TotemDigiCollection_T2DetId_T2StripDigi__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TotemDigiCollection_T2DetId_T2StripDigi__datamem_bld(&__TotemDigiCollection_T2DetId_T2StripDigi__db_datamem);
Reflex::GenreflexMemberBuilder __TotemDigiCollection_T2DetId_T2StripDigi__funcmem_bld(&__TotemDigiCollection_T2DetId_T2StripDigi__db_funcmem);
void __TotemDigiCollection_T2DetId_T2StripDigi__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TotemDigiCollection<T2DetId,T2StripDigi>"), typeid(::TotemDigiCollection<T2DetId,T2StripDigi>), sizeof(::TotemDigiCollection<T2DetId,T2StripDigi>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4432, Reflex::Literal("TotemDigiCollection<T2DetId,T2StripDigi>::const_iterator"))
  .AddTypedef(type_2512, Reflex::Literal("TotemDigiCollection<T2DetId,T2StripDigi>::Range"))
  .AddTypedef(type_424, Reflex::Literal("TotemDigiCollection<T2DetId,T2StripDigi>::DigiRangeIterator"))
  .AddTypedef(type_2638, Reflex::Literal("TotemDigiCollection<T2DetId,T2StripDigi>::container"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TotemDigiCollection"), destructor_4437, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13474, type_13475), Reflex::Literal("operator="), operator_4438, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13475), Reflex::Literal("TotemDigiCollection"), constructor_4439, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TotemDigiCollection"), constructor_4440, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1189, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TotemDigiCollection_T2DetId_T2StripDigi__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TotemDigiCollection_T2DetId_T2StripDigi__funcmem_bld);
}

//------Delayed data member builder for class TotemDigiCollection<T2DetId,T2StripDigi> -------------------
void __TotemDigiCollection_T2DetId_T2StripDigi__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2638, Reflex::Literal("data_"), OffsetOf(__shadow__::__TotemDigiCollection_T2DetId_T2StripDigi_, data_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TotemDigiCollection<T2DetId,T2StripDigi> -------------------
void __TotemDigiCollection_T2DetId_T2StripDigi__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_4168, type_8532), Reflex::Literal("insertDigi"), method_4441, 0, "index;digi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2512, type_4168), Reflex::Literal("put"), method_4442, 0, "range;index", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2512, type_4168), Reflex::Literal("get"), method_4443, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_424), Reflex::Literal("begin"), method_4444, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_424), Reflex::Literal("end"), method_4445, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class T2PadDigi -------------------------------
static  void operator_4874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T2PadDigi*)o)->operator=)(*(const ::T2PadDigi*)arg[0]);
  else   (((::T2PadDigi*)o)->operator=)(*(const ::T2PadDigi*)arg[0]);
}

static void constructor_4875( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2PadDigi(*(const ::T2PadDigi*)arg[0]);
  else ::new(mem) ::T2PadDigi(*(const ::T2PadDigi*)arg[0]);
}

static void constructor_4876( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2PadDigi(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  else ::new(mem) ::T2PadDigi(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
}

static void constructor_4877( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2PadDigi();
  else ::new(mem) ::T2PadDigi();
}

static void destructor_4878(void*, void * o, const std::vector<void*>&, void *) {
(((::T2PadDigi*)o)->::T2PadDigi::~T2PadDigi)();
}
static  void method_4879( void*, void* o, const std::vector<void*>&, void*)
{
  (((::T2PadDigi*)o)->reset)();
}

static  void method_4880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2PadDigi*)o)->getHitCounter)());
  else   (((const ::T2PadDigi*)o)->getHitCounter)();
}

static  void method_4881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2PadDigi*)o)->getAdc)());
  else   (((const ::T2PadDigi*)o)->getAdc)();
}

static  void method_4882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2PadDigi*)o)->getPadNr)());
  else   (((const ::T2PadDigi*)o)->getPadNr)();
}

static  void method_4883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2PadDigi*)o)->getRow)());
  else   (((const ::T2PadDigi*)o)->getRow)();
}

static  void method_4884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2PadDigi*)o)->getCol)());
  else   (((const ::T2PadDigi*)o)->getCol)();
}

static void method_newdel_1591( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T2PadDigi >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T2PadDigi >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T2PadDigi >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T2PadDigi >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T2PadDigi >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T2PadDigi -------------------------------
void __T2PadDigi_db_datamem(Reflex::Class*);
void __T2PadDigi_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T2PadDigi_datamem_bld(&__T2PadDigi_db_datamem);
Reflex::GenreflexMemberBuilder __T2PadDigi_funcmem_bld(&__T2PadDigi_db_funcmem);
void __T2PadDigi_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T2PadDigi"), typeid(::T2PadDigi), sizeof(::T2PadDigi), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8465, type_8467), Reflex::Literal("operator="), operator_4874, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8467), Reflex::Literal("T2PadDigi"), constructor_4875, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_68, type_68, type_68, type_68), Reflex::Literal("T2PadDigi"), constructor_4876, 0, "padNr;row;col;adc", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T2PadDigi"), constructor_4877, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T2PadDigi"), destructor_4878, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1591, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T2PadDigi_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T2PadDigi_funcmem_bld);
}

//------Delayed data member builder for class T2PadDigi -------------------
void __T2PadDigi_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_68, Reflex::Literal("hitCounter"), OffsetOf(__shadow__::__T2PadDigi, hitCounter), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("adc"), OffsetOf(__shadow__::__T2PadDigi, adc), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("padNr"), OffsetOf(__shadow__::__T2PadDigi, padNr), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("row"), OffsetOf(__shadow__::__T2PadDigi, row), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("col"), OffsetOf(__shadow__::__T2PadDigi, col), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T2PadDigi -------------------
void __T2PadDigi_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("reset"), method_4879, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getHitCounter"), method_4880, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getAdc"), method_4881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getPadNr"), method_4882, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getRow"), method_4883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("getCol"), method_4884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class pair<T2DetId,std::vector<T2PadDigi, std::allocator<T2PadDigi> > > -------------------------------
static void destructor_8249(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<T2DetId,std::vector<T2PadDigi> >*)o)->::std::pair<T2DetId,std::vector<T2PadDigi> >::~pair)();
}
static  void operator_8250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<T2DetId,std::vector<T2PadDigi> >*)o)->operator=)(*(const ::std::pair<T2DetId,std::vector<T2PadDigi> >*)arg[0]);
  else   (((::std::pair<T2DetId,std::vector<T2PadDigi> >*)o)->operator=)(*(const ::std::pair<T2DetId,std::vector<T2PadDigi> >*)arg[0]);
}

static void constructor_8251( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2PadDigi> >(*(const ::std::pair<T2DetId,std::vector<T2PadDigi> >*)arg[0]);
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2PadDigi> >(*(const ::std::pair<T2DetId,std::vector<T2PadDigi> >*)arg[0]);
}

static void constructor_8252( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2PadDigi> >();
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2PadDigi> >();
}

static void constructor_8253( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2PadDigi> >(*(const ::T2DetId*)arg[0],
      *(const ::std::vector<T2PadDigi>*)arg[1]);
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2PadDigi> >(*(const ::T2DetId*)arg[0],
      *(const ::std::vector<T2PadDigi>*)arg[1]);
}

static void method_newdel_2500( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2PadDigi> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2PadDigi> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2PadDigi> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2PadDigi> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2PadDigi> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<T2DetId,std::vector<T2PadDigi, std::allocator<T2PadDigi> > > -------------------------------
void __std__pair_T2DetId_std__vector_T2PadDigi_s__db_datamem(Reflex::Class*);
void __std__pair_T2DetId_std__vector_T2PadDigi_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_T2DetId_std__vector_T2PadDigi_s__datamem_bld(&__std__pair_T2DetId_std__vector_T2PadDigi_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_T2DetId_std__vector_T2PadDigi_s__funcmem_bld(&__std__pair_T2DetId_std__vector_T2PadDigi_s__db_funcmem);
void __std__pair_T2DetId_std__vector_T2PadDigi_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<T2DetId,std::vector<T2PadDigi> >"), typeid(::std::pair<T2DetId,std::vector<T2PadDigi> >), sizeof(::std::pair<T2DetId,std::vector<T2PadDigi> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_774, Reflex::Literal("std::pair<T2DetId,std::vector<T2PadDigi> >::first_type"))
  .AddTypedef(type_2536, Reflex::Literal("std::pair<T2DetId,std::vector<T2PadDigi> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_8249, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17182, type_17183), Reflex::Literal("operator="), operator_8250, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17183), Reflex::Literal("pair"), constructor_8251, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_8252, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4168, type_8597), Reflex::Literal("pair"), constructor_8253, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2500, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_T2DetId_std__vector_T2PadDigi_s__datamem_bld);
}

//------Delayed data member builder for class pair<T2DetId,std::vector<T2PadDigi, std::allocator<T2PadDigi> > > -------------------
void __std__pair_T2DetId_std__vector_T2PadDigi_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_774, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_T2DetId_std__vector_T2PadDigi_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2536, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_T2DetId_std__vector_T2PadDigi_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<T2DetId,std::vector<T2PadDigi, std::allocator<T2PadDigi> > > -------------------
void __std__pair_T2DetId_std__vector_T2PadDigi_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<T2DetId,std::vector<T2StripDigi, std::allocator<T2StripDigi> > > -------------------------------
static void destructor_8258(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<T2DetId,std::vector<T2StripDigi> >*)o)->::std::pair<T2DetId,std::vector<T2StripDigi> >::~pair)();
}
static  void operator_8259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<T2DetId,std::vector<T2StripDigi> >*)o)->operator=)(*(const ::std::pair<T2DetId,std::vector<T2StripDigi> >*)arg[0]);
  else   (((::std::pair<T2DetId,std::vector<T2StripDigi> >*)o)->operator=)(*(const ::std::pair<T2DetId,std::vector<T2StripDigi> >*)arg[0]);
}

static void constructor_8260( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2StripDigi> >(*(const ::std::pair<T2DetId,std::vector<T2StripDigi> >*)arg[0]);
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2StripDigi> >(*(const ::std::pair<T2DetId,std::vector<T2StripDigi> >*)arg[0]);
}

static void constructor_8261( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2StripDigi> >();
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2StripDigi> >();
}

static void constructor_8262( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2StripDigi> >(*(const ::T2DetId*)arg[0],
      *(const ::std::vector<T2StripDigi>*)arg[1]);
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2StripDigi> >(*(const ::T2DetId*)arg[0],
      *(const ::std::vector<T2StripDigi>*)arg[1]);
}

static void method_newdel_2501( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2StripDigi> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2StripDigi> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2StripDigi> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2StripDigi> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2StripDigi> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<T2DetId,std::vector<T2StripDigi, std::allocator<T2StripDigi> > > -------------------------------
void __std__pair_T2DetId_std__vector_T2StripDigi_s__db_datamem(Reflex::Class*);
void __std__pair_T2DetId_std__vector_T2StripDigi_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_T2DetId_std__vector_T2StripDigi_s__datamem_bld(&__std__pair_T2DetId_std__vector_T2StripDigi_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_T2DetId_std__vector_T2StripDigi_s__funcmem_bld(&__std__pair_T2DetId_std__vector_T2StripDigi_s__db_funcmem);
void __std__pair_T2DetId_std__vector_T2StripDigi_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<T2DetId,std::vector<T2StripDigi> >"), typeid(::std::pair<T2DetId,std::vector<T2StripDigi> >), sizeof(::std::pair<T2DetId,std::vector<T2StripDigi> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_774, Reflex::Literal("std::pair<T2DetId,std::vector<T2StripDigi> >::first_type"))
  .AddTypedef(type_2537, Reflex::Literal("std::pair<T2DetId,std::vector<T2StripDigi> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_8258, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17184, type_17185), Reflex::Literal("operator="), operator_8259, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17185), Reflex::Literal("pair"), constructor_8260, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_8261, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4168, type_8662), Reflex::Literal("pair"), constructor_8262, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2501, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_T2DetId_std__vector_T2StripDigi_s__datamem_bld);
}

//------Delayed data member builder for class pair<T2DetId,std::vector<T2StripDigi, std::allocator<T2StripDigi> > > -------------------
void __std__pair_T2DetId_std__vector_T2StripDigi_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_774, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_T2DetId_std__vector_T2StripDigi_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2537, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_T2DetId_std__vector_T2StripDigi_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<T2DetId,std::vector<T2StripDigi, std::allocator<T2StripDigi> > > -------------------
void __std__pair_T2DetId_std__vector_T2StripDigi_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<T2PadDigi,std::allocator<T2PadDigi> > -------------------------------
static void constructor_8476( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2PadDigi>();
  else ::new(mem) ::std::vector<T2PadDigi>();
}

static void constructor_8477( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2PadDigi>(*(const ::std::allocator<T2PadDigi>*)arg[0]);
  else ::new(mem) ::std::vector<T2PadDigi>(*(const ::std::allocator<T2PadDigi>*)arg[0]);
}

static void constructor_8478( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2PadDigi>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<T2PadDigi>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2PadDigi>(*(::std::size_t*)arg[0],
      *(const ::T2PadDigi*)arg[1]);
  else ::new(mem) ::std::vector<T2PadDigi>(*(::std::size_t*)arg[0],
      *(const ::T2PadDigi*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2PadDigi>(*(::std::size_t*)arg[0],
      *(const ::T2PadDigi*)arg[1],
      *(const ::std::allocator<T2PadDigi>*)arg[2]);
  else ::new(mem) ::std::vector<T2PadDigi>(*(::std::size_t*)arg[0],
      *(const ::T2PadDigi*)arg[1],
      *(const ::std::allocator<T2PadDigi>*)arg[2]);
  }
}

static void constructor_8479( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2PadDigi>(*(const ::std::vector<T2PadDigi>*)arg[0]);
  else ::new(mem) ::std::vector<T2PadDigi>(*(const ::std::vector<T2PadDigi>*)arg[0]);
}

static void destructor_8480(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<T2PadDigi>*)o)->::std::vector<T2PadDigi>::~vector)();
}
static  void operator_8481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2PadDigi>*)o)->operator=)(*(const ::std::vector<T2PadDigi>*)arg[0]);
  else   (((::std::vector<T2PadDigi>*)o)->operator=)(*(const ::std::vector<T2PadDigi>*)arg[0]);
}

static  void method_8482( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2PadDigi>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::T2PadDigi*)arg[1]);
}

static  void method_8483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >)((((::std::vector<T2PadDigi>*)o)->begin)());
  else   (((::std::vector<T2PadDigi>*)o)->begin)();
}

static  void method_8484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2PadDigi*,std::vector<T2PadDigi> >)((((const ::std::vector<T2PadDigi>*)o)->begin)());
  else   (((const ::std::vector<T2PadDigi>*)o)->begin)();
}

static  void method_8485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >)((((::std::vector<T2PadDigi>*)o)->end)());
  else   (((::std::vector<T2PadDigi>*)o)->end)();
}

static  void method_8486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2PadDigi*,std::vector<T2PadDigi> >)((((const ::std::vector<T2PadDigi>*)o)->end)());
  else   (((const ::std::vector<T2PadDigi>*)o)->end)();
}

static  void method_8491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2PadDigi>*)o)->size)());
  else   (((const ::std::vector<T2PadDigi>*)o)->size)();
}

static  void method_8492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2PadDigi>*)o)->max_size)());
  else   (((const ::std::vector<T2PadDigi>*)o)->max_size)();
}

static  void method_8493( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<T2PadDigi>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<T2PadDigi>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::T2PadDigi*)arg[1]);
  }
}

static  void method_8494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2PadDigi>*)o)->capacity)());
  else   (((const ::std::vector<T2PadDigi>*)o)->capacity)();
}

static  void method_8495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<T2PadDigi>*)o)->empty)());
  else   (((const ::std::vector<T2PadDigi>*)o)->empty)();
}

static  void method_8496( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2PadDigi>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8497( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2PadDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2PadDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8498( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2PadDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2PadDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2PadDigi>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2PadDigi>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2PadDigi>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2PadDigi>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2PadDigi>*)o)->front)();
  else   (((::std::vector<T2PadDigi>*)o)->front)();
}

static  void method_8503( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2PadDigi>*)o)->front)();
  else   (((const ::std::vector<T2PadDigi>*)o)->front)();
}

static  void method_8504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2PadDigi>*)o)->back)();
  else   (((::std::vector<T2PadDigi>*)o)->back)();
}

static  void method_8505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2PadDigi>*)o)->back)();
  else   (((const ::std::vector<T2PadDigi>*)o)->back)();
}

static  void method_8506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<T2PadDigi>*)o)->data)());
  else   (((::std::vector<T2PadDigi>*)o)->data)();
}

static  void method_8507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<T2PadDigi>*)o)->data)());
  else   (((const ::std::vector<T2PadDigi>*)o)->data)();
}

static  void method_8508( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2PadDigi>*)o)->push_back)(*(const ::T2PadDigi*)arg[0]);
}

static  void method_8509( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2PadDigi>*)o)->pop_back)();
}

static  void method_8510( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >)((((::std::vector<T2PadDigi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >*)arg[0],
    *(const ::T2PadDigi*)arg[1]));
  else   (((::std::vector<T2PadDigi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >*)arg[0],
    *(const ::T2PadDigi*)arg[1]);
}

static  void method_8511( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2PadDigi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::T2PadDigi*)arg[2]);
}

static  void method_8512( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >)((((::std::vector<T2PadDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >*)arg[0]));
  else   (((::std::vector<T2PadDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >*)arg[0]);
}

static  void method_8513( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >)((((::std::vector<T2PadDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >*)arg[1]));
  else   (((::std::vector<T2PadDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2PadDigi*,std::vector<T2PadDigi> >*)arg[1]);
}

static  void method_8514( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2PadDigi>*)o)->swap)(*(::std::vector<T2PadDigi>*)arg[0]);
}

static  void method_8515( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2PadDigi>*)o)->clear)();
}

static void method_newdel_2536( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<T2PadDigi> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<T2PadDigi> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<T2PadDigi> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<T2PadDigi> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<T2PadDigi> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2PadDigi,std::allocator<T2PadDigi> >")), ::Reflex::BaseOffset< ::std::vector<T2PadDigi>,::std::_Vector_base<T2PadDigi,std::allocator<T2PadDigi> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<T2PadDigi> >::Generate();
  else ::Reflex::Proxy< ::std::vector<T2PadDigi> >::Generate();
}

//------Dictionary for class vector<T2PadDigi,std::allocator<T2PadDigi> > -------------------------------
void __std__vector_T2PadDigi__db_datamem(Reflex::Class*);
void __std__vector_T2PadDigi__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_T2PadDigi__datamem_bld(&__std__vector_T2PadDigi__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_T2PadDigi__funcmem_bld(&__std__vector_T2PadDigi__db_funcmem);
void __std__vector_T2PadDigi__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<T2PadDigi>"), typeid(::std::vector<T2PadDigi>), sizeof(::std::vector<T2PadDigi>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2157, ::Reflex::BaseOffset< ::std::vector<T2PadDigi>, ::std::_Vector_base<T2PadDigi,std::allocator<T2PadDigi> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1591, Reflex::Literal("std::vector<T2PadDigi>::_Alloc_value_type"))
  .AddTypedef(type_2157, Reflex::Literal("std::vector<T2PadDigi>::_Base"))
  .AddTypedef(type_2696, Reflex::Literal("std::vector<T2PadDigi>::_Tp_alloc_type"))
  .AddTypedef(type_5124, Reflex::Literal("std::vector<T2PadDigi>::_Alloc_traits"))
  .AddTypedef(type_1591, Reflex::Literal("std::vector<T2PadDigi>::value_type"))
  .AddTypedef(type_6044, Reflex::Literal("std::vector<T2PadDigi>::pointer"))
  .AddTypedef(type_8463, Reflex::Literal("std::vector<T2PadDigi>::const_pointer"))
  .AddTypedef(type_8465, Reflex::Literal("std::vector<T2PadDigi>::reference"))
  .AddTypedef(type_8467, Reflex::Literal("std::vector<T2PadDigi>::const_reference"))
  .AddTypedef(type_5055, Reflex::Literal("std::vector<T2PadDigi>::iterator"))
  .AddTypedef(type_4001, Reflex::Literal("std::vector<T2PadDigi>::const_iterator"))
  .AddTypedef(type_2794, Reflex::Literal("std::vector<T2PadDigi>::const_reverse_iterator"))
  .AddTypedef(type_2795, Reflex::Literal("std::vector<T2PadDigi>::reverse_iterator"))
  .AddTypedef(type_2680, Reflex::Literal("std::vector<T2PadDigi>::size_type"))
  .AddTypedef(type_2614, Reflex::Literal("std::vector<T2PadDigi>::difference_type"))
  .AddTypedef(type_2696, Reflex::Literal("std::vector<T2PadDigi>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8476, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16543), Reflex::Literal("vector"), constructor_8477, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2680, type_8467, type_16543), Reflex::Literal("vector"), constructor_8478, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8597), Reflex::Literal("vector"), constructor_8479, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8480, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2536, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_T2PadDigi__funcmem_bld);
}

//------Delayed data member builder for class vector<T2PadDigi,std::allocator<T2PadDigi> > -------------------
void __std__vector_T2PadDigi__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<T2PadDigi,std::allocator<T2PadDigi> > -------------------
void __std__vector_T2PadDigi__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8595, type_8597), Reflex::Literal("operator="), operator_8481, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2680, type_8467), Reflex::Literal("assign"), method_8482, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5055), Reflex::Literal("begin"), method_8483, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4001), Reflex::Literal("begin"), method_8484, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5055), Reflex::Literal("end"), method_8485, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4001), Reflex::Literal("end"), method_8486, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("size"), method_8491, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("max_size"), method_8492, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2680, type_1591), Reflex::Literal("resize"), method_8493, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("capacity"), method_8494, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_8495, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2680), Reflex::Literal("reserve"), method_8496, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8465, type_2680), Reflex::Literal("operator[]"), operator_8497, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8467, type_2680), Reflex::Literal("operator[]"), operator_8498, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8465, type_2680), Reflex::Literal("at"), method_8500, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8467, type_2680), Reflex::Literal("at"), method_8501, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8465), Reflex::Literal("front"), method_8502, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8467), Reflex::Literal("front"), method_8503, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8465), Reflex::Literal("back"), method_8504, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8467), Reflex::Literal("back"), method_8505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6044), Reflex::Literal("data"), method_8506, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8463), Reflex::Literal("data"), method_8507, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_8467), Reflex::Literal("push_back"), method_8508, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("pop_back"), method_8509, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5055, type_5055, type_8467), Reflex::Literal("insert"), method_8510, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_5055, type_2680, type_8467), Reflex::Literal("insert"), method_8511, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5055, type_5055), Reflex::Literal("erase"), method_8512, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5055, type_5055, type_5055), Reflex::Literal("erase"), method_8513, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_8595), Reflex::Literal("swap"), method_8514, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_8515, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<T2StripDigi,std::allocator<T2StripDigi> > -------------------------------
static void constructor_8541( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2StripDigi>();
  else ::new(mem) ::std::vector<T2StripDigi>();
}

static void constructor_8542( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2StripDigi>(*(const ::std::allocator<T2StripDigi>*)arg[0]);
  else ::new(mem) ::std::vector<T2StripDigi>(*(const ::std::allocator<T2StripDigi>*)arg[0]);
}

static void constructor_8543( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2StripDigi>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<T2StripDigi>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2StripDigi>(*(::std::size_t*)arg[0],
      *(const ::T2StripDigi*)arg[1]);
  else ::new(mem) ::std::vector<T2StripDigi>(*(::std::size_t*)arg[0],
      *(const ::T2StripDigi*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2StripDigi>(*(::std::size_t*)arg[0],
      *(const ::T2StripDigi*)arg[1],
      *(const ::std::allocator<T2StripDigi>*)arg[2]);
  else ::new(mem) ::std::vector<T2StripDigi>(*(::std::size_t*)arg[0],
      *(const ::T2StripDigi*)arg[1],
      *(const ::std::allocator<T2StripDigi>*)arg[2]);
  }
}

static void constructor_8544( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2StripDigi>(*(const ::std::vector<T2StripDigi>*)arg[0]);
  else ::new(mem) ::std::vector<T2StripDigi>(*(const ::std::vector<T2StripDigi>*)arg[0]);
}

static void destructor_8545(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<T2StripDigi>*)o)->::std::vector<T2StripDigi>::~vector)();
}
static  void operator_8546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2StripDigi>*)o)->operator=)(*(const ::std::vector<T2StripDigi>*)arg[0]);
  else   (((::std::vector<T2StripDigi>*)o)->operator=)(*(const ::std::vector<T2StripDigi>*)arg[0]);
}

static  void method_8547( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2StripDigi>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::T2StripDigi*)arg[1]);
}

static  void method_8548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >)((((::std::vector<T2StripDigi>*)o)->begin)());
  else   (((::std::vector<T2StripDigi>*)o)->begin)();
}

static  void method_8549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2StripDigi*,std::vector<T2StripDigi> >)((((const ::std::vector<T2StripDigi>*)o)->begin)());
  else   (((const ::std::vector<T2StripDigi>*)o)->begin)();
}

static  void method_8550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >)((((::std::vector<T2StripDigi>*)o)->end)());
  else   (((::std::vector<T2StripDigi>*)o)->end)();
}

static  void method_8551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2StripDigi*,std::vector<T2StripDigi> >)((((const ::std::vector<T2StripDigi>*)o)->end)());
  else   (((const ::std::vector<T2StripDigi>*)o)->end)();
}

static  void method_8556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2StripDigi>*)o)->size)());
  else   (((const ::std::vector<T2StripDigi>*)o)->size)();
}

static  void method_8557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2StripDigi>*)o)->max_size)());
  else   (((const ::std::vector<T2StripDigi>*)o)->max_size)();
}

static  void method_8558( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<T2StripDigi>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<T2StripDigi>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::T2StripDigi*)arg[1]);
  }
}

static  void method_8559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2StripDigi>*)o)->capacity)());
  else   (((const ::std::vector<T2StripDigi>*)o)->capacity)();
}

static  void method_8560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<T2StripDigi>*)o)->empty)());
  else   (((const ::std::vector<T2StripDigi>*)o)->empty)();
}

static  void method_8561( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2StripDigi>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2StripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2StripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2StripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2StripDigi>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2StripDigi>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2StripDigi>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2StripDigi>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2StripDigi>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2StripDigi>*)o)->front)();
  else   (((::std::vector<T2StripDigi>*)o)->front)();
}

static  void method_8568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2StripDigi>*)o)->front)();
  else   (((const ::std::vector<T2StripDigi>*)o)->front)();
}

static  void method_8569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2StripDigi>*)o)->back)();
  else   (((::std::vector<T2StripDigi>*)o)->back)();
}

static  void method_8570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2StripDigi>*)o)->back)();
  else   (((const ::std::vector<T2StripDigi>*)o)->back)();
}

static  void method_8571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<T2StripDigi>*)o)->data)());
  else   (((::std::vector<T2StripDigi>*)o)->data)();
}

static  void method_8572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<T2StripDigi>*)o)->data)());
  else   (((const ::std::vector<T2StripDigi>*)o)->data)();
}

static  void method_8573( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2StripDigi>*)o)->push_back)(*(const ::T2StripDigi*)arg[0]);
}

static  void method_8574( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2StripDigi>*)o)->pop_back)();
}

static  void method_8575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >)((((::std::vector<T2StripDigi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >*)arg[0],
    *(const ::T2StripDigi*)arg[1]));
  else   (((::std::vector<T2StripDigi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >*)arg[0],
    *(const ::T2StripDigi*)arg[1]);
}

static  void method_8576( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2StripDigi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::T2StripDigi*)arg[2]);
}

static  void method_8577( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >)((((::std::vector<T2StripDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >*)arg[0]));
  else   (((::std::vector<T2StripDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >*)arg[0]);
}

static  void method_8578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >)((((::std::vector<T2StripDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >*)arg[1]));
  else   (((::std::vector<T2StripDigi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2StripDigi*,std::vector<T2StripDigi> >*)arg[1]);
}

static  void method_8579( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2StripDigi>*)o)->swap)(*(::std::vector<T2StripDigi>*)arg[0]);
}

static  void method_8580( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2StripDigi>*)o)->clear)();
}

static void method_newdel_2537( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<T2StripDigi> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<T2StripDigi> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<T2StripDigi> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<T2StripDigi> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<T2StripDigi> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2StripDigi,std::allocator<T2StripDigi> >")), ::Reflex::BaseOffset< ::std::vector<T2StripDigi>,::std::_Vector_base<T2StripDigi,std::allocator<T2StripDigi> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<T2StripDigi> >::Generate();
  else ::Reflex::Proxy< ::std::vector<T2StripDigi> >::Generate();
}

//------Dictionary for class vector<T2StripDigi,std::allocator<T2StripDigi> > -------------------------------
void __std__vector_T2StripDigi__db_datamem(Reflex::Class*);
void __std__vector_T2StripDigi__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_T2StripDigi__datamem_bld(&__std__vector_T2StripDigi__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_T2StripDigi__funcmem_bld(&__std__vector_T2StripDigi__db_funcmem);
void __std__vector_T2StripDigi__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<T2StripDigi>"), typeid(::std::vector<T2StripDigi>), sizeof(::std::vector<T2StripDigi>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2158, ::Reflex::BaseOffset< ::std::vector<T2StripDigi>, ::std::_Vector_base<T2StripDigi,std::allocator<T2StripDigi> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_801, Reflex::Literal("std::vector<T2StripDigi>::_Alloc_value_type"))
  .AddTypedef(type_2158, Reflex::Literal("std::vector<T2StripDigi>::_Base"))
  .AddTypedef(type_2697, Reflex::Literal("std::vector<T2StripDigi>::_Tp_alloc_type"))
  .AddTypedef(type_5125, Reflex::Literal("std::vector<T2StripDigi>::_Alloc_traits"))
  .AddTypedef(type_801, Reflex::Literal("std::vector<T2StripDigi>::value_type"))
  .AddTypedef(type_6063, Reflex::Literal("std::vector<T2StripDigi>::pointer"))
  .AddTypedef(type_8528, Reflex::Literal("std::vector<T2StripDigi>::const_pointer"))
  .AddTypedef(type_8530, Reflex::Literal("std::vector<T2StripDigi>::reference"))
  .AddTypedef(type_8532, Reflex::Literal("std::vector<T2StripDigi>::const_reference"))
  .AddTypedef(type_5056, Reflex::Literal("std::vector<T2StripDigi>::iterator"))
  .AddTypedef(type_4432, Reflex::Literal("std::vector<T2StripDigi>::const_iterator"))
  .AddTypedef(type_2796, Reflex::Literal("std::vector<T2StripDigi>::const_reverse_iterator"))
  .AddTypedef(type_2797, Reflex::Literal("std::vector<T2StripDigi>::reverse_iterator"))
  .AddTypedef(type_2680, Reflex::Literal("std::vector<T2StripDigi>::size_type"))
  .AddTypedef(type_2614, Reflex::Literal("std::vector<T2StripDigi>::difference_type"))
  .AddTypedef(type_2697, Reflex::Literal("std::vector<T2StripDigi>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8541, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16556), Reflex::Literal("vector"), constructor_8542, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2680, type_8532, type_16556), Reflex::Literal("vector"), constructor_8543, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8662), Reflex::Literal("vector"), constructor_8544, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8545, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2537, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_T2StripDigi__funcmem_bld);
}

//------Delayed data member builder for class vector<T2StripDigi,std::allocator<T2StripDigi> > -------------------
void __std__vector_T2StripDigi__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<T2StripDigi,std::allocator<T2StripDigi> > -------------------
void __std__vector_T2StripDigi__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8660, type_8662), Reflex::Literal("operator="), operator_8546, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2680, type_8532), Reflex::Literal("assign"), method_8547, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5056), Reflex::Literal("begin"), method_8548, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4432), Reflex::Literal("begin"), method_8549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5056), Reflex::Literal("end"), method_8550, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4432), Reflex::Literal("end"), method_8551, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("size"), method_8556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("max_size"), method_8557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2680, type_801), Reflex::Literal("resize"), method_8558, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("capacity"), method_8559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_8560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2680), Reflex::Literal("reserve"), method_8561, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530, type_2680), Reflex::Literal("operator[]"), operator_8562, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8532, type_2680), Reflex::Literal("operator[]"), operator_8563, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530, type_2680), Reflex::Literal("at"), method_8565, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8532, type_2680), Reflex::Literal("at"), method_8566, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530), Reflex::Literal("front"), method_8567, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8532), Reflex::Literal("front"), method_8568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8530), Reflex::Literal("back"), method_8569, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8532), Reflex::Literal("back"), method_8570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6063), Reflex::Literal("data"), method_8571, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8528), Reflex::Literal("data"), method_8572, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_8532), Reflex::Literal("push_back"), method_8573, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("pop_back"), method_8574, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5056, type_5056, type_8532), Reflex::Literal("insert"), method_8575, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_5056, type_2680, type_8532), Reflex::Literal("insert"), method_8576, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5056, type_5056), Reflex::Literal("erase"), method_8577, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5056, type_5056, type_5056), Reflex::Literal("erase"), method_8578, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_8660), Reflex::Literal("swap"), method_8579, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_8580, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<T2DetId,std::vector<T2PadDigi, std::allocator<T2PadDigi> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2PadDigi, std::allocator<T2PadDigi> > > > > -------------------------------
static void destructor_9885(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->::std::map<T2DetId,std::vector<T2PadDigi> >::~map)();
}
static void constructor_9886( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2PadDigi> >();
  else ::new(mem) ::std::map<T2DetId,std::vector<T2PadDigi> >();
}

static void constructor_9887( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2PadDigi> >(*(const ::std::less<T2DetId>*)arg[0]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2PadDigi> >(*(const ::std::less<T2DetId>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2PadDigi> >(*(const ::std::less<T2DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const T2DetId,std::vector<T2PadDigi> > >*)arg[1]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2PadDigi> >(*(const ::std::less<T2DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const T2DetId,std::vector<T2PadDigi> > >*)arg[1]);
  }
}

static void constructor_9888( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2PadDigi> >(*(const ::std::map<T2DetId,std::vector<T2PadDigi> >*)arg[0]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2PadDigi> >(*(const ::std::map<T2DetId,std::vector<T2PadDigi> >*)arg[0]);
}

static  void operator_9889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->operator=)(*(const ::std::map<T2DetId,std::vector<T2PadDigi> >*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->operator=)(*(const ::std::map<T2DetId,std::vector<T2PadDigi> >*)arg[0]);
}

static  void method_9890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->get_allocator)());
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->get_allocator)();
}

static  void method_9891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->begin)());
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->begin)();
}

static  void method_9892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->begin)());
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->begin)();
}

static  void method_9893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->end)());
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->end)();
}

static  void method_9894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->end)());
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->end)();
}

static  void method_9899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->empty)());
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->empty)();
}

static  void method_9900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->size)());
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->size)();
}

static  void method_9901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->max_size)());
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->max_size)();
}

static  void operator_9902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->operator[])(*(const ::T2DetId*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->operator[])(*(const ::T2DetId*)arg[0]);
}

static  void method_9903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->at)(*(const ::T2DetId*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->at)(*(const ::T2DetId*)arg[0]);
}

static  void method_9904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->at)(*(const ::T2DetId*)arg[0]);
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->at)(*(const ::T2DetId*)arg[0]);
}

static  void method_9905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >,bool>)((((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->insert)(*(const ::std::pair<const T2DetId,std::vector<T2PadDigi> >*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->insert)(*(const ::std::pair<const T2DetId,std::vector<T2PadDigi> >*)arg[0]);
}

static  void method_9906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >*)arg[0],
    *(const ::std::pair<const T2DetId,std::vector<T2PadDigi> >*)arg[1]));
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >*)arg[0],
    *(const ::std::pair<const T2DetId,std::vector<T2PadDigi> >*)arg[1]);
}

static  void method_9907( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >*)arg[0]);
}

static  void method_9908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->erase)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->erase)(*(const ::T2DetId*)arg[0]);
}

static  void method_9909( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >*)arg[1]);
}

static  void method_9910( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->swap)(*(::std::map<T2DetId,std::vector<T2PadDigi> >*)arg[0]);
}

static  void method_9911( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->clear)();
}

static  void method_9912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<T2DetId>)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->key_comp)());
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->key_comp)();
}

static  void method_9914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->find)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->find)(*(const ::T2DetId*)arg[0]);
}

static  void method_9915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->find)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->find)(*(const ::T2DetId*)arg[0]);
}

static  void method_9916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->count)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->count)(*(const ::T2DetId*)arg[0]);
}

static  void method_9917( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >,std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > > >)((((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]);
}

static  void method_9922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > >,std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2PadDigi> > > >)((((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2PadDigi> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]);
}

static void method_newdel_2637( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2PadDigi> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2PadDigi> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2PadDigi> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2PadDigi> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2PadDigi> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<T2DetId,std::vector<T2PadDigi> > >::Generate();
  else ::Reflex::Proxy< ::std::map<T2DetId,std::vector<T2PadDigi> > >::Generate();
}

//------Dictionary for class map<T2DetId,std::vector<T2PadDigi, std::allocator<T2PadDigi> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2PadDigi, std::allocator<T2PadDigi> > > > > -------------------------------
void __std__map_T2DetId_std__vector_T2PadDigi_s__db_datamem(Reflex::Class*);
void __std__map_T2DetId_std__vector_T2PadDigi_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_T2DetId_std__vector_T2PadDigi_s__datamem_bld(&__std__map_T2DetId_std__vector_T2PadDigi_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_T2DetId_std__vector_T2PadDigi_s__funcmem_bld(&__std__map_T2DetId_std__vector_T2PadDigi_s__db_funcmem);
void __std__map_T2DetId_std__vector_T2PadDigi_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >"), typeid(::std::map<T2DetId,std::vector<T2PadDigi> >), sizeof(::std::map<T2DetId,std::vector<T2PadDigi> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_774, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::key_type"))
  .AddTypedef(type_2536, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::mapped_type"))
  .AddTypedef(type_2503, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::value_type"))
  .AddTypedef(type_2279, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::key_compare"))
  .AddTypedef(type_2699, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::allocator_type"))
  .AddTypedef(type_2503, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::_Alloc_value_type"))
  .AddTypedef(type_2699, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::_Pair_alloc_type"))
  .AddTypedef(type_2326, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::_Rep_type"))
  .AddTypedef(type_7363, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::pointer"))
  .AddTypedef(type_7365, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::const_pointer"))
  .AddTypedef(type_7367, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::reference"))
  .AddTypedef(type_7369, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::const_reference"))
  .AddTypedef(type_2589, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::iterator"))
  .AddTypedef(type_2682, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::const_iterator"))
  .AddTypedef(type_2680, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::size_type"))
  .AddTypedef(type_2614, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::difference_type"))
  .AddTypedef(type_2787, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::reverse_iterator"))
  .AddTypedef(type_2786, Reflex::Literal("std::map<T2DetId,std::vector<T2PadDigi> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_9885, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_9886, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16956, type_17035), Reflex::Literal("map"), constructor_9887, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17309), Reflex::Literal("map"), constructor_9888, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2637, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_T2DetId_std__vector_T2PadDigi_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_T2DetId_std__vector_T2PadDigi_s__funcmem_bld);
}

//------Delayed data member builder for class map<T2DetId,std::vector<T2PadDigi, std::allocator<T2PadDigi> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2PadDigi, std::allocator<T2PadDigi> > > > > -------------------
void __std__map_T2DetId_std__vector_T2PadDigi_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2326, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_T2DetId_std__vector_T2PadDigi_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<T2DetId,std::vector<T2PadDigi, std::allocator<T2PadDigi> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2PadDigi, std::allocator<T2PadDigi> > > > > -------------------
void __std__map_T2DetId_std__vector_T2PadDigi_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17310, type_17309), Reflex::Literal("operator="), operator_9889, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699), Reflex::Literal("get_allocator"), method_9890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589), Reflex::Literal("begin"), method_9891, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2682), Reflex::Literal("begin"), method_9892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589), Reflex::Literal("end"), method_9893, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2682), Reflex::Literal("end"), method_9894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_9899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("size"), method_9900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("max_size"), method_9901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8595, type_4168), Reflex::Literal("operator[]"), operator_9902, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8595, type_4168), Reflex::Literal("at"), method_9903, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8597, type_4168), Reflex::Literal("at"), method_9904, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2505, type_7369), Reflex::Literal("insert"), method_9905, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589, type_2589, type_7369), Reflex::Literal("insert"), method_9906, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2589), Reflex::Literal("erase"), method_9907, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680, type_4168), Reflex::Literal("erase"), method_9908, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2589, type_2589), Reflex::Literal("erase"), method_9909, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_17310), Reflex::Literal("swap"), method_9910, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_9911, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2279), Reflex::Literal("key_comp"), method_9912, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589, type_4168), Reflex::Literal("find"), method_9914, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2682, type_4168), Reflex::Literal("find"), method_9915, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680, type_4168), Reflex::Literal("count"), method_9916, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589, type_4168), Reflex::Literal("lower_bound"), method_9917, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2682, type_4168), Reflex::Literal("lower_bound"), method_9918, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2589, type_4168), Reflex::Literal("upper_bound"), method_9919, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2682, type_4168), Reflex::Literal("upper_bound"), method_9920, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504, type_4168), Reflex::Literal("equal_range"), method_9921, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2502, type_4168), Reflex::Literal("equal_range"), method_9922, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<T2DetId,std::vector<T2StripDigi, std::allocator<T2StripDigi> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2StripDigi, std::allocator<T2StripDigi> > > > > -------------------------------
static void destructor_9943(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->::std::map<T2DetId,std::vector<T2StripDigi> >::~map)();
}
static void constructor_9944( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2StripDigi> >();
  else ::new(mem) ::std::map<T2DetId,std::vector<T2StripDigi> >();
}

static void constructor_9945( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2StripDigi> >(*(const ::std::less<T2DetId>*)arg[0]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2StripDigi> >(*(const ::std::less<T2DetId>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2StripDigi> >(*(const ::std::less<T2DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const T2DetId,std::vector<T2StripDigi> > >*)arg[1]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2StripDigi> >(*(const ::std::less<T2DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const T2DetId,std::vector<T2StripDigi> > >*)arg[1]);
  }
}

static void constructor_9946( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2StripDigi> >(*(const ::std::map<T2DetId,std::vector<T2StripDigi> >*)arg[0]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2StripDigi> >(*(const ::std::map<T2DetId,std::vector<T2StripDigi> >*)arg[0]);
}

static  void operator_9947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->operator=)(*(const ::std::map<T2DetId,std::vector<T2StripDigi> >*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->operator=)(*(const ::std::map<T2DetId,std::vector<T2StripDigi> >*)arg[0]);
}

static  void method_9948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->get_allocator)());
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->get_allocator)();
}

static  void method_9949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->begin)());
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->begin)();
}

static  void method_9950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->begin)());
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->begin)();
}

static  void method_9951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->end)());
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->end)();
}

static  void method_9952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->end)());
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->end)();
}

static  void method_9957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->empty)());
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->empty)();
}

static  void method_9958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->size)());
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->size)();
}

static  void method_9959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->max_size)());
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->max_size)();
}

static  void operator_9960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->operator[])(*(const ::T2DetId*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->operator[])(*(const ::T2DetId*)arg[0]);
}

static  void method_9961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->at)(*(const ::T2DetId*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->at)(*(const ::T2DetId*)arg[0]);
}

static  void method_9962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->at)(*(const ::T2DetId*)arg[0]);
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->at)(*(const ::T2DetId*)arg[0]);
}

static  void method_9963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >,bool>)((((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->insert)(*(const ::std::pair<const T2DetId,std::vector<T2StripDigi> >*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->insert)(*(const ::std::pair<const T2DetId,std::vector<T2StripDigi> >*)arg[0]);
}

static  void method_9964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >*)arg[0],
    *(const ::std::pair<const T2DetId,std::vector<T2StripDigi> >*)arg[1]));
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >*)arg[0],
    *(const ::std::pair<const T2DetId,std::vector<T2StripDigi> >*)arg[1]);
}

static  void method_9965( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >*)arg[0]);
}

static  void method_9966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->erase)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->erase)(*(const ::T2DetId*)arg[0]);
}

static  void method_9967( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >*)arg[1]);
}

static  void method_9968( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->swap)(*(::std::map<T2DetId,std::vector<T2StripDigi> >*)arg[0]);
}

static  void method_9969( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->clear)();
}

static  void method_9970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<T2DetId>)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->key_comp)());
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->key_comp)();
}

static  void method_9972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->find)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->find)(*(const ::T2DetId*)arg[0]);
}

static  void method_9973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->find)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->find)(*(const ::T2DetId*)arg[0]);
}

static  void method_9974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->count)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->count)(*(const ::T2DetId*)arg[0]);
}

static  void method_9975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_9979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >,std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > > >)((((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]);
}

static  void method_9980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > >,std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2StripDigi> > > >)((((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2StripDigi> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]);
}

static void method_newdel_2638( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2StripDigi> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2StripDigi> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2StripDigi> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2StripDigi> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2StripDigi> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<T2DetId,std::vector<T2StripDigi> > >::Generate();
  else ::Reflex::Proxy< ::std::map<T2DetId,std::vector<T2StripDigi> > >::Generate();
}

//------Dictionary for class map<T2DetId,std::vector<T2StripDigi, std::allocator<T2StripDigi> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2StripDigi, std::allocator<T2StripDigi> > > > > -------------------------------
void __std__map_T2DetId_std__vector_T2StripDigi_s__db_datamem(Reflex::Class*);
void __std__map_T2DetId_std__vector_T2StripDigi_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_T2DetId_std__vector_T2StripDigi_s__datamem_bld(&__std__map_T2DetId_std__vector_T2StripDigi_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_T2DetId_std__vector_T2StripDigi_s__funcmem_bld(&__std__map_T2DetId_std__vector_T2StripDigi_s__db_funcmem);
void __std__map_T2DetId_std__vector_T2StripDigi_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >"), typeid(::std::map<T2DetId,std::vector<T2StripDigi> >), sizeof(::std::map<T2DetId,std::vector<T2StripDigi> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_774, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::key_type"))
  .AddTypedef(type_2537, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::mapped_type"))
  .AddTypedef(type_2509, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::value_type"))
  .AddTypedef(type_2279, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::key_compare"))
  .AddTypedef(type_2701, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::allocator_type"))
  .AddTypedef(type_2509, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::_Alloc_value_type"))
  .AddTypedef(type_2701, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::_Pair_alloc_type"))
  .AddTypedef(type_2327, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::_Rep_type"))
  .AddTypedef(type_7472, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::pointer"))
  .AddTypedef(type_7474, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::const_pointer"))
  .AddTypedef(type_7476, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::reference"))
  .AddTypedef(type_7478, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::const_reference"))
  .AddTypedef(type_2590, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::iterator"))
  .AddTypedef(type_2683, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::const_iterator"))
  .AddTypedef(type_2680, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::size_type"))
  .AddTypedef(type_2614, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::difference_type"))
  .AddTypedef(type_2789, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::reverse_iterator"))
  .AddTypedef(type_2788, Reflex::Literal("std::map<T2DetId,std::vector<T2StripDigi> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_9943, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_9944, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16956, type_17043), Reflex::Literal("map"), constructor_9945, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17311), Reflex::Literal("map"), constructor_9946, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2638, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_T2DetId_std__vector_T2StripDigi_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_T2DetId_std__vector_T2StripDigi_s__funcmem_bld);
}

//------Delayed data member builder for class map<T2DetId,std::vector<T2StripDigi, std::allocator<T2StripDigi> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2StripDigi, std::allocator<T2StripDigi> > > > > -------------------
void __std__map_T2DetId_std__vector_T2StripDigi_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2327, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_T2DetId_std__vector_T2StripDigi_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<T2DetId,std::vector<T2StripDigi, std::allocator<T2StripDigi> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2StripDigi, std::allocator<T2StripDigi> > > > > -------------------
void __std__map_T2DetId_std__vector_T2StripDigi_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17312, type_17311), Reflex::Literal("operator="), operator_9947, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2701), Reflex::Literal("get_allocator"), method_9948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2590), Reflex::Literal("begin"), method_9949, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2683), Reflex::Literal("begin"), method_9950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2590), Reflex::Literal("end"), method_9951, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2683), Reflex::Literal("end"), method_9952, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("empty"), method_9957, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("size"), method_9958, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("max_size"), method_9959, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8660, type_4168), Reflex::Literal("operator[]"), operator_9960, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8660, type_4168), Reflex::Literal("at"), method_9961, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8662, type_4168), Reflex::Literal("at"), method_9962, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2511, type_7478), Reflex::Literal("insert"), method_9963, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2590, type_2590, type_7478), Reflex::Literal("insert"), method_9964, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2590), Reflex::Literal("erase"), method_9965, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680, type_4168), Reflex::Literal("erase"), method_9966, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2590, type_2590), Reflex::Literal("erase"), method_9967, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_17312), Reflex::Literal("swap"), method_9968, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_9969, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2279), Reflex::Literal("key_comp"), method_9970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2590, type_4168), Reflex::Literal("find"), method_9972, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2683, type_4168), Reflex::Literal("find"), method_9973, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680, type_4168), Reflex::Literal("count"), method_9974, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2590, type_4168), Reflex::Literal("lower_bound"), method_9975, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2683, type_4168), Reflex::Literal("lower_bound"), method_9976, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2590, type_4168), Reflex::Literal("upper_bound"), method_9977, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2683, type_4168), Reflex::Literal("upper_bound"), method_9978, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2510, type_4168), Reflex::Literal("equal_range"), method_9979, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2508, type_4168), Reflex::Literal("equal_range"), method_9980, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::pair<T2DetId, std::vector<T2PadDigi, std::allocator<T2PadDigi> > > > -------------------------------
static void constructor_12821( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >();
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >();
}

static void constructor_12822( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >(*(::std::auto_ptr<std::pair<T2DetId,std::vector<T2PadDigi> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >(*(::std::auto_ptr<std::pair<T2DetId,std::vector<T2PadDigi> > >*)arg[0]);
}

static void destructor_12823(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >::~Wrapper)();
}
static  void method_12824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->product)();
}

static  void operator_12825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->operator->)();
}

static  void method_12826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->productTypeInfo)();
}

static  void method_12827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->typeInfo)();
}

static void constructor_12828( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >((::std::pair<T2DetId,std::vector<T2PadDigi> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >((::std::pair<T2DetId,std::vector<T2PadDigi> >*)arg[0]);
}

static  void method_12829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->getInterface)();
}

static  void method_12830( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12831( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12832( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->dynamicTypeInfo)();
}

static  void method_12834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->isPresent)();
}

static  void method_12835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3374( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::pair<T2DetId, std::vector<T2PadDigi, std::allocator<T2PadDigi> > > > -------------------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__datamem_bld(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__funcmem_bld(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__db_funcmem);
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >"), typeid(::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >), sizeof(::edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2500, Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >::value_type"))
  .AddTypedef(type_2500, Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12821, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2366), Reflex::Literal("Wrapper"), constructor_12822, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12823, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19056), Reflex::Literal("Wrapper"), constructor_12828, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3374, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::pair<T2DetId, std::vector<T2PadDigi, std::allocator<T2PadDigi> > > > -------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2500, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::pair<T2DetId, std::vector<T2PadDigi, std::allocator<T2PadDigi> > > > -------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19055), Reflex::Literal("product"), method_12824, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19055), Reflex::Literal("operator->"), operator_12825, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("productTypeInfo"), method_12826, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("typeInfo"), method_12827, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19057), Reflex::Literal("getInterface"), method_12829, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12931, type_17194, type_18980), Reflex::Literal("fillView"), method_12830, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_11629, type_274, type_6784), Reflex::Literal("setPtr"), method_12831, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_11629, type_17195, type_17194), Reflex::Literal("fillPtrVector"), method_12832, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("dynamicTypeInfo"), method_12833, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_12834, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("dynamicTypeInfo_"), method_12835, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TotemDigiCollection<T2DetId, T2PadDigi> > -------------------------------
static void constructor_12842( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >();
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >();
}

static void constructor_12843( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >(*(::std::auto_ptr<TotemDigiCollection<T2DetId,T2PadDigi> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >(*(::std::auto_ptr<TotemDigiCollection<T2DetId,T2PadDigi> >*)arg[0]);
}

static void destructor_12844(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >::~Wrapper)();
}
static  void method_12845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->product)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->product)();
}

static  void operator_12846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->operator->)();
}

static  void method_12847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->productTypeInfo)();
}

static  void method_12848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->typeInfo)();
}

static void constructor_12849( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >((::TotemDigiCollection<T2DetId,T2PadDigi>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >((::TotemDigiCollection<T2DetId,T2PadDigi>*)arg[0]);
}

static  void method_12850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->getInterface)());
  else   (((::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->getInterface)();
}

static  void method_12851( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12852( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12853( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->dynamicTypeInfo)();
}

static  void method_12855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->isPresent)();
}

static  void method_12856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3375( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TotemDigiCollection<T2DetId, T2PadDigi> > -------------------------------
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__datamem_bld(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__funcmem_bld(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__db_funcmem);
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >"), typeid(::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >), sizeof(::edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "1029384756")
  .AddTypedef(type_804, Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >::value_type"))
  .AddTypedef(type_804, Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12842, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367), Reflex::Literal("Wrapper"), constructor_12843, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12844, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19061), Reflex::Literal("Wrapper"), constructor_12849, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3375, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TotemDigiCollection<T2DetId, T2PadDigi> > -------------------
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_804, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TotemDigiCollection<T2DetId, T2PadDigi> > -------------------
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19060), Reflex::Literal("product"), method_12845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19060), Reflex::Literal("operator->"), operator_12846, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("productTypeInfo"), method_12847, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("typeInfo"), method_12848, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19062), Reflex::Literal("getInterface"), method_12850, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12931, type_17194, type_18980), Reflex::Literal("fillView"), method_12851, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_11629, type_274, type_6784), Reflex::Literal("setPtr"), method_12852, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_11629, type_17195, type_17194), Reflex::Literal("fillPtrVector"), method_12853, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("dynamicTypeInfo"), method_12854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_12855, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("dynamicTypeInfo_"), method_12856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::pair<T2DetId, std::vector<T2StripDigi, std::allocator<T2StripDigi> > > > -------------------------------
static void constructor_12863( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >();
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >();
}

static void constructor_12864( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >(*(::std::auto_ptr<std::pair<T2DetId,std::vector<T2StripDigi> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >(*(::std::auto_ptr<std::pair<T2DetId,std::vector<T2StripDigi> > >*)arg[0]);
}

static void destructor_12865(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >::~Wrapper)();
}
static  void method_12866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->product)();
}

static  void operator_12867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->operator->)();
}

static  void method_12868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->productTypeInfo)();
}

static  void method_12869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->typeInfo)();
}

static void constructor_12870( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >((::std::pair<T2DetId,std::vector<T2StripDigi> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >((::std::pair<T2DetId,std::vector<T2StripDigi> >*)arg[0]);
}

static  void method_12871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->getInterface)();
}

static  void method_12872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12873( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12874( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->dynamicTypeInfo)();
}

static  void method_12876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->isPresent)();
}

static  void method_12877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3376( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::pair<T2DetId, std::vector<T2StripDigi, std::allocator<T2StripDigi> > > > -------------------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__datamem_bld(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__funcmem_bld(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__db_funcmem);
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >"), typeid(::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >), sizeof(::edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2501, Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >::value_type"))
  .AddTypedef(type_2501, Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12863, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2368), Reflex::Literal("Wrapper"), constructor_12864, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12865, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19066), Reflex::Literal("Wrapper"), constructor_12870, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3376, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::pair<T2DetId, std::vector<T2StripDigi, std::allocator<T2StripDigi> > > > -------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2501, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::pair<T2DetId, std::vector<T2StripDigi, std::allocator<T2StripDigi> > > > -------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19065), Reflex::Literal("product"), method_12866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19065), Reflex::Literal("operator->"), operator_12867, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("productTypeInfo"), method_12868, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("typeInfo"), method_12869, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19067), Reflex::Literal("getInterface"), method_12871, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12931, type_17194, type_18980), Reflex::Literal("fillView"), method_12872, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_11629, type_274, type_6784), Reflex::Literal("setPtr"), method_12873, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_11629, type_17195, type_17194), Reflex::Literal("fillPtrVector"), method_12874, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("dynamicTypeInfo"), method_12875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_12876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("dynamicTypeInfo_"), method_12877, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TotemDigiCollection<T2DetId, T2StripDigi> > -------------------------------
static void constructor_12884( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >();
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >();
}

static void constructor_12885( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >(*(::std::auto_ptr<TotemDigiCollection<T2DetId,T2StripDigi> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >(*(::std::auto_ptr<TotemDigiCollection<T2DetId,T2StripDigi> >*)arg[0]);
}

static void destructor_12886(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >::~Wrapper)();
}
static  void method_12887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->product)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->product)();
}

static  void operator_12888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->operator->)();
}

static  void method_12889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->productTypeInfo)();
}

static  void method_12890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->typeInfo)();
}

static void constructor_12891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >((::TotemDigiCollection<T2DetId,T2StripDigi>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >((::TotemDigiCollection<T2DetId,T2StripDigi>*)arg[0]);
}

static  void method_12892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->getInterface)());
  else   (((::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->getInterface)();
}

static  void method_12893( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12894( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->dynamicTypeInfo)();
}

static  void method_12897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->isPresent)();
}

static  void method_12898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3377( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TotemDigiCollection<T2DetId, T2StripDigi> > -------------------------------
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__datamem_bld(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__funcmem_bld(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__db_funcmem);
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >"), typeid(::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >), sizeof(::edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassID"), "1234567890")
  .AddTypedef(type_1189, Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >::value_type"))
  .AddTypedef(type_1189, Reflex::Literal("edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12884, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2369), Reflex::Literal("Wrapper"), constructor_12885, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12886, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19071), Reflex::Literal("Wrapper"), constructor_12891, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3377, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TotemDigiCollection<T2DetId, T2StripDigi> > -------------------
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1372, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1189, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TotemDigiCollection<T2DetId, T2StripDigi> > -------------------
void __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19070), Reflex::Literal("product"), method_12887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19070), Reflex::Literal("operator->"), operator_12888, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("productTypeInfo"), method_12889, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("typeInfo"), method_12890, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19072), Reflex::Literal("getInterface"), method_12892, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12931, type_17194, type_18980), Reflex::Literal("fillView"), method_12893, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_11629, type_274, type_6784), Reflex::Literal("setPtr"), method_12894, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_11629, type_17195, type_17194), Reflex::Literal("fillPtrVector"), method_12895, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("dynamicTypeInfo"), method_12896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1372), Reflex::Literal("isPresent"), method_12897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11629), Reflex::Literal("dynamicTypeInfo_"), method_12898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __T2StripDigi_dict(); 
      __TotemDigiCollection_T2DetId_T2PadDigi__dict(); 
      __TotemDigiCollection_T2DetId_T2StripDigi__dict(); 
      __T2PadDigi_dict(); 
      __std__pair_T2DetId_std__vector_T2PadDigi_s__dict(); 
      __std__pair_T2DetId_std__vector_T2StripDigi_s__dict(); 
      __std__vector_T2PadDigi__dict(); 
      __std__vector_T2StripDigi__dict(); 
      __std__map_T2DetId_std__vector_T2PadDigi_s__dict(); 
      __std__map_T2DetId_std__vector_T2StripDigi_s__dict(); 
      __edm__Wrapper_std__pair_T2DetId_std__vector_T2PadDigi_s_s__dict(); 
      __edm__Wrapper_TotemDigiCollection_T2DetId_T2PadDigi_s__dict(); 
      __edm__Wrapper_std__pair_T2DetId_std__vector_T2StripDigi_s_s__dict(); 
      __edm__Wrapper_TotemDigiCollection_T2DetId_T2StripDigi_s__dict(); 
    }
    ~Dictionaries() {
      type_801.Unload(); // class T2StripDigi 
      type_804.Unload(); // class TotemDigiCollection<T2DetId,T2PadDigi> 
      type_1189.Unload(); // class TotemDigiCollection<T2DetId,T2StripDigi> 
      type_1591.Unload(); // class T2PadDigi 
      type_2500.Unload(); // class std::pair<T2DetId,std::vector<T2PadDigi> > 
      type_2501.Unload(); // class std::pair<T2DetId,std::vector<T2StripDigi> > 
      type_2536.Unload(); // class std::vector<T2PadDigi> 
      type_2537.Unload(); // class std::vector<T2StripDigi> 
      type_2637.Unload(); // class std::map<T2DetId,std::vector<T2PadDigi> > 
      type_2638.Unload(); // class std::map<T2DetId,std::vector<T2StripDigi> > 
      type_3374.Unload(); // class edm::Wrapper<std::pair<T2DetId,std::vector<T2PadDigi> > > 
      type_3375.Unload(); // class edm::Wrapper<TotemDigiCollection<T2DetId,T2PadDigi> > 
      type_3376.Unload(); // class edm::Wrapper<std::pair<T2DetId,std::vector<T2StripDigi> > > 
      type_3377.Unload(); // class edm::Wrapper<TotemDigiCollection<T2DetId,T2StripDigi> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
