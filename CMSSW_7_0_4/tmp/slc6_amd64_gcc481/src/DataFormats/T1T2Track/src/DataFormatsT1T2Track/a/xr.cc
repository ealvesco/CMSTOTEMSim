// Generated at Mon Jul 11 23:13:34 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/T1T2Track/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_64 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_693 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_348 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_875 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1562 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_100 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_755 = ::Reflex::TypeBuilder(Reflex::Literal("T2Road"));
  ::Reflex::Type type_1570 = ::Reflex::TypeBuilder(Reflex::Literal("T2Hit"));
  ::Reflex::Type type_181 = ::Reflex::TypeBuilder(Reflex::Literal("T1DetId"));
  ::Reflex::Type type_570 = ::Reflex::TypeBuilder(Reflex::Literal("T1T2Track"));
  ::Reflex::Type type_2129 = ::Reflex::TypeBuilder(Reflex::Literal("TVector3"));
  ::Reflex::Type type_2128 = ::Reflex::TypeBuilder(Reflex::Literal("TVector2"));
  ::Reflex::Type type_1968 = ::Reflex::TypeBuilder(Reflex::Literal("hit_entry"));
  ::Reflex::Type type_202 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_344 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_495 = ::Reflex::TypeBuilder(Reflex::Literal("T1RecHitGlobal"));
  ::Reflex::Type type_480 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_4189 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2130 = ::Reflex::TypeBuilder(Reflex::Literal("TVectorT<double>"));
  ::Reflex::Type type_1065 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixT<double>"));
  ::Reflex::Type type_2854 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long>"));
  ::Reflex::Type type_2849 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T2Hit>"));
  ::Reflex::Type type_2829 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<long,long>"));
  ::Reflex::Type type_2444 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T1T2Track>"));
  ::Reflex::Type type_2850 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T2Cluster>"));
  ::Reflex::Type type_2853 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<hit_entry>"));
  ::Reflex::Type type_2847 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_3018 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<T1T2Track>"));
  ::Reflex::Type type_2851 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<cluster_entry>"));
  ::Reflex::Type type_2848 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_2002 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T1RecHitGlobal>"));
  ::Reflex::Type type_454 = ::Reflex::TypeBuilder(Reflex::Literal("Point3DBase<float,GlobalTag>"));
  ::Reflex::Type type_3021 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<T1RecHitGlobal>"));
  ::Reflex::Type type_795 = ::Reflex::TypeBuilder(Reflex::Literal("GlobalErrorBase<double,ErrorMatrixTag>"));
  ::Reflex::Type type_4092 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<T1T2Track> >"));
  ::Reflex::Type type_2678 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<T1T2Track> >"));
  ::Reflex::Type type_4122 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<T1T2Track> >"));
  ::Reflex::Type type_6811 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<T1T2Track> >"));
  ::Reflex::Type type_3968 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_2470 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T1T2Track,std::allocator<T1T2Track> >"));
  ::Reflex::Type type_6814 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<T1RecHitGlobal> >"));
  ::Reflex::Type type_6728 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >"));
  ::Reflex::Type type_2473 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T1RecHitGlobal,std::allocator<T1RecHitGlobal> >"));
  ::Reflex::Type type_6729 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const T1T2Track*,std::vector<T1T2Track> >"));
  ::Reflex::Type type_6734 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >"));
  ::Reflex::Type type_6735 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const T1RecHitGlobal*,std::vector<T1RecHitGlobal> >"));
  ::Reflex::Type type_3117 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> > >"));
  ::Reflex::Type type_3116 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const T1T2Track*,std::vector<T1T2Track> > >"));
  ::Reflex::Type type_3123 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> > >"));
  ::Reflex::Type type_3122 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const T1RecHitGlobal*,std::vector<T1RecHitGlobal> > >"));
  ::Reflex::Type type_2003 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T1Road"), type_2002);
  ::Reflex::Type type_2445 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T1T2TrackCollection"), type_2444);
  ::Reflex::Type type_1494 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Global3DPoint"), type_454);
  ::Reflex::Type type_552 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GlobalPoint"), type_1494);
  ::Reflex::Type type_796 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("GlobalError"), type_795);
  ::Reflex::Type type_6879 = ::Reflex::ReferenceBuilder(type_495);
  ::Reflex::Type type_495c = ::Reflex::ConstBuilder(type_495);
  ::Reflex::Type type_5791 = ::Reflex::ReferenceBuilder(type_495c);
  ::Reflex::Type type_552c = ::Reflex::ConstBuilder(type_552);
  ::Reflex::Type type_15286 = ::Reflex::ReferenceBuilder(type_552c);
  ::Reflex::Type type_796c = ::Reflex::ConstBuilder(type_796);
  ::Reflex::Type type_15287 = ::Reflex::ReferenceBuilder(type_796c);
  ::Reflex::Type type_181c = ::Reflex::ConstBuilder(type_181);
  ::Reflex::Type type_5792 = ::Reflex::ReferenceBuilder(type_181c);
  ::Reflex::Type type_6875 = ::Reflex::PointerBuilder(type_495);
  ::Reflex::Type type_15344 = ::Reflex::ArrayBuilder(type_100, 4);
  ::Reflex::Type type_15345 = ::Reflex::ArrayBuilder(type_15344, 4);
  ::Reflex::Type type_7948 = ::Reflex::ReferenceBuilder(type_570);
  ::Reflex::Type type_570c = ::Reflex::ConstBuilder(type_570);
  ::Reflex::Type type_7950 = ::Reflex::ReferenceBuilder(type_570c);
  ::Reflex::Type type_2131 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TVectorD"), type_2130);
  ::Reflex::Type type_2131c = ::Reflex::ConstBuilder(type_2131);
  ::Reflex::Type type_15346 = ::Reflex::ReferenceBuilder(type_2131c);
  ::Reflex::Type type_1066 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TMatrixD"), type_1065);
  ::Reflex::Type type_1066c = ::Reflex::ConstBuilder(type_1066);
  ::Reflex::Type type_15347 = ::Reflex::ReferenceBuilder(type_1066c);
  ::Reflex::Type type_1570c = ::Reflex::ConstBuilder(type_1570);
  ::Reflex::Type type_5540 = ::Reflex::ReferenceBuilder(type_1570c);
  ::Reflex::Type type_12100 = ::Reflex::ReferenceBuilder(type_100);
  ::Reflex::Type type_7547 = ::Reflex::ReferenceBuilder(type_755);
  ::Reflex::Type type_755c = ::Reflex::ConstBuilder(type_755);
  ::Reflex::Type type_7549 = ::Reflex::ReferenceBuilder(type_755c);
  ::Reflex::Type type_1521 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_202);
  ::Reflex::Type type_10318 = ::Reflex::ReferenceBuilder(type_1570);
  ::Reflex::Type type_2851c = ::Reflex::ConstBuilder(type_2851);
  ::Reflex::Type type_15750 = ::Reflex::ReferenceBuilder(type_2851c);
  ::Reflex::Type type_6877 = ::Reflex::PointerBuilder(type_495c);
  ::Reflex::Type type_3003 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_344);
  ::Reflex::Type type_2932 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_348);
  ::Reflex::Type type_3021c = ::Reflex::ConstBuilder(type_3021);
  ::Reflex::Type type_17522 = ::Reflex::ReferenceBuilder(type_3021c);
  ::Reflex::Type type_2002c = ::Reflex::ConstBuilder(type_2002);
  ::Reflex::Type type_7213 = ::Reflex::ReferenceBuilder(type_2002c);
  ::Reflex::Type type_7211 = ::Reflex::ReferenceBuilder(type_2002);
  ::Reflex::Type type_7944 = ::Reflex::PointerBuilder(type_570);
  ::Reflex::Type type_7946 = ::Reflex::PointerBuilder(type_570c);
  ::Reflex::Type type_3018c = ::Reflex::ConstBuilder(type_3018);
  ::Reflex::Type type_18754 = ::Reflex::ReferenceBuilder(type_3018c);
  ::Reflex::Type type_2444c = ::Reflex::ConstBuilder(type_2444);
  ::Reflex::Type type_18755 = ::Reflex::ReferenceBuilder(type_2444c);
  ::Reflex::Type type_18756 = ::Reflex::ReferenceBuilder(type_2444);
  ::Reflex::Type type_21512 = ::Reflex::PointerBuilder(type_2444c);
  ::Reflex::Type type_480c = ::Reflex::ConstBuilder(type_480);
  ::Reflex::Type type_13599 = ::Reflex::ReferenceBuilder(type_480c);
  ::Reflex::Type type_21513 = ::Reflex::PointerBuilder(type_2444);
  ::Reflex::Type type_4122c = ::Reflex::ConstBuilder(type_4122);
  ::Reflex::Type type_21514 = ::Reflex::PointerBuilder(type_4122c);
  ::Reflex::Type type_4189c = ::Reflex::ConstBuilder(type_4189);
  ::Reflex::Type type_14915 = ::Reflex::ReferenceBuilder(type_4189c);
  ::Reflex::Type type_19496 = ::Reflex::ReferenceBuilder(type_2847);
  ::Reflex::Type type_21301 = ::Reflex::ReferenceBuilder(type_3968);
  ::Reflex::Type type_693c = ::Reflex::ConstBuilder(type_693);
  ::Reflex::Type type_3663 = ::Reflex::PointerBuilder(type_693c);
  ::Reflex::Type type_8973 = ::Reflex::ReferenceBuilder(type_3663);
  ::Reflex::Type type_2848c = ::Reflex::ConstBuilder(type_2848);
  ::Reflex::Type type_19497 = ::Reflex::ReferenceBuilder(type_2848c);
  ::Reflex::Type type_4092f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<T1T2TrackCollection>"), type_4092);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __T1RecHitGlobal
#undef __T1RecHitGlobal
#endif
class __T1RecHitGlobal {
  public:
  __T1RecHitGlobal();
  ::GlobalPoint theGlobalPosition;
  ::GlobalError theGlobalError;
  ::T1DetId theId;
};
#ifdef __T1T2Track
#undef __T1T2Track
#endif
class __T1T2Track {
  public:
  __T1T2Track();
  virtual ~__T1T2Track() throw();
  double bx_;
  double by_;
  unsigned int t2_roadID;
  double _TanthetaRZ;
  double _bRZ;
  double _bxRZ;
  double _byRZ;
  double _phiRZ;
  double _ax_rz;
  double _ay_rz;
  double _bxRZ_;
  double _byRZ_;
  double _e_TanthetaRZ;
  double _e_bRZ;
  double _e_phiRZ;
  double _etaRZ;
  double _chi2R;
  double _chi2Phi;
  double _Z_at_RminRZ;
  unsigned int _numHit_t2;
  unsigned int _numPadOnlyHit_t2;
  unsigned int _numStripOnlyHit_t2;
  unsigned int _numCl1HitHit_t2;
  int _t2GhostId;
  ::std::vector<T1RecHitGlobal> track_hits_vector_1;
  ::T2Road track_hits_vector_2;
  double track_params_vector_[4];
  double z0_;
  double par_covariance_matrix_[4][4];
  double par_covariance_vector_[4];
  double chiSquared_;
  double chiSquaredoverN_;
  double chiSquaredX_;
  double chiSquaredY_;
  double _Z_at_Rmin;
  double _Rmin;
  double _theta;
  double _phi;
  double _eta;
  int _hemisphere;
  int _detector;
  bool valid_;
};
#ifdef __T2Road
#undef __T2Road
#endif
class __T2Road {
  public:
  __T2Road();
  ::std::vector<T2Hit> thisRoad;
  ::std::vector<T2Cluster> thisPadRoad;
  unsigned int RoadID;
  double roadDR_;
  double roadDPhi_;
  double roadPhimin;
  double roadPhimax;
  double roadRmin;
  double roadRmax;
};
#ifdef __T2Hit
#undef __T2Hit
#endif
class __T2Hit {
  public:
  __T2Hit();
  virtual ~__T2Hit() throw();
  ::std::vector<cluster_entry> ClusterStrip_entries;
  ::std::vector<cluster_entry> ClusterPad_entries;
  ::std::pair<long,long> HitUniqueId;
  ::std::vector<long> StripVectorBelowThePadId;
  unsigned int Hit_PosInCollection;
  float hitR_;
  float hitPhi_;
  float hitZ_;
  float hitDR_;
  float hitDPhi_;
  float hitDZ_;
  float hitX_;
  float hitY_;
  float hitDX_;
  float hitDY_;
  bool VtxHits;
  bool HitInTrk;
  unsigned int hithalftele_;
  unsigned int hitplane_;
  unsigned int hitplaneside_;
  unsigned int hitarm_;
  ::uint32_t detrawid_;
  unsigned int hitClass_;
  unsigned int hit_numstrip_;
  unsigned int hit_numpad_;
  unsigned int hit_numpadcol_;
  ::std::vector<hit_entry> thehitentries;
};
#ifdef __std__vector_T1RecHitGlobal_
#undef __std__vector_T1RecHitGlobal_
#endif
class __std__vector_T1RecHitGlobal_ : protected ::std::_Vector_base<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > {
  public:
  __std__vector_T1RecHitGlobal_();
};
#ifdef __std__vector_T1T2Track_
#undef __std__vector_T1T2Track_
#endif
class __std__vector_T1T2Track_ : protected ::std::_Vector_base<T1T2Track,std::allocator<T1T2Track> > {
  public:
  __std__vector_T1T2Track_();
};
#ifdef __edm__Wrapper_std__vector_T1T2Track_s_
#undef __edm__Wrapper_std__vector_T1T2Track_s_
#endif
class __edm__Wrapper_std__vector_T1T2Track_s_ {
  public:
  __edm__Wrapper_std__vector_T1T2Track_s_();
  bool present;
  ::std::vector<T1T2Track> obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class T1RecHitGlobal -------------------------------
static  void operator_4515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T1RecHitGlobal*)o)->operator=)(*(const ::T1RecHitGlobal*)arg[0]);
  else   (((::T1RecHitGlobal*)o)->operator=)(*(const ::T1RecHitGlobal*)arg[0]);
}

static void constructor_4516( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1RecHitGlobal(*(const ::T1RecHitGlobal*)arg[0]);
  else ::new(mem) ::T1RecHitGlobal(*(const ::T1RecHitGlobal*)arg[0]);
}

static void constructor_4517( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1RecHitGlobal();
  else ::new(mem) ::T1RecHitGlobal();
}

static void constructor_4518( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1RecHitGlobal(*(const ::GlobalPoint*)arg[0],
      *(const ::GlobalError*)arg[1]);
  else ::new(mem) ::T1RecHitGlobal(*(const ::GlobalPoint*)arg[0],
      *(const ::GlobalError*)arg[1]);
}

static void constructor_4519( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1RecHitGlobal(*(const ::T1DetId*)arg[0],
      *(const ::GlobalPoint*)arg[1],
      *(const ::GlobalError*)arg[2]);
  else ::new(mem) ::T1RecHitGlobal(*(const ::T1DetId*)arg[0],
      *(const ::GlobalPoint*)arg[1],
      *(const ::GlobalError*)arg[2]);
}

static void destructor_4520(void*, void * o, const std::vector<void*>&, void *) {
(((::T1RecHitGlobal*)o)->::T1RecHitGlobal::~T1RecHitGlobal)();
}
static  void method_4521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::T1RecHitGlobal*)o)->clone)());
  else   (((const ::T1RecHitGlobal*)o)->clone)();
}

static  void method_4522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (GlobalPoint)((((const ::T1RecHitGlobal*)o)->GlobalPosition)());
  else   (((const ::T1RecHitGlobal*)o)->GlobalPosition)();
}

static  void method_4523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (GlobalError)((((const ::T1RecHitGlobal*)o)->GlobalPositionError)());
  else   (((const ::T1RecHitGlobal*)o)->GlobalPositionError)();
}

static  void method_4524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T1RecHitGlobal*)o)->Eta)(*(float*)arg[0],
    *(float*)arg[1],
    *(float*)arg[2]));
  else   (((const ::T1RecHitGlobal*)o)->Eta)(*(float*)arg[0],
    *(float*)arg[1],
    *(float*)arg[2]);
}

static  void method_4525( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T1RecHitGlobal*)o)->Phi)(*(float*)arg[0],
    *(float*)arg[1]));
  else   (((const ::T1RecHitGlobal*)o)->Phi)(*(float*)arg[0],
    *(float*)arg[1]);
}

static  void method_4526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T1RecHitGlobal*)o)->eta)());
  else   (((const ::T1RecHitGlobal*)o)->eta)();
}

static  void method_4527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T1RecHitGlobal*)o)->phi)());
  else   (((const ::T1RecHitGlobal*)o)->phi)();
}

static  void method_4528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (T1DetId)((((const ::T1RecHitGlobal*)o)->Id)());
  else   (((const ::T1RecHitGlobal*)o)->Id)();
}

static void method_newdel_495( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T1RecHitGlobal >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T1RecHitGlobal >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T1RecHitGlobal >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T1RecHitGlobal >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T1RecHitGlobal >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T1RecHitGlobal -------------------------------
void __T1RecHitGlobal_db_datamem(Reflex::Class*);
void __T1RecHitGlobal_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T1RecHitGlobal_datamem_bld(&__T1RecHitGlobal_db_datamem);
Reflex::GenreflexMemberBuilder __T1RecHitGlobal_funcmem_bld(&__T1RecHitGlobal_db_funcmem);
void __T1RecHitGlobal_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T1RecHitGlobal"), typeid(::T1RecHitGlobal), sizeof(::T1RecHitGlobal), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6879, type_5791), Reflex::Literal("operator="), operator_4515, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5791), Reflex::Literal("T1RecHitGlobal"), constructor_4516, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T1RecHitGlobal"), constructor_4517, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15286, type_15287), Reflex::Literal("T1RecHitGlobal"), constructor_4518, 0, "pos;err", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5792, type_15286, type_15287), Reflex::Literal("T1RecHitGlobal"), constructor_4519, 0, "id;pos;err", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T1RecHitGlobal"), destructor_4520, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_495, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T1RecHitGlobal_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T1RecHitGlobal_funcmem_bld);
}

//------Delayed data member builder for class T1RecHitGlobal -------------------
void __T1RecHitGlobal_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_552, Reflex::Literal("theGlobalPosition"), OffsetOf(__shadow__::__T1RecHitGlobal, theGlobalPosition), ::Reflex::PRIVATE)
  .AddDataMember(type_796, Reflex::Literal("theGlobalError"), OffsetOf(__shadow__::__T1RecHitGlobal, theGlobalError), ::Reflex::PRIVATE)
  .AddDataMember(type_181, Reflex::Literal("theId"), OffsetOf(__shadow__::__T1RecHitGlobal, theId), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T1RecHitGlobal -------------------
void __T1RecHitGlobal_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6875), Reflex::Literal("clone"), method_4521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_552), Reflex::Literal("GlobalPosition"), method_4522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_796), Reflex::Literal("GlobalPositionError"), method_4523, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875, type_875, type_875, type_875), Reflex::Literal("Eta"), method_4524, 0, ";;", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875, type_875, type_875), Reflex::Literal("Phi"), method_4525, 0, ";", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("eta"), method_4526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("phi"), method_4527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_181), Reflex::Literal("Id"), method_4528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class T1T2Track -------------------------------
static  void operator_4857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T1T2Track*)o)->operator=)(*(const ::T1T2Track*)arg[0]);
  else   (((::T1T2Track*)o)->operator=)(*(const ::T1T2Track*)arg[0]);
}

static void constructor_4858( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1T2Track(*(const ::T1T2Track*)arg[0]);
  else ::new(mem) ::T1T2Track(*(const ::T1T2Track*)arg[0]);
}

static void constructor_4859( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1T2Track();
  else ::new(mem) ::T1T2Track();
}

static void constructor_4860( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1T2Track(*(int*)arg[0]);
  else ::new(mem) ::T1T2Track(*(int*)arg[0]);
}

static void constructor_4861( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1T2Track(*(double*)arg[0],
      *(const ::TVectorD*)arg[1],
      *(const ::TMatrixD*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7]);
  else ::new(mem) ::T1T2Track(*(double*)arg[0],
      *(const ::TVectorD*)arg[1],
      *(const ::TMatrixD*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(int*)arg[6],
      *(int*)arg[7]);
}

static void constructor_4862( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1T2Track(*(const ::TVectorD*)arg[0],
      *(const ::TMatrixD*)arg[1],
      *(double*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4]);
  else ::new(mem) ::T1T2Track(*(const ::TVectorD*)arg[0],
      *(const ::TMatrixD*)arg[1],
      *(double*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4]);
}

static void constructor_4863( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1T2Track(*(double*)arg[0],
      *(const ::TVectorD*)arg[1],
      *(const ::TMatrixD*)arg[2],
      *(double*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5]);
  else ::new(mem) ::T1T2Track(*(double*)arg[0],
      *(const ::TVectorD*)arg[1],
      *(const ::TMatrixD*)arg[2],
      *(double*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5]);
}

static void constructor_4864( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1T2Track(*(const ::TVectorD*)arg[0],
      *(const ::TMatrixD*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6]);
  else ::new(mem) ::T1T2Track(*(const ::TVectorD*)arg[0],
      *(const ::TMatrixD*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6]);
}

static void constructor_4865( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1T2Track(*(const ::TVectorD*)arg[0],
      *(const ::TMatrixD*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(int*)arg[12],
      *(int*)arg[13]);
  else ::new(mem) ::T1T2Track(*(const ::TVectorD*)arg[0],
      *(const ::TMatrixD*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(int*)arg[12],
      *(int*)arg[13]);
}

static void constructor_4866( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1T2Track(*(const ::TVectorD*)arg[0],
      *(const ::TMatrixD*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(int*)arg[15],
      *(unsigned int*)arg[16],
      *(unsigned int*)arg[17],
      *(unsigned int*)arg[18],
      *(unsigned int*)arg[19]);
  else ::new(mem) ::T1T2Track(*(const ::TVectorD*)arg[0],
      *(const ::TMatrixD*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(int*)arg[5],
      *(int*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(int*)arg[15],
      *(unsigned int*)arg[16],
      *(unsigned int*)arg[17],
      *(unsigned int*)arg[18],
      *(unsigned int*)arg[19]);
}

static void destructor_4867(void*, void * o, const std::vector<void*>&, void *) {
(((::T1T2Track*)o)->::T1T2Track::~T1T2Track)();
}
static  void method_4868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T1T2Track*)o)->GetHitEntries)());
  else   (((const ::T1T2Track*)o)->GetHitEntries)();
}

static  void method_4869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::T1T2Track*)o)->GetHitT1)(*(int*)arg[0]);
  else   (((const ::T1T2Track*)o)->GetHitT1)(*(int*)arg[0]);
}

static  void method_4870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::T1T2Track*)o)->GetHitT2)(*(int*)arg[0]);
  else   (((const ::T1T2Track*)o)->GetHitT2)(*(int*)arg[0]);
}

static  void method_4871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<T2Hit>)((((::T1T2Track*)o)->GetT2TrackHits)());
  else   (((::T1T2Track*)o)->GetT2TrackHits)();
}

static  void method_4872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1T2Track*)o)->AddHit)(*(const ::T1RecHitGlobal*)arg[0]);
}

static  void method_4873( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1T2Track*)o)->AddHit)(*(const ::T2Hit*)arg[0]);
}

static  void method_4874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->X0)());
  else   (((const ::T1T2Track*)o)->X0)();
}

static  void method_4875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->X0Sigma)());
  else   (((const ::T1T2Track*)o)->X0Sigma)();
}

static  void method_4876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->Y0)());
  else   (((const ::T1T2Track*)o)->Y0)();
}

static  void method_4877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->Y0Sigma)());
  else   (((const ::T1T2Track*)o)->Y0Sigma)();
}

static  void method_4878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->Z0)());
  else   (((const ::T1T2Track*)o)->Z0)();
}

static  void method_4879( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1T2Track*)o)->Z0)(*(double*)arg[0]);
}

static  void method_4880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->GetTx)());
  else   (((const ::T1T2Track*)o)->GetTx)();
}

static  void method_4881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->GetTxSigma)());
  else   (((const ::T1T2Track*)o)->GetTxSigma)();
}

static  void method_4882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->GetTy)());
  else   (((const ::T1T2Track*)o)->GetTy)();
}

static  void method_4883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->GetTySigma)());
  else   (((const ::T1T2Track*)o)->GetTySigma)();
}

static  void method_4884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->Z_at_Rmin)());
  else   (((const ::T1T2Track*)o)->Z_at_Rmin)();
}

static  void method_4885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->Rmin)());
  else   (((const ::T1T2Track*)o)->Rmin)();
}

static  void method_4886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->Theta)());
  else   (((const ::T1T2Track*)o)->Theta)();
}

static  void method_4887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->Eta)());
  else   (((const ::T1T2Track*)o)->Eta)();
}

static  void method_4888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->Phi)());
  else   (((const ::T1T2Track*)o)->Phi)();
}

static  void method_4889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((const ::T1T2Track*)o)->GetDirectionVector)());
  else   (((const ::T1T2Track*)o)->GetDirectionVector)();
}

static  void method_4890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TVectorD)((((const ::T1T2Track*)o)->ParameterVector)());
  else   (((const ::T1T2Track*)o)->ParameterVector)();
}

static  void method_4891( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1T2Track*)o)->ParameterVector)(*(const ::TVectorD*)arg[0]);
}

static  void method_4892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TMatrixD)((((const ::T1T2Track*)o)->CovarianceMatrix)());
  else   (((const ::T1T2Track*)o)->CovarianceMatrix)();
}

static  void method_4893( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1T2Track*)o)->CovarianceMatrix)(*(const ::TMatrixD*)arg[0]);
}

static  void method_4894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->ChiSquared)());
  else   (((const ::T1T2Track*)o)->ChiSquared)();
}

static  void method_4895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1T2Track*)o)->ChiSquared)(*(double*)arg[0]);
}

static  void method_4896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->ChiSquaredR)());
  else   (((const ::T1T2Track*)o)->ChiSquaredR)();
}

static  void method_4897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->ChiSquaredPhi)());
  else   (((const ::T1T2Track*)o)->ChiSquaredPhi)();
}

static  void method_4898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->ChiSquaredX)());
  else   (((const ::T1T2Track*)o)->ChiSquaredX)();
}

static  void method_4899( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1T2Track*)o)->ChiSquaredX)(*(double*)arg[0]);
}

static  void method_4900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->ChiSquaredY)());
  else   (((const ::T1T2Track*)o)->ChiSquaredY)();
}

static  void method_4901( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1T2Track*)o)->ChiSquaredY)(*(double*)arg[0]);
}

static  void method_4902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->ChiSquaredOverN)());
  else   (((const ::T1T2Track*)o)->ChiSquaredOverN)();
}

static  void method_4903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->ChiSquaredXOverN)());
  else   (((const ::T1T2Track*)o)->ChiSquaredXOverN)();
}

static  void method_4904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T1T2Track*)o)->ChiSquaredYOverN)());
  else   (((const ::T1T2Track*)o)->ChiSquaredYOverN)();
}

static  void method_4905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TVector2)((((const ::T1T2Track*)o)->GetTrackPoint)(*(double*)arg[0]));
  else   (((const ::T1T2Track*)o)->GetTrackPoint)(*(double*)arg[0]);
}

static  void method_4906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TVector3)((((::T1T2Track*)o)->TrackCentrePoint)());
  else   (((::T1T2Track*)o)->TrackCentrePoint)();
}

static  void method_4907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TMatrixD)((((const ::T1T2Track*)o)->TrackPointInterpolationCovariance)(*(double*)arg[0]));
  else   (((const ::T1T2Track*)o)->TrackPointInterpolationCovariance)(*(double*)arg[0]);
}

static  void method_4908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::T1T2Track*)o)->IsValid)());
  else   (((::T1T2Track*)o)->IsValid)();
}

static  void method_4909( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1T2Track*)o)->IsValid)(*(bool*)arg[0]);
}

static  void method_4910( void*, void* o, const std::vector<void*>&, void*)
{
  (((::T1T2Track*)o)->Reset)();
}

static  void method_4911( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1T2Track*)o)->SetDet)(*(int*)arg[0]);
}

static  void method_4912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T1T2Track*)o)->GetDet)());
  else   (((const ::T1T2Track*)o)->GetDet)();
}

static  void method_4913( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::T1T2Track*)o)->NCommonHits)(*(::T1T2Track*)arg[0]));
  else   (((::T1T2Track*)o)->NCommonHits)(*(::T1T2Track*)arg[0]);
}

static void method_newdel_570( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T1T2Track >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T1T2Track >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T1T2Track >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T1T2Track >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T1T2Track >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T1T2Track -------------------------------
void __T1T2Track_db_datamem(Reflex::Class*);
void __T1T2Track_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T1T2Track_datamem_bld(&__T1T2Track_db_datamem);
Reflex::GenreflexMemberBuilder __T1T2Track_funcmem_bld(&__T1T2Track_db_funcmem);
void __T1T2Track_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T1T2Track"), typeid(::T1T2Track), sizeof(::T1T2Track), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("_167"), Reflex::Literal("dimension=4"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("_168"), Reflex::Literal("covarianceSize=16"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7948, type_7950), Reflex::Literal("operator="), operator_4857, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7950), Reflex::Literal("T1T2Track"), constructor_4858, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T1T2Track"), constructor_4859, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_64), Reflex::Literal("T1T2Track"), constructor_4860, 0, "det", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_100, type_15346, type_15347, type_100, type_100, type_100, type_64, type_64), Reflex::Literal("T1T2Track"), constructor_4861, 0, "z0;track_params_vector;par_covariance_matrix;chiSquared;chiSquaredX;chiSquaredY;hemi;detector", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15346, type_15347, type_100, type_64, type_64), Reflex::Literal("T1T2Track"), constructor_4862, 0, "track_params_vector;par_covariance_matrix;chiSquared;hemi;detector", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_100, type_15346, type_15347, type_100, type_64, type_64), Reflex::Literal("T1T2Track"), constructor_4863, 0, "z0;track_params_vector;par_covariance_matrix;chiSquared;hemi;detector", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15346, type_15347, type_100, type_100, type_100, type_64, type_64), Reflex::Literal("T1T2Track"), constructor_4864, 0, "track_params_vector;par_covariance_matrix;chiSquared;chiSquaredX;chiSquaredY;hemi;detector", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15346, type_15347, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_64, type_64), Reflex::Literal("T1T2Track"), constructor_4865, 0, "track_params_vector;par_covariance_matrix;a_rz;b_rz;phim;e_a_rz;e_b_rz;e_phim;chi2;chi2R;chi2Phi;normchi2red;hemisphere;detector", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15346, type_15347, type_100, type_100, type_100, type_64, type_64, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_64, type_202, type_202, type_202, type_202), Reflex::Literal("T1T2Track"), constructor_4866, 0, "track_params_vector;par_covariance_matrix;chiSquared;chiSquaredX;chiSquaredY;hemi;det;TanthetaRZ;bRZ;phiRZ;e_TanthetaRZ;e_bRZ;e_phiRZ;chi2R;chi2Phi;theT2RoadID;numHit_t2;numCl1HitHit_t2;numStripOnlyHit_t2;numPadOnlyHit_t2", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T1T2Track"), destructor_4867, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_570, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T1T2Track_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T1T2Track_funcmem_bld);
}

//------Delayed data member builder for class T1T2Track -------------------
void __T1T2Track_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_100, Reflex::Literal("bx_"), OffsetOf(__shadow__::__T1T2Track, bx_), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("by_"), OffsetOf(__shadow__::__T1T2Track, by_), ::Reflex::PUBLIC)
  .AddDataMember(type_202, Reflex::Literal("t2_roadID"), OffsetOf(__shadow__::__T1T2Track, t2_roadID), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_TanthetaRZ"), OffsetOf(__shadow__::__T1T2Track, _TanthetaRZ), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_bRZ"), OffsetOf(__shadow__::__T1T2Track, _bRZ), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_bxRZ"), OffsetOf(__shadow__::__T1T2Track, _bxRZ), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_byRZ"), OffsetOf(__shadow__::__T1T2Track, _byRZ), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_phiRZ"), OffsetOf(__shadow__::__T1T2Track, _phiRZ), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_ax_rz"), OffsetOf(__shadow__::__T1T2Track, _ax_rz), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_ay_rz"), OffsetOf(__shadow__::__T1T2Track, _ay_rz), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_bxRZ_"), OffsetOf(__shadow__::__T1T2Track, _bxRZ_), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_byRZ_"), OffsetOf(__shadow__::__T1T2Track, _byRZ_), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_e_TanthetaRZ"), OffsetOf(__shadow__::__T1T2Track, _e_TanthetaRZ), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_e_bRZ"), OffsetOf(__shadow__::__T1T2Track, _e_bRZ), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_e_phiRZ"), OffsetOf(__shadow__::__T1T2Track, _e_phiRZ), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_etaRZ"), OffsetOf(__shadow__::__T1T2Track, _etaRZ), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_chi2R"), OffsetOf(__shadow__::__T1T2Track, _chi2R), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_chi2Phi"), OffsetOf(__shadow__::__T1T2Track, _chi2Phi), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("_Z_at_RminRZ"), OffsetOf(__shadow__::__T1T2Track, _Z_at_RminRZ), ::Reflex::PUBLIC)
  .AddDataMember(type_202, Reflex::Literal("_numHit_t2"), OffsetOf(__shadow__::__T1T2Track, _numHit_t2), ::Reflex::PUBLIC)
  .AddDataMember(type_202, Reflex::Literal("_numPadOnlyHit_t2"), OffsetOf(__shadow__::__T1T2Track, _numPadOnlyHit_t2), ::Reflex::PUBLIC)
  .AddDataMember(type_202, Reflex::Literal("_numStripOnlyHit_t2"), OffsetOf(__shadow__::__T1T2Track, _numStripOnlyHit_t2), ::Reflex::PUBLIC)
  .AddDataMember(type_202, Reflex::Literal("_numCl1HitHit_t2"), OffsetOf(__shadow__::__T1T2Track, _numCl1HitHit_t2), ::Reflex::PUBLIC)
  .AddDataMember(type_64, Reflex::Literal("_t2GhostId"), OffsetOf(__shadow__::__T1T2Track, _t2GhostId), ::Reflex::PUBLIC)
  .AddDataMember(type_2002, Reflex::Literal("track_hits_vector_1"), OffsetOf(__shadow__::__T1T2Track, track_hits_vector_1), ::Reflex::PRIVATE)
  .AddDataMember(type_755, Reflex::Literal("track_hits_vector_2"), OffsetOf(__shadow__::__T1T2Track, track_hits_vector_2), ::Reflex::PRIVATE)
  .AddDataMember(type_15344, Reflex::Literal("track_params_vector_"), OffsetOf(__shadow__::__T1T2Track, track_params_vector_), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("z0_"), OffsetOf(__shadow__::__T1T2Track, z0_), ::Reflex::PRIVATE)
  .AddDataMember(type_15345, Reflex::Literal("par_covariance_matrix_"), OffsetOf(__shadow__::__T1T2Track, par_covariance_matrix_), ::Reflex::PRIVATE)
  .AddDataMember(type_15344, Reflex::Literal("par_covariance_vector_"), OffsetOf(__shadow__::__T1T2Track, par_covariance_vector_), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("chiSquared_"), OffsetOf(__shadow__::__T1T2Track, chiSquared_), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("chiSquaredoverN_"), OffsetOf(__shadow__::__T1T2Track, chiSquaredoverN_), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("chiSquaredX_"), OffsetOf(__shadow__::__T1T2Track, chiSquaredX_), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("chiSquaredY_"), OffsetOf(__shadow__::__T1T2Track, chiSquaredY_), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("_Z_at_Rmin"), OffsetOf(__shadow__::__T1T2Track, _Z_at_Rmin), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("_Rmin"), OffsetOf(__shadow__::__T1T2Track, _Rmin), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("_theta"), OffsetOf(__shadow__::__T1T2Track, _theta), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("_phi"), OffsetOf(__shadow__::__T1T2Track, _phi), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("_eta"), OffsetOf(__shadow__::__T1T2Track, _eta), ::Reflex::PRIVATE)
  .AddDataMember(type_64, Reflex::Literal("_hemisphere"), OffsetOf(__shadow__::__T1T2Track, _hemisphere), ::Reflex::PRIVATE)
  .AddDataMember(type_64, Reflex::Literal("_detector"), OffsetOf(__shadow__::__T1T2Track, _detector), ::Reflex::PRIVATE)
  .AddDataMember(type_1562, Reflex::Literal("valid_"), OffsetOf(__shadow__::__T1T2Track, valid_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T1T2Track -------------------
void __T1T2Track_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202), Reflex::Literal("GetHitEntries"), method_4868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5791, type_64), Reflex::Literal("GetHitT1"), method_4869, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5540, type_64), Reflex::Literal("GetHitT2"), method_4870, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2849), Reflex::Literal("GetT2TrackHits"), method_4871, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_5791), Reflex::Literal("AddHit"), method_4872, 0, "hit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_1570c), Reflex::Literal("AddHit"), method_4873, 0, "hit", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("X0"), method_4874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("X0Sigma"), method_4875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("Y0"), method_4876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("Y0Sigma"), method_4877, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("Z0"), method_4878, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_100), Reflex::Literal("Z0"), method_4879, 0, "z0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("GetTx"), method_4880, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("GetTxSigma"), method_4881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("GetTy"), method_4882, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("GetTySigma"), method_4883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("Z_at_Rmin"), method_4884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("Rmin"), method_4885, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("Theta"), method_4886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("Eta"), method_4887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("Phi"), method_4888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2129), Reflex::Literal("GetDirectionVector"), method_4889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2131), Reflex::Literal("ParameterVector"), method_4890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_15346), Reflex::Literal("ParameterVector"), method_4891, 0, "track_params_vector", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1066), Reflex::Literal("CovarianceMatrix"), method_4892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_15347), Reflex::Literal("CovarianceMatrix"), method_4893, 0, "par_covariance_matrix", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("ChiSquared"), method_4894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_12100), Reflex::Literal("ChiSquared"), method_4895, 0, "chiSquared", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("ChiSquaredR"), method_4896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("ChiSquaredPhi"), method_4897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("ChiSquaredX"), method_4898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_12100), Reflex::Literal("ChiSquaredX"), method_4899, 0, "chiSquared", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("ChiSquaredY"), method_4900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_12100), Reflex::Literal("ChiSquaredY"), method_4901, 0, "chiSquared", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("ChiSquaredOverN"), method_4902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("ChiSquaredXOverN"), method_4903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("ChiSquaredYOverN"), method_4904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2128, type_100), Reflex::Literal("GetTrackPoint"), method_4905, 0, "z", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2129), Reflex::Literal("TrackCentrePoint"), method_4906, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1066, type_100), Reflex::Literal("TrackPointInterpolationCovariance"), method_4907, 0, "z", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1562), Reflex::Literal("IsValid"), method_4908, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_1562), Reflex::Literal("IsValid"), method_4909, 0, "valid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693), Reflex::Literal("Reset"), method_4910, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_64), Reflex::Literal("SetDet"), method_4911, 0, "det", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_64), Reflex::Literal("GetDet"), method_4912, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202, type_7948), Reflex::Literal("NCommonHits"), method_4913, 0, "otherTrack", ::Reflex::PUBLIC);
}
//------Stub functions for class T2Road -------------------------------
static void destructor_5258(void*, void * o, const std::vector<void*>&, void *) {
(((::T2Road*)o)->::T2Road::~T2Road)();
}
static  void operator_5259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T2Road*)o)->operator=)(*(const ::T2Road*)arg[0]);
  else   (((::T2Road*)o)->operator=)(*(const ::T2Road*)arg[0]);
}

static void constructor_5260( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Road(*(const ::T2Road*)arg[0]);
  else ::new(mem) ::T2Road(*(const ::T2Road*)arg[0]);
}

static void constructor_5261( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Road();
  else ::new(mem) ::T2Road();
}

static  void method_5262( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Road*)o)->SetRoadDR)(*(float*)arg[0]);
}

static  void method_5263( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Road*)o)->SetRoadDPhi)(*(float*)arg[0]);
}

static  void method_5264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T2Road*)o)->GetRoadDPhi)());
  else   (((const ::T2Road*)o)->GetRoadDPhi)();
}

static  void method_5265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T2Road*)o)->GetRoadDR)());
  else   (((const ::T2Road*)o)->GetRoadDR)();
}

static  void method_5266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Road*)o)->GetRoadSize)());
  else   (((const ::T2Road*)o)->GetRoadSize)();
}

static  void method_5267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T2Road*)o)->GetRoadPhimin)());
  else   (((const ::T2Road*)o)->GetRoadPhimin)();
}

static  void method_5268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T2Road*)o)->GetRoadPhimax)());
  else   (((const ::T2Road*)o)->GetRoadPhimax)();
}

static  void method_5269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T2Road*)o)->GetRoadRmin)());
  else   (((const ::T2Road*)o)->GetRoadRmin)();
}

static  void method_5270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::T2Road*)o)->GetRoadRmax)());
  else   (((const ::T2Road*)o)->GetRoadRmax)();
}

static  void method_5271( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Road*)o)->SetRoadPhimin)(*(double*)arg[0]);
}

static  void method_5272( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Road*)o)->SetRoadPhimax)(*(double*)arg[0]);
}

static  void method_5273( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Road*)o)->SetRoadRmin)(*(double*)arg[0]);
}

static  void method_5274( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Road*)o)->SetRoadRmax)(*(double*)arg[0]);
}

static  void method_5275( void*, void* o, const std::vector<void*>&, void*)
{
  (((::T2Road*)o)->CalculateRoadExtreme)();
}

static  void method_5276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Road*)o)->GetRoadID)());
  else   (((const ::T2Road*)o)->GetRoadID)();
}

static  void method_5277( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Road*)o)->SetRoadID)(*(unsigned int*)arg[0]);
}

static void method_newdel_755( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T2Road >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T2Road >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T2Road >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T2Road >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T2Road >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T2Road -------------------------------
void __T2Road_db_datamem(Reflex::Class*);
void __T2Road_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T2Road_datamem_bld(&__T2Road_db_datamem);
Reflex::GenreflexMemberBuilder __T2Road_funcmem_bld(&__T2Road_db_funcmem);
void __T2Road_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T2Road"), typeid(::T2Road), sizeof(::T2Road), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T2Road"), destructor_5258, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7547, type_7549), Reflex::Literal("operator="), operator_5259, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7549), Reflex::Literal("T2Road"), constructor_5260, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T2Road"), constructor_5261, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_755, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T2Road_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T2Road_funcmem_bld);
}

//------Delayed data member builder for class T2Road -------------------
void __T2Road_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2849, Reflex::Literal("thisRoad"), OffsetOf(__shadow__::__T2Road, thisRoad), ::Reflex::PUBLIC)
  .AddDataMember(type_2850, Reflex::Literal("thisPadRoad"), OffsetOf(__shadow__::__T2Road, thisPadRoad), ::Reflex::PUBLIC)
  .AddDataMember(type_202, Reflex::Literal("RoadID"), OffsetOf(__shadow__::__T2Road, RoadID), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("roadDR_"), OffsetOf(__shadow__::__T2Road, roadDR_), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("roadDPhi_"), OffsetOf(__shadow__::__T2Road, roadDPhi_), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("roadPhimin"), OffsetOf(__shadow__::__T2Road, roadPhimin), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("roadPhimax"), OffsetOf(__shadow__::__T2Road, roadPhimax), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("roadRmin"), OffsetOf(__shadow__::__T2Road, roadRmin), ::Reflex::PRIVATE)
  .AddDataMember(type_100, Reflex::Literal("roadRmax"), OffsetOf(__shadow__::__T2Road, roadRmax), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T2Road -------------------
void __T2Road_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetRoadDR"), method_5262, 0, "dR", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetRoadDPhi"), method_5263, 0, "dPhi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("GetRoadDPhi"), method_5264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("GetRoadDR"), method_5265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202), Reflex::Literal("GetRoadSize"), method_5266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("GetRoadPhimin"), method_5267, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("GetRoadPhimax"), method_5268, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("GetRoadRmin"), method_5269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_100), Reflex::Literal("GetRoadRmax"), method_5270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_100), Reflex::Literal("SetRoadPhimin"), method_5271, 0, "rm", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_100), Reflex::Literal("SetRoadPhimax"), method_5272, 0, "rM", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_100), Reflex::Literal("SetRoadRmin"), method_5273, 0, "pm", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_100), Reflex::Literal("SetRoadRmax"), method_5274, 0, "pM", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693), Reflex::Literal("CalculateRoadExtreme"), method_5275, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202), Reflex::Literal("GetRoadID"), method_5276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_202), Reflex::Literal("SetRoadID"), method_5277, 0, "roadid_", ::Reflex::PUBLIC);
}
//------Stub functions for class T2Hit -------------------------------
static  void operator_6095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T2Hit*)o)->operator=)(*(const ::T2Hit*)arg[0]);
  else   (((::T2Hit*)o)->operator=)(*(const ::T2Hit*)arg[0]);
}

static void constructor_6096( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Hit(*(const ::T2Hit*)arg[0]);
  else ::new(mem) ::T2Hit(*(const ::T2Hit*)arg[0]);
}

static void constructor_6097( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Hit();
  else ::new(mem) ::T2Hit();
}

static void constructor_6098( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Hit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::uint32_t*)arg[3]);
  else ::new(mem) ::T2Hit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::uint32_t*)arg[3]);
}

static void constructor_6099( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Hit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(::uint32_t*)arg[6]);
  else ::new(mem) ::T2Hit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(::uint32_t*)arg[6]);
}

static void destructor_6100(void*, void * o, const std::vector<void*>&, void *) {
(((::T2Hit*)o)->::T2Hit::~T2Hit)();
}
static  void method_6101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitR)());
  else   (((const ::T2Hit*)o)->GetHitR)();
}

static  void method_6102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitPhi)());
  else   (((const ::T2Hit*)o)->GetHitPhi)();
}

static  void method_6103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitZ)());
  else   (((const ::T2Hit*)o)->GetHitZ)();
}

static  void method_6104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitDR)());
  else   (((const ::T2Hit*)o)->GetHitDR)();
}

static  void method_6105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitDPhi)());
  else   (((const ::T2Hit*)o)->GetHitDPhi)();
}

static  void method_6106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitDZ)());
  else   (((const ::T2Hit*)o)->GetHitDZ)();
}

static  void method_6107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitX)());
  else   (((const ::T2Hit*)o)->GetHitX)();
}

static  void method_6108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitDX)());
  else   (((const ::T2Hit*)o)->GetHitDX)();
}

static  void method_6109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitY)());
  else   (((const ::T2Hit*)o)->GetHitY)();
}

static  void method_6110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Hit*)o)->GetHitDY)());
  else   (((const ::T2Hit*)o)->GetHitDY)();
}

static  void method_6111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitClass)());
  else   (((const ::T2Hit*)o)->GetHitClass)();
}

static  void method_6112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitNumStrip)());
  else   (((const ::T2Hit*)o)->GetHitNumStrip)();
}

static  void method_6113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitNumPad)());
  else   (((const ::T2Hit*)o)->GetHitNumPad)();
}

static  void method_6114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitPadCol)());
  else   (((const ::T2Hit*)o)->GetHitPadCol)();
}

static  void method_6115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitArm)());
  else   (((const ::T2Hit*)o)->GetHitArm)();
}

static  void method_6116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitHalftele)());
  else   (((const ::T2Hit*)o)->GetHitHalftele)();
}

static  void method_6117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitPlane)());
  else   (((const ::T2Hit*)o)->GetHitPlane)();
}

static  void method_6118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2Hit*)o)->GetHitPlaneSide)());
  else   (((const ::T2Hit*)o)->GetHitPlaneSide)();
}

static  void method_6119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::T2Hit*)o)->GetHitDetRawId)());
  else   (((const ::T2Hit*)o)->GetHitDetRawId)();
}

static  void method_6120( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitArm)(*(unsigned int*)arg[0]);
}

static  void method_6121( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitHalftele)(*(unsigned int*)arg[0]);
}

static  void method_6122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitPlane)(*(unsigned int*)arg[0]);
}

static  void method_6123( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitPlaneSide)(*(unsigned int*)arg[0]);
}

static  void method_6124( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDetRawId)(*(::uint32_t*)arg[0]);
}

static  void method_6125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitR)(*(float*)arg[0]);
}

static  void method_6126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitPhi)(*(float*)arg[0]);
}

static  void method_6127( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitZ)(*(float*)arg[0]);
}

static  void method_6128( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDR)(*(float*)arg[0]);
}

static  void method_6129( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDPhi)(*(float*)arg[0]);
}

static  void method_6130( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDZ)(*(float*)arg[0]);
}

static  void method_6131( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitX)(*(float*)arg[0]);
}

static  void method_6132( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDX)(*(float*)arg[0]);
}

static  void method_6133( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitY)(*(float*)arg[0]);
}

static  void method_6134( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitDY)(*(float*)arg[0]);
}

static  void method_6135( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitClass)(*(unsigned int*)arg[0]);
}

static  void method_6136( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitNumStrip)(*(unsigned int*)arg[0]);
}

static  void method_6137( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitNumPad)(*(unsigned int*)arg[0]);
}

static  void method_6138( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->SetHitNumPadCol)(*(unsigned int*)arg[0]);
}

static  void method_6139( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->AddFormingCluster)(*(::hit_entry*)arg[0]);
}

static  void method_6140( void*, void* o, const std::vector<void*>&, void*)
{
  (((::T2Hit*)o)->ComputeHit)();
}

static  void method_6141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::T2Hit*)o)->GetCluStripEntries)();
  else   (((const ::T2Hit*)o)->GetCluStripEntries)();
}

static  void method_6142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::T2Hit*)o)->GetCluPadEntries)();
  else   (((const ::T2Hit*)o)->GetCluPadEntries)();
}

static  void method_6143( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->AddCluPadEntries)(*(::std::vector<cluster_entry>*)arg[0]);
}

static  void method_6144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Hit*)o)->AddCluStripEntries)(*(::std::vector<cluster_entry>*)arg[0]);
}

static void method_newdel_1570( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T2Hit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T2Hit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T2Hit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T2Hit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T2Hit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T2Hit -------------------------------
void __T2Hit_db_datamem(Reflex::Class*);
void __T2Hit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T2Hit_datamem_bld(&__T2Hit_db_datamem);
Reflex::GenreflexMemberBuilder __T2Hit_funcmem_bld(&__T2Hit_db_funcmem);
void __T2Hit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T2Hit"), typeid(::T2Hit), sizeof(::T2Hit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddTypedef(type_2853, Reflex::Literal("T2Hit::vecthit_entries"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10318, type_5540), Reflex::Literal("operator="), operator_6095, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5540), Reflex::Literal("T2Hit"), constructor_6096, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T2Hit"), constructor_6097, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_100, type_100, type_100, type_1521), Reflex::Literal("T2Hit"), constructor_6098, 0, "expX;expY;Z;cmsswid", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_100, type_100, type_100, type_100, type_100, type_100, type_1521), Reflex::Literal("T2Hit"), constructor_6099, 0, "X;Y;Z;EX;EY;EZ;cmsswid", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T2Hit"), destructor_6100, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1570, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T2Hit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T2Hit_funcmem_bld);
}

//------Delayed data member builder for class T2Hit -------------------
void __T2Hit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2851, Reflex::Literal("ClusterStrip_entries"), OffsetOf(__shadow__::__T2Hit, ClusterStrip_entries), ::Reflex::PUBLIC)
  .AddDataMember(type_2851, Reflex::Literal("ClusterPad_entries"), OffsetOf(__shadow__::__T2Hit, ClusterPad_entries), ::Reflex::PUBLIC)
  .AddDataMember(type_2829, Reflex::Literal("HitUniqueId"), OffsetOf(__shadow__::__T2Hit, HitUniqueId), ::Reflex::PUBLIC)
  .AddDataMember(type_2854, Reflex::Literal("StripVectorBelowThePadId"), OffsetOf(__shadow__::__T2Hit, StripVectorBelowThePadId), ::Reflex::PUBLIC)
  .AddDataMember(type_202, Reflex::Literal("Hit_PosInCollection"), OffsetOf(__shadow__::__T2Hit, Hit_PosInCollection), ::Reflex::PUBLIC)
  .AddDataMember(type_875, Reflex::Literal("hitR_"), OffsetOf(__shadow__::__T2Hit, hitR_), ::Reflex::PRIVATE)
  .AddDataMember(type_875, Reflex::Literal("hitPhi_"), OffsetOf(__shadow__::__T2Hit, hitPhi_), ::Reflex::PRIVATE)
  .AddDataMember(type_875, Reflex::Literal("hitZ_"), OffsetOf(__shadow__::__T2Hit, hitZ_), ::Reflex::PRIVATE)
  .AddDataMember(type_875, Reflex::Literal("hitDR_"), OffsetOf(__shadow__::__T2Hit, hitDR_), ::Reflex::PRIVATE)
  .AddDataMember(type_875, Reflex::Literal("hitDPhi_"), OffsetOf(__shadow__::__T2Hit, hitDPhi_), ::Reflex::PRIVATE)
  .AddDataMember(type_875, Reflex::Literal("hitDZ_"), OffsetOf(__shadow__::__T2Hit, hitDZ_), ::Reflex::PRIVATE)
  .AddDataMember(type_875, Reflex::Literal("hitX_"), OffsetOf(__shadow__::__T2Hit, hitX_), ::Reflex::PRIVATE)
  .AddDataMember(type_875, Reflex::Literal("hitY_"), OffsetOf(__shadow__::__T2Hit, hitY_), ::Reflex::PRIVATE)
  .AddDataMember(type_875, Reflex::Literal("hitDX_"), OffsetOf(__shadow__::__T2Hit, hitDX_), ::Reflex::PRIVATE)
  .AddDataMember(type_875, Reflex::Literal("hitDY_"), OffsetOf(__shadow__::__T2Hit, hitDY_), ::Reflex::PRIVATE)
  .AddDataMember(type_1562, Reflex::Literal("VtxHits"), OffsetOf(__shadow__::__T2Hit, VtxHits), ::Reflex::PRIVATE)
  .AddDataMember(type_1562, Reflex::Literal("HitInTrk"), OffsetOf(__shadow__::__T2Hit, HitInTrk), ::Reflex::PRIVATE)
  .AddDataMember(type_202, Reflex::Literal("hithalftele_"), OffsetOf(__shadow__::__T2Hit, hithalftele_), ::Reflex::PRIVATE)
  .AddDataMember(type_202, Reflex::Literal("hitplane_"), OffsetOf(__shadow__::__T2Hit, hitplane_), ::Reflex::PRIVATE)
  .AddDataMember(type_202, Reflex::Literal("hitplaneside_"), OffsetOf(__shadow__::__T2Hit, hitplaneside_), ::Reflex::PRIVATE)
  .AddDataMember(type_202, Reflex::Literal("hitarm_"), OffsetOf(__shadow__::__T2Hit, hitarm_), ::Reflex::PRIVATE)
  .AddDataMember(type_1521, Reflex::Literal("detrawid_"), OffsetOf(__shadow__::__T2Hit, detrawid_), ::Reflex::PRIVATE)
  .AddDataMember(type_202, Reflex::Literal("hitClass_"), OffsetOf(__shadow__::__T2Hit, hitClass_), ::Reflex::PRIVATE)
  .AddDataMember(type_202, Reflex::Literal("hit_numstrip_"), OffsetOf(__shadow__::__T2Hit, hit_numstrip_), ::Reflex::PRIVATE)
  .AddDataMember(type_202, Reflex::Literal("hit_numpad_"), OffsetOf(__shadow__::__T2Hit, hit_numpad_), ::Reflex::PRIVATE)
  .AddDataMember(type_202, Reflex::Literal("hit_numpadcol_"), OffsetOf(__shadow__::__T2Hit, hit_numpadcol_), ::Reflex::PRIVATE)
  .AddDataMember(type_2853, Reflex::Literal("thehitentries"), OffsetOf(__shadow__::__T2Hit, thehitentries), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T2Hit -------------------
void __T2Hit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("GetHitR"), method_6101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("GetHitPhi"), method_6102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("GetHitZ"), method_6103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("GetHitDR"), method_6104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("GetHitDPhi"), method_6105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("GetHitDZ"), method_6106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("GetHitX"), method_6107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("GetHitDX"), method_6108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("GetHitY"), method_6109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_875), Reflex::Literal("GetHitDY"), method_6110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202), Reflex::Literal("GetHitClass"), method_6111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202), Reflex::Literal("GetHitNumStrip"), method_6112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202), Reflex::Literal("GetHitNumPad"), method_6113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202), Reflex::Literal("GetHitPadCol"), method_6114, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202), Reflex::Literal("GetHitArm"), method_6115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202), Reflex::Literal("GetHitHalftele"), method_6116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202), Reflex::Literal("GetHitPlane"), method_6117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_202), Reflex::Literal("GetHitPlaneSide"), method_6118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1521), Reflex::Literal("GetHitDetRawId"), method_6119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_202), Reflex::Literal("SetHitArm"), method_6120, 0, "harm", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_202), Reflex::Literal("SetHitHalftele"), method_6121, 0, "hht", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_202), Reflex::Literal("SetHitPlane"), method_6122, 0, "hpl", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_202), Reflex::Literal("SetHitPlaneSide"), method_6123, 0, "hpls", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_1521), Reflex::Literal("SetHitDetRawId"), method_6124, 0, "drid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetHitR"), method_6125, 0, "hitR", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetHitPhi"), method_6126, 0, "hitPhi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetHitZ"), method_6127, 0, "hitZ", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetHitDR"), method_6128, 0, "hitDR", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetHitDPhi"), method_6129, 0, "hitDPhi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetHitDZ"), method_6130, 0, "hitDZ", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetHitX"), method_6131, 0, "hitX", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetHitDX"), method_6132, 0, "hitDX", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetHitY"), method_6133, 0, "hitY", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_875), Reflex::Literal("SetHitDY"), method_6134, 0, "hitDY", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_202), Reflex::Literal("SetHitClass"), method_6135, 0, "hitClass", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_202), Reflex::Literal("SetHitNumStrip"), method_6136, 0, "hit_numstrip", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_202), Reflex::Literal("SetHitNumPad"), method_6137, 0, "hit_numpad", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_202), Reflex::Literal("SetHitNumPadCol"), method_6138, 0, "hit_numpadcol", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_1968), Reflex::Literal("AddFormingCluster"), method_6139, 0, "ahit_entry", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693), Reflex::Literal("ComputeHit"), method_6140, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15750), Reflex::Literal("GetCluStripEntries"), method_6141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15750), Reflex::Literal("GetCluPadEntries"), method_6142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_2851), Reflex::Literal("AddCluPadEntries"), method_6143, 0, "tocpp", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_2851), Reflex::Literal("AddCluStripEntries"), method_6144, 0, "tocps", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > -------------------------------
static void constructor_6889( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>();
  else ::new(mem) ::std::vector<T1RecHitGlobal>();
}

static void constructor_6890( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>(*(const ::std::allocator<T1RecHitGlobal>*)arg[0]);
  else ::new(mem) ::std::vector<T1RecHitGlobal>(*(const ::std::allocator<T1RecHitGlobal>*)arg[0]);
}

static void constructor_6891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0],
      *(const ::T1RecHitGlobal*)arg[1]);
  else ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0],
      *(const ::T1RecHitGlobal*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0],
      *(const ::T1RecHitGlobal*)arg[1],
      *(const ::std::allocator<T1RecHitGlobal>*)arg[2]);
  else ::new(mem) ::std::vector<T1RecHitGlobal>(*(::std::size_t*)arg[0],
      *(const ::T1RecHitGlobal*)arg[1],
      *(const ::std::allocator<T1RecHitGlobal>*)arg[2]);
  }
}

static void constructor_6892( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1RecHitGlobal>(*(const ::std::vector<T1RecHitGlobal>*)arg[0]);
  else ::new(mem) ::std::vector<T1RecHitGlobal>(*(const ::std::vector<T1RecHitGlobal>*)arg[0]);
}

static void destructor_6893(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<T1RecHitGlobal>*)o)->::std::vector<T1RecHitGlobal>::~vector)();
}
static  void operator_6894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1RecHitGlobal>*)o)->operator=)(*(const ::std::vector<T1RecHitGlobal>*)arg[0]);
  else   (((::std::vector<T1RecHitGlobal>*)o)->operator=)(*(const ::std::vector<T1RecHitGlobal>*)arg[0]);
}

static  void method_6895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::T1RecHitGlobal*)arg[1]);
}

static  void method_6896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((::std::vector<T1RecHitGlobal>*)o)->begin)());
  else   (((::std::vector<T1RecHitGlobal>*)o)->begin)();
}

static  void method_6897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((const ::std::vector<T1RecHitGlobal>*)o)->begin)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->begin)();
}

static  void method_6898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((::std::vector<T1RecHitGlobal>*)o)->end)());
  else   (((::std::vector<T1RecHitGlobal>*)o)->end)();
}

static  void method_6899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((const ::std::vector<T1RecHitGlobal>*)o)->end)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->end)();
}

static  void method_6904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1RecHitGlobal>*)o)->size)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->size)();
}

static  void method_6905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1RecHitGlobal>*)o)->max_size)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->max_size)();
}

static  void method_6906( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<T1RecHitGlobal>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<T1RecHitGlobal>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::T1RecHitGlobal*)arg[1]);
  }
}

static  void method_6907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1RecHitGlobal>*)o)->capacity)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->capacity)();
}

static  void method_6908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<T1RecHitGlobal>*)o)->empty)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->empty)();
}

static  void method_6909( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6910( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1RecHitGlobal>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T1RecHitGlobal>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1RecHitGlobal>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6913( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1RecHitGlobal>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T1RecHitGlobal>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1RecHitGlobal>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1RecHitGlobal>*)o)->front)();
  else   (((::std::vector<T1RecHitGlobal>*)o)->front)();
}

static  void method_6916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1RecHitGlobal>*)o)->front)();
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->front)();
}

static  void method_6917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1RecHitGlobal>*)o)->back)();
  else   (((::std::vector<T1RecHitGlobal>*)o)->back)();
}

static  void method_6918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1RecHitGlobal>*)o)->back)();
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->back)();
}

static  void method_6919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<T1RecHitGlobal>*)o)->data)());
  else   (((::std::vector<T1RecHitGlobal>*)o)->data)();
}

static  void method_6920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<T1RecHitGlobal>*)o)->data)());
  else   (((const ::std::vector<T1RecHitGlobal>*)o)->data)();
}

static  void method_6921( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->push_back)(*(const ::T1RecHitGlobal*)arg[0]);
}

static  void method_6922( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->pop_back)();
}

static  void method_6923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((::std::vector<T1RecHitGlobal>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0],
    *(const ::T1RecHitGlobal*)arg[1]));
  else   (((::std::vector<T1RecHitGlobal>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0],
    *(const ::T1RecHitGlobal*)arg[1]);
}

static  void method_6924( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::T1RecHitGlobal*)arg[2]);
}

static  void method_6925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((::std::vector<T1RecHitGlobal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0]));
  else   (((::std::vector<T1RecHitGlobal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0]);
}

static  void method_6926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >)((((::std::vector<T1RecHitGlobal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[1]));
  else   (((::std::vector<T1RecHitGlobal>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T1RecHitGlobal*,std::vector<T1RecHitGlobal> >*)arg[1]);
}

static  void method_6927( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->swap)(*(::std::vector<T1RecHitGlobal>*)arg[0]);
}

static  void method_6928( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T1RecHitGlobal>*)o)->clear)();
}

static void method_newdel_2002( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<T1RecHitGlobal> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<T1RecHitGlobal> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<T1RecHitGlobal> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<T1RecHitGlobal> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<T1RecHitGlobal> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T1RecHitGlobal,std::allocator<T1RecHitGlobal> >")), ::Reflex::BaseOffset< ::std::vector<T1RecHitGlobal>,::std::_Vector_base<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<T1RecHitGlobal> >::Generate();
  else ::Reflex::Proxy< ::std::vector<T1RecHitGlobal> >::Generate();
}

//------Dictionary for class vector<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > -------------------------------
void __std__vector_T1RecHitGlobal__db_datamem(Reflex::Class*);
void __std__vector_T1RecHitGlobal__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_T1RecHitGlobal__datamem_bld(&__std__vector_T1RecHitGlobal__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_T1RecHitGlobal__funcmem_bld(&__std__vector_T1RecHitGlobal__db_funcmem);
void __std__vector_T1RecHitGlobal__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<T1RecHitGlobal>"), typeid(::std::vector<T1RecHitGlobal>), sizeof(::std::vector<T1RecHitGlobal>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2473, ::Reflex::BaseOffset< ::std::vector<T1RecHitGlobal>, ::std::_Vector_base<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_495, Reflex::Literal("std::vector<T1RecHitGlobal>::_Alloc_value_type"))
  .AddTypedef(type_2473, Reflex::Literal("std::vector<T1RecHitGlobal>::_Base"))
  .AddTypedef(type_3021, Reflex::Literal("std::vector<T1RecHitGlobal>::_Tp_alloc_type"))
  .AddTypedef(type_6814, Reflex::Literal("std::vector<T1RecHitGlobal>::_Alloc_traits"))
  .AddTypedef(type_495, Reflex::Literal("std::vector<T1RecHitGlobal>::value_type"))
  .AddTypedef(type_6875, Reflex::Literal("std::vector<T1RecHitGlobal>::pointer"))
  .AddTypedef(type_6877, Reflex::Literal("std::vector<T1RecHitGlobal>::const_pointer"))
  .AddTypedef(type_6879, Reflex::Literal("std::vector<T1RecHitGlobal>::reference"))
  .AddTypedef(type_5791, Reflex::Literal("std::vector<T1RecHitGlobal>::const_reference"))
  .AddTypedef(type_6734, Reflex::Literal("std::vector<T1RecHitGlobal>::iterator"))
  .AddTypedef(type_6735, Reflex::Literal("std::vector<T1RecHitGlobal>::const_iterator"))
  .AddTypedef(type_3122, Reflex::Literal("std::vector<T1RecHitGlobal>::const_reverse_iterator"))
  .AddTypedef(type_3123, Reflex::Literal("std::vector<T1RecHitGlobal>::reverse_iterator"))
  .AddTypedef(type_3003, Reflex::Literal("std::vector<T1RecHitGlobal>::size_type"))
  .AddTypedef(type_2932, Reflex::Literal("std::vector<T1RecHitGlobal>::difference_type"))
  .AddTypedef(type_3021, Reflex::Literal("std::vector<T1RecHitGlobal>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6889, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17522), Reflex::Literal("vector"), constructor_6890, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3003, type_5791, type_17522), Reflex::Literal("vector"), constructor_6891, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7213), Reflex::Literal("vector"), constructor_6892, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6893, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2002, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_T1RecHitGlobal__funcmem_bld);
}

//------Delayed data member builder for class vector<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > -------------------
void __std__vector_T1RecHitGlobal__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<T1RecHitGlobal,std::allocator<T1RecHitGlobal> > -------------------
void __std__vector_T1RecHitGlobal__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7211, type_7213), Reflex::Literal("operator="), operator_6894, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_3003, type_5791), Reflex::Literal("assign"), method_6895, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6734), Reflex::Literal("begin"), method_6896, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6735), Reflex::Literal("begin"), method_6897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6734), Reflex::Literal("end"), method_6898, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6735), Reflex::Literal("end"), method_6899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3003), Reflex::Literal("size"), method_6904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3003), Reflex::Literal("max_size"), method_6905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_3003, type_495), Reflex::Literal("resize"), method_6906, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3003), Reflex::Literal("capacity"), method_6907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1562), Reflex::Literal("empty"), method_6908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_3003), Reflex::Literal("reserve"), method_6909, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6879, type_3003), Reflex::Literal("operator[]"), operator_6910, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5791, type_3003), Reflex::Literal("operator[]"), operator_6911, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6879, type_3003), Reflex::Literal("at"), method_6913, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5791, type_3003), Reflex::Literal("at"), method_6914, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6879), Reflex::Literal("front"), method_6915, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5791), Reflex::Literal("front"), method_6916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6879), Reflex::Literal("back"), method_6917, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5791), Reflex::Literal("back"), method_6918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6875), Reflex::Literal("data"), method_6919, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6877), Reflex::Literal("data"), method_6920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_5791), Reflex::Literal("push_back"), method_6921, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693), Reflex::Literal("pop_back"), method_6922, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6734, type_6734, type_5791), Reflex::Literal("insert"), method_6923, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_6734, type_3003, type_5791), Reflex::Literal("insert"), method_6924, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6734, type_6734), Reflex::Literal("erase"), method_6925, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6734, type_6734, type_6734), Reflex::Literal("erase"), method_6926, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_7211), Reflex::Literal("swap"), method_6927, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693), Reflex::Literal("clear"), method_6928, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<T1T2Track,std::allocator<T1T2Track> > -------------------------------
static void constructor_7959( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1T2Track>();
  else ::new(mem) ::std::vector<T1T2Track>();
}

static void constructor_7960( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1T2Track>(*(const ::std::allocator<T1T2Track>*)arg[0]);
  else ::new(mem) ::std::vector<T1T2Track>(*(const ::std::allocator<T1T2Track>*)arg[0]);
}

static void constructor_7961( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1T2Track>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<T1T2Track>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1T2Track>(*(::std::size_t*)arg[0],
      *(const ::T1T2Track*)arg[1]);
  else ::new(mem) ::std::vector<T1T2Track>(*(::std::size_t*)arg[0],
      *(const ::T1T2Track*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1T2Track>(*(::std::size_t*)arg[0],
      *(const ::T1T2Track*)arg[1],
      *(const ::std::allocator<T1T2Track>*)arg[2]);
  else ::new(mem) ::std::vector<T1T2Track>(*(::std::size_t*)arg[0],
      *(const ::T1T2Track*)arg[1],
      *(const ::std::allocator<T1T2Track>*)arg[2]);
  }
}

static void constructor_7962( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1T2Track>(*(const ::std::vector<T1T2Track>*)arg[0]);
  else ::new(mem) ::std::vector<T1T2Track>(*(const ::std::vector<T1T2Track>*)arg[0]);
}

static void destructor_7963(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<T1T2Track>*)o)->::std::vector<T1T2Track>::~vector)();
}
static  void operator_7964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1T2Track>*)o)->operator=)(*(const ::std::vector<T1T2Track>*)arg[0]);
  else   (((::std::vector<T1T2Track>*)o)->operator=)(*(const ::std::vector<T1T2Track>*)arg[0]);
}

static  void method_7965( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1T2Track>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::T1T2Track*)arg[1]);
}

static  void method_7966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >)((((::std::vector<T1T2Track>*)o)->begin)());
  else   (((::std::vector<T1T2Track>*)o)->begin)();
}

static  void method_7967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T1T2Track*,std::vector<T1T2Track> >)((((const ::std::vector<T1T2Track>*)o)->begin)());
  else   (((const ::std::vector<T1T2Track>*)o)->begin)();
}

static  void method_7968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >)((((::std::vector<T1T2Track>*)o)->end)());
  else   (((::std::vector<T1T2Track>*)o)->end)();
}

static  void method_7969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T1T2Track*,std::vector<T1T2Track> >)((((const ::std::vector<T1T2Track>*)o)->end)());
  else   (((const ::std::vector<T1T2Track>*)o)->end)();
}

static  void method_7974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1T2Track>*)o)->size)());
  else   (((const ::std::vector<T1T2Track>*)o)->size)();
}

static  void method_7975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1T2Track>*)o)->max_size)());
  else   (((const ::std::vector<T1T2Track>*)o)->max_size)();
}

static  void method_7976( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<T1T2Track>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<T1T2Track>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::T1T2Track*)arg[1]);
  }
}

static  void method_7977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1T2Track>*)o)->capacity)());
  else   (((const ::std::vector<T1T2Track>*)o)->capacity)();
}

static  void method_7978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<T1T2Track>*)o)->empty)());
  else   (((const ::std::vector<T1T2Track>*)o)->empty)();
}

static  void method_7979( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1T2Track>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_7980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1T2Track>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T1T2Track>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_7981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1T2Track>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T1T2Track>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_7983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1T2Track>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T1T2Track>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1T2Track>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T1T2Track>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1T2Track>*)o)->front)();
  else   (((::std::vector<T1T2Track>*)o)->front)();
}

static  void method_7986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1T2Track>*)o)->front)();
  else   (((const ::std::vector<T1T2Track>*)o)->front)();
}

static  void method_7987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1T2Track>*)o)->back)();
  else   (((::std::vector<T1T2Track>*)o)->back)();
}

static  void method_7988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1T2Track>*)o)->back)();
  else   (((const ::std::vector<T1T2Track>*)o)->back)();
}

static  void method_7989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<T1T2Track>*)o)->data)());
  else   (((::std::vector<T1T2Track>*)o)->data)();
}

static  void method_7990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<T1T2Track>*)o)->data)());
  else   (((const ::std::vector<T1T2Track>*)o)->data)();
}

static  void method_7991( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1T2Track>*)o)->push_back)(*(const ::T1T2Track*)arg[0]);
}

static  void method_7992( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T1T2Track>*)o)->pop_back)();
}

static  void method_7993( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >)((((::std::vector<T1T2Track>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >*)arg[0],
    *(const ::T1T2Track*)arg[1]));
  else   (((::std::vector<T1T2Track>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >*)arg[0],
    *(const ::T1T2Track*)arg[1]);
}

static  void method_7994( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1T2Track>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::T1T2Track*)arg[2]);
}

static  void method_7995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >)((((::std::vector<T1T2Track>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >*)arg[0]));
  else   (((::std::vector<T1T2Track>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >*)arg[0]);
}

static  void method_7996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >)((((::std::vector<T1T2Track>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >*)arg[1]));
  else   (((::std::vector<T1T2Track>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T1T2Track*,std::vector<T1T2Track> >*)arg[1]);
}

static  void method_7997( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1T2Track>*)o)->swap)(*(::std::vector<T1T2Track>*)arg[0]);
}

static  void method_7998( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T1T2Track>*)o)->clear)();
}

static void method_newdel_2444( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<T1T2Track> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<T1T2Track> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<T1T2Track> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<T1T2Track> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<T1T2Track> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T1T2Track,std::allocator<T1T2Track> >")), ::Reflex::BaseOffset< ::std::vector<T1T2Track>,::std::_Vector_base<T1T2Track,std::allocator<T1T2Track> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<T1T2Track> >::Generate();
  else ::Reflex::Proxy< ::std::vector<T1T2Track> >::Generate();
}

//------Dictionary for class vector<T1T2Track,std::allocator<T1T2Track> > -------------------------------
void __std__vector_T1T2Track__db_datamem(Reflex::Class*);
void __std__vector_T1T2Track__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_T1T2Track__datamem_bld(&__std__vector_T1T2Track__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_T1T2Track__funcmem_bld(&__std__vector_T1T2Track__db_funcmem);
void __std__vector_T1T2Track__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<T1T2Track>"), typeid(::std::vector<T1T2Track>), sizeof(::std::vector<T1T2Track>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2470, ::Reflex::BaseOffset< ::std::vector<T1T2Track>, ::std::_Vector_base<T1T2Track,std::allocator<T1T2Track> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_570, Reflex::Literal("std::vector<T1T2Track>::_Alloc_value_type"))
  .AddTypedef(type_2470, Reflex::Literal("std::vector<T1T2Track>::_Base"))
  .AddTypedef(type_3018, Reflex::Literal("std::vector<T1T2Track>::_Tp_alloc_type"))
  .AddTypedef(type_6811, Reflex::Literal("std::vector<T1T2Track>::_Alloc_traits"))
  .AddTypedef(type_570, Reflex::Literal("std::vector<T1T2Track>::value_type"))
  .AddTypedef(type_7944, Reflex::Literal("std::vector<T1T2Track>::pointer"))
  .AddTypedef(type_7946, Reflex::Literal("std::vector<T1T2Track>::const_pointer"))
  .AddTypedef(type_7948, Reflex::Literal("std::vector<T1T2Track>::reference"))
  .AddTypedef(type_7950, Reflex::Literal("std::vector<T1T2Track>::const_reference"))
  .AddTypedef(type_6728, Reflex::Literal("std::vector<T1T2Track>::iterator"))
  .AddTypedef(type_6729, Reflex::Literal("std::vector<T1T2Track>::const_iterator"))
  .AddTypedef(type_3116, Reflex::Literal("std::vector<T1T2Track>::const_reverse_iterator"))
  .AddTypedef(type_3117, Reflex::Literal("std::vector<T1T2Track>::reverse_iterator"))
  .AddTypedef(type_3003, Reflex::Literal("std::vector<T1T2Track>::size_type"))
  .AddTypedef(type_2932, Reflex::Literal("std::vector<T1T2Track>::difference_type"))
  .AddTypedef(type_3018, Reflex::Literal("std::vector<T1T2Track>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_7959, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18754), Reflex::Literal("vector"), constructor_7960, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3003, type_7950, type_18754), Reflex::Literal("vector"), constructor_7961, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18755), Reflex::Literal("vector"), constructor_7962, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_7963, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2444, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_T1T2Track__funcmem_bld);
}

//------Delayed data member builder for class vector<T1T2Track,std::allocator<T1T2Track> > -------------------
void __std__vector_T1T2Track__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<T1T2Track,std::allocator<T1T2Track> > -------------------
void __std__vector_T1T2Track__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18756, type_18755), Reflex::Literal("operator="), operator_7964, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_3003, type_7950), Reflex::Literal("assign"), method_7965, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6728), Reflex::Literal("begin"), method_7966, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6729), Reflex::Literal("begin"), method_7967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6728), Reflex::Literal("end"), method_7968, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6729), Reflex::Literal("end"), method_7969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3003), Reflex::Literal("size"), method_7974, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3003), Reflex::Literal("max_size"), method_7975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_3003, type_570), Reflex::Literal("resize"), method_7976, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3003), Reflex::Literal("capacity"), method_7977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1562), Reflex::Literal("empty"), method_7978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_3003), Reflex::Literal("reserve"), method_7979, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7948, type_3003), Reflex::Literal("operator[]"), operator_7980, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_3003), Reflex::Literal("operator[]"), operator_7981, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7948, type_3003), Reflex::Literal("at"), method_7983, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950, type_3003), Reflex::Literal("at"), method_7984, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7948), Reflex::Literal("front"), method_7985, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950), Reflex::Literal("front"), method_7986, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7948), Reflex::Literal("back"), method_7987, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7950), Reflex::Literal("back"), method_7988, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7944), Reflex::Literal("data"), method_7989, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7946), Reflex::Literal("data"), method_7990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_7950), Reflex::Literal("push_back"), method_7991, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693), Reflex::Literal("pop_back"), method_7992, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6728, type_6728, type_7950), Reflex::Literal("insert"), method_7993, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_6728, type_3003, type_7950), Reflex::Literal("insert"), method_7994, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6728, type_6728), Reflex::Literal("erase"), method_7995, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6728, type_6728, type_6728), Reflex::Literal("erase"), method_7996, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_18756), Reflex::Literal("swap"), method_7997, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693), Reflex::Literal("clear"), method_7998, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<std::vector<T1T2Track, std::allocator<T1T2Track> > > -------------------------------
static void constructor_14868( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T1T2Track> >();
  else ::new(mem) ::edm::Wrapper<std::vector<T1T2Track> >();
}

static void constructor_14869( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T1T2Track> >(*(::std::auto_ptr<std::vector<T1T2Track> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<T1T2Track> >(*(::std::auto_ptr<std::vector<T1T2Track> >*)arg[0]);
}

static void destructor_14870(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<T1T2Track> >*)o)->::edm::Wrapper<std::vector<T1T2Track> >::~Wrapper)();
}
static  void method_14871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->product)();
}

static  void operator_14872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->operator->)();
}

static  void method_14873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<T1T2Track> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<T1T2Track> >*)o)->productTypeInfo)();
}

static  void method_14874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<T1T2Track> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<T1T2Track> >*)o)->typeInfo)();
}

static void constructor_14875( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<T1T2Track> >((::std::vector<T1T2Track>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<T1T2Track> >((::std::vector<T1T2Track>*)arg[0]);
}

static  void method_14876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<T1T2Track> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<T1T2Track> >*)o)->getInterface)();
}

static  void method_14877( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_14878( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_14879( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_14880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->dynamicTypeInfo)();
}

static  void method_14881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->isPresent)();
}

static  void method_14882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<T1T2Track> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4092( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1T2Track> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1T2Track> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1T2Track> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1T2Track> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<T1T2Track> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<T1T2Track, std::allocator<T1T2Track> > > -------------------------------
void __edm__Wrapper_std__vector_T1T2Track_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_T1T2Track_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_T1T2Track_s__datamem_bld(&__edm__Wrapper_std__vector_T1T2Track_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_T1T2Track_s__funcmem_bld(&__edm__Wrapper_std__vector_T1T2Track_s__db_funcmem);
void __edm__Wrapper_std__vector_T1T2Track_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<T1T2Track> >"), typeid(::edm::Wrapper<std::vector<T1T2Track> >), sizeof(::edm::Wrapper<std::vector<T1T2Track> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<T1T2TrackCollection>")
  .AddTypedef(type_2444, Reflex::Literal("edm::Wrapper<std::vector<T1T2Track> >::value_type"))
  .AddTypedef(type_2444, Reflex::Literal("edm::Wrapper<std::vector<T1T2Track> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_14868, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2678), Reflex::Literal("Wrapper"), constructor_14869, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_14870, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21513), Reflex::Literal("Wrapper"), constructor_14875, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4092, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_T1T2Track_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_T1T2Track_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<T1T2Track, std::allocator<T1T2Track> > > -------------------
void __edm__Wrapper_std__vector_T1T2Track_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1562, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_T1T2Track_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2444, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_T1T2Track_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<T1T2Track, std::allocator<T1T2Track> > > -------------------
void __edm__Wrapper_std__vector_T1T2Track_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21512), Reflex::Literal("product"), method_14871, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21512), Reflex::Literal("operator->"), operator_14872, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13599), Reflex::Literal("productTypeInfo"), method_14873, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13599), Reflex::Literal("typeInfo"), method_14874, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21514), Reflex::Literal("getInterface"), method_14876, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_14915, type_19496, type_21301), Reflex::Literal("fillView"), method_14877, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_13599, type_344, type_8973), Reflex::Literal("setPtr"), method_14878, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_693, type_13599, type_19497, type_19496), Reflex::Literal("fillPtrVector"), method_14879, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13599), Reflex::Literal("dynamicTypeInfo"), method_14880, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1562), Reflex::Literal("isPresent"), method_14881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13599), Reflex::Literal("dynamicTypeInfo_"), method_14882, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __T1RecHitGlobal_dict(); 
      __T1T2Track_dict(); 
      __T2Road_dict(); 
      __T2Hit_dict(); 
      __std__vector_T1RecHitGlobal__dict(); 
      __std__vector_T1T2Track__dict(); 
      __edm__Wrapper_std__vector_T1T2Track_s__dict(); 
    }
    ~Dictionaries() {
      type_495.Unload(); // class T1RecHitGlobal 
      type_570.Unload(); // class T1T2Track 
      type_755.Unload(); // class T2Road 
      type_1570.Unload(); // class T2Hit 
      type_2002.Unload(); // class std::vector<T1RecHitGlobal> 
      type_2444.Unload(); // class std::vector<T1T2Track> 
      type_4092.Unload(); // class edm::Wrapper<std::vector<T1T2Track> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
