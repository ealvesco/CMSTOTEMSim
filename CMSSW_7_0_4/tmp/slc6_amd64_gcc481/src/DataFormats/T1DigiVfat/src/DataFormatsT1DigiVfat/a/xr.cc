// Generated at Mon Jul 11 23:14:25 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/T1DigiVfat/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_68 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_9 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_575 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_748 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1370 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_173 = ::Reflex::TypeBuilder(Reflex::Literal("T1DetId"));
  ::Reflex::Type type_1529 = ::Reflex::TypeBuilder(Reflex::Literal("T1DigiVfat"));
  ::Reflex::Type type_278 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_397 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3404 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2279 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<T1DetId>"));
  ::Reflex::Type type_2512 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T1DigiVfat>"));
  ::Reflex::Type type_2510 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2671 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<T1DigiVfat>"));
  ::Reflex::Type type_2511 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_1372 = ::Reflex::TypeBuilder(Reflex::Literal("TotemDigiCollection<T1DetId,T1DigiVfat>"));
  ::Reflex::Type type_426 = ::Reflex::TypeBuilder(Reflex::Literal("DigiContainerIterator<T1DetId,T1DigiVfat>"));
  ::Reflex::Type type_2614 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >"));
  ::Reflex::Type type_2487 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<T1DetId,std::vector<T1DigiVfat> >"));
  ::Reflex::Type type_2489 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const T1DetId,std::vector<T1DigiVfat> >"));
  ::Reflex::Type type_5051 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<T1DigiVfat> >"));
  ::Reflex::Type type_3266 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3344 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >"));
  ::Reflex::Type type_2368 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TotemDigiCollection<T1DetId,T1DigiVfat> >"));
  ::Reflex::Type type_2152 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T1DigiVfat,std::allocator<T1DigiVfat> >"));
  ::Reflex::Type type_3343 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >"));
  ::Reflex::Type type_2367 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::pair<T1DetId,std::vector<T1DigiVfat> > >"));
  ::Reflex::Type type_3374 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TotemDigiCollection<T1DetId,T1DigiVfat> >"));
  ::Reflex::Type type_4985 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >"));
  ::Reflex::Type type_2673 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >"));
  ::Reflex::Type type_3373 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::pair<T1DetId,std::vector<T1DigiVfat> > >"));
  ::Reflex::Type type_4454 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const T1DigiVfat*,std::vector<T1DigiVfat> >"));
  ::Reflex::Type type_2565 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >"));
  ::Reflex::Type type_2658 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >"));
  ::Reflex::Type type_2759 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> > >"));
  ::Reflex::Type type_2491 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >,bool>"));
  ::Reflex::Type type_2758 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const T1DigiVfat*,std::vector<T1DigiVfat> > >"));
  ::Reflex::Type type_2755 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > > >"));
  ::Reflex::Type type_2754 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > > >"));
  ::Reflex::Type type_2493 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<const T1DigiVfat*,std::vector<T1DigiVfat> >,__gnu_cxx::__normal_iterator<const T1DigiVfat*,std::vector<T1DigiVfat> > >"));
  ::Reflex::Type type_2490 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >,std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > > >"));
  ::Reflex::Type type_2488 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >,std::_Rb_tree_const_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > > >"));
  ::Reflex::Type type_2327 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<T1DetId,std::pair<const T1DetId,std::vector<T1DigiVfat> >,std::_Select1st<std::pair<const T1DetId,std::vector<T1DigiVfat> > >,std::less<T1DetId>,std::allocator<std::pair<const T1DetId,std::vector<T1DigiVfat> > > >"));
  ::Reflex::Type type_13129 = ::Reflex::ReferenceBuilder(type_1372);
  ::Reflex::Type type_1372c = ::Reflex::ConstBuilder(type_1372);
  ::Reflex::Type type_13130 = ::Reflex::ReferenceBuilder(type_1372c);
  ::Reflex::Type type_173c = ::Reflex::ConstBuilder(type_173);
  ::Reflex::Type type_4092 = ::Reflex::ReferenceBuilder(type_173c);
  ::Reflex::Type type_1529c = ::Reflex::ConstBuilder(type_1529);
  ::Reflex::Type type_4093 = ::Reflex::ReferenceBuilder(type_1529c);
  ::Reflex::Type type_1696 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("int32_t"), type_68);
  ::Reflex::Type type_8225 = ::Reflex::ReferenceBuilder(type_1529);
  ::Reflex::Type type_16479 = ::Reflex::ReferenceBuilder(type_2487);
  ::Reflex::Type type_2487c = ::Reflex::ConstBuilder(type_2487);
  ::Reflex::Type type_16480 = ::Reflex::ReferenceBuilder(type_2487c);
  ::Reflex::Type type_2512c = ::Reflex::ConstBuilder(type_2512);
  ::Reflex::Type type_8291 = ::Reflex::ReferenceBuilder(type_2512c);
  ::Reflex::Type type_5947 = ::Reflex::PointerBuilder(type_1529);
  ::Reflex::Type type_8223 = ::Reflex::PointerBuilder(type_1529c);
  ::Reflex::Type type_2655 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_278);
  ::Reflex::Type type_2592 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_9);
  ::Reflex::Type type_2671c = ::Reflex::ConstBuilder(type_2671);
  ::Reflex::Type type_15864 = ::Reflex::ReferenceBuilder(type_2671c);
  ::Reflex::Type type_8289 = ::Reflex::ReferenceBuilder(type_2512);
  ::Reflex::Type type_7235 = ::Reflex::PointerBuilder(type_2489);
  ::Reflex::Type type_2489c = ::Reflex::ConstBuilder(type_2489);
  ::Reflex::Type type_7237 = ::Reflex::PointerBuilder(type_2489c);
  ::Reflex::Type type_7239 = ::Reflex::ReferenceBuilder(type_2489);
  ::Reflex::Type type_7241 = ::Reflex::ReferenceBuilder(type_2489c);
  ::Reflex::Type type_2279c = ::Reflex::ConstBuilder(type_2279);
  ::Reflex::Type type_16265 = ::Reflex::ReferenceBuilder(type_2279c);
  ::Reflex::Type type_2673c = ::Reflex::ConstBuilder(type_2673);
  ::Reflex::Type type_16342 = ::Reflex::ReferenceBuilder(type_2673c);
  ::Reflex::Type type_2614c = ::Reflex::ConstBuilder(type_2614);
  ::Reflex::Type type_16606 = ::Reflex::ReferenceBuilder(type_2614c);
  ::Reflex::Type type_16607 = ::Reflex::ReferenceBuilder(type_2614);
  ::Reflex::Type type_18333 = ::Reflex::PointerBuilder(type_2487c);
  ::Reflex::Type type_397c = ::Reflex::ConstBuilder(type_397);
  ::Reflex::Type type_11129 = ::Reflex::ReferenceBuilder(type_397c);
  ::Reflex::Type type_18334 = ::Reflex::PointerBuilder(type_2487);
  ::Reflex::Type type_3373c = ::Reflex::ConstBuilder(type_3373);
  ::Reflex::Type type_18335 = ::Reflex::PointerBuilder(type_3373c);
  ::Reflex::Type type_3404c = ::Reflex::ConstBuilder(type_3404);
  ::Reflex::Type type_12381 = ::Reflex::ReferenceBuilder(type_3404c);
  ::Reflex::Type type_16489 = ::Reflex::ReferenceBuilder(type_2510);
  ::Reflex::Type type_18258 = ::Reflex::ReferenceBuilder(type_3266);
  ::Reflex::Type type_575c = ::Reflex::ConstBuilder(type_575);
  ::Reflex::Type type_2963 = ::Reflex::PointerBuilder(type_575c);
  ::Reflex::Type type_6668 = ::Reflex::ReferenceBuilder(type_2963);
  ::Reflex::Type type_2511c = ::Reflex::ConstBuilder(type_2511);
  ::Reflex::Type type_16490 = ::Reflex::ReferenceBuilder(type_2511c);
  ::Reflex::Type type_18338 = ::Reflex::PointerBuilder(type_1372c);
  ::Reflex::Type type_18339 = ::Reflex::PointerBuilder(type_1372);
  ::Reflex::Type type_3374c = ::Reflex::ConstBuilder(type_3374);
  ::Reflex::Type type_18340 = ::Reflex::PointerBuilder(type_3374c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TotemDigiCollection_T1DetId_T1DigiVfat_
#undef __TotemDigiCollection_T1DetId_T1DigiVfat_
#endif
class __TotemDigiCollection_T1DetId_T1DigiVfat_ {
  public:
  __TotemDigiCollection_T1DetId_T1DigiVfat_();
  ::std::map<T1DetId,std::vector<T1DigiVfat> > data_;
};
#ifdef __T1DigiVfat
#undef __T1DigiVfat
#endif
class __T1DigiVfat {
  public:
  __T1DigiVfat();
  int strip_;
  int threshold_;
  ::int32_t bx_;
  float charge_;
  int quality_;
};
#ifdef __std__pair_T1DetId_std__vector_T1DigiVfat_s_
#undef __std__pair_T1DetId_std__vector_T1DigiVfat_s_
#endif
struct __std__pair_T1DetId_std__vector_T1DigiVfat_s_ {
  public:
  __std__pair_T1DetId_std__vector_T1DigiVfat_s_();
  ::T1DetId first;
  ::std::vector<T1DigiVfat> second;
};
#ifdef __std__vector_T1DigiVfat_
#undef __std__vector_T1DigiVfat_
#endif
class __std__vector_T1DigiVfat_ : protected ::std::_Vector_base<T1DigiVfat,std::allocator<T1DigiVfat> > {
  public:
  __std__vector_T1DigiVfat_();
};
#ifdef __std__map_T1DetId_std__vector_T1DigiVfat_s_
#undef __std__map_T1DetId_std__vector_T1DigiVfat_s_
#endif
class __std__map_T1DetId_std__vector_T1DigiVfat_s_ {
  public:
  __std__map_T1DetId_std__vector_T1DigiVfat_s_();
  ::std::_Rb_tree<T1DetId,std::pair<const T1DetId,std::vector<T1DigiVfat> >,std::_Select1st<std::pair<const T1DetId,std::vector<T1DigiVfat> > >,std::less<T1DetId>,std::allocator<std::pair<const T1DetId,std::vector<T1DigiVfat> > > > _M_t;
};
#ifdef __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s_
#undef __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s_
#endif
class __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s_ {
  public:
  __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s_();
  bool present;
  ::std::pair<T1DetId,std::vector<T1DigiVfat> > obj;
};
#ifdef __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s_
#undef __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s_
#endif
class __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s_ {
  public:
  __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s_();
  bool present;
  ::TotemDigiCollection<T1DetId,T1DigiVfat> obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class TotemDigiCollection<T1DetId,T1DigiVfat> -------------------------------
static void destructor_4459(void*, void * o, const std::vector<void*>&, void *) {
(((::TotemDigiCollection<T1DetId,T1DigiVfat>*)o)->::TotemDigiCollection<T1DetId,T1DigiVfat>::~TotemDigiCollection)();
}
static  void operator_4460( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TotemDigiCollection<T1DetId,T1DigiVfat>*)o)->operator=)(*(const ::TotemDigiCollection<T1DetId,T1DigiVfat>*)arg[0]);
  else   (((::TotemDigiCollection<T1DetId,T1DigiVfat>*)o)->operator=)(*(const ::TotemDigiCollection<T1DetId,T1DigiVfat>*)arg[0]);
}

static void constructor_4461( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemDigiCollection<T1DetId,T1DigiVfat>(*(const ::TotemDigiCollection<T1DetId,T1DigiVfat>*)arg[0]);
  else ::new(mem) ::TotemDigiCollection<T1DetId,T1DigiVfat>(*(const ::TotemDigiCollection<T1DetId,T1DigiVfat>*)arg[0]);
}

static void constructor_4462( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemDigiCollection<T1DetId,T1DigiVfat>();
  else ::new(mem) ::TotemDigiCollection<T1DetId,T1DigiVfat>();
}

static  void method_4463( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TotemDigiCollection<T1DetId,T1DigiVfat>*)o)->insertDigi)(*(const ::T1DetId*)arg[0],
    *(const ::T1DigiVfat*)arg[1]);
}

static  void method_4464( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TotemDigiCollection<T1DetId,T1DigiVfat>*)o)->put)(*(::std::pair<__gnu_cxx::__normal_iterator<const T1DigiVfat*,std::vector<T1DigiVfat> >,__gnu_cxx::__normal_iterator<const T1DigiVfat*,std::vector<T1DigiVfat> > >*)arg[0],
    *(const ::T1DetId*)arg[1]);
}

static  void method_4465( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::__normal_iterator<const T1DigiVfat*,std::vector<T1DigiVfat> >,__gnu_cxx::__normal_iterator<const T1DigiVfat*,std::vector<T1DigiVfat> > >)((((const ::TotemDigiCollection<T1DetId,T1DigiVfat>*)o)->get)(*(const ::T1DetId*)arg[0]));
  else   (((const ::TotemDigiCollection<T1DetId,T1DigiVfat>*)o)->get)(*(const ::T1DetId*)arg[0]);
}

static  void method_4466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (DigiContainerIterator<T1DetId,T1DigiVfat>)((((const ::TotemDigiCollection<T1DetId,T1DigiVfat>*)o)->begin)());
  else   (((const ::TotemDigiCollection<T1DetId,T1DigiVfat>*)o)->begin)();
}

static  void method_4467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (DigiContainerIterator<T1DetId,T1DigiVfat>)((((const ::TotemDigiCollection<T1DetId,T1DigiVfat>*)o)->end)());
  else   (((const ::TotemDigiCollection<T1DetId,T1DigiVfat>*)o)->end)();
}

static void method_newdel_1372( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T1DetId,T1DigiVfat> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T1DetId,T1DigiVfat> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T1DetId,T1DigiVfat> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T1DetId,T1DigiVfat> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TotemDigiCollection<T1DetId,T1DigiVfat> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TotemDigiCollection<T1DetId,T1DigiVfat> -------------------------------
void __TotemDigiCollection_T1DetId_T1DigiVfat__db_datamem(Reflex::Class*);
void __TotemDigiCollection_T1DetId_T1DigiVfat__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TotemDigiCollection_T1DetId_T1DigiVfat__datamem_bld(&__TotemDigiCollection_T1DetId_T1DigiVfat__db_datamem);
Reflex::GenreflexMemberBuilder __TotemDigiCollection_T1DetId_T1DigiVfat__funcmem_bld(&__TotemDigiCollection_T1DetId_T1DigiVfat__db_funcmem);
void __TotemDigiCollection_T1DetId_T1DigiVfat__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TotemDigiCollection<T1DetId,T1DigiVfat>"), typeid(::TotemDigiCollection<T1DetId,T1DigiVfat>), sizeof(::TotemDigiCollection<T1DetId,T1DigiVfat>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_4454, Reflex::Literal("TotemDigiCollection<T1DetId,T1DigiVfat>::const_iterator"))
  .AddTypedef(type_2493, Reflex::Literal("TotemDigiCollection<T1DetId,T1DigiVfat>::Range"))
  .AddTypedef(type_426, Reflex::Literal("TotemDigiCollection<T1DetId,T1DigiVfat>::DigiRangeIterator"))
  .AddTypedef(type_2614, Reflex::Literal("TotemDigiCollection<T1DetId,T1DigiVfat>::container"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TotemDigiCollection"), destructor_4459, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13129, type_13130), Reflex::Literal("operator="), operator_4460, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13130), Reflex::Literal("TotemDigiCollection"), constructor_4461, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TotemDigiCollection"), constructor_4462, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1372, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TotemDigiCollection_T1DetId_T1DigiVfat__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TotemDigiCollection_T1DetId_T1DigiVfat__funcmem_bld);
}

//------Delayed data member builder for class TotemDigiCollection<T1DetId,T1DigiVfat> -------------------
void __TotemDigiCollection_T1DetId_T1DigiVfat__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2614, Reflex::Literal("data_"), OffsetOf(__shadow__::__TotemDigiCollection_T1DetId_T1DigiVfat_, data_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TotemDigiCollection<T1DetId,T1DigiVfat> -------------------
void __TotemDigiCollection_T1DetId_T1DigiVfat__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_4092, type_4093), Reflex::Literal("insertDigi"), method_4463, 0, "index;digi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2493, type_4092), Reflex::Literal("put"), method_4464, 0, "range;index", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2493, type_4092), Reflex::Literal("get"), method_4465, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_426), Reflex::Literal("begin"), method_4466, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_426), Reflex::Literal("end"), method_4467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class T1DigiVfat -------------------------------
static void destructor_4617(void*, void * o, const std::vector<void*>&, void *) {
(((::T1DigiVfat*)o)->::T1DigiVfat::~T1DigiVfat)();
}
static  void operator_4618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T1DigiVfat*)o)->operator=)(*(const ::T1DigiVfat*)arg[0]);
  else   (((::T1DigiVfat*)o)->operator=)(*(const ::T1DigiVfat*)arg[0]);
}

static void constructor_4619( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1DigiVfat(*(const ::T1DigiVfat*)arg[0]);
  else ::new(mem) ::T1DigiVfat(*(const ::T1DigiVfat*)arg[0]);
}

static void constructor_4620( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1DigiVfat(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  else ::new(mem) ::T1DigiVfat(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
}

static void constructor_4621( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1DigiVfat(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(float*)arg[3]);
  else ::new(mem) ::T1DigiVfat(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(float*)arg[3]);
}

static void constructor_4622( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1DigiVfat(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  else ::new(mem) ::T1DigiVfat(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
}

static void constructor_4623( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1DigiVfat(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(float*)arg[3],
      *(int*)arg[4]);
  else ::new(mem) ::T1DigiVfat(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(float*)arg[3],
      *(int*)arg[4]);
}

static void constructor_4624( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T1DigiVfat();
  else ::new(mem) ::T1DigiVfat();
}

static  void operator_4625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::T1DigiVfat*)o)->operator==)(*(const ::T1DigiVfat*)arg[0]));
  else   (((const ::T1DigiVfat*)o)->operator==)(*(const ::T1DigiVfat*)arg[0]);
}

static  void operator_4626( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::T1DigiVfat*)o)->operator<)(*(const ::T1DigiVfat*)arg[0]));
  else   (((const ::T1DigiVfat*)o)->operator<)(*(const ::T1DigiVfat*)arg[0]);
}

static  void method_4627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T1DigiVfat*)o)->strip)());
  else   (((const ::T1DigiVfat*)o)->strip)();
}

static  void method_4628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T1DigiVfat*)o)->threshold)());
  else   (((const ::T1DigiVfat*)o)->threshold)();
}

static  void method_4629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T1DigiVfat*)o)->bx)());
  else   (((const ::T1DigiVfat*)o)->bx)();
}

static  void method_4630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T1DigiVfat*)o)->quality)());
  else   (((const ::T1DigiVfat*)o)->quality)();
}

static  void method_4631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T1DigiVfat*)o)->charge)());
  else   (((const ::T1DigiVfat*)o)->charge)();
}

static  void method_4632( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::T1DigiVfat*)o)->print)();
}

static  void method_4633( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T1DigiVfat*)o)->setThreshold)(*(int*)arg[0]);
}

static void method_newdel_1529( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T1DigiVfat >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T1DigiVfat >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T1DigiVfat >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T1DigiVfat >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T1DigiVfat >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T1DigiVfat -------------------------------
void __T1DigiVfat_db_datamem(Reflex::Class*);
void __T1DigiVfat_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T1DigiVfat_datamem_bld(&__T1DigiVfat_db_datamem);
Reflex::GenreflexMemberBuilder __T1DigiVfat_funcmem_bld(&__T1DigiVfat_db_funcmem);
void __T1DigiVfat_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T1DigiVfat"), typeid(::T1DigiVfat), sizeof(::T1DigiVfat), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T1DigiVfat"), destructor_4617, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8225, type_4093), Reflex::Literal("operator="), operator_4618, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4093), Reflex::Literal("T1DigiVfat"), constructor_4619, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_68, type_68, type_68), Reflex::Literal("T1DigiVfat"), constructor_4620, 0, "strip;threshold;bx", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_68, type_68, type_68, type_748), Reflex::Literal("T1DigiVfat"), constructor_4621, 0, "strip;threshold;bx;charge", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_68, type_68, type_68, type_68), Reflex::Literal("T1DigiVfat"), constructor_4622, 0, "strip;threshold;bx;quality", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_68, type_68, type_68, type_748, type_68), Reflex::Literal("T1DigiVfat"), constructor_4623, 0, "strip;threshold;bx;charge;quality", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T1DigiVfat"), constructor_4624, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1529, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T1DigiVfat_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T1DigiVfat_funcmem_bld);
}

//------Delayed data member builder for class T1DigiVfat -------------------
void __T1DigiVfat_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_68, Reflex::Literal("strip_"), OffsetOf(__shadow__::__T1DigiVfat, strip_), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("threshold_"), OffsetOf(__shadow__::__T1DigiVfat, threshold_), ::Reflex::PRIVATE)
  .AddDataMember(type_1696, Reflex::Literal("bx_"), OffsetOf(__shadow__::__T1DigiVfat, bx_), ::Reflex::PRIVATE)
  .AddDataMember(type_748, Reflex::Literal("charge_"), OffsetOf(__shadow__::__T1DigiVfat, charge_), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("quality_"), OffsetOf(__shadow__::__T1DigiVfat, quality_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T1DigiVfat -------------------
void __T1DigiVfat_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1370, type_4093), Reflex::Literal("operator=="), operator_4625, 0, "digi", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1370, type_4093), Reflex::Literal("operator<"), operator_4626, 0, "digi", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("strip"), method_4627, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("threshold"), method_4628, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("bx"), method_4629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("quality"), method_4630, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_748), Reflex::Literal("charge"), method_4631, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("print"), method_4632, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_68), Reflex::Literal("setThreshold"), method_4633, 0, "thr", ::Reflex::PUBLIC);
}
//------Stub functions for class pair<T1DetId,std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > -------------------------------
static void destructor_8018(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<T1DetId,std::vector<T1DigiVfat> >*)o)->::std::pair<T1DetId,std::vector<T1DigiVfat> >::~pair)();
}
static  void operator_8019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<T1DetId,std::vector<T1DigiVfat> >*)o)->operator=)(*(const ::std::pair<T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
  else   (((::std::pair<T1DetId,std::vector<T1DigiVfat> >*)o)->operator=)(*(const ::std::pair<T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
}

static void constructor_8020( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T1DetId,std::vector<T1DigiVfat> >(*(const ::std::pair<T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
  else ::new(mem) ::std::pair<T1DetId,std::vector<T1DigiVfat> >(*(const ::std::pair<T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
}

static void constructor_8021( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T1DetId,std::vector<T1DigiVfat> >();
  else ::new(mem) ::std::pair<T1DetId,std::vector<T1DigiVfat> >();
}

static void constructor_8022( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T1DetId,std::vector<T1DigiVfat> >(*(const ::T1DetId*)arg[0],
      *(const ::std::vector<T1DigiVfat>*)arg[1]);
  else ::new(mem) ::std::pair<T1DetId,std::vector<T1DigiVfat> >(*(const ::T1DetId*)arg[0],
      *(const ::std::vector<T1DigiVfat>*)arg[1]);
}

static void method_newdel_2487( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<T1DetId,std::vector<T1DigiVfat> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<T1DetId,std::vector<T1DigiVfat> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<T1DetId,std::vector<T1DigiVfat> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<T1DetId,std::vector<T1DigiVfat> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<T1DetId,std::vector<T1DigiVfat> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<T1DetId,std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > -------------------------------
void __std__pair_T1DetId_std__vector_T1DigiVfat_s__db_datamem(Reflex::Class*);
void __std__pair_T1DetId_std__vector_T1DigiVfat_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_T1DetId_std__vector_T1DigiVfat_s__datamem_bld(&__std__pair_T1DetId_std__vector_T1DigiVfat_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_T1DetId_std__vector_T1DigiVfat_s__funcmem_bld(&__std__pair_T1DetId_std__vector_T1DigiVfat_s__db_funcmem);
void __std__pair_T1DetId_std__vector_T1DigiVfat_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<T1DetId,std::vector<T1DigiVfat> >"), typeid(::std::pair<T1DetId,std::vector<T1DigiVfat> >), sizeof(::std::pair<T1DetId,std::vector<T1DigiVfat> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_173, Reflex::Literal("std::pair<T1DetId,std::vector<T1DigiVfat> >::first_type"))
  .AddTypedef(type_2512, Reflex::Literal("std::pair<T1DetId,std::vector<T1DigiVfat> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_8018, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16479, type_16480), Reflex::Literal("operator="), operator_8019, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16480), Reflex::Literal("pair"), constructor_8020, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_8021, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4092, type_8291), Reflex::Literal("pair"), constructor_8022, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2487, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_T1DetId_std__vector_T1DigiVfat_s__datamem_bld);
}

//------Delayed data member builder for class pair<T1DetId,std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > -------------------
void __std__pair_T1DetId_std__vector_T1DigiVfat_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_173, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_T1DetId_std__vector_T1DigiVfat_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2512, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_T1DetId_std__vector_T1DigiVfat_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<T1DetId,std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > -------------------
void __std__pair_T1DetId_std__vector_T1DigiVfat_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<T1DigiVfat,std::allocator<T1DigiVfat> > -------------------------------
static void constructor_8235( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1DigiVfat>();
  else ::new(mem) ::std::vector<T1DigiVfat>();
}

static void constructor_8236( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1DigiVfat>(*(const ::std::allocator<T1DigiVfat>*)arg[0]);
  else ::new(mem) ::std::vector<T1DigiVfat>(*(const ::std::allocator<T1DigiVfat>*)arg[0]);
}

static void constructor_8237( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1DigiVfat>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<T1DigiVfat>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1DigiVfat>(*(::std::size_t*)arg[0],
      *(const ::T1DigiVfat*)arg[1]);
  else ::new(mem) ::std::vector<T1DigiVfat>(*(::std::size_t*)arg[0],
      *(const ::T1DigiVfat*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1DigiVfat>(*(::std::size_t*)arg[0],
      *(const ::T1DigiVfat*)arg[1],
      *(const ::std::allocator<T1DigiVfat>*)arg[2]);
  else ::new(mem) ::std::vector<T1DigiVfat>(*(::std::size_t*)arg[0],
      *(const ::T1DigiVfat*)arg[1],
      *(const ::std::allocator<T1DigiVfat>*)arg[2]);
  }
}

static void constructor_8238( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T1DigiVfat>(*(const ::std::vector<T1DigiVfat>*)arg[0]);
  else ::new(mem) ::std::vector<T1DigiVfat>(*(const ::std::vector<T1DigiVfat>*)arg[0]);
}

static void destructor_8239(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<T1DigiVfat>*)o)->::std::vector<T1DigiVfat>::~vector)();
}
static  void operator_8240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1DigiVfat>*)o)->operator=)(*(const ::std::vector<T1DigiVfat>*)arg[0]);
  else   (((::std::vector<T1DigiVfat>*)o)->operator=)(*(const ::std::vector<T1DigiVfat>*)arg[0]);
}

static  void method_8241( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1DigiVfat>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::T1DigiVfat*)arg[1]);
}

static  void method_8242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >)((((::std::vector<T1DigiVfat>*)o)->begin)());
  else   (((::std::vector<T1DigiVfat>*)o)->begin)();
}

static  void method_8243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T1DigiVfat*,std::vector<T1DigiVfat> >)((((const ::std::vector<T1DigiVfat>*)o)->begin)());
  else   (((const ::std::vector<T1DigiVfat>*)o)->begin)();
}

static  void method_8244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >)((((::std::vector<T1DigiVfat>*)o)->end)());
  else   (((::std::vector<T1DigiVfat>*)o)->end)();
}

static  void method_8245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T1DigiVfat*,std::vector<T1DigiVfat> >)((((const ::std::vector<T1DigiVfat>*)o)->end)());
  else   (((const ::std::vector<T1DigiVfat>*)o)->end)();
}

static  void method_8250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1DigiVfat>*)o)->size)());
  else   (((const ::std::vector<T1DigiVfat>*)o)->size)();
}

static  void method_8251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1DigiVfat>*)o)->max_size)());
  else   (((const ::std::vector<T1DigiVfat>*)o)->max_size)();
}

static  void method_8252( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<T1DigiVfat>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<T1DigiVfat>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::T1DigiVfat*)arg[1]);
  }
}

static  void method_8253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T1DigiVfat>*)o)->capacity)());
  else   (((const ::std::vector<T1DigiVfat>*)o)->capacity)();
}

static  void method_8254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<T1DigiVfat>*)o)->empty)());
  else   (((const ::std::vector<T1DigiVfat>*)o)->empty)();
}

static  void method_8255( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1DigiVfat>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1DigiVfat>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T1DigiVfat>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1DigiVfat>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T1DigiVfat>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1DigiVfat>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T1DigiVfat>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8260( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1DigiVfat>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T1DigiVfat>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1DigiVfat>*)o)->front)();
  else   (((::std::vector<T1DigiVfat>*)o)->front)();
}

static  void method_8262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1DigiVfat>*)o)->front)();
  else   (((const ::std::vector<T1DigiVfat>*)o)->front)();
}

static  void method_8263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T1DigiVfat>*)o)->back)();
  else   (((::std::vector<T1DigiVfat>*)o)->back)();
}

static  void method_8264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T1DigiVfat>*)o)->back)();
  else   (((const ::std::vector<T1DigiVfat>*)o)->back)();
}

static  void method_8265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<T1DigiVfat>*)o)->data)());
  else   (((::std::vector<T1DigiVfat>*)o)->data)();
}

static  void method_8266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<T1DigiVfat>*)o)->data)());
  else   (((const ::std::vector<T1DigiVfat>*)o)->data)();
}

static  void method_8267( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1DigiVfat>*)o)->push_back)(*(const ::T1DigiVfat*)arg[0]);
}

static  void method_8268( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T1DigiVfat>*)o)->pop_back)();
}

static  void method_8269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >)((((::std::vector<T1DigiVfat>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >*)arg[0],
    *(const ::T1DigiVfat*)arg[1]));
  else   (((::std::vector<T1DigiVfat>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >*)arg[0],
    *(const ::T1DigiVfat*)arg[1]);
}

static  void method_8270( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1DigiVfat>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::T1DigiVfat*)arg[2]);
}

static  void method_8271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >)((((::std::vector<T1DigiVfat>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >*)arg[0]));
  else   (((::std::vector<T1DigiVfat>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >*)arg[0]);
}

static  void method_8272( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >)((((::std::vector<T1DigiVfat>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >*)arg[1]));
  else   (((::std::vector<T1DigiVfat>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T1DigiVfat*,std::vector<T1DigiVfat> >*)arg[1]);
}

static  void method_8273( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T1DigiVfat>*)o)->swap)(*(::std::vector<T1DigiVfat>*)arg[0]);
}

static  void method_8274( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T1DigiVfat>*)o)->clear)();
}

static void method_newdel_2512( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<T1DigiVfat> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<T1DigiVfat> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<T1DigiVfat> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<T1DigiVfat> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<T1DigiVfat> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T1DigiVfat,std::allocator<T1DigiVfat> >")), ::Reflex::BaseOffset< ::std::vector<T1DigiVfat>,::std::_Vector_base<T1DigiVfat,std::allocator<T1DigiVfat> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<T1DigiVfat> >::Generate();
  else ::Reflex::Proxy< ::std::vector<T1DigiVfat> >::Generate();
}

//------Dictionary for class vector<T1DigiVfat,std::allocator<T1DigiVfat> > -------------------------------
void __std__vector_T1DigiVfat__db_datamem(Reflex::Class*);
void __std__vector_T1DigiVfat__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_T1DigiVfat__datamem_bld(&__std__vector_T1DigiVfat__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_T1DigiVfat__funcmem_bld(&__std__vector_T1DigiVfat__db_funcmem);
void __std__vector_T1DigiVfat__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<T1DigiVfat>"), typeid(::std::vector<T1DigiVfat>), sizeof(::std::vector<T1DigiVfat>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2152, ::Reflex::BaseOffset< ::std::vector<T1DigiVfat>, ::std::_Vector_base<T1DigiVfat,std::allocator<T1DigiVfat> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1529, Reflex::Literal("std::vector<T1DigiVfat>::_Alloc_value_type"))
  .AddTypedef(type_2152, Reflex::Literal("std::vector<T1DigiVfat>::_Base"))
  .AddTypedef(type_2671, Reflex::Literal("std::vector<T1DigiVfat>::_Tp_alloc_type"))
  .AddTypedef(type_5051, Reflex::Literal("std::vector<T1DigiVfat>::_Alloc_traits"))
  .AddTypedef(type_1529, Reflex::Literal("std::vector<T1DigiVfat>::value_type"))
  .AddTypedef(type_5947, Reflex::Literal("std::vector<T1DigiVfat>::pointer"))
  .AddTypedef(type_8223, Reflex::Literal("std::vector<T1DigiVfat>::const_pointer"))
  .AddTypedef(type_8225, Reflex::Literal("std::vector<T1DigiVfat>::reference"))
  .AddTypedef(type_4093, Reflex::Literal("std::vector<T1DigiVfat>::const_reference"))
  .AddTypedef(type_4985, Reflex::Literal("std::vector<T1DigiVfat>::iterator"))
  .AddTypedef(type_4454, Reflex::Literal("std::vector<T1DigiVfat>::const_iterator"))
  .AddTypedef(type_2758, Reflex::Literal("std::vector<T1DigiVfat>::const_reverse_iterator"))
  .AddTypedef(type_2759, Reflex::Literal("std::vector<T1DigiVfat>::reverse_iterator"))
  .AddTypedef(type_2655, Reflex::Literal("std::vector<T1DigiVfat>::size_type"))
  .AddTypedef(type_2592, Reflex::Literal("std::vector<T1DigiVfat>::difference_type"))
  .AddTypedef(type_2671, Reflex::Literal("std::vector<T1DigiVfat>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8235, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15864), Reflex::Literal("vector"), constructor_8236, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2655, type_4093, type_15864), Reflex::Literal("vector"), constructor_8237, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8291), Reflex::Literal("vector"), constructor_8238, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8239, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2512, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_T1DigiVfat__funcmem_bld);
}

//------Delayed data member builder for class vector<T1DigiVfat,std::allocator<T1DigiVfat> > -------------------
void __std__vector_T1DigiVfat__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<T1DigiVfat,std::allocator<T1DigiVfat> > -------------------
void __std__vector_T1DigiVfat__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8289, type_8291), Reflex::Literal("operator="), operator_8240, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2655, type_4093), Reflex::Literal("assign"), method_8241, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4985), Reflex::Literal("begin"), method_8242, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4454), Reflex::Literal("begin"), method_8243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4985), Reflex::Literal("end"), method_8244, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4454), Reflex::Literal("end"), method_8245, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2655), Reflex::Literal("size"), method_8250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2655), Reflex::Literal("max_size"), method_8251, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2655, type_1529), Reflex::Literal("resize"), method_8252, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2655), Reflex::Literal("capacity"), method_8253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1370), Reflex::Literal("empty"), method_8254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2655), Reflex::Literal("reserve"), method_8255, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8225, type_2655), Reflex::Literal("operator[]"), operator_8256, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4093, type_2655), Reflex::Literal("operator[]"), operator_8257, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8225, type_2655), Reflex::Literal("at"), method_8259, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4093, type_2655), Reflex::Literal("at"), method_8260, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8225), Reflex::Literal("front"), method_8261, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4093), Reflex::Literal("front"), method_8262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8225), Reflex::Literal("back"), method_8263, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4093), Reflex::Literal("back"), method_8264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5947), Reflex::Literal("data"), method_8265, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8223), Reflex::Literal("data"), method_8266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_4093), Reflex::Literal("push_back"), method_8267, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("pop_back"), method_8268, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4985, type_4985, type_4093), Reflex::Literal("insert"), method_8269, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_4985, type_2655, type_4093), Reflex::Literal("insert"), method_8270, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4985, type_4985), Reflex::Literal("erase"), method_8271, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4985, type_4985, type_4985), Reflex::Literal("erase"), method_8272, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_8289), Reflex::Literal("swap"), method_8273, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_8274, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<T1DetId,std::vector<T1DigiVfat, std::allocator<T1DigiVfat> >,std::less<T1DetId>,std::allocator<std::pair<const T1DetId, std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > > > -------------------------------
static void destructor_9531(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->::std::map<T1DetId,std::vector<T1DigiVfat> >::~map)();
}
static void constructor_9532( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T1DetId,std::vector<T1DigiVfat> >();
  else ::new(mem) ::std::map<T1DetId,std::vector<T1DigiVfat> >();
}

static void constructor_9533( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T1DetId,std::vector<T1DigiVfat> >(*(const ::std::less<T1DetId>*)arg[0]);
  else ::new(mem) ::std::map<T1DetId,std::vector<T1DigiVfat> >(*(const ::std::less<T1DetId>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T1DetId,std::vector<T1DigiVfat> >(*(const ::std::less<T1DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >*)arg[1]);
  else ::new(mem) ::std::map<T1DetId,std::vector<T1DigiVfat> >(*(const ::std::less<T1DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >*)arg[1]);
  }
}

static void constructor_9534( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T1DetId,std::vector<T1DigiVfat> >(*(const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
  else ::new(mem) ::std::map<T1DetId,std::vector<T1DigiVfat> >(*(const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
}

static  void operator_9535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->operator=)(*(const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->operator=)(*(const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
}

static  void method_9536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->get_allocator)());
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->get_allocator)();
}

static  void method_9537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->begin)());
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->begin)();
}

static  void method_9538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->begin)());
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->begin)();
}

static  void method_9539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->end)());
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->end)();
}

static  void method_9540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->end)());
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->end)();
}

static  void method_9545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->empty)());
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->empty)();
}

static  void method_9546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->size)());
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->size)();
}

static  void method_9547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->max_size)());
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->max_size)();
}

static  void operator_9548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->operator[])(*(const ::T1DetId*)arg[0]);
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->operator[])(*(const ::T1DetId*)arg[0]);
}

static  void method_9549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->at)(*(const ::T1DetId*)arg[0]);
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->at)(*(const ::T1DetId*)arg[0]);
}

static  void method_9550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->at)(*(const ::T1DetId*)arg[0]);
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->at)(*(const ::T1DetId*)arg[0]);
}

static  void method_9551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >,bool>)((((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->insert)(*(const ::std::pair<const T1DetId,std::vector<T1DigiVfat> >*)arg[0]));
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->insert)(*(const ::std::pair<const T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
}

static  void method_9552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >*)arg[0],
    *(const ::std::pair<const T1DetId,std::vector<T1DigiVfat> >*)arg[1]));
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >*)arg[0],
    *(const ::std::pair<const T1DetId,std::vector<T1DigiVfat> >*)arg[1]);
}

static  void method_9553( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >*)arg[0]);
}

static  void method_9554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->erase)(*(const ::T1DetId*)arg[0]));
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->erase)(*(const ::T1DetId*)arg[0]);
}

static  void method_9555( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >*)arg[1]);
}

static  void method_9556( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->swap)(*(::std::map<T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
}

static  void method_9557( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->clear)();
}

static  void method_9558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<T1DetId>)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->key_comp)());
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->key_comp)();
}

static  void method_9560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->find)(*(const ::T1DetId*)arg[0]));
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->find)(*(const ::T1DetId*)arg[0]);
}

static  void method_9561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->find)(*(const ::T1DetId*)arg[0]));
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->find)(*(const ::T1DetId*)arg[0]);
}

static  void method_9562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->count)(*(const ::T1DetId*)arg[0]));
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->count)(*(const ::T1DetId*)arg[0]);
}

static  void method_9563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->lower_bound)(*(const ::T1DetId*)arg[0]));
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->lower_bound)(*(const ::T1DetId*)arg[0]);
}

static  void method_9564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->lower_bound)(*(const ::T1DetId*)arg[0]));
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->lower_bound)(*(const ::T1DetId*)arg[0]);
}

static  void method_9565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->upper_bound)(*(const ::T1DetId*)arg[0]));
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->upper_bound)(*(const ::T1DetId*)arg[0]);
}

static  void method_9566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->upper_bound)(*(const ::T1DetId*)arg[0]));
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->upper_bound)(*(const ::T1DetId*)arg[0]);
}

static  void method_9567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >,std::_Rb_tree_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > > >)((((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->equal_range)(*(const ::T1DetId*)arg[0]));
  else   (((::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->equal_range)(*(const ::T1DetId*)arg[0]);
}

static  void method_9568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > >,std::_Rb_tree_const_iterator<std::pair<const T1DetId,std::vector<T1DigiVfat> > > >)((((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->equal_range)(*(const ::T1DetId*)arg[0]));
  else   (((const ::std::map<T1DetId,std::vector<T1DigiVfat> >*)o)->equal_range)(*(const ::T1DetId*)arg[0]);
}

static void method_newdel_2614( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<T1DetId,std::vector<T1DigiVfat> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<T1DetId,std::vector<T1DigiVfat> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<T1DetId,std::vector<T1DigiVfat> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<T1DetId,std::vector<T1DigiVfat> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<T1DetId,std::vector<T1DigiVfat> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<T1DetId,std::vector<T1DigiVfat> > >::Generate();
  else ::Reflex::Proxy< ::std::map<T1DetId,std::vector<T1DigiVfat> > >::Generate();
}

//------Dictionary for class map<T1DetId,std::vector<T1DigiVfat, std::allocator<T1DigiVfat> >,std::less<T1DetId>,std::allocator<std::pair<const T1DetId, std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > > > -------------------------------
void __std__map_T1DetId_std__vector_T1DigiVfat_s__db_datamem(Reflex::Class*);
void __std__map_T1DetId_std__vector_T1DigiVfat_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_T1DetId_std__vector_T1DigiVfat_s__datamem_bld(&__std__map_T1DetId_std__vector_T1DigiVfat_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_T1DetId_std__vector_T1DigiVfat_s__funcmem_bld(&__std__map_T1DetId_std__vector_T1DigiVfat_s__db_funcmem);
void __std__map_T1DetId_std__vector_T1DigiVfat_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >"), typeid(::std::map<T1DetId,std::vector<T1DigiVfat> >), sizeof(::std::map<T1DetId,std::vector<T1DigiVfat> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_173, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::key_type"))
  .AddTypedef(type_2512, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::mapped_type"))
  .AddTypedef(type_2489, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::value_type"))
  .AddTypedef(type_2279, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::key_compare"))
  .AddTypedef(type_2673, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::allocator_type"))
  .AddTypedef(type_2489, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::_Alloc_value_type"))
  .AddTypedef(type_2673, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::_Pair_alloc_type"))
  .AddTypedef(type_2327, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::_Rep_type"))
  .AddTypedef(type_7235, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::pointer"))
  .AddTypedef(type_7237, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::const_pointer"))
  .AddTypedef(type_7239, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::reference"))
  .AddTypedef(type_7241, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::const_reference"))
  .AddTypedef(type_2565, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::iterator"))
  .AddTypedef(type_2658, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::const_iterator"))
  .AddTypedef(type_2655, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::size_type"))
  .AddTypedef(type_2592, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::difference_type"))
  .AddTypedef(type_2755, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::reverse_iterator"))
  .AddTypedef(type_2754, Reflex::Literal("std::map<T1DetId,std::vector<T1DigiVfat> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_9531, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_9532, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16265, type_16342), Reflex::Literal("map"), constructor_9533, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16606), Reflex::Literal("map"), constructor_9534, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2614, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_T1DetId_std__vector_T1DigiVfat_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_T1DetId_std__vector_T1DigiVfat_s__funcmem_bld);
}

//------Delayed data member builder for class map<T1DetId,std::vector<T1DigiVfat, std::allocator<T1DigiVfat> >,std::less<T1DetId>,std::allocator<std::pair<const T1DetId, std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > > > -------------------
void __std__map_T1DetId_std__vector_T1DigiVfat_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2327, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_T1DetId_std__vector_T1DigiVfat_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<T1DetId,std::vector<T1DigiVfat, std::allocator<T1DigiVfat> >,std::less<T1DetId>,std::allocator<std::pair<const T1DetId, std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > > > -------------------
void __std__map_T1DetId_std__vector_T1DigiVfat_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16607, type_16606), Reflex::Literal("operator="), operator_9535, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2673), Reflex::Literal("get_allocator"), method_9536, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2565), Reflex::Literal("begin"), method_9537, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2658), Reflex::Literal("begin"), method_9538, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2565), Reflex::Literal("end"), method_9539, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2658), Reflex::Literal("end"), method_9540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1370), Reflex::Literal("empty"), method_9545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2655), Reflex::Literal("size"), method_9546, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2655), Reflex::Literal("max_size"), method_9547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8289, type_4092), Reflex::Literal("operator[]"), operator_9548, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8289, type_4092), Reflex::Literal("at"), method_9549, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8291, type_4092), Reflex::Literal("at"), method_9550, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2491, type_7241), Reflex::Literal("insert"), method_9551, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2565, type_2565, type_7241), Reflex::Literal("insert"), method_9552, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2565), Reflex::Literal("erase"), method_9553, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2655, type_4092), Reflex::Literal("erase"), method_9554, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2565, type_2565), Reflex::Literal("erase"), method_9555, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_16607), Reflex::Literal("swap"), method_9556, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_9557, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2279), Reflex::Literal("key_comp"), method_9558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2565, type_4092), Reflex::Literal("find"), method_9560, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2658, type_4092), Reflex::Literal("find"), method_9561, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2655, type_4092), Reflex::Literal("count"), method_9562, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2565, type_4092), Reflex::Literal("lower_bound"), method_9563, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2658, type_4092), Reflex::Literal("lower_bound"), method_9564, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2565, type_4092), Reflex::Literal("upper_bound"), method_9565, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2658, type_4092), Reflex::Literal("upper_bound"), method_9566, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2490, type_4092), Reflex::Literal("equal_range"), method_9567, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2488, type_4092), Reflex::Literal("equal_range"), method_9568, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::pair<T1DetId, std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > > -------------------------------
static void constructor_12313( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >();
  else ::new(mem) ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >();
}

static void constructor_12314( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >(*(::std::auto_ptr<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >(*(::std::auto_ptr<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)arg[0]);
}

static void destructor_12315(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >::~Wrapper)();
}
static  void method_12316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->product)();
}

static  void operator_12317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->operator->)();
}

static  void method_12318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->productTypeInfo)();
}

static  void method_12319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->typeInfo)();
}

static void constructor_12320( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >((::std::pair<T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >((::std::pair<T1DetId,std::vector<T1DigiVfat> >*)arg[0]);
}

static  void method_12321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->getInterface)();
}

static  void method_12322( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12323( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12324( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->dynamicTypeInfo)();
}

static  void method_12326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->isPresent)();
}

static  void method_12327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3343( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::pair<T1DetId, std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > > -------------------------------
void __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__datamem_bld(&__edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__funcmem_bld(&__edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__db_funcmem);
void __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >"), typeid(::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >), sizeof(::edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2487, Reflex::Literal("edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >::value_type"))
  .AddTypedef(type_2487, Reflex::Literal("edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12313, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367), Reflex::Literal("Wrapper"), constructor_12314, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12315, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18334), Reflex::Literal("Wrapper"), constructor_12320, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3343, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::pair<T1DetId, std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > > -------------------
void __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1370, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2487, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::pair<T1DetId, std::vector<T1DigiVfat, std::allocator<T1DigiVfat> > > > -------------------
void __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18333), Reflex::Literal("product"), method_12316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18333), Reflex::Literal("operator->"), operator_12317, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11129), Reflex::Literal("productTypeInfo"), method_12318, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11129), Reflex::Literal("typeInfo"), method_12319, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18335), Reflex::Literal("getInterface"), method_12321, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12381, type_16489, type_18258), Reflex::Literal("fillView"), method_12322, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_11129, type_278, type_6668), Reflex::Literal("setPtr"), method_12323, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_11129, type_16490, type_16489), Reflex::Literal("fillPtrVector"), method_12324, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11129), Reflex::Literal("dynamicTypeInfo"), method_12325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1370), Reflex::Literal("isPresent"), method_12326, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11129), Reflex::Literal("dynamicTypeInfo_"), method_12327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TotemDigiCollection<T1DetId, T1DigiVfat> > -------------------------------
static void constructor_12334( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >();
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >();
}

static void constructor_12335( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >(*(::std::auto_ptr<TotemDigiCollection<T1DetId,T1DigiVfat> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >(*(::std::auto_ptr<TotemDigiCollection<T1DetId,T1DigiVfat> >*)arg[0]);
}

static void destructor_12336(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >::~Wrapper)();
}
static  void method_12337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->product)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->product)();
}

static  void operator_12338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->operator->)();
}

static  void method_12339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->productTypeInfo)();
}

static  void method_12340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->typeInfo)();
}

static void constructor_12341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >((::TotemDigiCollection<T1DetId,T1DigiVfat>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >((::TotemDigiCollection<T1DetId,T1DigiVfat>*)arg[0]);
}

static  void method_12342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->getInterface)());
  else   (((::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->getInterface)();
}

static  void method_12343( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12344( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12345( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->dynamicTypeInfo)();
}

static  void method_12347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->isPresent)();
}

static  void method_12348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3344( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TotemDigiCollection<T1DetId, T1DigiVfat> > -------------------------------
void __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__datamem_bld(&__edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__funcmem_bld(&__edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__db_funcmem);
void __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >"), typeid(::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >), sizeof(::edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_1372, Reflex::Literal("edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >::value_type"))
  .AddTypedef(type_1372, Reflex::Literal("edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12334, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2368), Reflex::Literal("Wrapper"), constructor_12335, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12336, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18339), Reflex::Literal("Wrapper"), constructor_12341, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3344, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TotemDigiCollection<T1DetId, T1DigiVfat> > -------------------
void __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1370, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1372, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TotemDigiCollection<T1DetId, T1DigiVfat> > -------------------
void __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18338), Reflex::Literal("product"), method_12337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18338), Reflex::Literal("operator->"), operator_12338, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11129), Reflex::Literal("productTypeInfo"), method_12339, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11129), Reflex::Literal("typeInfo"), method_12340, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18340), Reflex::Literal("getInterface"), method_12342, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12381, type_16489, type_18258), Reflex::Literal("fillView"), method_12343, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_11129, type_278, type_6668), Reflex::Literal("setPtr"), method_12344, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_11129, type_16490, type_16489), Reflex::Literal("fillPtrVector"), method_12345, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11129), Reflex::Literal("dynamicTypeInfo"), method_12346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1370), Reflex::Literal("isPresent"), method_12347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11129), Reflex::Literal("dynamicTypeInfo_"), method_12348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TotemDigiCollection_T1DetId_T1DigiVfat__dict(); 
      __T1DigiVfat_dict(); 
      __std__pair_T1DetId_std__vector_T1DigiVfat_s__dict(); 
      __std__vector_T1DigiVfat__dict(); 
      __std__map_T1DetId_std__vector_T1DigiVfat_s__dict(); 
      __edm__Wrapper_std__pair_T1DetId_std__vector_T1DigiVfat_s_s__dict(); 
      __edm__Wrapper_TotemDigiCollection_T1DetId_T1DigiVfat_s__dict(); 
    }
    ~Dictionaries() {
      type_1372.Unload(); // class TotemDigiCollection<T1DetId,T1DigiVfat> 
      type_1529.Unload(); // class T1DigiVfat 
      type_2487.Unload(); // class std::pair<T1DetId,std::vector<T1DigiVfat> > 
      type_2512.Unload(); // class std::vector<T1DigiVfat> 
      type_2614.Unload(); // class std::map<T1DetId,std::vector<T1DigiVfat> > 
      type_3343.Unload(); // class edm::Wrapper<std::pair<T1DetId,std::vector<T1DigiVfat> > > 
      type_3344.Unload(); // class edm::Wrapper<TotemDigiCollection<T1DetId,T1DigiVfat> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
