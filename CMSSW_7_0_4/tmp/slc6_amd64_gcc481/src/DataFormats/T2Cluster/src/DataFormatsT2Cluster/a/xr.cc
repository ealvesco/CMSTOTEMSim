// Generated at Mon Jul 11 23:12:26 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/T2Cluster/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_69 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_10 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_577 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_750 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_376 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_99 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1235 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_1375 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_771 = ::Reflex::TypeBuilder(Reflex::Literal("T2DetId"));
  ::Reflex::Type type_1214 = ::Reflex::TypeBuilder(Reflex::Literal("T2Cluster"));
  ::Reflex::Type type_276 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1931 = ::Reflex::TypeBuilder(Reflex::Literal("T2ROGeometry"));
  ::Reflex::Type type_269 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_194 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_1267 = ::Reflex::TypeBuilder(Reflex::Literal("cluster_entry"));
  ::Reflex::Type type_392 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3440 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2287 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<T2DetId>"));
  ::Reflex::Type type_2525 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2522 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<T2Cluster>"));
  ::Reflex::Type type_2520 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2679 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<T2Cluster>"));
  ::Reflex::Type type_2523 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<cluster_entry>"));
  ::Reflex::Type type_2521 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_4499 = ::Reflex::EnumTypeBuilder(Reflex::Literal("T2Cluster::cluster_type"));
  ::Reflex::Type type_2681 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<cluster_entry>"));
  ::Reflex::Type type_1436 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >"));
  ::Reflex::Type type_2498 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<T2DetId,std::vector<T2Cluster> >"));
  ::Reflex::Type type_2499 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const T2DetId,std::vector<T2Cluster> >"));
  ::Reflex::Type type_5186 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<T2Cluster> >"));
  ::Reflex::Type type_3263 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_2159 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2Cluster,std::allocator<T2Cluster> >"));
  ::Reflex::Type type_2524 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::map<T2DetId,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_3340 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_5188 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<cluster_entry> >"));
  ::Reflex::Type type_2374 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<T2DetId,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_3339 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_2373 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::pair<T2DetId,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_2161 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cluster_entry,std::allocator<cluster_entry> >"));
  ::Reflex::Type type_5116 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >"));
  ::Reflex::Type type_2680 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const T2DetId,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_3370 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<T2DetId,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_3369 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::pair<T2DetId,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_782 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >"));
  ::Reflex::Type type_5117 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const T2Cluster*,std::vector<T2Cluster> >"));
  ::Reflex::Type type_2375 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >"));
  ::Reflex::Type type_5120 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >"));
  ::Reflex::Type type_2575 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_5121 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const cluster_entry*,std::vector<cluster_entry> >"));
  ::Reflex::Type type_2666 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_3371 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >"));
  ::Reflex::Type type_2767 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_2502 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >,bool>"));
  ::Reflex::Type type_2766 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const T2Cluster*,std::vector<T2Cluster> > >"));
  ::Reflex::Type type_2773 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> > >"));
  ::Reflex::Type type_2771 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > > >"));
  ::Reflex::Type type_2772 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const cluster_entry*,std::vector<cluster_entry> > >"));
  ::Reflex::Type type_2770 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > > >"));
  ::Reflex::Type type_2501 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >,std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > > >"));
  ::Reflex::Type type_2500 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >,std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > > >"));
  ::Reflex::Type type_2335 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<T2DetId,std::pair<const T2DetId,std::vector<T2Cluster> >,std::_Select1st<std::pair<const T2DetId,std::vector<T2Cluster> > >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId,std::vector<T2Cluster> > > >"));
  ::Reflex::Type type_783 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2PadClusterCollectionWrapper"), type_782);
  ::Reflex::Type type_1437 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2StripClusterCollection"), type_1436);
  ::Reflex::Type type_1784 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2PadClusterCollection"), type_1436);
  ::Reflex::Type type_1894 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("T2StripClusterCollectionWrapper"), type_782);
  ::Reflex::Type type_1339 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_276);
  ::Reflex::Type type_8377 = ::Reflex::ReferenceBuilder(type_1214);
  ::Reflex::Type type_1214c = ::Reflex::ConstBuilder(type_1214);
  ::Reflex::Type type_4382 = ::Reflex::ReferenceBuilder(type_1214c);
  ::Reflex::Type type_2523c = ::Reflex::ConstBuilder(type_2523);
  ::Reflex::Type type_13353 = ::Reflex::ReferenceBuilder(type_2523c);
  ::Reflex::Type type_1267c = ::Reflex::ConstBuilder(type_1267);
  ::Reflex::Type type_8443 = ::Reflex::ReferenceBuilder(type_1267c);
  ::Reflex::Type type_13354 = ::Reflex::ReferenceBuilder(type_2525);
  ::Reflex::Type type_9981 = ::Reflex::ReferenceBuilder(type_750);
  ::Reflex::Type type_13355 = ::Reflex::ReferenceBuilder(type_194);
  ::Reflex::Type type_8441 = ::Reflex::ReferenceBuilder(type_1267);
  ::Reflex::Type type_16046 = ::Reflex::ArrayBuilder(type_99, 24);
  ::Reflex::Type type_19234 = ::Reflex::ArrayBuilder(type_99, 2);
  ::Reflex::Type type_16047 = ::Reflex::ArrayBuilder(type_19234, 256);
  ::Reflex::Type type_19235 = ::Reflex::ArrayBuilder(type_99, 65);
  ::Reflex::Type type_16048 = ::Reflex::ArrayBuilder(type_19235, 24);
  ::Reflex::Type type_16049 = ::Reflex::ReferenceBuilder(type_1931);
  ::Reflex::Type type_1931c = ::Reflex::ConstBuilder(type_1931);
  ::Reflex::Type type_16050 = ::Reflex::ReferenceBuilder(type_1931c);
  ::Reflex::Type type_16761 = ::Reflex::ReferenceBuilder(type_2498);
  ::Reflex::Type type_2498c = ::Reflex::ConstBuilder(type_2498);
  ::Reflex::Type type_16762 = ::Reflex::ReferenceBuilder(type_2498c);
  ::Reflex::Type type_771c = ::Reflex::ConstBuilder(type_771);
  ::Reflex::Type type_4383 = ::Reflex::ReferenceBuilder(type_771c);
  ::Reflex::Type type_2522c = ::Reflex::ConstBuilder(type_2522);
  ::Reflex::Type type_13365 = ::Reflex::ReferenceBuilder(type_2522c);
  ::Reflex::Type type_6118 = ::Reflex::PointerBuilder(type_1214);
  ::Reflex::Type type_8375 = ::Reflex::PointerBuilder(type_1214c);
  ::Reflex::Type type_2664 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_269);
  ::Reflex::Type type_2602 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_10);
  ::Reflex::Type type_2679c = ::Reflex::ConstBuilder(type_2679);
  ::Reflex::Type type_16128 = ::Reflex::ReferenceBuilder(type_2679c);
  ::Reflex::Type type_13364 = ::Reflex::ReferenceBuilder(type_2522);
  ::Reflex::Type type_6156 = ::Reflex::PointerBuilder(type_1267);
  ::Reflex::Type type_8439 = ::Reflex::PointerBuilder(type_1267c);
  ::Reflex::Type type_2681c = ::Reflex::ConstBuilder(type_2681);
  ::Reflex::Type type_16154 = ::Reflex::ReferenceBuilder(type_2681c);
  ::Reflex::Type type_16773 = ::Reflex::ReferenceBuilder(type_2523);
  ::Reflex::Type type_18614 = ::Reflex::PointerBuilder(type_2498c);
  ::Reflex::Type type_392c = ::Reflex::ConstBuilder(type_392);
  ::Reflex::Type type_11351 = ::Reflex::ReferenceBuilder(type_392c);
  ::Reflex::Type type_18615 = ::Reflex::PointerBuilder(type_2498);
  ::Reflex::Type type_3369c = ::Reflex::ConstBuilder(type_3369);
  ::Reflex::Type type_18616 = ::Reflex::PointerBuilder(type_3369c);
  ::Reflex::Type type_3440c = ::Reflex::ConstBuilder(type_3440);
  ::Reflex::Type type_12583 = ::Reflex::ReferenceBuilder(type_3440c);
  ::Reflex::Type type_13302 = ::Reflex::ReferenceBuilder(type_2520);
  ::Reflex::Type type_13303 = ::Reflex::ReferenceBuilder(type_3263);
  ::Reflex::Type type_577c = ::Reflex::ConstBuilder(type_577);
  ::Reflex::Type type_2977 = ::Reflex::PointerBuilder(type_577c);
  ::Reflex::Type type_6861 = ::Reflex::ReferenceBuilder(type_2977);
  ::Reflex::Type type_2521c = ::Reflex::ConstBuilder(type_2521);
  ::Reflex::Type type_13304 = ::Reflex::ReferenceBuilder(type_2521c);
  ::Reflex::Type type_4588 = ::Reflex::PointerBuilder(type_2499);
  ::Reflex::Type type_2499c = ::Reflex::ConstBuilder(type_2499);
  ::Reflex::Type type_4590 = ::Reflex::PointerBuilder(type_2499c);
  ::Reflex::Type type_4592 = ::Reflex::ReferenceBuilder(type_2499);
  ::Reflex::Type type_4594 = ::Reflex::ReferenceBuilder(type_2499c);
  ::Reflex::Type type_2287c = ::Reflex::ConstBuilder(type_2287);
  ::Reflex::Type type_13362 = ::Reflex::ReferenceBuilder(type_2287c);
  ::Reflex::Type type_2680c = ::Reflex::ConstBuilder(type_2680);
  ::Reflex::Type type_13363 = ::Reflex::ReferenceBuilder(type_2680c);
  ::Reflex::Type type_1436c = ::Reflex::ConstBuilder(type_1436);
  ::Reflex::Type type_8508 = ::Reflex::ReferenceBuilder(type_1436c);
  ::Reflex::Type type_8506 = ::Reflex::ReferenceBuilder(type_1436);
  ::Reflex::Type type_8504 = ::Reflex::PointerBuilder(type_1436c);
  ::Reflex::Type type_6137 = ::Reflex::PointerBuilder(type_1436);
  ::Reflex::Type type_3370c = ::Reflex::ConstBuilder(type_3370);
  ::Reflex::Type type_18619 = ::Reflex::PointerBuilder(type_3370c);
  ::Reflex::Type type_2524c = ::Reflex::ConstBuilder(type_2524);
  ::Reflex::Type type_13299 = ::Reflex::PointerBuilder(type_2524c);
  ::Reflex::Type type_13300 = ::Reflex::PointerBuilder(type_2524);
  ::Reflex::Type type_3371c = ::Reflex::ConstBuilder(type_3371);
  ::Reflex::Type type_13301 = ::Reflex::PointerBuilder(type_3371c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __T2Cluster
#undef __T2Cluster
#endif
class __T2Cluster {
  public:
  __T2Cluster();
  virtual ~__T2Cluster() throw();
  long ClustId_unique;
  ::uint32_t det_id_;
  ::T2Cluster::cluster_type type_;
  unsigned short entry_numb_;
  unsigned short radial_spread_;
  unsigned short angular_spread_;
  float radial_centre_;
  float angular_centre_;
  float R_centre_;
  float DR_centre_;
  float Phi_centre_;
  float DPhi_centre_;
  ::std::vector<cluster_entry> cluster_entries;
};
#ifdef __cluster_entry
#undef __cluster_entry
#endif
class __cluster_entry {
  public:
  __cluster_entry();
  unsigned short rad_coord;
  unsigned short ang_coord;
};
#ifdef __T2ROGeometry
#undef __T2ROGeometry
#endif
class __T2ROGeometry {
  public:
  __T2ROGeometry();
  virtual ~__T2ROGeometry() throw();
  double pi;
  ::uint32_t det_id_;
  unsigned int T2arm_;
  unsigned int T2halfTelescope_;
  unsigned int T2plane_;
  unsigned int T2planeSide_;
  char T2DetType_;
  double StripWidth;
  double StripPitch;
  double StripMinR;
  double StripMinPhiDeg;
  double StripMaxPhiDeg;
  double StripCutSchiftY;
  double StripCut;
  double PadRCut;
  double PadMinR;
  double PadRDPhiCut;
  double PadMaxR[24];
  double PadMaxPhiDeg[24];
  double PadDPhiDeg[24];
  double StripPhiMin[256][2];
  double StripPhiMax[256][2];
  double StripDPhiMaxMin[256][2];
  double StripRMin[256][2];
  double StripRMax[256][2];
  double PadRMin[24][65];
  double PadRMax[24][65];
  double PadPhiMin[24][65];
  double PadPhiMax[24][65];
};
#ifdef __std__pair_T2DetId_std__vector_T2Cluster_s_
#undef __std__pair_T2DetId_std__vector_T2Cluster_s_
#endif
struct __std__pair_T2DetId_std__vector_T2Cluster_s_ {
  public:
  __std__pair_T2DetId_std__vector_T2Cluster_s_();
  ::T2DetId first;
  ::std::vector<T2Cluster> second;
};
#ifdef __std__vector_T2Cluster_
#undef __std__vector_T2Cluster_
#endif
class __std__vector_T2Cluster_ : protected ::std::_Vector_base<T2Cluster,std::allocator<T2Cluster> > {
  public:
  __std__vector_T2Cluster_();
};
#ifdef __std__vector_cluster_entry_
#undef __std__vector_cluster_entry_
#endif
class __std__vector_cluster_entry_ : protected ::std::_Vector_base<cluster_entry,std::allocator<cluster_entry> > {
  public:
  __std__vector_cluster_entry_();
};
#ifdef __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s_
#undef __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s_
#endif
class __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s_ {
  public:
  __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s_();
  bool present;
  ::std::pair<T2DetId,std::vector<T2Cluster> > obj;
};
#ifdef __std__map_T2DetId_std__vector_T2Cluster_s_
#undef __std__map_T2DetId_std__vector_T2Cluster_s_
#endif
class __std__map_T2DetId_std__vector_T2Cluster_s_ {
  public:
  __std__map_T2DetId_std__vector_T2Cluster_s_();
  ::std::_Rb_tree<T2DetId,std::pair<const T2DetId,std::vector<T2Cluster> >,std::_Select1st<std::pair<const T2DetId,std::vector<T2Cluster> > >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId,std::vector<T2Cluster> > > > _M_t;
};
#ifdef __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s_
#undef __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s_
#endif
class __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s_ {
  public:
  __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s_();
  bool present;
  ::std::map<T2DetId,std::vector<T2Cluster> > obj;
};
#ifdef __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s_
#undef __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s_
#endif
class __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s_ {
  public:
  __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s_();
  bool present;
  ::std::vector<std::map<T2DetId,std::vector<T2Cluster> > > obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class T2Cluster -------------------------------
static  void operator_4500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T2Cluster*)o)->operator=)(*(const ::T2Cluster*)arg[0]);
  else   (((::T2Cluster*)o)->operator=)(*(const ::T2Cluster*)arg[0]);
}

static void constructor_4501( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Cluster(*(const ::T2Cluster*)arg[0]);
  else ::new(mem) ::T2Cluster(*(const ::T2Cluster*)arg[0]);
}

static void constructor_4502( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2Cluster();
  else ::new(mem) ::T2Cluster();
}

static void destructor_4503(void*, void * o, const std::vector<void*>&, void *) {
(((::T2Cluster*)o)->::T2Cluster::~T2Cluster)();
}
static  void method_4504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::T2Cluster*)o)->GetNoOfEntries)());
  else   (((const ::T2Cluster*)o)->GetNoOfEntries)();
}

static  void method_4505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::T2Cluster*)o)->GetRadialSpread)());
  else   (((const ::T2Cluster*)o)->GetRadialSpread)();
}

static  void method_4506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::T2Cluster*)o)->GetAngularSpread)());
  else   (((const ::T2Cluster*)o)->GetAngularSpread)();
}

static  void method_4507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Cluster*)o)->GetRadialCentrePos)());
  else   (((const ::T2Cluster*)o)->GetRadialCentrePos)();
}

static  void method_4508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Cluster*)o)->GetAngularCentrePos)());
  else   (((const ::T2Cluster*)o)->GetAngularCentrePos)();
}

static  void method_4509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Cluster*)o)->GetClusterR)());
  else   (((const ::T2Cluster*)o)->GetClusterR)();
}

static  void method_4510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Cluster*)o)->GetClusterDR)());
  else   (((const ::T2Cluster*)o)->GetClusterDR)();
}

static  void method_4511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Cluster*)o)->GetClusterPhi)());
  else   (((const ::T2Cluster*)o)->GetClusterPhi)();
}

static  void method_4512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::T2Cluster*)o)->GetClusterDPhi)());
  else   (((const ::T2Cluster*)o)->GetClusterDPhi)();
}

static  void method_4513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::T2Cluster*)o)->GetClusterType)());
  else   (((const ::T2Cluster*)o)->GetClusterType)();
}

static  void method_4514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::T2Cluster*)o)->GetDetID)());
  else   (((const ::T2Cluster*)o)->GetDetID)();
}

static  void method_4515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::T2Cluster*)o)->GetEntries)();
  else   (((const ::T2Cluster*)o)->GetEntries)();
}

static  void method_4516( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->SetNoOfEntries)(*(unsigned short*)arg[0]);
}

static  void method_4517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->SetRadialSpread)(*(unsigned short*)arg[0]);
}

static  void method_4518( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->SetAngularSpread)(*(unsigned short*)arg[0]);
}

static  void method_4519( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->SetRadialCentrePos)(*(float*)arg[0]);
}

static  void method_4520( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->SetAngularCentrePos)(*(float*)arg[0]);
}

static  void method_4521( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->SetClusterR)(*(float*)arg[0]);
}

static  void method_4522( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->SetClusterDR)(*(float*)arg[0]);
}

static  void method_4523( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->SetClusterPhi)(*(float*)arg[0]);
}

static  void method_4524( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->SetClusterDPhi)(*(float*)arg[0]);
}

static  void method_4525( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->SetClusterType)(*(::T2Cluster::cluster_type*)arg[0]);
}

static  void method_4526( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->SetDetID)(*(::uint32_t*)arg[0]);
}

static  void method_4527( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->AddEntry)(*(const ::cluster_entry*)arg[0]);
}

static  void method_4528( void*, void* o, const std::vector<void*>&, void*)
{
  (((::T2Cluster*)o)->ComputeClusterParams)();
}

static  void method_4529( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->ComputeClusterParamsForTracking)(*(double*)arg[0],
    *(int*)arg[1]);
}

static  void method_4530( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->Blobangular_centre_spread)(*(::std::vector<double>*)arg[0],
    *(float*)arg[1],
    *(unsigned short*)arg[2]);
}

static  void method_4531( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->Blobradial_centre_spread)(*(::std::vector<double>*)arg[0],
    *(float*)arg[1],
    *(unsigned short*)arg[2]);
}

static  void method_4532( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->BlobPhi_Dphi)(*(::std::vector<double>*)arg[0],
    *(::std::vector<double>*)arg[1],
    *(float*)arg[2],
    *(float*)arg[3]);
}

static  void method_4533( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2Cluster*)o)->BlobR_DR)(*(::std::vector<double>*)arg[0],
    *(::std::vector<double>*)arg[1],
    *(float*)arg[2],
    *(float*)arg[3]);
}

static void method_newdel_1214( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T2Cluster >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T2Cluster >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T2Cluster >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T2Cluster >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T2Cluster >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T2Cluster -------------------------------
void __T2Cluster_db_datamem(Reflex::Class*);
void __T2Cluster_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T2Cluster_datamem_bld(&__T2Cluster_db_datamem);
Reflex::GenreflexMemberBuilder __T2Cluster_funcmem_bld(&__T2Cluster_db_funcmem);
void __T2Cluster_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T2Cluster"), typeid(::T2Cluster), sizeof(::T2Cluster), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddTypedef(type_2523, Reflex::Literal("T2Cluster::cluster_entries_vector"))
  .AddEnum(Reflex::Literal("T2Cluster::cluster_type"), Reflex::Literal("pad=0;strip=1"), &typeid(T2Cluster::cluster_type), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8377, type_4382), Reflex::Literal("operator="), operator_4500, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4382), Reflex::Literal("T2Cluster"), constructor_4501, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T2Cluster"), constructor_4502, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T2Cluster"), destructor_4503, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1214, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T2Cluster_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T2Cluster_funcmem_bld);
}

//------Delayed data member builder for class T2Cluster -------------------
void __T2Cluster_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10, Reflex::Literal("ClustId_unique"), OffsetOf(__shadow__::__T2Cluster, ClustId_unique), ::Reflex::PUBLIC)
  .AddDataMember(type_1339, Reflex::Literal("det_id_"), OffsetOf(__shadow__::__T2Cluster, det_id_), ::Reflex::PRIVATE)
  .AddDataMember(type_4499, Reflex::Literal("type_"), OffsetOf(__shadow__::__T2Cluster, type_), ::Reflex::PRIVATE)
  .AddDataMember(type_194, Reflex::Literal("entry_numb_"), OffsetOf(__shadow__::__T2Cluster, entry_numb_), ::Reflex::PRIVATE)
  .AddDataMember(type_194, Reflex::Literal("radial_spread_"), OffsetOf(__shadow__::__T2Cluster, radial_spread_), ::Reflex::PRIVATE)
  .AddDataMember(type_194, Reflex::Literal("angular_spread_"), OffsetOf(__shadow__::__T2Cluster, angular_spread_), ::Reflex::PRIVATE)
  .AddDataMember(type_750, Reflex::Literal("radial_centre_"), OffsetOf(__shadow__::__T2Cluster, radial_centre_), ::Reflex::PRIVATE)
  .AddDataMember(type_750, Reflex::Literal("angular_centre_"), OffsetOf(__shadow__::__T2Cluster, angular_centre_), ::Reflex::PRIVATE)
  .AddDataMember(type_750, Reflex::Literal("R_centre_"), OffsetOf(__shadow__::__T2Cluster, R_centre_), ::Reflex::PRIVATE)
  .AddDataMember(type_750, Reflex::Literal("DR_centre_"), OffsetOf(__shadow__::__T2Cluster, DR_centre_), ::Reflex::PRIVATE)
  .AddDataMember(type_750, Reflex::Literal("Phi_centre_"), OffsetOf(__shadow__::__T2Cluster, Phi_centre_), ::Reflex::PRIVATE)
  .AddDataMember(type_750, Reflex::Literal("DPhi_centre_"), OffsetOf(__shadow__::__T2Cluster, DPhi_centre_), ::Reflex::PRIVATE)
  .AddDataMember(type_2523, Reflex::Literal("cluster_entries"), OffsetOf(__shadow__::__T2Cluster, cluster_entries), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T2Cluster -------------------
void __T2Cluster_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_194), Reflex::Literal("GetNoOfEntries"), method_4504, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_376), Reflex::Literal("GetRadialSpread"), method_4505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_376), Reflex::Literal("GetAngularSpread"), method_4506, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_750), Reflex::Literal("GetRadialCentrePos"), method_4507, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_750), Reflex::Literal("GetAngularCentrePos"), method_4508, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_750), Reflex::Literal("GetClusterR"), method_4509, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_750), Reflex::Literal("GetClusterDR"), method_4510, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_750), Reflex::Literal("GetClusterPhi"), method_4511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_750), Reflex::Literal("GetClusterDPhi"), method_4512, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4499), Reflex::Literal("GetClusterType"), method_4513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1339), Reflex::Literal("GetDetID"), method_4514, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13353), Reflex::Literal("GetEntries"), method_4515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_194), Reflex::Literal("SetNoOfEntries"), method_4516, 0, "entry_numb", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_194), Reflex::Literal("SetRadialSpread"), method_4517, 0, "radial_spread", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_194), Reflex::Literal("SetAngularSpread"), method_4518, 0, "angular_spread", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_750), Reflex::Literal("SetRadialCentrePos"), method_4519, 0, "radial_centre_pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_750), Reflex::Literal("SetAngularCentrePos"), method_4520, 0, "angular_centre_pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_750), Reflex::Literal("SetClusterR"), method_4521, 0, "R_centre_pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_750), Reflex::Literal("SetClusterDR"), method_4522, 0, "DR_centre_pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_750), Reflex::Literal("SetClusterPhi"), method_4523, 0, "Phi_centre_pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_750), Reflex::Literal("SetClusterDPhi"), method_4524, 0, "DPhi_centre_pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_4499), Reflex::Literal("SetClusterType"), method_4525, 0, "clu_type", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_1339), Reflex::Literal("SetDetID"), method_4526, 0, "det_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_8443), Reflex::Literal("AddEntry"), method_4527, 0, "point", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("ComputeClusterParams"), method_4528, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_99, type_69), Reflex::Literal("ComputeClusterParamsForTracking"), method_4529, 0, "Projectionthreshold;BlobMinSize", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_13354, type_9981, type_13355), Reflex::Literal("Blobangular_centre_spread"), method_4530, 0, "AllColscenters;angular_centre_;angular_spread_", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_13354, type_9981, type_13355), Reflex::Literal("Blobradial_centre_spread"), method_4531, 0, "AllRowscenters;radial_centre_;radial_spread_", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_13354, type_13354, type_9981, type_9981), Reflex::Literal("BlobPhi_Dphi"), method_4532, 0, "AllAzimuthcenters;AllAzimDphi;Phi_centre_;DPhi_centre", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_13354, type_13354, type_9981, type_9981), Reflex::Literal("BlobR_DR"), method_4533, 0, "AllRadialcenters;AllRadialDR;R_centre_;DR_centre_", ::Reflex::PUBLIC);
}
//------Stub functions for class cluster_entry -------------------------------
static void destructor_4541(void*, void * o, const std::vector<void*>&, void *) {
(((::cluster_entry*)o)->::cluster_entry::~cluster_entry)();
}
static  void operator_4542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::cluster_entry*)o)->operator=)(*(const ::cluster_entry*)arg[0]);
  else   (((::cluster_entry*)o)->operator=)(*(const ::cluster_entry*)arg[0]);
}

static void constructor_4543( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cluster_entry(*(const ::cluster_entry*)arg[0]);
  else ::new(mem) ::cluster_entry(*(const ::cluster_entry*)arg[0]);
}

static void constructor_4544( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cluster_entry();
  else ::new(mem) ::cluster_entry();
}

static void constructor_4545( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::cluster_entry(*(unsigned short*)arg[0],
      *(unsigned short*)arg[1]);
  else ::new(mem) ::cluster_entry(*(unsigned short*)arg[0],
      *(unsigned short*)arg[1]);
}

static void method_newdel_1267( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::cluster_entry >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::cluster_entry >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::cluster_entry >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::cluster_entry >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::cluster_entry >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class cluster_entry -------------------------------
void __cluster_entry_db_datamem(Reflex::Class*);
void __cluster_entry_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __cluster_entry_datamem_bld(&__cluster_entry_db_datamem);
Reflex::GenreflexMemberBuilder __cluster_entry_funcmem_bld(&__cluster_entry_db_funcmem);
void __cluster_entry_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("cluster_entry"), typeid(::cluster_entry), sizeof(::cluster_entry), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~cluster_entry"), destructor_4541, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8441, type_8443), Reflex::Literal("operator="), operator_4542, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8443), Reflex::Literal("cluster_entry"), constructor_4543, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("cluster_entry"), constructor_4544, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_194, type_194), Reflex::Literal("cluster_entry"), constructor_4545, 0, "rad;ang", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1267, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__cluster_entry_datamem_bld);
}

//------Delayed data member builder for class cluster_entry -------------------
void __cluster_entry_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_194, Reflex::Literal("rad_coord"), OffsetOf(__shadow__::__cluster_entry, rad_coord), ::Reflex::PUBLIC)
  .AddDataMember(type_194, Reflex::Literal("ang_coord"), OffsetOf(__shadow__::__cluster_entry, ang_coord), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class cluster_entry -------------------
void __cluster_entry_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class T2ROGeometry -------------------------------
static  void operator_5653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::T2ROGeometry*)o)->operator=)(*(const ::T2ROGeometry*)arg[0]);
  else   (((::T2ROGeometry*)o)->operator=)(*(const ::T2ROGeometry*)arg[0]);
}

static void constructor_5654( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2ROGeometry(*(const ::T2ROGeometry*)arg[0]);
  else ::new(mem) ::T2ROGeometry(*(const ::T2ROGeometry*)arg[0]);
}

static void constructor_5655( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2ROGeometry();
  else ::new(mem) ::T2ROGeometry();
}

static void constructor_5656( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::T2ROGeometry(*(::uint32_t*)arg[0]);
  else ::new(mem) ::T2ROGeometry(*(::uint32_t*)arg[0]);
}

static void destructor_5657(void*, void * o, const std::vector<void*>&, void *) {
(((::T2ROGeometry*)o)->::T2ROGeometry::~T2ROGeometry)();
}
static  void method_5658( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::T2ROGeometry*)o)->SetT2DetType)(*(::uint32_t*)arg[0]);
}

static  void method_5659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (char)((((const ::T2ROGeometry*)o)->GetT2DetType)());
  else   (((const ::T2ROGeometry*)o)->GetT2DetType)();
}

static  void method_5660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::T2ROGeometry*)o)->GetStripPhiMin)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::T2ROGeometry*)o)->GetStripPhiMin)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::T2ROGeometry*)o)->GetStripPhiMax)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::T2ROGeometry*)o)->GetStripPhiMax)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::T2ROGeometry*)o)->GetStripRMin)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::T2ROGeometry*)o)->GetStripRMin)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::T2ROGeometry*)o)->GetStripRMax)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::T2ROGeometry*)o)->GetStripRMax)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::T2ROGeometry*)o)->GetPadPhiMin)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::T2ROGeometry*)o)->GetPadPhiMin)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::T2ROGeometry*)o)->GetPadPhiMax)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::T2ROGeometry*)o)->GetPadPhiMax)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::T2ROGeometry*)o)->GetPadRMin)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::T2ROGeometry*)o)->GetPadRMin)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::T2ROGeometry*)o)->GetPadRMax)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::T2ROGeometry*)o)->GetPadRMax)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::T2ROGeometry*)o)->GetPadPhiMinLocal)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::T2ROGeometry*)o)->GetPadPhiMinLocal)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::T2ROGeometry*)o)->GetPadPhiMaxLocal)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((::T2ROGeometry*)o)->GetPadPhiMaxLocal)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::T2ROGeometry*)o)->GetDetId)());
  else   (((const ::T2ROGeometry*)o)->GetDetId)();
}

static void method_newdel_1931( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::T2ROGeometry >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::T2ROGeometry >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::T2ROGeometry >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::T2ROGeometry >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::T2ROGeometry >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class T2ROGeometry -------------------------------
void __T2ROGeometry_db_datamem(Reflex::Class*);
void __T2ROGeometry_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __T2ROGeometry_datamem_bld(&__T2ROGeometry_db_datamem);
Reflex::GenreflexMemberBuilder __T2ROGeometry_funcmem_bld(&__T2ROGeometry_db_funcmem);
void __T2ROGeometry_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("T2ROGeometry"), typeid(::T2ROGeometry), sizeof(::T2ROGeometry), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16049, type_16050), Reflex::Literal("operator="), operator_5653, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16050), Reflex::Literal("T2ROGeometry"), constructor_5654, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("T2ROGeometry"), constructor_5655, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1339), Reflex::Literal("T2ROGeometry"), constructor_5656, 0, "det_id", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~T2ROGeometry"), destructor_5657, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1931, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__T2ROGeometry_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__T2ROGeometry_funcmem_bld);
}

//------Delayed data member builder for class T2ROGeometry -------------------
void __T2ROGeometry_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_99, Reflex::Literal("pi"), OffsetOf(__shadow__::__T2ROGeometry, pi), ::Reflex::PUBLIC)
  .AddDataMember(type_1339, Reflex::Literal("det_id_"), OffsetOf(__shadow__::__T2ROGeometry, det_id_), ::Reflex::PRIVATE)
  .AddDataMember(type_276, Reflex::Literal("T2arm_"), OffsetOf(__shadow__::__T2ROGeometry, T2arm_), ::Reflex::PRIVATE)
  .AddDataMember(type_276, Reflex::Literal("T2halfTelescope_"), OffsetOf(__shadow__::__T2ROGeometry, T2halfTelescope_), ::Reflex::PRIVATE)
  .AddDataMember(type_276, Reflex::Literal("T2plane_"), OffsetOf(__shadow__::__T2ROGeometry, T2plane_), ::Reflex::PRIVATE)
  .AddDataMember(type_276, Reflex::Literal("T2planeSide_"), OffsetOf(__shadow__::__T2ROGeometry, T2planeSide_), ::Reflex::PRIVATE)
  .AddDataMember(type_1235, Reflex::Literal("T2DetType_"), OffsetOf(__shadow__::__T2ROGeometry, T2DetType_), ::Reflex::PRIVATE)
  .AddDataMember(type_99, Reflex::Literal("StripWidth"), OffsetOf(__shadow__::__T2ROGeometry, StripWidth), ::Reflex::PRIVATE)
  .AddDataMember(type_99, Reflex::Literal("StripPitch"), OffsetOf(__shadow__::__T2ROGeometry, StripPitch), ::Reflex::PRIVATE)
  .AddDataMember(type_99, Reflex::Literal("StripMinR"), OffsetOf(__shadow__::__T2ROGeometry, StripMinR), ::Reflex::PRIVATE)
  .AddDataMember(type_99, Reflex::Literal("StripMinPhiDeg"), OffsetOf(__shadow__::__T2ROGeometry, StripMinPhiDeg), ::Reflex::PRIVATE)
  .AddDataMember(type_99, Reflex::Literal("StripMaxPhiDeg"), OffsetOf(__shadow__::__T2ROGeometry, StripMaxPhiDeg), ::Reflex::PRIVATE)
  .AddDataMember(type_99, Reflex::Literal("StripCutSchiftY"), OffsetOf(__shadow__::__T2ROGeometry, StripCutSchiftY), ::Reflex::PRIVATE)
  .AddDataMember(type_99, Reflex::Literal("StripCut"), OffsetOf(__shadow__::__T2ROGeometry, StripCut), ::Reflex::PRIVATE)
  .AddDataMember(type_99, Reflex::Literal("PadRCut"), OffsetOf(__shadow__::__T2ROGeometry, PadRCut), ::Reflex::PRIVATE)
  .AddDataMember(type_99, Reflex::Literal("PadMinR"), OffsetOf(__shadow__::__T2ROGeometry, PadMinR), ::Reflex::PRIVATE)
  .AddDataMember(type_99, Reflex::Literal("PadRDPhiCut"), OffsetOf(__shadow__::__T2ROGeometry, PadRDPhiCut), ::Reflex::PRIVATE)
  .AddDataMember(type_16046, Reflex::Literal("PadMaxR"), OffsetOf(__shadow__::__T2ROGeometry, PadMaxR), ::Reflex::PRIVATE)
  .AddDataMember(type_16046, Reflex::Literal("PadMaxPhiDeg"), OffsetOf(__shadow__::__T2ROGeometry, PadMaxPhiDeg), ::Reflex::PRIVATE)
  .AddDataMember(type_16046, Reflex::Literal("PadDPhiDeg"), OffsetOf(__shadow__::__T2ROGeometry, PadDPhiDeg), ::Reflex::PRIVATE)
  .AddDataMember(type_16047, Reflex::Literal("StripPhiMin"), OffsetOf(__shadow__::__T2ROGeometry, StripPhiMin), ::Reflex::PRIVATE)
  .AddDataMember(type_16047, Reflex::Literal("StripPhiMax"), OffsetOf(__shadow__::__T2ROGeometry, StripPhiMax), ::Reflex::PRIVATE)
  .AddDataMember(type_16047, Reflex::Literal("StripDPhiMaxMin"), OffsetOf(__shadow__::__T2ROGeometry, StripDPhiMaxMin), ::Reflex::PRIVATE)
  .AddDataMember(type_16047, Reflex::Literal("StripRMin"), OffsetOf(__shadow__::__T2ROGeometry, StripRMin), ::Reflex::PRIVATE)
  .AddDataMember(type_16047, Reflex::Literal("StripRMax"), OffsetOf(__shadow__::__T2ROGeometry, StripRMax), ::Reflex::PRIVATE)
  .AddDataMember(type_16048, Reflex::Literal("PadRMin"), OffsetOf(__shadow__::__T2ROGeometry, PadRMin), ::Reflex::PRIVATE)
  .AddDataMember(type_16048, Reflex::Literal("PadRMax"), OffsetOf(__shadow__::__T2ROGeometry, PadRMax), ::Reflex::PRIVATE)
  .AddDataMember(type_16048, Reflex::Literal("PadPhiMin"), OffsetOf(__shadow__::__T2ROGeometry, PadPhiMin), ::Reflex::PRIVATE)
  .AddDataMember(type_16048, Reflex::Literal("PadPhiMax"), OffsetOf(__shadow__::__T2ROGeometry, PadPhiMax), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class T2ROGeometry -------------------
void __T2ROGeometry_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_1339), Reflex::Literal("SetT2DetType"), method_5658, 0, "det_id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1235), Reflex::Literal("GetT2DetType"), method_5659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_99, type_69, type_69), Reflex::Literal("GetStripPhiMin"), method_5660, 0, "i_raw;j_col", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_99, type_69, type_69), Reflex::Literal("GetStripPhiMax"), method_5661, 0, "i_raw;j_col", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_99, type_69, type_69), Reflex::Literal("GetStripRMin"), method_5662, 0, "i_raw;j_col", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_99, type_69, type_69), Reflex::Literal("GetStripRMax"), method_5663, 0, "i_raw;j_col", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_99, type_69, type_69), Reflex::Literal("GetPadPhiMin"), method_5664, 0, "i_raw;j_col", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_99, type_69, type_69), Reflex::Literal("GetPadPhiMax"), method_5665, 0, "i_raw;j_col", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_99, type_69, type_69), Reflex::Literal("GetPadRMin"), method_5666, 0, "i_raw;j_col", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_99, type_69, type_69), Reflex::Literal("GetPadRMax"), method_5667, 0, "i_raw;j_col", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_99, type_69, type_69), Reflex::Literal("GetPadPhiMinLocal"), method_5668, 0, "i_raw;j_col", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_99, type_69, type_69), Reflex::Literal("GetPadPhiMaxLocal"), method_5669, 0, "i_raw;j_col", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_276), Reflex::Literal("GetDetId"), method_5670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class pair<T2DetId,std::vector<T2Cluster, std::allocator<T2Cluster> > > -------------------------------
static void destructor_8170(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<T2DetId,std::vector<T2Cluster> >*)o)->::std::pair<T2DetId,std::vector<T2Cluster> >::~pair)();
}
static  void operator_8171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<T2DetId,std::vector<T2Cluster> >*)o)->operator=)(*(const ::std::pair<T2DetId,std::vector<T2Cluster> >*)arg[0]);
  else   (((::std::pair<T2DetId,std::vector<T2Cluster> >*)o)->operator=)(*(const ::std::pair<T2DetId,std::vector<T2Cluster> >*)arg[0]);
}

static void constructor_8172( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2Cluster> >(*(const ::std::pair<T2DetId,std::vector<T2Cluster> >*)arg[0]);
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2Cluster> >(*(const ::std::pair<T2DetId,std::vector<T2Cluster> >*)arg[0]);
}

static void constructor_8173( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2Cluster> >();
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2Cluster> >();
}

static void constructor_8174( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<T2DetId,std::vector<T2Cluster> >(*(const ::T2DetId*)arg[0],
      *(const ::std::vector<T2Cluster>*)arg[1]);
  else ::new(mem) ::std::pair<T2DetId,std::vector<T2Cluster> >(*(const ::T2DetId*)arg[0],
      *(const ::std::vector<T2Cluster>*)arg[1]);
}

static void method_newdel_2498( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2Cluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2Cluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2Cluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2Cluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<T2DetId,std::vector<T2Cluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<T2DetId,std::vector<T2Cluster, std::allocator<T2Cluster> > > -------------------------------
void __std__pair_T2DetId_std__vector_T2Cluster_s__db_datamem(Reflex::Class*);
void __std__pair_T2DetId_std__vector_T2Cluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_T2DetId_std__vector_T2Cluster_s__datamem_bld(&__std__pair_T2DetId_std__vector_T2Cluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_T2DetId_std__vector_T2Cluster_s__funcmem_bld(&__std__pair_T2DetId_std__vector_T2Cluster_s__db_funcmem);
void __std__pair_T2DetId_std__vector_T2Cluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<T2DetId,std::vector<T2Cluster> >"), typeid(::std::pair<T2DetId,std::vector<T2Cluster> >), sizeof(::std::pair<T2DetId,std::vector<T2Cluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_771, Reflex::Literal("std::pair<T2DetId,std::vector<T2Cluster> >::first_type"))
  .AddTypedef(type_2522, Reflex::Literal("std::pair<T2DetId,std::vector<T2Cluster> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_8170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16761, type_16762), Reflex::Literal("operator="), operator_8171, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16762), Reflex::Literal("pair"), constructor_8172, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_8173, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4383, type_13365), Reflex::Literal("pair"), constructor_8174, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2498, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_T2DetId_std__vector_T2Cluster_s__datamem_bld);
}

//------Delayed data member builder for class pair<T2DetId,std::vector<T2Cluster, std::allocator<T2Cluster> > > -------------------
void __std__pair_T2DetId_std__vector_T2Cluster_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_771, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_T2DetId_std__vector_T2Cluster_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2522, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_T2DetId_std__vector_T2Cluster_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<T2DetId,std::vector<T2Cluster, std::allocator<T2Cluster> > > -------------------
void __std__pair_T2DetId_std__vector_T2Cluster_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<T2Cluster,std::allocator<T2Cluster> > -------------------------------
static void constructor_8387( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Cluster>();
  else ::new(mem) ::std::vector<T2Cluster>();
}

static void constructor_8388( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Cluster>(*(const ::std::allocator<T2Cluster>*)arg[0]);
  else ::new(mem) ::std::vector<T2Cluster>(*(const ::std::allocator<T2Cluster>*)arg[0]);
}

static void constructor_8389( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Cluster>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<T2Cluster>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Cluster>(*(::std::size_t*)arg[0],
      *(const ::T2Cluster*)arg[1]);
  else ::new(mem) ::std::vector<T2Cluster>(*(::std::size_t*)arg[0],
      *(const ::T2Cluster*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Cluster>(*(::std::size_t*)arg[0],
      *(const ::T2Cluster*)arg[1],
      *(const ::std::allocator<T2Cluster>*)arg[2]);
  else ::new(mem) ::std::vector<T2Cluster>(*(::std::size_t*)arg[0],
      *(const ::T2Cluster*)arg[1],
      *(const ::std::allocator<T2Cluster>*)arg[2]);
  }
}

static void constructor_8390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<T2Cluster>(*(const ::std::vector<T2Cluster>*)arg[0]);
  else ::new(mem) ::std::vector<T2Cluster>(*(const ::std::vector<T2Cluster>*)arg[0]);
}

static void destructor_8391(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<T2Cluster>*)o)->::std::vector<T2Cluster>::~vector)();
}
static  void operator_8392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2Cluster>*)o)->operator=)(*(const ::std::vector<T2Cluster>*)arg[0]);
  else   (((::std::vector<T2Cluster>*)o)->operator=)(*(const ::std::vector<T2Cluster>*)arg[0]);
}

static  void method_8393( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2Cluster>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::T2Cluster*)arg[1]);
}

static  void method_8394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >)((((::std::vector<T2Cluster>*)o)->begin)());
  else   (((::std::vector<T2Cluster>*)o)->begin)();
}

static  void method_8395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2Cluster*,std::vector<T2Cluster> >)((((const ::std::vector<T2Cluster>*)o)->begin)());
  else   (((const ::std::vector<T2Cluster>*)o)->begin)();
}

static  void method_8396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >)((((::std::vector<T2Cluster>*)o)->end)());
  else   (((::std::vector<T2Cluster>*)o)->end)();
}

static  void method_8397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const T2Cluster*,std::vector<T2Cluster> >)((((const ::std::vector<T2Cluster>*)o)->end)());
  else   (((const ::std::vector<T2Cluster>*)o)->end)();
}

static  void method_8402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2Cluster>*)o)->size)());
  else   (((const ::std::vector<T2Cluster>*)o)->size)();
}

static  void method_8403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2Cluster>*)o)->max_size)());
  else   (((const ::std::vector<T2Cluster>*)o)->max_size)();
}

static  void method_8404( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<T2Cluster>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<T2Cluster>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::T2Cluster*)arg[1]);
  }
}

static  void method_8405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<T2Cluster>*)o)->capacity)());
  else   (((const ::std::vector<T2Cluster>*)o)->capacity)();
}

static  void method_8406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<T2Cluster>*)o)->empty)());
  else   (((const ::std::vector<T2Cluster>*)o)->empty)();
}

static  void method_8407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2Cluster>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8408( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2Cluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2Cluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2Cluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2Cluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8411( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2Cluster>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<T2Cluster>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8412( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2Cluster>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<T2Cluster>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2Cluster>*)o)->front)();
  else   (((::std::vector<T2Cluster>*)o)->front)();
}

static  void method_8414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2Cluster>*)o)->front)();
  else   (((const ::std::vector<T2Cluster>*)o)->front)();
}

static  void method_8415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<T2Cluster>*)o)->back)();
  else   (((::std::vector<T2Cluster>*)o)->back)();
}

static  void method_8416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<T2Cluster>*)o)->back)();
  else   (((const ::std::vector<T2Cluster>*)o)->back)();
}

static  void method_8417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<T2Cluster>*)o)->data)());
  else   (((::std::vector<T2Cluster>*)o)->data)();
}

static  void method_8418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<T2Cluster>*)o)->data)());
  else   (((const ::std::vector<T2Cluster>*)o)->data)();
}

static  void method_8419( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2Cluster>*)o)->push_back)(*(const ::T2Cluster*)arg[0]);
}

static  void method_8420( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2Cluster>*)o)->pop_back)();
}

static  void method_8421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >)((((::std::vector<T2Cluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >*)arg[0],
    *(const ::T2Cluster*)arg[1]));
  else   (((::std::vector<T2Cluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >*)arg[0],
    *(const ::T2Cluster*)arg[1]);
}

static  void method_8422( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2Cluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::T2Cluster*)arg[2]);
}

static  void method_8423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >)((((::std::vector<T2Cluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >*)arg[0]));
  else   (((::std::vector<T2Cluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >*)arg[0]);
}

static  void method_8424( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >)((((::std::vector<T2Cluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >*)arg[1]));
  else   (((::std::vector<T2Cluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<T2Cluster*,std::vector<T2Cluster> >*)arg[1]);
}

static  void method_8425( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<T2Cluster>*)o)->swap)(*(::std::vector<T2Cluster>*)arg[0]);
}

static  void method_8426( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<T2Cluster>*)o)->clear)();
}

static void method_newdel_2522( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<T2Cluster> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<T2Cluster> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<T2Cluster> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<T2Cluster> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<T2Cluster> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<T2Cluster,std::allocator<T2Cluster> >")), ::Reflex::BaseOffset< ::std::vector<T2Cluster>,::std::_Vector_base<T2Cluster,std::allocator<T2Cluster> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<T2Cluster> >::Generate();
  else ::Reflex::Proxy< ::std::vector<T2Cluster> >::Generate();
}

//------Dictionary for class vector<T2Cluster,std::allocator<T2Cluster> > -------------------------------
void __std__vector_T2Cluster__db_datamem(Reflex::Class*);
void __std__vector_T2Cluster__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_T2Cluster__datamem_bld(&__std__vector_T2Cluster__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_T2Cluster__funcmem_bld(&__std__vector_T2Cluster__db_funcmem);
void __std__vector_T2Cluster__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<T2Cluster>"), typeid(::std::vector<T2Cluster>), sizeof(::std::vector<T2Cluster>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2159, ::Reflex::BaseOffset< ::std::vector<T2Cluster>, ::std::_Vector_base<T2Cluster,std::allocator<T2Cluster> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1214, Reflex::Literal("std::vector<T2Cluster>::_Alloc_value_type"))
  .AddTypedef(type_2159, Reflex::Literal("std::vector<T2Cluster>::_Base"))
  .AddTypedef(type_2679, Reflex::Literal("std::vector<T2Cluster>::_Tp_alloc_type"))
  .AddTypedef(type_5186, Reflex::Literal("std::vector<T2Cluster>::_Alloc_traits"))
  .AddTypedef(type_1214, Reflex::Literal("std::vector<T2Cluster>::value_type"))
  .AddTypedef(type_6118, Reflex::Literal("std::vector<T2Cluster>::pointer"))
  .AddTypedef(type_8375, Reflex::Literal("std::vector<T2Cluster>::const_pointer"))
  .AddTypedef(type_8377, Reflex::Literal("std::vector<T2Cluster>::reference"))
  .AddTypedef(type_4382, Reflex::Literal("std::vector<T2Cluster>::const_reference"))
  .AddTypedef(type_5116, Reflex::Literal("std::vector<T2Cluster>::iterator"))
  .AddTypedef(type_5117, Reflex::Literal("std::vector<T2Cluster>::const_iterator"))
  .AddTypedef(type_2766, Reflex::Literal("std::vector<T2Cluster>::const_reverse_iterator"))
  .AddTypedef(type_2767, Reflex::Literal("std::vector<T2Cluster>::reverse_iterator"))
  .AddTypedef(type_2664, Reflex::Literal("std::vector<T2Cluster>::size_type"))
  .AddTypedef(type_2602, Reflex::Literal("std::vector<T2Cluster>::difference_type"))
  .AddTypedef(type_2679, Reflex::Literal("std::vector<T2Cluster>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8387, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16128), Reflex::Literal("vector"), constructor_8388, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2664, type_4382, type_16128), Reflex::Literal("vector"), constructor_8389, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13365), Reflex::Literal("vector"), constructor_8390, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8391, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2522, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_T2Cluster__funcmem_bld);
}

//------Delayed data member builder for class vector<T2Cluster,std::allocator<T2Cluster> > -------------------
void __std__vector_T2Cluster__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<T2Cluster,std::allocator<T2Cluster> > -------------------
void __std__vector_T2Cluster__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13364, type_13365), Reflex::Literal("operator="), operator_8392, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_2664, type_4382), Reflex::Literal("assign"), method_8393, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5116), Reflex::Literal("begin"), method_8394, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5117), Reflex::Literal("begin"), method_8395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5116), Reflex::Literal("end"), method_8396, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5117), Reflex::Literal("end"), method_8397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("size"), method_8402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("max_size"), method_8403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_2664, type_1214), Reflex::Literal("resize"), method_8404, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("capacity"), method_8405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1375), Reflex::Literal("empty"), method_8406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_2664), Reflex::Literal("reserve"), method_8407, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8377, type_2664), Reflex::Literal("operator[]"), operator_8408, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4382, type_2664), Reflex::Literal("operator[]"), operator_8409, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8377, type_2664), Reflex::Literal("at"), method_8411, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4382, type_2664), Reflex::Literal("at"), method_8412, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8377), Reflex::Literal("front"), method_8413, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4382), Reflex::Literal("front"), method_8414, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8377), Reflex::Literal("back"), method_8415, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4382), Reflex::Literal("back"), method_8416, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6118), Reflex::Literal("data"), method_8417, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8375), Reflex::Literal("data"), method_8418, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_4382), Reflex::Literal("push_back"), method_8419, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("pop_back"), method_8420, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5116, type_5116, type_4382), Reflex::Literal("insert"), method_8421, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_5116, type_2664, type_4382), Reflex::Literal("insert"), method_8422, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5116, type_5116), Reflex::Literal("erase"), method_8423, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5116, type_5116, type_5116), Reflex::Literal("erase"), method_8424, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_13364), Reflex::Literal("swap"), method_8425, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("clear"), method_8426, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<cluster_entry,std::allocator<cluster_entry> > -------------------------------
static void constructor_8452( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cluster_entry>();
  else ::new(mem) ::std::vector<cluster_entry>();
}

static void constructor_8453( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cluster_entry>(*(const ::std::allocator<cluster_entry>*)arg[0]);
  else ::new(mem) ::std::vector<cluster_entry>(*(const ::std::allocator<cluster_entry>*)arg[0]);
}

static void constructor_8454( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cluster_entry>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<cluster_entry>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cluster_entry>(*(::std::size_t*)arg[0],
      *(const ::cluster_entry*)arg[1]);
  else ::new(mem) ::std::vector<cluster_entry>(*(::std::size_t*)arg[0],
      *(const ::cluster_entry*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cluster_entry>(*(::std::size_t*)arg[0],
      *(const ::cluster_entry*)arg[1],
      *(const ::std::allocator<cluster_entry>*)arg[2]);
  else ::new(mem) ::std::vector<cluster_entry>(*(::std::size_t*)arg[0],
      *(const ::cluster_entry*)arg[1],
      *(const ::std::allocator<cluster_entry>*)arg[2]);
  }
}

static void constructor_8455( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<cluster_entry>(*(const ::std::vector<cluster_entry>*)arg[0]);
  else ::new(mem) ::std::vector<cluster_entry>(*(const ::std::vector<cluster_entry>*)arg[0]);
}

static void destructor_8456(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<cluster_entry>*)o)->::std::vector<cluster_entry>::~vector)();
}
static  void operator_8457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cluster_entry>*)o)->operator=)(*(const ::std::vector<cluster_entry>*)arg[0]);
  else   (((::std::vector<cluster_entry>*)o)->operator=)(*(const ::std::vector<cluster_entry>*)arg[0]);
}

static  void method_8458( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cluster_entry>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::cluster_entry*)arg[1]);
}

static  void method_8459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >)((((::std::vector<cluster_entry>*)o)->begin)());
  else   (((::std::vector<cluster_entry>*)o)->begin)();
}

static  void method_8460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const cluster_entry*,std::vector<cluster_entry> >)((((const ::std::vector<cluster_entry>*)o)->begin)());
  else   (((const ::std::vector<cluster_entry>*)o)->begin)();
}

static  void method_8461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >)((((::std::vector<cluster_entry>*)o)->end)());
  else   (((::std::vector<cluster_entry>*)o)->end)();
}

static  void method_8462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const cluster_entry*,std::vector<cluster_entry> >)((((const ::std::vector<cluster_entry>*)o)->end)());
  else   (((const ::std::vector<cluster_entry>*)o)->end)();
}

static  void method_8467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cluster_entry>*)o)->size)());
  else   (((const ::std::vector<cluster_entry>*)o)->size)();
}

static  void method_8468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cluster_entry>*)o)->max_size)());
  else   (((const ::std::vector<cluster_entry>*)o)->max_size)();
}

static  void method_8469( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<cluster_entry>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<cluster_entry>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::cluster_entry*)arg[1]);
  }
}

static  void method_8470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<cluster_entry>*)o)->capacity)());
  else   (((const ::std::vector<cluster_entry>*)o)->capacity)();
}

static  void method_8471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<cluster_entry>*)o)->empty)());
  else   (((const ::std::vector<cluster_entry>*)o)->empty)();
}

static  void method_8472( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cluster_entry>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cluster_entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cluster_entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8474( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cluster_entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cluster_entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8476( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cluster_entry>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<cluster_entry>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8477( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cluster_entry>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<cluster_entry>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cluster_entry>*)o)->front)();
  else   (((::std::vector<cluster_entry>*)o)->front)();
}

static  void method_8479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cluster_entry>*)o)->front)();
  else   (((const ::std::vector<cluster_entry>*)o)->front)();
}

static  void method_8480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<cluster_entry>*)o)->back)();
  else   (((::std::vector<cluster_entry>*)o)->back)();
}

static  void method_8481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<cluster_entry>*)o)->back)();
  else   (((const ::std::vector<cluster_entry>*)o)->back)();
}

static  void method_8482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<cluster_entry>*)o)->data)());
  else   (((::std::vector<cluster_entry>*)o)->data)();
}

static  void method_8483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<cluster_entry>*)o)->data)());
  else   (((const ::std::vector<cluster_entry>*)o)->data)();
}

static  void method_8484( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cluster_entry>*)o)->push_back)(*(const ::cluster_entry*)arg[0]);
}

static  void method_8485( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cluster_entry>*)o)->pop_back)();
}

static  void method_8486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >)((((::std::vector<cluster_entry>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >*)arg[0],
    *(const ::cluster_entry*)arg[1]));
  else   (((::std::vector<cluster_entry>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >*)arg[0],
    *(const ::cluster_entry*)arg[1]);
}

static  void method_8487( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cluster_entry>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::cluster_entry*)arg[2]);
}

static  void method_8488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >)((((::std::vector<cluster_entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >*)arg[0]));
  else   (((::std::vector<cluster_entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >*)arg[0]);
}

static  void method_8489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >)((((::std::vector<cluster_entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >*)arg[1]));
  else   (((::std::vector<cluster_entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<cluster_entry*,std::vector<cluster_entry> >*)arg[1]);
}

static  void method_8490( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<cluster_entry>*)o)->swap)(*(::std::vector<cluster_entry>*)arg[0]);
}

static  void method_8491( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<cluster_entry>*)o)->clear)();
}

static void method_newdel_2523( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<cluster_entry> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<cluster_entry> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<cluster_entry> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<cluster_entry> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<cluster_entry> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<cluster_entry,std::allocator<cluster_entry> >")), ::Reflex::BaseOffset< ::std::vector<cluster_entry>,::std::_Vector_base<cluster_entry,std::allocator<cluster_entry> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<cluster_entry> >::Generate();
  else ::Reflex::Proxy< ::std::vector<cluster_entry> >::Generate();
}

//------Dictionary for class vector<cluster_entry,std::allocator<cluster_entry> > -------------------------------
void __std__vector_cluster_entry__db_datamem(Reflex::Class*);
void __std__vector_cluster_entry__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_cluster_entry__datamem_bld(&__std__vector_cluster_entry__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_cluster_entry__funcmem_bld(&__std__vector_cluster_entry__db_funcmem);
void __std__vector_cluster_entry__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<cluster_entry>"), typeid(::std::vector<cluster_entry>), sizeof(::std::vector<cluster_entry>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2161, ::Reflex::BaseOffset< ::std::vector<cluster_entry>, ::std::_Vector_base<cluster_entry,std::allocator<cluster_entry> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1267, Reflex::Literal("std::vector<cluster_entry>::_Alloc_value_type"))
  .AddTypedef(type_2161, Reflex::Literal("std::vector<cluster_entry>::_Base"))
  .AddTypedef(type_2681, Reflex::Literal("std::vector<cluster_entry>::_Tp_alloc_type"))
  .AddTypedef(type_5188, Reflex::Literal("std::vector<cluster_entry>::_Alloc_traits"))
  .AddTypedef(type_1267, Reflex::Literal("std::vector<cluster_entry>::value_type"))
  .AddTypedef(type_6156, Reflex::Literal("std::vector<cluster_entry>::pointer"))
  .AddTypedef(type_8439, Reflex::Literal("std::vector<cluster_entry>::const_pointer"))
  .AddTypedef(type_8441, Reflex::Literal("std::vector<cluster_entry>::reference"))
  .AddTypedef(type_8443, Reflex::Literal("std::vector<cluster_entry>::const_reference"))
  .AddTypedef(type_5120, Reflex::Literal("std::vector<cluster_entry>::iterator"))
  .AddTypedef(type_5121, Reflex::Literal("std::vector<cluster_entry>::const_iterator"))
  .AddTypedef(type_2772, Reflex::Literal("std::vector<cluster_entry>::const_reverse_iterator"))
  .AddTypedef(type_2773, Reflex::Literal("std::vector<cluster_entry>::reverse_iterator"))
  .AddTypedef(type_2664, Reflex::Literal("std::vector<cluster_entry>::size_type"))
  .AddTypedef(type_2602, Reflex::Literal("std::vector<cluster_entry>::difference_type"))
  .AddTypedef(type_2681, Reflex::Literal("std::vector<cluster_entry>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8452, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16154), Reflex::Literal("vector"), constructor_8453, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2664, type_8443, type_16154), Reflex::Literal("vector"), constructor_8454, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13353), Reflex::Literal("vector"), constructor_8455, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8456, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2523, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_cluster_entry__funcmem_bld);
}

//------Delayed data member builder for class vector<cluster_entry,std::allocator<cluster_entry> > -------------------
void __std__vector_cluster_entry__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<cluster_entry,std::allocator<cluster_entry> > -------------------
void __std__vector_cluster_entry__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16773, type_13353), Reflex::Literal("operator="), operator_8457, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_2664, type_8443), Reflex::Literal("assign"), method_8458, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5120), Reflex::Literal("begin"), method_8459, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5121), Reflex::Literal("begin"), method_8460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5120), Reflex::Literal("end"), method_8461, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5121), Reflex::Literal("end"), method_8462, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("size"), method_8467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("max_size"), method_8468, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_2664, type_1267), Reflex::Literal("resize"), method_8469, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("capacity"), method_8470, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1375), Reflex::Literal("empty"), method_8471, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_2664), Reflex::Literal("reserve"), method_8472, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8441, type_2664), Reflex::Literal("operator[]"), operator_8473, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8443, type_2664), Reflex::Literal("operator[]"), operator_8474, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8441, type_2664), Reflex::Literal("at"), method_8476, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8443, type_2664), Reflex::Literal("at"), method_8477, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8441), Reflex::Literal("front"), method_8478, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8443), Reflex::Literal("front"), method_8479, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8441), Reflex::Literal("back"), method_8480, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8443), Reflex::Literal("back"), method_8481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6156), Reflex::Literal("data"), method_8482, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8439), Reflex::Literal("data"), method_8483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_8443), Reflex::Literal("push_back"), method_8484, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("pop_back"), method_8485, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5120, type_5120, type_8443), Reflex::Literal("insert"), method_8486, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_5120, type_2664, type_8443), Reflex::Literal("insert"), method_8487, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5120, type_5120), Reflex::Literal("erase"), method_8488, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5120, type_5120, type_5120), Reflex::Literal("erase"), method_8489, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_16773), Reflex::Literal("swap"), method_8490, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("clear"), method_8491, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<std::pair<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > -------------------------------
static void constructor_12515( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >();
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >();
}

static void constructor_12516( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >(*(::std::auto_ptr<std::pair<T2DetId,std::vector<T2Cluster> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >(*(::std::auto_ptr<std::pair<T2DetId,std::vector<T2Cluster> > >*)arg[0]);
}

static void destructor_12517(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >::~Wrapper)();
}
static  void method_12518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->product)();
}

static  void operator_12519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->operator->)();
}

static  void method_12520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->productTypeInfo)();
}

static  void method_12521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->typeInfo)();
}

static void constructor_12522( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >((::std::pair<T2DetId,std::vector<T2Cluster> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >((::std::pair<T2DetId,std::vector<T2Cluster> >*)arg[0]);
}

static  void method_12523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->getInterface)();
}

static  void method_12524( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12525( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12526( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->dynamicTypeInfo)();
}

static  void method_12528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->isPresent)();
}

static  void method_12529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3339( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::pair<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > -------------------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__datamem_bld(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__funcmem_bld(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__db_funcmem);
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >"), typeid(::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >), sizeof(::edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2498, Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >::value_type"))
  .AddTypedef(type_2498, Reflex::Literal("edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12515, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2373), Reflex::Literal("Wrapper"), constructor_12516, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12517, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18615), Reflex::Literal("Wrapper"), constructor_12522, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3339, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::pair<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > -------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1375, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2498, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::pair<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > -------------------
void __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18614), Reflex::Literal("product"), method_12518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18614), Reflex::Literal("operator->"), operator_12519, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("productTypeInfo"), method_12520, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("typeInfo"), method_12521, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18616), Reflex::Literal("getInterface"), method_12523, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_12583, type_13302, type_13303), Reflex::Literal("fillView"), method_12524, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_11351, type_269, type_6861), Reflex::Literal("setPtr"), method_12525, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_11351, type_13304, type_13302), Reflex::Literal("fillPtrVector"), method_12526, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("dynamicTypeInfo"), method_12527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1375), Reflex::Literal("isPresent"), method_12528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("dynamicTypeInfo_"), method_12529, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<T2DetId,std::vector<T2Cluster, std::allocator<T2Cluster> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > -------------------------------
static void destructor_4602(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->::std::map<T2DetId,std::vector<T2Cluster> >::~map)();
}
static void constructor_4603( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2Cluster> >();
  else ::new(mem) ::std::map<T2DetId,std::vector<T2Cluster> >();
}

static void constructor_4604( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2Cluster> >(*(const ::std::less<T2DetId>*)arg[0]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2Cluster> >(*(const ::std::less<T2DetId>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2Cluster> >(*(const ::std::less<T2DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const T2DetId,std::vector<T2Cluster> > >*)arg[1]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2Cluster> >(*(const ::std::less<T2DetId>*)arg[0],
      *(const ::std::allocator<std::pair<const T2DetId,std::vector<T2Cluster> > >*)arg[1]);
  }
}

static void constructor_4605( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<T2DetId,std::vector<T2Cluster> >(*(const ::std::map<T2DetId,std::vector<T2Cluster> >*)arg[0]);
  else ::new(mem) ::std::map<T2DetId,std::vector<T2Cluster> >(*(const ::std::map<T2DetId,std::vector<T2Cluster> >*)arg[0]);
}

static  void operator_4606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->operator=)(*(const ::std::map<T2DetId,std::vector<T2Cluster> >*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->operator=)(*(const ::std::map<T2DetId,std::vector<T2Cluster> >*)arg[0]);
}

static  void method_4607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->get_allocator)());
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->get_allocator)();
}

static  void method_4608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->begin)());
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->begin)();
}

static  void method_4609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->begin)());
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->begin)();
}

static  void method_4610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->end)());
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->end)();
}

static  void method_4611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->end)());
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->end)();
}

static  void method_4616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->empty)());
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->empty)();
}

static  void method_4617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->size)());
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->size)();
}

static  void method_4618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->max_size)());
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->max_size)();
}

static  void operator_4619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->operator[])(*(const ::T2DetId*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->operator[])(*(const ::T2DetId*)arg[0]);
}

static  void method_4620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->at)(*(const ::T2DetId*)arg[0]);
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->at)(*(const ::T2DetId*)arg[0]);
}

static  void method_4621( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->at)(*(const ::T2DetId*)arg[0]);
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->at)(*(const ::T2DetId*)arg[0]);
}

static  void method_4622( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >,bool>)((((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->insert)(*(const ::std::pair<const T2DetId,std::vector<T2Cluster> >*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->insert)(*(const ::std::pair<const T2DetId,std::vector<T2Cluster> >*)arg[0]);
}

static  void method_4623( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >*)arg[0],
    *(const ::std::pair<const T2DetId,std::vector<T2Cluster> >*)arg[1]));
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >*)arg[0],
    *(const ::std::pair<const T2DetId,std::vector<T2Cluster> >*)arg[1]);
}

static  void method_4624( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >*)arg[0]);
}

static  void method_4625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->erase)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->erase)(*(const ::T2DetId*)arg[0]);
}

static  void method_4626( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >*)arg[1]);
}

static  void method_4627( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->swap)(*(::std::map<T2DetId,std::vector<T2Cluster> >*)arg[0]);
}

static  void method_4628( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->clear)();
}

static  void method_4629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<T2DetId>)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->key_comp)());
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->key_comp)();
}

static  void method_4631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->find)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->find)(*(const ::T2DetId*)arg[0]);
}

static  void method_4632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->find)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->find)(*(const ::T2DetId*)arg[0]);
}

static  void method_4633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->count)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->count)(*(const ::T2DetId*)arg[0]);
}

static  void method_4634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_4635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->lower_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_4636( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_4637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->upper_bound)(*(const ::T2DetId*)arg[0]);
}

static  void method_4638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >,std::_Rb_tree_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > > >)((((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]));
  else   (((::std::map<T2DetId,std::vector<T2Cluster> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]);
}

static  void method_4639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > >,std::_Rb_tree_const_iterator<std::pair<const T2DetId,std::vector<T2Cluster> > > >)((((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]));
  else   (((const ::std::map<T2DetId,std::vector<T2Cluster> >*)o)->equal_range)(*(const ::T2DetId*)arg[0]);
}

static void method_newdel_1436( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2Cluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2Cluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2Cluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2Cluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<T2DetId,std::vector<T2Cluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<T2DetId,std::vector<T2Cluster> > >::Generate();
  else ::Reflex::Proxy< ::std::map<T2DetId,std::vector<T2Cluster> > >::Generate();
}

//------Dictionary for class map<T2DetId,std::vector<T2Cluster, std::allocator<T2Cluster> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > -------------------------------
void __std__map_T2DetId_std__vector_T2Cluster_s__db_datamem(Reflex::Class*);
void __std__map_T2DetId_std__vector_T2Cluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_T2DetId_std__vector_T2Cluster_s__datamem_bld(&__std__map_T2DetId_std__vector_T2Cluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_T2DetId_std__vector_T2Cluster_s__funcmem_bld(&__std__map_T2DetId_std__vector_T2Cluster_s__db_funcmem);
void __std__map_T2DetId_std__vector_T2Cluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >"), typeid(::std::map<T2DetId,std::vector<T2Cluster> >), sizeof(::std::map<T2DetId,std::vector<T2Cluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_771, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::key_type"))
  .AddTypedef(type_2522, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::mapped_type"))
  .AddTypedef(type_2499, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::value_type"))
  .AddTypedef(type_2287, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::key_compare"))
  .AddTypedef(type_2680, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::allocator_type"))
  .AddTypedef(type_2499, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::_Alloc_value_type"))
  .AddTypedef(type_2680, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::_Pair_alloc_type"))
  .AddTypedef(type_2335, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::_Rep_type"))
  .AddTypedef(type_4588, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::pointer"))
  .AddTypedef(type_4590, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::const_pointer"))
  .AddTypedef(type_4592, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::reference"))
  .AddTypedef(type_4594, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::const_reference"))
  .AddTypedef(type_2575, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::iterator"))
  .AddTypedef(type_2666, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::const_iterator"))
  .AddTypedef(type_2664, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::size_type"))
  .AddTypedef(type_2602, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::difference_type"))
  .AddTypedef(type_2771, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::reverse_iterator"))
  .AddTypedef(type_2770, Reflex::Literal("std::map<T2DetId,std::vector<T2Cluster> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_4602, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_4603, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13362, type_13363), Reflex::Literal("map"), constructor_4604, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8508), Reflex::Literal("map"), constructor_4605, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1436, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_T2DetId_std__vector_T2Cluster_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_T2DetId_std__vector_T2Cluster_s__funcmem_bld);
}

//------Delayed data member builder for class map<T2DetId,std::vector<T2Cluster, std::allocator<T2Cluster> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > -------------------
void __std__map_T2DetId_std__vector_T2Cluster_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2335, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_T2DetId_std__vector_T2Cluster_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<T2DetId,std::vector<T2Cluster, std::allocator<T2Cluster> >,std::less<T2DetId>,std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > -------------------
void __std__map_T2DetId_std__vector_T2Cluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8506, type_8508), Reflex::Literal("operator="), operator_4606, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("get_allocator"), method_4607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2575), Reflex::Literal("begin"), method_4608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666), Reflex::Literal("begin"), method_4609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2575), Reflex::Literal("end"), method_4610, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666), Reflex::Literal("end"), method_4611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1375), Reflex::Literal("empty"), method_4616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("size"), method_4617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("max_size"), method_4618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13364, type_4383), Reflex::Literal("operator[]"), operator_4619, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13364, type_4383), Reflex::Literal("at"), method_4620, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13365, type_4383), Reflex::Literal("at"), method_4621, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2502, type_4594), Reflex::Literal("insert"), method_4622, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2575, type_2575, type_4594), Reflex::Literal("insert"), method_4623, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_2575), Reflex::Literal("erase"), method_4624, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664, type_4383), Reflex::Literal("erase"), method_4625, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_2575, type_2575), Reflex::Literal("erase"), method_4626, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_8506), Reflex::Literal("swap"), method_4627, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("clear"), method_4628, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2287), Reflex::Literal("key_comp"), method_4629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2575, type_4383), Reflex::Literal("find"), method_4631, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_4383), Reflex::Literal("find"), method_4632, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664, type_4383), Reflex::Literal("count"), method_4633, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2575, type_4383), Reflex::Literal("lower_bound"), method_4634, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_4383), Reflex::Literal("lower_bound"), method_4635, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2575, type_4383), Reflex::Literal("upper_bound"), method_4636, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_4383), Reflex::Literal("upper_bound"), method_4637, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2501, type_4383), Reflex::Literal("equal_range"), method_4638, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2500, type_4383), Reflex::Literal("equal_range"), method_4639, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > > -------------------------------
static void constructor_12536( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >();
  else ::new(mem) ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >();
}

static void constructor_12537( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >(*(::std::auto_ptr<std::map<T2DetId,std::vector<T2Cluster> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >(*(::std::auto_ptr<std::map<T2DetId,std::vector<T2Cluster> > >*)arg[0]);
}

static void destructor_12538(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >::~Wrapper)();
}
static  void method_12539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->product)();
}

static  void operator_12540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->operator->)();
}

static  void method_12541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->productTypeInfo)();
}

static  void method_12542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->typeInfo)();
}

static void constructor_12543( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >((::std::map<T2DetId,std::vector<T2Cluster> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >((::std::map<T2DetId,std::vector<T2Cluster> >*)arg[0]);
}

static  void method_12544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->getInterface)();
}

static  void method_12545( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12546( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12547( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->dynamicTypeInfo)();
}

static  void method_12549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->isPresent)();
}

static  void method_12550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3340( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > > -------------------------------
void __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__datamem_bld(&__edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__funcmem_bld(&__edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__db_funcmem);
void __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >"), typeid(::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >), sizeof(::edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1436, Reflex::Literal("edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >::value_type"))
  .AddTypedef(type_1436, Reflex::Literal("edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12536, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2374), Reflex::Literal("Wrapper"), constructor_12537, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12538, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6137), Reflex::Literal("Wrapper"), constructor_12543, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3340, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > > -------------------
void __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1375, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1436, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > > -------------------
void __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8504), Reflex::Literal("product"), method_12539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8504), Reflex::Literal("operator->"), operator_12540, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("productTypeInfo"), method_12541, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("typeInfo"), method_12542, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18619), Reflex::Literal("getInterface"), method_12544, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_12583, type_13302, type_13303), Reflex::Literal("fillView"), method_12545, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_11351, type_269, type_6861), Reflex::Literal("setPtr"), method_12546, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_11351, type_13304, type_13302), Reflex::Literal("fillPtrVector"), method_12547, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("dynamicTypeInfo"), method_12548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1375), Reflex::Literal("isPresent"), method_12549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("dynamicTypeInfo_"), method_12550, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > >, std::allocator<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > > > > -------------------------------
static void constructor_4206( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >();
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >();
}

static void constructor_4207( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >(*(::std::auto_ptr<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >(*(::std::auto_ptr<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)arg[0]);
}

static void destructor_4208(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >::~Wrapper)();
}
static  void method_4209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->product)();
}

static  void operator_4210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->operator->)();
}

static  void method_4211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->productTypeInfo)();
}

static  void method_4212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->typeInfo)();
}

static void constructor_4213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >((::std::vector<std::map<T2DetId,std::vector<T2Cluster> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >((::std::vector<std::map<T2DetId,std::vector<T2Cluster> > >*)arg[0]);
}

static  void method_4214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->getInterface)();
}

static  void method_4215( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_4216( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_4217( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_4218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->dynamicTypeInfo)();
}

static  void method_4219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->isPresent)();
}

static  void method_4220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_782( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > >, std::allocator<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > > > > -------------------------------
void __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__datamem_bld(&__edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__funcmem_bld(&__edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__db_funcmem);
void __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >"), typeid(::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >), sizeof(::edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2524, Reflex::Literal("edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >::value_type"))
  .AddTypedef(type_2524, Reflex::Literal("edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_4206, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2375), Reflex::Literal("Wrapper"), constructor_4207, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_4208, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13300), Reflex::Literal("Wrapper"), constructor_4213, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_782, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > >, std::allocator<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > > > > -------------------
void __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1375, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2524, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > >, std::allocator<std::map<T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> >, std::less<T2DetId>, std::allocator<std::pair<const T2DetId, std::vector<T2Cluster, std::allocator<T2Cluster> > > > > > > > -------------------
void __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13299), Reflex::Literal("product"), method_4209, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13299), Reflex::Literal("operator->"), operator_4210, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("productTypeInfo"), method_4211, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("typeInfo"), method_4212, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13301), Reflex::Literal("getInterface"), method_4214, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_12583, type_13302, type_13303), Reflex::Literal("fillView"), method_4215, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_11351, type_269, type_6861), Reflex::Literal("setPtr"), method_4216, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_11351, type_13304, type_13302), Reflex::Literal("fillPtrVector"), method_4217, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("dynamicTypeInfo"), method_4218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1375), Reflex::Literal("isPresent"), method_4219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11351), Reflex::Literal("dynamicTypeInfo_"), method_4220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __T2Cluster_dict(); 
      __cluster_entry_dict(); 
      __T2ROGeometry_dict(); 
      __std__pair_T2DetId_std__vector_T2Cluster_s__dict(); 
      __std__vector_T2Cluster__dict(); 
      __std__vector_cluster_entry__dict(); 
      __edm__Wrapper_std__pair_T2DetId_std__vector_T2Cluster_s_s__dict(); 
      __std__map_T2DetId_std__vector_T2Cluster_s__dict(); 
      __edm__Wrapper_std__map_T2DetId_std__vector_T2Cluster_s_s__dict(); 
      __edm__Wrapper_std__vector_std__map_T2DetId_std__vector_T2Cluster_s_s_s__dict(); 
    }
    ~Dictionaries() {
      type_1214.Unload(); // class T2Cluster 
      type_1267.Unload(); // class cluster_entry 
      type_1931.Unload(); // class T2ROGeometry 
      type_2498.Unload(); // class std::pair<T2DetId,std::vector<T2Cluster> > 
      type_2522.Unload(); // class std::vector<T2Cluster> 
      type_2523.Unload(); // class std::vector<cluster_entry> 
      type_3339.Unload(); // class edm::Wrapper<std::pair<T2DetId,std::vector<T2Cluster> > > 
      type_1436.Unload(); // class std::map<T2DetId,std::vector<T2Cluster> > 
      type_3340.Unload(); // class edm::Wrapper<std::map<T2DetId,std::vector<T2Cluster> > > 
      type_782.Unload(); // class edm::Wrapper<std::vector<std::map<T2DetId,std::vector<T2Cluster> > > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
