// Generated at Mon Jul 11 23:54:12 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/TotemAnalysis/TotemAnalysisEvent/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_69 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_11 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_575 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_254 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1354 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_100 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_199 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1960 = ::Reflex::TypeBuilder(Reflex::Literal("TotemRPEvent"));
  ::Reflex::Type type_291 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_403 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3476 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_812 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpPattern"));
  ::Reflex::Type type_2556 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_945 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpDigiInfo"));
  ::Reflex::Type type_1901 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpTrackInfo"));
  ::Reflex::Type type_574 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpPatternInfo"));
  ::Reflex::Type type_2257 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned int>"));
  ::Reflex::Type type_2533 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2534 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3404 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TotemRPEvent>"));
  ::Reflex::Type type_2363 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TotemRPEvent>"));
  ::Reflex::Type type_528 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpReconstructedProton"));
  ::Reflex::Type type_2555 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRootDumpPattern>"));
  ::Reflex::Type type_2538 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRootDumpDigiInfo>"));
  ::Reflex::Type type_3399 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpPattern>"));
  ::Reflex::Type type_4585 = ::Reflex::TypeBuilder(Reflex::Literal("totemRPAnalysis::TotemRPAnalysis"));
  ::Reflex::Type type_2535 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRootDumpTrackInfo>"));
  ::Reflex::Type type_2358 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpPattern>"));
  ::Reflex::Type type_3402 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpDigiInfo>"));
  ::Reflex::Type type_1681 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpReconstructedProtonPair"));
  ::Reflex::Type type_2361 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpDigiInfo>"));
  ::Reflex::Type type_3403 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpTrackInfo>"));
  ::Reflex::Type type_2537 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRootDumpPatternInfo>"));
  ::Reflex::Type type_2723 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRootDumpDigiInfo>"));
  ::Reflex::Type type_2362 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpTrackInfo>"));
  ::Reflex::Type type_2717 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRootDumpTrackInfo>"));
  ::Reflex::Type type_3447 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TotemRPEvent>"));
  ::Reflex::Type type_3398 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpPatternInfo>"));
  ::Reflex::Type type_2357 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpPatternInfo>"));
  ::Reflex::Type type_2722 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRootDumpPatternInfo>"));
  ::Reflex::Type type_3442 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpPattern>"));
  ::Reflex::Type type_2660 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>"));
  ::Reflex::Type type_3445 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpDigiInfo>"));
  ::Reflex::Type type_2661 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>"));
  ::Reflex::Type type_2536 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_3446 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpTrackInfo>"));
  ::Reflex::Type type_3401 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_2659 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>"));
  ::Reflex::Type type_3441 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpPatternInfo>"));
  ::Reflex::Type type_2360 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_2721 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_3396 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2355 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_3397 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3400 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProtonPair>"));
  ::Reflex::Type type_2485 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RPRootDumpDigiInfo>"));
  ::Reflex::Type type_2356 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2359 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpReconstructedProtonPair>"));
  ::Reflex::Type type_2486 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RPRootDumpTrackInfo>"));
  ::Reflex::Type type_3395 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2354 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2484 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RPRootDumpPatternInfo>"));
  ::Reflex::Type type_2657 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_3444 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_3313 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3439 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2658 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3440 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3443 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpReconstructedProtonPair>"));
  ::Reflex::Type type_3392 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2351 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_3393 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3394 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2352 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2353 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_3438 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2482 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_3391 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2350 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_5226 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_5227 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2483 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_5225 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2719 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_3435 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2720 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3436 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3437 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_3389 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2718 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2348 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_3434 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_3390 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2349 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_5224 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2134 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2608 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2609 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2135 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2715 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2607 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_3432 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2133 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2701 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2716 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2702 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3433 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_5130 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2700 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_5132 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2605 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_5128 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_5131 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2606 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2501 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,bool>"));
  ::Reflex::Type type_5133 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2698 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2504 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,bool>"));
  ::Reflex::Type type_2498 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,bool>"));
  ::Reflex::Type type_5129 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2699 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2132 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2866 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2868 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2491 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,bool>"));
  ::Reflex::Type type_2864 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2865 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_5126 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2495 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,bool>"));
  ::Reflex::Type type_2867 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2826 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2863 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2828 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2860 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_5127 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2824 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2825 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2862 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >"));
  ::Reflex::Type type_2827 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2859 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2823 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2861 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >"));
  ::Reflex::Type type_2822 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2821 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2500 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2503 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2497 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2499 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2502 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2496 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2490 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2494 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >"));
  ::Reflex::Type type_2489 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2493 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >"));
  ::Reflex::Type type_2303 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpDigiInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2304 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpTrackInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2302 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpPatternInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2300 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpReconstructedProton>,std::_Select1st<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2301 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >"));
  ::Reflex::Type type_9005 = ::Reflex::ReferenceBuilder(type_528);
  ::Reflex::Type type_528c = ::Reflex::ConstBuilder(type_528);
  ::Reflex::Type type_9007 = ::Reflex::ReferenceBuilder(type_528c);
  ::Reflex::Type type_9070 = ::Reflex::ReferenceBuilder(type_574);
  ::Reflex::Type type_574c = ::Reflex::ConstBuilder(type_574);
  ::Reflex::Type type_9072 = ::Reflex::ReferenceBuilder(type_574c);
  ::Reflex::Type type_9960 = ::Reflex::ReferenceBuilder(type_812);
  ::Reflex::Type type_812c = ::Reflex::ConstBuilder(type_812);
  ::Reflex::Type type_9962 = ::Reflex::ReferenceBuilder(type_812c);
  ::Reflex::Type type_9135 = ::Reflex::ReferenceBuilder(type_945);
  ::Reflex::Type type_945c = ::Reflex::ConstBuilder(type_945);
  ::Reflex::Type type_9137 = ::Reflex::ReferenceBuilder(type_945c);
  ::Reflex::Type type_14854 = ::Reflex::ReferenceBuilder(type_1681);
  ::Reflex::Type type_1681c = ::Reflex::ConstBuilder(type_1681);
  ::Reflex::Type type_14855 = ::Reflex::ReferenceBuilder(type_1681c);
  ::Reflex::Type type_8940 = ::Reflex::ReferenceBuilder(type_1901);
  ::Reflex::Type type_1901c = ::Reflex::ConstBuilder(type_1901);
  ::Reflex::Type type_8942 = ::Reflex::ReferenceBuilder(type_1901c);
  ::Reflex::Type type_254c = ::Reflex::ConstBuilder(type_254);
  ::Reflex::Type type_2930 = ::Reflex::PointerBuilder(type_254c);
  ::Reflex::Type type_17838 = ::Reflex::ReferenceBuilder(type_1960);
  ::Reflex::Type type_1960c = ::Reflex::ConstBuilder(type_1960);
  ::Reflex::Type type_17839 = ::Reflex::ReferenceBuilder(type_1960c);
  ::Reflex::Type type_6198 = ::Reflex::PointerBuilder(type_1901);
  ::Reflex::Type type_8938 = ::Reflex::PointerBuilder(type_1901c);
  ::Reflex::Type type_2696 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_291);
  ::Reflex::Type type_2631 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_11);
  ::Reflex::Type type_2717c = ::Reflex::ConstBuilder(type_2717);
  ::Reflex::Type type_17918 = ::Reflex::ReferenceBuilder(type_2717c);
  ::Reflex::Type type_2535c = ::Reflex::ConstBuilder(type_2535);
  ::Reflex::Type type_18582 = ::Reflex::ReferenceBuilder(type_2535c);
  ::Reflex::Type type_18583 = ::Reflex::ReferenceBuilder(type_2535);
  ::Reflex::Type type_6141 = ::Reflex::PointerBuilder(type_528);
  ::Reflex::Type type_9003 = ::Reflex::PointerBuilder(type_528c);
  ::Reflex::Type type_2721c = ::Reflex::ConstBuilder(type_2721);
  ::Reflex::Type type_17879 = ::Reflex::ReferenceBuilder(type_2721c);
  ::Reflex::Type type_2536c = ::Reflex::ConstBuilder(type_2536);
  ::Reflex::Type type_18585 = ::Reflex::ReferenceBuilder(type_2536c);
  ::Reflex::Type type_18586 = ::Reflex::ReferenceBuilder(type_2536);
  ::Reflex::Type type_6160 = ::Reflex::PointerBuilder(type_574);
  ::Reflex::Type type_9068 = ::Reflex::PointerBuilder(type_574c);
  ::Reflex::Type type_2722c = ::Reflex::ConstBuilder(type_2722);
  ::Reflex::Type type_17892 = ::Reflex::ReferenceBuilder(type_2722c);
  ::Reflex::Type type_2537c = ::Reflex::ConstBuilder(type_2537);
  ::Reflex::Type type_18588 = ::Reflex::ReferenceBuilder(type_2537c);
  ::Reflex::Type type_18589 = ::Reflex::ReferenceBuilder(type_2537);
  ::Reflex::Type type_6179 = ::Reflex::PointerBuilder(type_945);
  ::Reflex::Type type_9133 = ::Reflex::PointerBuilder(type_945c);
  ::Reflex::Type type_2723c = ::Reflex::ConstBuilder(type_2723);
  ::Reflex::Type type_17905 = ::Reflex::ReferenceBuilder(type_2723c);
  ::Reflex::Type type_2538c = ::Reflex::ConstBuilder(type_2538);
  ::Reflex::Type type_18591 = ::Reflex::ReferenceBuilder(type_2538c);
  ::Reflex::Type type_18592 = ::Reflex::ReferenceBuilder(type_2538);
  ::Reflex::Type type_7449 = ::Reflex::PointerBuilder(type_2482);
  ::Reflex::Type type_2482c = ::Reflex::ConstBuilder(type_2482);
  ::Reflex::Type type_7451 = ::Reflex::PointerBuilder(type_2482c);
  ::Reflex::Type type_7453 = ::Reflex::ReferenceBuilder(type_2482);
  ::Reflex::Type type_7455 = ::Reflex::ReferenceBuilder(type_2482c);
  ::Reflex::Type type_2257c = ::Reflex::ConstBuilder(type_2257);
  ::Reflex::Type type_18316 = ::Reflex::ReferenceBuilder(type_2257c);
  ::Reflex::Type type_2715c = ::Reflex::ConstBuilder(type_2715);
  ::Reflex::Type type_18388 = ::Reflex::ReferenceBuilder(type_2715c);
  ::Reflex::Type type_2657c = ::Reflex::ConstBuilder(type_2657);
  ::Reflex::Type type_18743 = ::Reflex::ReferenceBuilder(type_2657c);
  ::Reflex::Type type_18744 = ::Reflex::ReferenceBuilder(type_2657);
  ::Reflex::Type type_199c = ::Reflex::ConstBuilder(type_199);
  ::Reflex::Type type_18317 = ::Reflex::ReferenceBuilder(type_199c);
  ::Reflex::Type type_7558 = ::Reflex::PointerBuilder(type_2483);
  ::Reflex::Type type_2483c = ::Reflex::ConstBuilder(type_2483);
  ::Reflex::Type type_7560 = ::Reflex::PointerBuilder(type_2483c);
  ::Reflex::Type type_7562 = ::Reflex::ReferenceBuilder(type_2483);
  ::Reflex::Type type_7564 = ::Reflex::ReferenceBuilder(type_2483c);
  ::Reflex::Type type_2716c = ::Reflex::ConstBuilder(type_2716);
  ::Reflex::Type type_18396 = ::Reflex::ReferenceBuilder(type_2716c);
  ::Reflex::Type type_2658c = ::Reflex::ConstBuilder(type_2658);
  ::Reflex::Type type_18745 = ::Reflex::ReferenceBuilder(type_2658c);
  ::Reflex::Type type_18746 = ::Reflex::ReferenceBuilder(type_2658);
  ::Reflex::Type type_7667 = ::Reflex::PointerBuilder(type_2484);
  ::Reflex::Type type_2484c = ::Reflex::ConstBuilder(type_2484);
  ::Reflex::Type type_7669 = ::Reflex::PointerBuilder(type_2484c);
  ::Reflex::Type type_7671 = ::Reflex::ReferenceBuilder(type_2484);
  ::Reflex::Type type_7673 = ::Reflex::ReferenceBuilder(type_2484c);
  ::Reflex::Type type_2718c = ::Reflex::ConstBuilder(type_2718);
  ::Reflex::Type type_18403 = ::Reflex::ReferenceBuilder(type_2718c);
  ::Reflex::Type type_2659c = ::Reflex::ConstBuilder(type_2659);
  ::Reflex::Type type_18747 = ::Reflex::ReferenceBuilder(type_2659c);
  ::Reflex::Type type_18748 = ::Reflex::ReferenceBuilder(type_2659);
  ::Reflex::Type type_7776 = ::Reflex::PointerBuilder(type_2485);
  ::Reflex::Type type_2485c = ::Reflex::ConstBuilder(type_2485);
  ::Reflex::Type type_7778 = ::Reflex::PointerBuilder(type_2485c);
  ::Reflex::Type type_7780 = ::Reflex::ReferenceBuilder(type_2485);
  ::Reflex::Type type_7782 = ::Reflex::ReferenceBuilder(type_2485c);
  ::Reflex::Type type_2719c = ::Reflex::ConstBuilder(type_2719);
  ::Reflex::Type type_18410 = ::Reflex::ReferenceBuilder(type_2719c);
  ::Reflex::Type type_2660c = ::Reflex::ConstBuilder(type_2660);
  ::Reflex::Type type_18749 = ::Reflex::ReferenceBuilder(type_2660c);
  ::Reflex::Type type_18750 = ::Reflex::ReferenceBuilder(type_2660);
  ::Reflex::Type type_7885 = ::Reflex::PointerBuilder(type_2486);
  ::Reflex::Type type_2486c = ::Reflex::ConstBuilder(type_2486);
  ::Reflex::Type type_7887 = ::Reflex::PointerBuilder(type_2486c);
  ::Reflex::Type type_7889 = ::Reflex::ReferenceBuilder(type_2486);
  ::Reflex::Type type_7891 = ::Reflex::ReferenceBuilder(type_2486c);
  ::Reflex::Type type_2720c = ::Reflex::ConstBuilder(type_2720);
  ::Reflex::Type type_18417 = ::Reflex::ReferenceBuilder(type_2720c);
  ::Reflex::Type type_2661c = ::Reflex::ConstBuilder(type_2661);
  ::Reflex::Type type_18751 = ::Reflex::ReferenceBuilder(type_2661c);
  ::Reflex::Type type_18752 = ::Reflex::ReferenceBuilder(type_2661);
  ::Reflex::Type type_20491 = ::Reflex::PointerBuilder(type_2657c);
  ::Reflex::Type type_403c = ::Reflex::ConstBuilder(type_403);
  ::Reflex::Type type_12524 = ::Reflex::ReferenceBuilder(type_403c);
  ::Reflex::Type type_20492 = ::Reflex::PointerBuilder(type_2657);
  ::Reflex::Type type_3432c = ::Reflex::ConstBuilder(type_3432);
  ::Reflex::Type type_20493 = ::Reflex::PointerBuilder(type_3432c);
  ::Reflex::Type type_3476c = ::Reflex::ConstBuilder(type_3476);
  ::Reflex::Type type_14055 = ::Reflex::ReferenceBuilder(type_3476c);
  ::Reflex::Type type_18578 = ::Reflex::ReferenceBuilder(type_2533);
  ::Reflex::Type type_20419 = ::Reflex::ReferenceBuilder(type_3313);
  ::Reflex::Type type_575c = ::Reflex::ConstBuilder(type_575);
  ::Reflex::Type type_3048 = ::Reflex::PointerBuilder(type_575c);
  ::Reflex::Type type_6956 = ::Reflex::ReferenceBuilder(type_3048);
  ::Reflex::Type type_2534c = ::Reflex::ConstBuilder(type_2534);
  ::Reflex::Type type_18579 = ::Reflex::ReferenceBuilder(type_2534c);
  ::Reflex::Type type_20496 = ::Reflex::PointerBuilder(type_2658c);
  ::Reflex::Type type_20497 = ::Reflex::PointerBuilder(type_2658);
  ::Reflex::Type type_3433c = ::Reflex::ConstBuilder(type_3433);
  ::Reflex::Type type_20498 = ::Reflex::PointerBuilder(type_3433c);
  ::Reflex::Type type_20501 = ::Reflex::PointerBuilder(type_2659c);
  ::Reflex::Type type_20502 = ::Reflex::PointerBuilder(type_2659);
  ::Reflex::Type type_3434c = ::Reflex::ConstBuilder(type_3434);
  ::Reflex::Type type_20503 = ::Reflex::PointerBuilder(type_3434c);
  ::Reflex::Type type_20506 = ::Reflex::PointerBuilder(type_2660c);
  ::Reflex::Type type_20507 = ::Reflex::PointerBuilder(type_2660);
  ::Reflex::Type type_3435c = ::Reflex::ConstBuilder(type_3435);
  ::Reflex::Type type_20508 = ::Reflex::PointerBuilder(type_3435c);
  ::Reflex::Type type_20511 = ::Reflex::PointerBuilder(type_2661c);
  ::Reflex::Type type_20512 = ::Reflex::PointerBuilder(type_2661);
  ::Reflex::Type type_3436c = ::Reflex::ConstBuilder(type_3436);
  ::Reflex::Type type_20513 = ::Reflex::PointerBuilder(type_3436c);
  ::Reflex::Type type_20516 = ::Reflex::PointerBuilder(type_2536c);
  ::Reflex::Type type_20517 = ::Reflex::PointerBuilder(type_2536);
  ::Reflex::Type type_3437c = ::Reflex::ConstBuilder(type_3437);
  ::Reflex::Type type_20518 = ::Reflex::PointerBuilder(type_3437c);
  ::Reflex::Type type_20521 = ::Reflex::PointerBuilder(type_2537c);
  ::Reflex::Type type_20522 = ::Reflex::PointerBuilder(type_2537);
  ::Reflex::Type type_3438c = ::Reflex::ConstBuilder(type_3438);
  ::Reflex::Type type_20523 = ::Reflex::PointerBuilder(type_3438c);
  ::Reflex::Type type_20526 = ::Reflex::PointerBuilder(type_2538c);
  ::Reflex::Type type_20527 = ::Reflex::PointerBuilder(type_2538);
  ::Reflex::Type type_3439c = ::Reflex::ConstBuilder(type_3439);
  ::Reflex::Type type_20528 = ::Reflex::PointerBuilder(type_3439c);
  ::Reflex::Type type_20531 = ::Reflex::PointerBuilder(type_2535c);
  ::Reflex::Type type_20532 = ::Reflex::PointerBuilder(type_2535);
  ::Reflex::Type type_3440c = ::Reflex::ConstBuilder(type_3440);
  ::Reflex::Type type_20533 = ::Reflex::PointerBuilder(type_3440c);
  ::Reflex::Type type_3441c = ::Reflex::ConstBuilder(type_3441);
  ::Reflex::Type type_20536 = ::Reflex::PointerBuilder(type_3441c);
  ::Reflex::Type type_9958 = ::Reflex::PointerBuilder(type_812c);
  ::Reflex::Type type_6482 = ::Reflex::PointerBuilder(type_812);
  ::Reflex::Type type_3442c = ::Reflex::ConstBuilder(type_3442);
  ::Reflex::Type type_20539 = ::Reflex::PointerBuilder(type_3442c);
  ::Reflex::Type type_20542 = ::Reflex::PointerBuilder(type_1681c);
  ::Reflex::Type type_20543 = ::Reflex::PointerBuilder(type_1681);
  ::Reflex::Type type_3443c = ::Reflex::ConstBuilder(type_3443);
  ::Reflex::Type type_20544 = ::Reflex::PointerBuilder(type_3443c);
  ::Reflex::Type type_3444c = ::Reflex::ConstBuilder(type_3444);
  ::Reflex::Type type_20547 = ::Reflex::PointerBuilder(type_3444c);
  ::Reflex::Type type_3445c = ::Reflex::ConstBuilder(type_3445);
  ::Reflex::Type type_20550 = ::Reflex::PointerBuilder(type_3445c);
  ::Reflex::Type type_3446c = ::Reflex::ConstBuilder(type_3446);
  ::Reflex::Type type_20553 = ::Reflex::PointerBuilder(type_3446c);
  ::Reflex::Type type_20556 = ::Reflex::PointerBuilder(type_1960c);
  ::Reflex::Type type_20557 = ::Reflex::PointerBuilder(type_1960);
  ::Reflex::Type type_3447c = ::Reflex::ConstBuilder(type_3447);
  ::Reflex::Type type_20558 = ::Reflex::PointerBuilder(type_3447c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __RPRootDumpReconstructedProton
#undef __RPRootDumpReconstructedProton
#endif
struct __RPRootDumpReconstructedProton {
  public:
  __RPRootDumpReconstructedProton();
  virtual ~__RPRootDumpReconstructedProton() throw();
  bool valid;
  double thx;
  double thy;
  double phi;
  double t;
  double tx;
  double ty;
  double xi;
  double x0;
  double y0;
  double chi2;
  double chindf;
};
#ifdef __RPRootDumpPatternInfo
#undef __RPRootDumpPatternInfo
#endif
struct __RPRootDumpPatternInfo {
  public:
  __RPRootDumpPatternInfo();
  virtual ~__RPRootDumpPatternInfo() throw();
  ::std::vector<RPRootDumpPattern> u;
  ::std::vector<RPRootDumpPattern> v;
  bool fittable;
  unsigned int u_no;
  unsigned int v_no;
};
#ifdef __RPRootDumpPattern
#undef __RPRootDumpPattern
#endif
struct __RPRootDumpPattern {
  public:
  __RPRootDumpPattern();
  virtual ~__RPRootDumpPattern() throw();
  double a;
  double b;
  double w;
};
#ifdef __RPRootDumpDigiInfo
#undef __RPRootDumpDigiInfo
#endif
struct __RPRootDumpDigiInfo {
  public:
  __RPRootDumpDigiInfo();
  virtual ~__RPRootDumpDigiInfo() throw();
  ::std::vector<int> numberOfClusters;
  unsigned int numberOfPlanesOn;
  unsigned int uPlanesOn;
  unsigned int vPlanesOn;
  ::std::vector<int> planeId;
  ::std::vector<int> clusterSize;
  ::std::vector<int> centralStrip;
};
#ifdef __RPRootDumpReconstructedProtonPair
#undef __RPRootDumpReconstructedProtonPair
#endif
struct __RPRootDumpReconstructedProtonPair {
  public:
  __RPRootDumpReconstructedProtonPair();
  virtual ~__RPRootDumpReconstructedProtonPair() throw();
  bool valid;
  double thxr;
  double thyr;
  double xir;
  double phir;
  double thxl;
  double thyl;
  double xil;
  double phil;
  double x0;
  double y0;
  double z0;
  double chi2;
  double chindf;
  double tr;
  double txr;
  double tyr;
  double tl;
  double txl;
  double tyl;
  double t;
};
#ifdef __RPRootDumpTrackInfo
#undef __RPRootDumpTrackInfo
#endif
struct __RPRootDumpTrackInfo {
  public:
  __RPRootDumpTrackInfo();
  virtual ~__RPRootDumpTrackInfo() throw();
  bool valid;
  double x;
  double y;
  double z;
  double thx;
  double thy;
  double chi2;
  double chi2ndf;
  unsigned int entries;
  double res_x;
  double res_y;
  ::std::vector<int> u_sect;
  ::std::vector<int> v_sect;
  int u_sect_no;
  int v_sect_no;
  unsigned int u_id;
  unsigned int v_id;
};
#ifdef __TotemRPEvent
#undef __TotemRPEvent
#endif
struct __TotemRPEvent {
  public:
  __TotemRPEvent();
  ::std::map<unsigned int,RPRootDumpTrackInfo> track_info_;
  ::std::map<unsigned int,RPRootDumpDigiInfo> digi_info_;
  ::std::map<unsigned int,RPRootDumpPatternInfo> par_patterns_info_;
  ::std::map<unsigned int,RPRootDumpPatternInfo> nonpar_patterns_info_;
  ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > multi_track_info_;
  ::std::map<unsigned int,RPRootDumpReconstructedProton> rec_pr_info_;
  ::std::map<unsigned int,RPRootDumpReconstructedProton> sim_pr_info_;
  ::RPRootDumpReconstructedProtonPair rec_pr_pair_info_;
};
#ifdef __std__vector_RPRootDumpTrackInfo_
#undef __std__vector_RPRootDumpTrackInfo_
#endif
class __std__vector_RPRootDumpTrackInfo_ : protected ::std::_Vector_base<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > {
  public:
  __std__vector_RPRootDumpTrackInfo_();
};
#ifdef __std__vector_RPRootDumpReconstructedProton_
#undef __std__vector_RPRootDumpReconstructedProton_
#endif
class __std__vector_RPRootDumpReconstructedProton_ : protected ::std::_Vector_base<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > {
  public:
  __std__vector_RPRootDumpReconstructedProton_();
};
#ifdef __std__vector_RPRootDumpPatternInfo_
#undef __std__vector_RPRootDumpPatternInfo_
#endif
class __std__vector_RPRootDumpPatternInfo_ : protected ::std::_Vector_base<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > {
  public:
  __std__vector_RPRootDumpPatternInfo_();
};
#ifdef __std__vector_RPRootDumpDigiInfo_
#undef __std__vector_RPRootDumpDigiInfo_
#endif
class __std__vector_RPRootDumpDigiInfo_ : protected ::std::_Vector_base<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > {
  public:
  __std__vector_RPRootDumpDigiInfo_();
};
#ifdef __std__map_unsignedsint_RPRootDumpReconstructedProton_
#undef __std__map_unsignedsint_RPRootDumpReconstructedProton_
#endif
class __std__map_unsignedsint_RPRootDumpReconstructedProton_ {
  public:
  __std__map_unsignedsint_RPRootDumpReconstructedProton_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpReconstructedProton>,std::_Select1st<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > > _M_t;
};
#ifdef __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_
#undef __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_
#endif
class __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_ {
  public:
  __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > > _M_t;
};
#ifdef __std__map_unsignedsint_RPRootDumpPatternInfo_
#undef __std__map_unsignedsint_RPRootDumpPatternInfo_
#endif
class __std__map_unsignedsint_RPRootDumpPatternInfo_ {
  public:
  __std__map_unsignedsint_RPRootDumpPatternInfo_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpPatternInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> > > _M_t;
};
#ifdef __std__map_unsignedsint_RPRootDumpDigiInfo_
#undef __std__map_unsignedsint_RPRootDumpDigiInfo_
#endif
class __std__map_unsignedsint_RPRootDumpDigiInfo_ {
  public:
  __std__map_unsignedsint_RPRootDumpDigiInfo_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpDigiInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> > > _M_t;
};
#ifdef __std__map_unsignedsint_RPRootDumpTrackInfo_
#undef __std__map_unsignedsint_RPRootDumpTrackInfo_
#endif
class __std__map_unsignedsint_RPRootDumpTrackInfo_ {
  public:
  __std__map_unsignedsint_RPRootDumpTrackInfo_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpTrackInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> > > _M_t;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_
#undef __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_();
  bool present;
  ::std::map<unsigned int,RPRootDumpReconstructedProton> obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_
#undef __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_();
  bool present;
  ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_
#undef __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_();
  bool present;
  ::std::map<unsigned int,RPRootDumpPatternInfo> obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_
#undef __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_();
  bool present;
  ::std::map<unsigned int,RPRootDumpDigiInfo> obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_
#undef __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_();
  bool present;
  ::std::map<unsigned int,RPRootDumpTrackInfo> obj;
};
#ifdef __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_
#undef __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_
#endif
class __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_ {
  public:
  __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_();
  bool present;
  ::std::vector<RPRootDumpReconstructedProton> obj;
};
#ifdef __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_
#undef __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_
#endif
class __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_ {
  public:
  __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_();
  bool present;
  ::std::vector<RPRootDumpPatternInfo> obj;
};
#ifdef __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_
#undef __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_
#endif
class __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_ {
  public:
  __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_();
  bool present;
  ::std::vector<RPRootDumpDigiInfo> obj;
};
#ifdef __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_
#undef __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_
#endif
class __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_ {
  public:
  __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_();
  bool present;
  ::std::vector<RPRootDumpTrackInfo> obj;
};
#ifdef __edm__Wrapper_RPRootDumpPatternInfo_
#undef __edm__Wrapper_RPRootDumpPatternInfo_
#endif
class __edm__Wrapper_RPRootDumpPatternInfo_ {
  public:
  __edm__Wrapper_RPRootDumpPatternInfo_();
  bool present;
  ::RPRootDumpPatternInfo obj;
};
#ifdef __edm__Wrapper_RPRootDumpPattern_
#undef __edm__Wrapper_RPRootDumpPattern_
#endif
class __edm__Wrapper_RPRootDumpPattern_ {
  public:
  __edm__Wrapper_RPRootDumpPattern_();
  bool present;
  ::RPRootDumpPattern obj;
};
#ifdef __edm__Wrapper_RPRootDumpReconstructedProtonPair_
#undef __edm__Wrapper_RPRootDumpReconstructedProtonPair_
#endif
class __edm__Wrapper_RPRootDumpReconstructedProtonPair_ {
  public:
  __edm__Wrapper_RPRootDumpReconstructedProtonPair_();
  bool present;
  ::RPRootDumpReconstructedProtonPair obj;
};
#ifdef __edm__Wrapper_RPRootDumpReconstructedProton_
#undef __edm__Wrapper_RPRootDumpReconstructedProton_
#endif
class __edm__Wrapper_RPRootDumpReconstructedProton_ {
  public:
  __edm__Wrapper_RPRootDumpReconstructedProton_();
  bool present;
  ::RPRootDumpReconstructedProton obj;
};
#ifdef __edm__Wrapper_RPRootDumpDigiInfo_
#undef __edm__Wrapper_RPRootDumpDigiInfo_
#endif
class __edm__Wrapper_RPRootDumpDigiInfo_ {
  public:
  __edm__Wrapper_RPRootDumpDigiInfo_();
  bool present;
  ::RPRootDumpDigiInfo obj;
};
#ifdef __edm__Wrapper_RPRootDumpTrackInfo_
#undef __edm__Wrapper_RPRootDumpTrackInfo_
#endif
class __edm__Wrapper_RPRootDumpTrackInfo_ {
  public:
  __edm__Wrapper_RPRootDumpTrackInfo_();
  bool present;
  ::RPRootDumpTrackInfo obj;
};
#ifdef __edm__Wrapper_TotemRPEvent_
#undef __edm__Wrapper_TotemRPEvent_
#endif
class __edm__Wrapper_TotemRPEvent_ {
  public:
  __edm__Wrapper_TotemRPEvent_();
  bool present;
  ::TotemRPEvent obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class RPRootDumpReconstructedProton -------------------------------
static  void operator_3757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpReconstructedProton*)o)->operator=)(*(const ::RPRootDumpReconstructedProton*)arg[0]);
  else   (((::RPRootDumpReconstructedProton*)o)->operator=)(*(const ::RPRootDumpReconstructedProton*)arg[0]);
}

static void constructor_3758( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpReconstructedProton(*(const ::RPRootDumpReconstructedProton*)arg[0]);
  else ::new(mem) ::RPRootDumpReconstructedProton(*(const ::RPRootDumpReconstructedProton*)arg[0]);
}

static void constructor_3759( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpReconstructedProton();
  else ::new(mem) ::RPRootDumpReconstructedProton();
}

static void destructor_3760(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpReconstructedProton*)o)->::RPRootDumpReconstructedProton::~RPRootDumpReconstructedProton)();
}
static void method_newdel_528( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProton >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProton >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProton >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProton >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProton >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpReconstructedProton -------------------------------
void __RPRootDumpReconstructedProton_db_datamem(Reflex::Class*);
void __RPRootDumpReconstructedProton_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpReconstructedProton_datamem_bld(&__RPRootDumpReconstructedProton_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpReconstructedProton_funcmem_bld(&__RPRootDumpReconstructedProton_db_funcmem);
void __RPRootDumpReconstructedProton_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpReconstructedProton"), typeid(::RPRootDumpReconstructedProton), sizeof(::RPRootDumpReconstructedProton), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9005, type_9007), Reflex::Literal("operator="), operator_3757, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9007), Reflex::Literal("RPRootDumpReconstructedProton"), constructor_3758, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpReconstructedProton"), constructor_3759, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpReconstructedProton"), destructor_3760, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_528, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpReconstructedProton_datamem_bld);
}

//------Delayed data member builder for class RPRootDumpReconstructedProton -------------------
void __RPRootDumpReconstructedProton_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("valid"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, valid), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("thx"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, thx), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("thy"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, thy), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("phi"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("t"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, t), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("tx"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, tx), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("ty"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, ty), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("xi"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, xi), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("x0"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, x0), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("y0"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, y0), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("chi2"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, chi2), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("chindf"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, chindf), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpReconstructedProton -------------------
void __RPRootDumpReconstructedProton_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPRootDumpPatternInfo -------------------------------
static  void operator_3942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpPatternInfo*)o)->operator=)(*(const ::RPRootDumpPatternInfo*)arg[0]);
  else   (((::RPRootDumpPatternInfo*)o)->operator=)(*(const ::RPRootDumpPatternInfo*)arg[0]);
}

static void constructor_3943( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPatternInfo(*(const ::RPRootDumpPatternInfo*)arg[0]);
  else ::new(mem) ::RPRootDumpPatternInfo(*(const ::RPRootDumpPatternInfo*)arg[0]);
}

static void constructor_3944( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPatternInfo();
  else ::new(mem) ::RPRootDumpPatternInfo();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPatternInfo(*(bool*)arg[0]);
  else ::new(mem) ::RPRootDumpPatternInfo(*(bool*)arg[0]);
  }
}

static void destructor_3945(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpPatternInfo*)o)->::RPRootDumpPatternInfo::~RPRootDumpPatternInfo)();
}
static  void method_3946( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RPRootDumpPatternInfo*)o)->Reset)();
}

static void constructor_x1( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPatternInfo();
  else ::new(mem) ::RPRootDumpPatternInfo();
}

static void method_newdel_574( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpPatternInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpPatternInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpPatternInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpPatternInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpPatternInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpPatternInfo -------------------------------
void __RPRootDumpPatternInfo_db_datamem(Reflex::Class*);
void __RPRootDumpPatternInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpPatternInfo_datamem_bld(&__RPRootDumpPatternInfo_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpPatternInfo_funcmem_bld(&__RPRootDumpPatternInfo_db_funcmem);
void __RPRootDumpPatternInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpPatternInfo"), typeid(::RPRootDumpPatternInfo), sizeof(::RPRootDumpPatternInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9070, type_9072), Reflex::Literal("operator="), operator_3942, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9072), Reflex::Literal("RPRootDumpPatternInfo"), constructor_3943, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1354), Reflex::Literal("RPRootDumpPatternInfo"), constructor_3944, 0, "_f=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpPatternInfo"), destructor_3945, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpPatternInfo"), constructor_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_574, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpPatternInfo_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPRootDumpPatternInfo_funcmem_bld);
}

//------Delayed data member builder for class RPRootDumpPatternInfo -------------------
void __RPRootDumpPatternInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2555, Reflex::Literal("u"), OffsetOf(__shadow__::__RPRootDumpPatternInfo, u), ::Reflex::PUBLIC)
  .AddDataMember(type_2555, Reflex::Literal("v"), OffsetOf(__shadow__::__RPRootDumpPatternInfo, v), ::Reflex::PUBLIC)
  .AddDataMember(type_1354, Reflex::Literal("fittable"), OffsetOf(__shadow__::__RPRootDumpPatternInfo, fittable), ::Reflex::PUBLIC)
  .AddDataMember(type_199, Reflex::Literal("u_no"), OffsetOf(__shadow__::__RPRootDumpPatternInfo, u_no), ::Reflex::PUBLIC)
  .AddDataMember(type_199, Reflex::Literal("v_no"), OffsetOf(__shadow__::__RPRootDumpPatternInfo, v_no), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpPatternInfo -------------------
void __RPRootDumpPatternInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("Reset"), method_3946, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class RPRootDumpPattern -------------------------------
static  void operator_4114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpPattern*)o)->operator=)(*(const ::RPRootDumpPattern*)arg[0]);
  else   (((::RPRootDumpPattern*)o)->operator=)(*(const ::RPRootDumpPattern*)arg[0]);
}

static void constructor_4115( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern(*(const ::RPRootDumpPattern*)arg[0]);
  else ::new(mem) ::RPRootDumpPattern(*(const ::RPRootDumpPattern*)arg[0]);
}

static void constructor_4116( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern();
  else ::new(mem) ::RPRootDumpPattern();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern(*(double*)arg[0]);
  else ::new(mem) ::RPRootDumpPattern(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::RPRootDumpPattern(*(double*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::RPRootDumpPattern(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
}

static void destructor_4117(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpPattern*)o)->::RPRootDumpPattern::~RPRootDumpPattern)();
}
static void constructor_x3( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern();
  else ::new(mem) ::RPRootDumpPattern();
}

static void method_newdel_812( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpPattern >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpPattern >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpPattern >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpPattern >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpPattern >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpPattern -------------------------------
void __RPRootDumpPattern_db_datamem(Reflex::Class*);
void __RPRootDumpPattern_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpPattern_datamem_bld(&__RPRootDumpPattern_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpPattern_funcmem_bld(&__RPRootDumpPattern_db_funcmem);
void __RPRootDumpPattern_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpPattern"), typeid(::RPRootDumpPattern), sizeof(::RPRootDumpPattern), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9960, type_9962), Reflex::Literal("operator="), operator_4114, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9962), Reflex::Literal("RPRootDumpPattern"), constructor_4115, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_100, type_100, type_100), Reflex::Literal("RPRootDumpPattern"), constructor_4116, 0, "_a=0.0;_b=0.0;_w=0.0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpPattern"), destructor_4117, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpPattern"), constructor_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_812, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpPattern_datamem_bld);
}

//------Delayed data member builder for class RPRootDumpPattern -------------------
void __RPRootDumpPattern_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_100, Reflex::Literal("a"), OffsetOf(__shadow__::__RPRootDumpPattern, a), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("b"), OffsetOf(__shadow__::__RPRootDumpPattern, b), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("w"), OffsetOf(__shadow__::__RPRootDumpPattern, w), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpPattern -------------------
void __RPRootDumpPattern_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPRootDumpDigiInfo -------------------------------
static  void operator_4268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpDigiInfo*)o)->operator=)(*(const ::RPRootDumpDigiInfo*)arg[0]);
  else   (((::RPRootDumpDigiInfo*)o)->operator=)(*(const ::RPRootDumpDigiInfo*)arg[0]);
}

static void constructor_4269( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpDigiInfo(*(const ::RPRootDumpDigiInfo*)arg[0]);
  else ::new(mem) ::RPRootDumpDigiInfo(*(const ::RPRootDumpDigiInfo*)arg[0]);
}

static void constructor_4270( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpDigiInfo();
  else ::new(mem) ::RPRootDumpDigiInfo();
}

static void destructor_4271(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpDigiInfo*)o)->::RPRootDumpDigiInfo::~RPRootDumpDigiInfo)();
}
static void method_newdel_945( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpDigiInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpDigiInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpDigiInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpDigiInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpDigiInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpDigiInfo -------------------------------
void __RPRootDumpDigiInfo_db_datamem(Reflex::Class*);
void __RPRootDumpDigiInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpDigiInfo_datamem_bld(&__RPRootDumpDigiInfo_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpDigiInfo_funcmem_bld(&__RPRootDumpDigiInfo_db_funcmem);
void __RPRootDumpDigiInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpDigiInfo"), typeid(::RPRootDumpDigiInfo), sizeof(::RPRootDumpDigiInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9135, type_9137), Reflex::Literal("operator="), operator_4268, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9137), Reflex::Literal("RPRootDumpDigiInfo"), constructor_4269, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpDigiInfo"), constructor_4270, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpDigiInfo"), destructor_4271, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_945, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpDigiInfo_datamem_bld);
}

//------Delayed data member builder for class RPRootDumpDigiInfo -------------------
void __RPRootDumpDigiInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2556, Reflex::Literal("numberOfClusters"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, numberOfClusters), ::Reflex::PUBLIC)
  .AddDataMember(type_199, Reflex::Literal("numberOfPlanesOn"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, numberOfPlanesOn), ::Reflex::PUBLIC)
  .AddDataMember(type_199, Reflex::Literal("uPlanesOn"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, uPlanesOn), ::Reflex::PUBLIC)
  .AddDataMember(type_199, Reflex::Literal("vPlanesOn"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, vPlanesOn), ::Reflex::PUBLIC)
  .AddDataMember(type_2556, Reflex::Literal("planeId"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, planeId), ::Reflex::PUBLIC)
  .AddDataMember(type_2556, Reflex::Literal("clusterSize"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, clusterSize), ::Reflex::PUBLIC)
  .AddDataMember(type_2556, Reflex::Literal("centralStrip"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, centralStrip), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpDigiInfo -------------------
void __RPRootDumpDigiInfo_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPRootDumpReconstructedProtonPair -------------------------------
static  void operator_5079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpReconstructedProtonPair*)o)->operator=)(*(const ::RPRootDumpReconstructedProtonPair*)arg[0]);
  else   (((::RPRootDumpReconstructedProtonPair*)o)->operator=)(*(const ::RPRootDumpReconstructedProtonPair*)arg[0]);
}

static void constructor_5080( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpReconstructedProtonPair(*(const ::RPRootDumpReconstructedProtonPair*)arg[0]);
  else ::new(mem) ::RPRootDumpReconstructedProtonPair(*(const ::RPRootDumpReconstructedProtonPair*)arg[0]);
}

static void constructor_5081( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpReconstructedProtonPair();
  else ::new(mem) ::RPRootDumpReconstructedProtonPair();
}

static void destructor_5082(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpReconstructedProtonPair*)o)->::RPRootDumpReconstructedProtonPair::~RPRootDumpReconstructedProtonPair)();
}
static void method_newdel_1681( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProtonPair >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProtonPair >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProtonPair >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProtonPair >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProtonPair >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpReconstructedProtonPair -------------------------------
void __RPRootDumpReconstructedProtonPair_db_datamem(Reflex::Class*);
void __RPRootDumpReconstructedProtonPair_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpReconstructedProtonPair_datamem_bld(&__RPRootDumpReconstructedProtonPair_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpReconstructedProtonPair_funcmem_bld(&__RPRootDumpReconstructedProtonPair_db_funcmem);
void __RPRootDumpReconstructedProtonPair_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpReconstructedProtonPair"), typeid(::RPRootDumpReconstructedProtonPair), sizeof(::RPRootDumpReconstructedProtonPair), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14854, type_14855), Reflex::Literal("operator="), operator_5079, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14855), Reflex::Literal("RPRootDumpReconstructedProtonPair"), constructor_5080, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpReconstructedProtonPair"), constructor_5081, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpReconstructedProtonPair"), destructor_5082, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1681, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpReconstructedProtonPair_datamem_bld);
}

//------Delayed data member builder for class RPRootDumpReconstructedProtonPair -------------------
void __RPRootDumpReconstructedProtonPair_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("valid"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, valid), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("thxr"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, thxr), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("thyr"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, thyr), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("xir"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, xir), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("phir"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, phir), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("thxl"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, thxl), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("thyl"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, thyl), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("xil"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, xil), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("phil"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, phil), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("x0"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, x0), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("y0"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, y0), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("z0"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, z0), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("chi2"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, chi2), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("chindf"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, chindf), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("tr"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, tr), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("txr"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, txr), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("tyr"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, tyr), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("tl"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, tl), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("txl"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, txl), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("tyl"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, tyl), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("t"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, t), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpReconstructedProtonPair -------------------
void __RPRootDumpReconstructedProtonPair_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPRootDumpTrackInfo -------------------------------
static  void operator_5924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpTrackInfo*)o)->operator=)(*(const ::RPRootDumpTrackInfo*)arg[0]);
  else   (((::RPRootDumpTrackInfo*)o)->operator=)(*(const ::RPRootDumpTrackInfo*)arg[0]);
}

static void constructor_5925( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpTrackInfo(*(const ::RPRootDumpTrackInfo*)arg[0]);
  else ::new(mem) ::RPRootDumpTrackInfo(*(const ::RPRootDumpTrackInfo*)arg[0]);
}

static void constructor_5926( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpTrackInfo();
  else ::new(mem) ::RPRootDumpTrackInfo();
}

static void destructor_5927(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpTrackInfo*)o)->::RPRootDumpTrackInfo::~RPRootDumpTrackInfo)();
}
static void method_newdel_1901( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpTrackInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpTrackInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpTrackInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpTrackInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpTrackInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpTrackInfo -------------------------------
void __RPRootDumpTrackInfo_db_datamem(Reflex::Class*);
void __RPRootDumpTrackInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpTrackInfo_datamem_bld(&__RPRootDumpTrackInfo_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpTrackInfo_funcmem_bld(&__RPRootDumpTrackInfo_db_funcmem);
void __RPRootDumpTrackInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpTrackInfo"), typeid(::RPRootDumpTrackInfo), sizeof(::RPRootDumpTrackInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8940, type_8942), Reflex::Literal("operator="), operator_5924, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8942), Reflex::Literal("RPRootDumpTrackInfo"), constructor_5925, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpTrackInfo"), constructor_5926, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpTrackInfo"), destructor_5927, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1901, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpTrackInfo_datamem_bld);
}

//------Delayed data member builder for class RPRootDumpTrackInfo -------------------
void __RPRootDumpTrackInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("valid"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, valid), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("x"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, x), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("y"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, y), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("z"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, z), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("thx"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, thx), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("thy"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, thy), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("chi2"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, chi2), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("chi2ndf"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, chi2ndf), ::Reflex::PUBLIC)
  .AddDataMember(type_199, Reflex::Literal("entries"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, entries), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("res_x"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, res_x), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("res_y"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, res_y), ::Reflex::PUBLIC)
  .AddDataMember(type_2556, Reflex::Literal("u_sect"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, u_sect), ::Reflex::PUBLIC)
  .AddDataMember(type_2556, Reflex::Literal("v_sect"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, v_sect), ::Reflex::PUBLIC)
  .AddDataMember(type_69, Reflex::Literal("u_sect_no"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, u_sect_no), ::Reflex::PUBLIC)
  .AddDataMember(type_69, Reflex::Literal("v_sect_no"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, v_sect_no), ::Reflex::PUBLIC)
  .AddDataMember(type_199, Reflex::Literal("u_id"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, u_id), ::Reflex::PUBLIC)
  .AddDataMember(type_199, Reflex::Literal("v_id"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, v_id), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpTrackInfo -------------------
void __RPRootDumpTrackInfo_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TotemRPEvent -------------------------------
static  void operator_5942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TotemRPEvent*)o)->operator=)(*(const ::TotemRPEvent*)arg[0]);
  else   (((::TotemRPEvent*)o)->operator=)(*(const ::TotemRPEvent*)arg[0]);
}

static void constructor_5943( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRPEvent(*(const ::TotemRPEvent*)arg[0]);
  else ::new(mem) ::TotemRPEvent(*(const ::TotemRPEvent*)arg[0]);
}

static void constructor_5944( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRPEvent();
  else ::new(mem) ::TotemRPEvent();
}

static void destructor_5945(void*, void * o, const std::vector<void*>&, void *) {
(((::TotemRPEvent*)o)->::TotemRPEvent::~TotemRPEvent)();
}
static  void method_5946( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TotemRPEvent*)o)->reset)();
}

static void method_newdel_1960( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TotemRPEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TotemRPEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TotemRPEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TotemRPEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TotemRPEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TotemRPEvent -------------------------------
void __TotemRPEvent_db_datamem(Reflex::Class*);
void __TotemRPEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TotemRPEvent_datamem_bld(&__TotemRPEvent_db_datamem);
Reflex::GenreflexMemberBuilder __TotemRPEvent_funcmem_bld(&__TotemRPEvent_db_funcmem);
void __TotemRPEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TotemRPEvent"), typeid(::TotemRPEvent), sizeof(::TotemRPEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddDataMember(type_2930, Reflex::Literal("name"), (size_t)&TotemRPEvent::name, ::Reflex::PUBLIC | ::Reflex::STATIC | Reflex::STATIC)
  .AddTypedef(type_4585, Reflex::Literal("TotemRPEvent::analysis_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17838, type_17839), Reflex::Literal("operator="), operator_5942, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17839), Reflex::Literal("TotemRPEvent"), constructor_5943, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TotemRPEvent"), constructor_5944, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TotemRPEvent"), destructor_5945, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1960, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TotemRPEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TotemRPEvent_funcmem_bld);
}

//------Delayed data member builder for class TotemRPEvent -------------------
void __TotemRPEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2661, Reflex::Literal("track_info_"), OffsetOf(__shadow__::__TotemRPEvent, track_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2660, Reflex::Literal("digi_info_"), OffsetOf(__shadow__::__TotemRPEvent, digi_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2659, Reflex::Literal("par_patterns_info_"), OffsetOf(__shadow__::__TotemRPEvent, par_patterns_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2659, Reflex::Literal("nonpar_patterns_info_"), OffsetOf(__shadow__::__TotemRPEvent, nonpar_patterns_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2658, Reflex::Literal("multi_track_info_"), OffsetOf(__shadow__::__TotemRPEvent, multi_track_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2657, Reflex::Literal("rec_pr_info_"), OffsetOf(__shadow__::__TotemRPEvent, rec_pr_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2657, Reflex::Literal("sim_pr_info_"), OffsetOf(__shadow__::__TotemRPEvent, sim_pr_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_1681, Reflex::Literal("rec_pr_pair_info_"), OffsetOf(__shadow__::__TotemRPEvent, rec_pr_pair_info_), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TotemRPEvent -------------------
void __TotemRPEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("reset"), method_5946, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > -------------------------------
static void constructor_8951( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>();
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>();
}

static void constructor_8952( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(const ::std::allocator<RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(const ::std::allocator<RPRootDumpTrackInfo>*)arg[0]);
}

static void constructor_8953( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpTrackInfo*)arg[1]);
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpTrackInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpTrackInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpTrackInfo>*)arg[2]);
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpTrackInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpTrackInfo>*)arg[2]);
  }
}

static void constructor_8954( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(const ::std::vector<RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(const ::std::vector<RPRootDumpTrackInfo>*)arg[0]);
}

static void destructor_8955(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRootDumpTrackInfo>*)o)->::std::vector<RPRootDumpTrackInfo>::~vector)();
}
static  void operator_8956( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpTrackInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpTrackInfo>*)arg[0]);
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_8957( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRootDumpTrackInfo*)arg[1]);
}

static  void method_8958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((::std::vector<RPRootDumpTrackInfo>*)o)->begin)());
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->begin)();
}

static  void method_8959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->begin)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->begin)();
}

static  void method_8960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((::std::vector<RPRootDumpTrackInfo>*)o)->end)());
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->end)();
}

static  void method_8961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->end)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->end)();
}

static  void method_8966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->size)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->size)();
}

static  void method_8967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->max_size)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->max_size)();
}

static  void method_8968( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRootDumpTrackInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRootDumpTrackInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRootDumpTrackInfo*)arg[1]);
  }
}

static  void method_8969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->capacity)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->capacity)();
}

static  void method_8970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->empty)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->empty)();
}

static  void method_8971( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpTrackInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpTrackInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpTrackInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpTrackInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpTrackInfo>*)o)->front)();
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->front)();
}

static  void method_8978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpTrackInfo>*)o)->front)();
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->front)();
}

static  void method_8979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpTrackInfo>*)o)->back)();
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->back)();
}

static  void method_8980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpTrackInfo>*)o)->back)();
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->back)();
}

static  void method_8981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRootDumpTrackInfo>*)o)->data)());
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->data)();
}

static  void method_8982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRootDumpTrackInfo>*)o)->data)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->data)();
}

static  void method_8983( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->push_back)(*(const ::RPRootDumpTrackInfo*)arg[0]);
}

static  void method_8984( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->pop_back)();
}

static  void method_8985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((::std::vector<RPRootDumpTrackInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0],
    *(const ::RPRootDumpTrackInfo*)arg[1]));
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0],
    *(const ::RPRootDumpTrackInfo*)arg[1]);
}

static  void method_8986( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRootDumpTrackInfo*)arg[2]);
}

static  void method_8987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((::std::vector<RPRootDumpTrackInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0]));
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_8988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((::std::vector<RPRootDumpTrackInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[1]));
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[1]);
}

static  void method_8989( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->swap)(*(::std::vector<RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_8990( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->clear)();
}

static void method_newdel_2535( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpTrackInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpTrackInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpTrackInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpTrackInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpTrackInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> >")), ::Reflex::BaseOffset< ::std::vector<RPRootDumpTrackInfo>,::std::_Vector_base<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRootDumpTrackInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRootDumpTrackInfo> >::Generate();
}

//------Dictionary for class vector<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > -------------------------------
void __std__vector_RPRootDumpTrackInfo__db_datamem(Reflex::Class*);
void __std__vector_RPRootDumpTrackInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpTrackInfo__datamem_bld(&__std__vector_RPRootDumpTrackInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpTrackInfo__funcmem_bld(&__std__vector_RPRootDumpTrackInfo__db_funcmem);
void __std__vector_RPRootDumpTrackInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRootDumpTrackInfo>"), typeid(::std::vector<RPRootDumpTrackInfo>), sizeof(::std::vector<RPRootDumpTrackInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2135, ::Reflex::BaseOffset< ::std::vector<RPRootDumpTrackInfo>, ::std::_Vector_base<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1901, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::_Alloc_value_type"))
  .AddTypedef(type_2135, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::_Base"))
  .AddTypedef(type_2717, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::_Tp_alloc_type"))
  .AddTypedef(type_5227, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::_Alloc_traits"))
  .AddTypedef(type_1901, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::value_type"))
  .AddTypedef(type_6198, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::pointer"))
  .AddTypedef(type_8938, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::const_pointer"))
  .AddTypedef(type_8940, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::reference"))
  .AddTypedef(type_8942, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::const_reference"))
  .AddTypedef(type_5132, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::iterator"))
  .AddTypedef(type_5133, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::const_iterator"))
  .AddTypedef(type_2827, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::const_reverse_iterator"))
  .AddTypedef(type_2828, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::reverse_iterator"))
  .AddTypedef(type_2696, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::size_type"))
  .AddTypedef(type_2631, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::difference_type"))
  .AddTypedef(type_2717, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8951, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17918), Reflex::Literal("vector"), constructor_8952, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2696, type_8942, type_17918), Reflex::Literal("vector"), constructor_8953, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18582), Reflex::Literal("vector"), constructor_8954, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8955, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2535, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRootDumpTrackInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > -------------------
void __std__vector_RPRootDumpTrackInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > -------------------
void __std__vector_RPRootDumpTrackInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18583, type_18582), Reflex::Literal("operator="), operator_8956, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696, type_8942), Reflex::Literal("assign"), method_8957, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5132), Reflex::Literal("begin"), method_8958, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5133), Reflex::Literal("begin"), method_8959, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5132), Reflex::Literal("end"), method_8960, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5133), Reflex::Literal("end"), method_8961, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("size"), method_8966, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("max_size"), method_8967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696, type_1901), Reflex::Literal("resize"), method_8968, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("capacity"), method_8969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("empty"), method_8970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696), Reflex::Literal("reserve"), method_8971, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8940, type_2696), Reflex::Literal("operator[]"), operator_8972, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8942, type_2696), Reflex::Literal("operator[]"), operator_8973, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8940, type_2696), Reflex::Literal("at"), method_8975, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8942, type_2696), Reflex::Literal("at"), method_8976, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8940), Reflex::Literal("front"), method_8977, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8942), Reflex::Literal("front"), method_8978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8940), Reflex::Literal("back"), method_8979, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8942), Reflex::Literal("back"), method_8980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6198), Reflex::Literal("data"), method_8981, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8938), Reflex::Literal("data"), method_8982, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_8942), Reflex::Literal("push_back"), method_8983, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("pop_back"), method_8984, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5132, type_5132, type_8942), Reflex::Literal("insert"), method_8985, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_5132, type_2696, type_8942), Reflex::Literal("insert"), method_8986, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5132, type_5132), Reflex::Literal("erase"), method_8987, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5132, type_5132, type_5132), Reflex::Literal("erase"), method_8988, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_18583), Reflex::Literal("swap"), method_8989, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_8990, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > -------------------------------
static void constructor_9016( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>();
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>();
}

static void constructor_9017( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(const ::std::allocator<RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(const ::std::allocator<RPRootDumpReconstructedProton>*)arg[0]);
}

static void constructor_9018( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpReconstructedProton*)arg[1]);
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpReconstructedProton*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpReconstructedProton*)arg[1],
      *(const ::std::allocator<RPRootDumpReconstructedProton>*)arg[2]);
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpReconstructedProton*)arg[1],
      *(const ::std::allocator<RPRootDumpReconstructedProton>*)arg[2]);
  }
}

static void constructor_9019( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(const ::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(const ::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
}

static void destructor_9020(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRootDumpReconstructedProton>*)o)->::std::vector<RPRootDumpReconstructedProton>::~vector)();
}
static  void operator_9021( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpReconstructedProton>*)o)->operator=)(*(const ::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->operator=)(*(const ::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_9022( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRootDumpReconstructedProton*)arg[1]);
}

static  void method_9023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((::std::vector<RPRootDumpReconstructedProton>*)o)->begin)());
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->begin)();
}

static  void method_9024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->begin)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->begin)();
}

static  void method_9025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((::std::vector<RPRootDumpReconstructedProton>*)o)->end)());
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->end)();
}

static  void method_9026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->end)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->end)();
}

static  void method_9031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->size)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->size)();
}

static  void method_9032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->max_size)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->max_size)();
}

static  void method_9033( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRootDumpReconstructedProton>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRootDumpReconstructedProton>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRootDumpReconstructedProton*)arg[1]);
  }
}

static  void method_9034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->capacity)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->capacity)();
}

static  void method_9035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->empty)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->empty)();
}

static  void method_9036( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9037( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9038( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9040( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9041( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpReconstructedProton>*)o)->front)();
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->front)();
}

static  void method_9043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpReconstructedProton>*)o)->front)();
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->front)();
}

static  void method_9044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpReconstructedProton>*)o)->back)();
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->back)();
}

static  void method_9045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpReconstructedProton>*)o)->back)();
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->back)();
}

static  void method_9046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRootDumpReconstructedProton>*)o)->data)());
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->data)();
}

static  void method_9047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->data)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->data)();
}

static  void method_9048( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->push_back)(*(const ::RPRootDumpReconstructedProton*)arg[0]);
}

static  void method_9049( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->pop_back)();
}

static  void method_9050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((::std::vector<RPRootDumpReconstructedProton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0],
    *(const ::RPRootDumpReconstructedProton*)arg[1]));
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0],
    *(const ::RPRootDumpReconstructedProton*)arg[1]);
}

static  void method_9051( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRootDumpReconstructedProton*)arg[2]);
}

static  void method_9052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((::std::vector<RPRootDumpReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0]));
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0]);
}

static  void method_9053( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((::std::vector<RPRootDumpReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[1]));
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[1]);
}

static  void method_9054( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->swap)(*(::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_9055( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->clear)();
}

static void method_newdel_2536( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpReconstructedProton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpReconstructedProton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpReconstructedProton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpReconstructedProton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpReconstructedProton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> >")), ::Reflex::BaseOffset< ::std::vector<RPRootDumpReconstructedProton>,::std::_Vector_base<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRootDumpReconstructedProton> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRootDumpReconstructedProton> >::Generate();
}

//------Dictionary for class vector<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > -------------------------------
void __std__vector_RPRootDumpReconstructedProton__db_datamem(Reflex::Class*);
void __std__vector_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpReconstructedProton__datamem_bld(&__std__vector_RPRootDumpReconstructedProton__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpReconstructedProton__funcmem_bld(&__std__vector_RPRootDumpReconstructedProton__db_funcmem);
void __std__vector_RPRootDumpReconstructedProton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRootDumpReconstructedProton>"), typeid(::std::vector<RPRootDumpReconstructedProton>), sizeof(::std::vector<RPRootDumpReconstructedProton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2132, ::Reflex::BaseOffset< ::std::vector<RPRootDumpReconstructedProton>, ::std::_Vector_base<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_528, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::_Alloc_value_type"))
  .AddTypedef(type_2132, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::_Base"))
  .AddTypedef(type_2721, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::_Tp_alloc_type"))
  .AddTypedef(type_5224, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::_Alloc_traits"))
  .AddTypedef(type_528, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::value_type"))
  .AddTypedef(type_6141, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::pointer"))
  .AddTypedef(type_9003, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::const_pointer"))
  .AddTypedef(type_9005, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::reference"))
  .AddTypedef(type_9007, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::const_reference"))
  .AddTypedef(type_5126, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::iterator"))
  .AddTypedef(type_5127, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::const_iterator"))
  .AddTypedef(type_2821, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::const_reverse_iterator"))
  .AddTypedef(type_2822, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::reverse_iterator"))
  .AddTypedef(type_2696, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::size_type"))
  .AddTypedef(type_2631, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::difference_type"))
  .AddTypedef(type_2721, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9016, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17879), Reflex::Literal("vector"), constructor_9017, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2696, type_9007, type_17879), Reflex::Literal("vector"), constructor_9018, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18585), Reflex::Literal("vector"), constructor_9019, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9020, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2536, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRootDumpReconstructedProton__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > -------------------
void __std__vector_RPRootDumpReconstructedProton__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > -------------------
void __std__vector_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18586, type_18585), Reflex::Literal("operator="), operator_9021, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696, type_9007), Reflex::Literal("assign"), method_9022, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5126), Reflex::Literal("begin"), method_9023, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5127), Reflex::Literal("begin"), method_9024, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5126), Reflex::Literal("end"), method_9025, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5127), Reflex::Literal("end"), method_9026, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("size"), method_9031, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("max_size"), method_9032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696, type_528), Reflex::Literal("resize"), method_9033, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("capacity"), method_9034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("empty"), method_9035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696), Reflex::Literal("reserve"), method_9036, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9005, type_2696), Reflex::Literal("operator[]"), operator_9037, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9007, type_2696), Reflex::Literal("operator[]"), operator_9038, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9005, type_2696), Reflex::Literal("at"), method_9040, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9007, type_2696), Reflex::Literal("at"), method_9041, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9005), Reflex::Literal("front"), method_9042, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9007), Reflex::Literal("front"), method_9043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9005), Reflex::Literal("back"), method_9044, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9007), Reflex::Literal("back"), method_9045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6141), Reflex::Literal("data"), method_9046, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9003), Reflex::Literal("data"), method_9047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_9007), Reflex::Literal("push_back"), method_9048, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("pop_back"), method_9049, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5126, type_5126, type_9007), Reflex::Literal("insert"), method_9050, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_5126, type_2696, type_9007), Reflex::Literal("insert"), method_9051, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5126, type_5126), Reflex::Literal("erase"), method_9052, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5126, type_5126, type_5126), Reflex::Literal("erase"), method_9053, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_18586), Reflex::Literal("swap"), method_9054, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_9055, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > -------------------------------
static void constructor_9081( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>();
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>();
}

static void constructor_9082( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(const ::std::allocator<RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(const ::std::allocator<RPRootDumpPatternInfo>*)arg[0]);
}

static void constructor_9083( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpPatternInfo*)arg[1]);
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpPatternInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpPatternInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpPatternInfo>*)arg[2]);
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpPatternInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpPatternInfo>*)arg[2]);
  }
}

static void constructor_9084( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(const ::std::vector<RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(const ::std::vector<RPRootDumpPatternInfo>*)arg[0]);
}

static void destructor_9085(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRootDumpPatternInfo>*)o)->::std::vector<RPRootDumpPatternInfo>::~vector)();
}
static  void operator_9086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpPatternInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpPatternInfo>*)arg[0]);
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_9087( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRootDumpPatternInfo*)arg[1]);
}

static  void method_9088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((::std::vector<RPRootDumpPatternInfo>*)o)->begin)());
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->begin)();
}

static  void method_9089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->begin)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->begin)();
}

static  void method_9090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((::std::vector<RPRootDumpPatternInfo>*)o)->end)());
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->end)();
}

static  void method_9091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->end)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->end)();
}

static  void method_9096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->size)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->size)();
}

static  void method_9097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->max_size)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->max_size)();
}

static  void method_9098( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRootDumpPatternInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRootDumpPatternInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRootDumpPatternInfo*)arg[1]);
  }
}

static  void method_9099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->capacity)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->capacity)();
}

static  void method_9100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->empty)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->empty)();
}

static  void method_9101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9102( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpPatternInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpPatternInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpPatternInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpPatternInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpPatternInfo>*)o)->front)();
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->front)();
}

static  void method_9108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpPatternInfo>*)o)->front)();
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->front)();
}

static  void method_9109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpPatternInfo>*)o)->back)();
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->back)();
}

static  void method_9110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpPatternInfo>*)o)->back)();
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->back)();
}

static  void method_9111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRootDumpPatternInfo>*)o)->data)());
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->data)();
}

static  void method_9112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRootDumpPatternInfo>*)o)->data)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->data)();
}

static  void method_9113( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->push_back)(*(const ::RPRootDumpPatternInfo*)arg[0]);
}

static  void method_9114( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->pop_back)();
}

static  void method_9115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((::std::vector<RPRootDumpPatternInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0],
    *(const ::RPRootDumpPatternInfo*)arg[1]));
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0],
    *(const ::RPRootDumpPatternInfo*)arg[1]);
}

static  void method_9116( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRootDumpPatternInfo*)arg[2]);
}

static  void method_9117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((::std::vector<RPRootDumpPatternInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0]));
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0]);
}

static  void method_9118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((::std::vector<RPRootDumpPatternInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[1]));
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[1]);
}

static  void method_9119( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->swap)(*(::std::vector<RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_9120( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->clear)();
}

static void method_newdel_2537( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpPatternInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpPatternInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpPatternInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpPatternInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpPatternInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> >")), ::Reflex::BaseOffset< ::std::vector<RPRootDumpPatternInfo>,::std::_Vector_base<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRootDumpPatternInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRootDumpPatternInfo> >::Generate();
}

//------Dictionary for class vector<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > -------------------------------
void __std__vector_RPRootDumpPatternInfo__db_datamem(Reflex::Class*);
void __std__vector_RPRootDumpPatternInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpPatternInfo__datamem_bld(&__std__vector_RPRootDumpPatternInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpPatternInfo__funcmem_bld(&__std__vector_RPRootDumpPatternInfo__db_funcmem);
void __std__vector_RPRootDumpPatternInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRootDumpPatternInfo>"), typeid(::std::vector<RPRootDumpPatternInfo>), sizeof(::std::vector<RPRootDumpPatternInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2133, ::Reflex::BaseOffset< ::std::vector<RPRootDumpPatternInfo>, ::std::_Vector_base<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_574, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::_Alloc_value_type"))
  .AddTypedef(type_2133, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::_Base"))
  .AddTypedef(type_2722, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::_Tp_alloc_type"))
  .AddTypedef(type_5225, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::_Alloc_traits"))
  .AddTypedef(type_574, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::value_type"))
  .AddTypedef(type_6160, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::pointer"))
  .AddTypedef(type_9068, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::const_pointer"))
  .AddTypedef(type_9070, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::reference"))
  .AddTypedef(type_9072, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::const_reference"))
  .AddTypedef(type_5128, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::iterator"))
  .AddTypedef(type_5129, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::const_iterator"))
  .AddTypedef(type_2823, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::const_reverse_iterator"))
  .AddTypedef(type_2824, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::reverse_iterator"))
  .AddTypedef(type_2696, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::size_type"))
  .AddTypedef(type_2631, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::difference_type"))
  .AddTypedef(type_2722, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9081, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17892), Reflex::Literal("vector"), constructor_9082, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2696, type_9072, type_17892), Reflex::Literal("vector"), constructor_9083, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18588), Reflex::Literal("vector"), constructor_9084, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9085, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2537, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRootDumpPatternInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > -------------------
void __std__vector_RPRootDumpPatternInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > -------------------
void __std__vector_RPRootDumpPatternInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18589, type_18588), Reflex::Literal("operator="), operator_9086, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696, type_9072), Reflex::Literal("assign"), method_9087, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5128), Reflex::Literal("begin"), method_9088, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5129), Reflex::Literal("begin"), method_9089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5128), Reflex::Literal("end"), method_9090, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5129), Reflex::Literal("end"), method_9091, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("size"), method_9096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("max_size"), method_9097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696, type_574), Reflex::Literal("resize"), method_9098, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("capacity"), method_9099, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("empty"), method_9100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696), Reflex::Literal("reserve"), method_9101, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9070, type_2696), Reflex::Literal("operator[]"), operator_9102, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9072, type_2696), Reflex::Literal("operator[]"), operator_9103, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9070, type_2696), Reflex::Literal("at"), method_9105, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9072, type_2696), Reflex::Literal("at"), method_9106, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9070), Reflex::Literal("front"), method_9107, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9072), Reflex::Literal("front"), method_9108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9070), Reflex::Literal("back"), method_9109, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9072), Reflex::Literal("back"), method_9110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6160), Reflex::Literal("data"), method_9111, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9068), Reflex::Literal("data"), method_9112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_9072), Reflex::Literal("push_back"), method_9113, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("pop_back"), method_9114, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5128, type_5128, type_9072), Reflex::Literal("insert"), method_9115, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_5128, type_2696, type_9072), Reflex::Literal("insert"), method_9116, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5128, type_5128), Reflex::Literal("erase"), method_9117, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5128, type_5128, type_5128), Reflex::Literal("erase"), method_9118, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_18589), Reflex::Literal("swap"), method_9119, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_9120, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > -------------------------------
static void constructor_9146( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>();
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>();
}

static void constructor_9147( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(const ::std::allocator<RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(const ::std::allocator<RPRootDumpDigiInfo>*)arg[0]);
}

static void constructor_9148( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpDigiInfo*)arg[1]);
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpDigiInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpDigiInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpDigiInfo>*)arg[2]);
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpDigiInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpDigiInfo>*)arg[2]);
  }
}

static void constructor_9149( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(const ::std::vector<RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(const ::std::vector<RPRootDumpDigiInfo>*)arg[0]);
}

static void destructor_9150(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRootDumpDigiInfo>*)o)->::std::vector<RPRootDumpDigiInfo>::~vector)();
}
static  void operator_9151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpDigiInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpDigiInfo>*)arg[0]);
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_9152( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRootDumpDigiInfo*)arg[1]);
}

static  void method_9153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((::std::vector<RPRootDumpDigiInfo>*)o)->begin)());
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->begin)();
}

static  void method_9154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->begin)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->begin)();
}

static  void method_9155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((::std::vector<RPRootDumpDigiInfo>*)o)->end)());
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->end)();
}

static  void method_9156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->end)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->end)();
}

static  void method_9161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->size)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->size)();
}

static  void method_9162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->max_size)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->max_size)();
}

static  void method_9163( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRootDumpDigiInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRootDumpDigiInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRootDumpDigiInfo*)arg[1]);
  }
}

static  void method_9164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->capacity)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->capacity)();
}

static  void method_9165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->empty)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->empty)();
}

static  void method_9166( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpDigiInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpDigiInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpDigiInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpDigiInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpDigiInfo>*)o)->front)();
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->front)();
}

static  void method_9173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpDigiInfo>*)o)->front)();
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->front)();
}

static  void method_9174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpDigiInfo>*)o)->back)();
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->back)();
}

static  void method_9175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpDigiInfo>*)o)->back)();
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->back)();
}

static  void method_9176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRootDumpDigiInfo>*)o)->data)());
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->data)();
}

static  void method_9177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRootDumpDigiInfo>*)o)->data)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->data)();
}

static  void method_9178( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->push_back)(*(const ::RPRootDumpDigiInfo*)arg[0]);
}

static  void method_9179( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->pop_back)();
}

static  void method_9180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((::std::vector<RPRootDumpDigiInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0],
    *(const ::RPRootDumpDigiInfo*)arg[1]));
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0],
    *(const ::RPRootDumpDigiInfo*)arg[1]);
}

static  void method_9181( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRootDumpDigiInfo*)arg[2]);
}

static  void method_9182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((::std::vector<RPRootDumpDigiInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0]));
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0]);
}

static  void method_9183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((::std::vector<RPRootDumpDigiInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[1]));
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[1]);
}

static  void method_9184( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->swap)(*(::std::vector<RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_9185( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->clear)();
}

static void method_newdel_2538( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpDigiInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpDigiInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpDigiInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpDigiInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpDigiInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> >")), ::Reflex::BaseOffset< ::std::vector<RPRootDumpDigiInfo>,::std::_Vector_base<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRootDumpDigiInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRootDumpDigiInfo> >::Generate();
}

//------Dictionary for class vector<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > -------------------------------
void __std__vector_RPRootDumpDigiInfo__db_datamem(Reflex::Class*);
void __std__vector_RPRootDumpDigiInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpDigiInfo__datamem_bld(&__std__vector_RPRootDumpDigiInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpDigiInfo__funcmem_bld(&__std__vector_RPRootDumpDigiInfo__db_funcmem);
void __std__vector_RPRootDumpDigiInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRootDumpDigiInfo>"), typeid(::std::vector<RPRootDumpDigiInfo>), sizeof(::std::vector<RPRootDumpDigiInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2134, ::Reflex::BaseOffset< ::std::vector<RPRootDumpDigiInfo>, ::std::_Vector_base<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_945, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::_Alloc_value_type"))
  .AddTypedef(type_2134, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::_Base"))
  .AddTypedef(type_2723, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::_Tp_alloc_type"))
  .AddTypedef(type_5226, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::_Alloc_traits"))
  .AddTypedef(type_945, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::value_type"))
  .AddTypedef(type_6179, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::pointer"))
  .AddTypedef(type_9133, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::const_pointer"))
  .AddTypedef(type_9135, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::reference"))
  .AddTypedef(type_9137, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::const_reference"))
  .AddTypedef(type_5130, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::iterator"))
  .AddTypedef(type_5131, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::const_iterator"))
  .AddTypedef(type_2825, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::const_reverse_iterator"))
  .AddTypedef(type_2826, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::reverse_iterator"))
  .AddTypedef(type_2696, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::size_type"))
  .AddTypedef(type_2631, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::difference_type"))
  .AddTypedef(type_2723, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9146, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17905), Reflex::Literal("vector"), constructor_9147, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2696, type_9137, type_17905), Reflex::Literal("vector"), constructor_9148, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18591), Reflex::Literal("vector"), constructor_9149, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9150, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2538, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRootDumpDigiInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > -------------------
void __std__vector_RPRootDumpDigiInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > -------------------
void __std__vector_RPRootDumpDigiInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18592, type_18591), Reflex::Literal("operator="), operator_9151, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696, type_9137), Reflex::Literal("assign"), method_9152, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5130), Reflex::Literal("begin"), method_9153, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5131), Reflex::Literal("begin"), method_9154, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5130), Reflex::Literal("end"), method_9155, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5131), Reflex::Literal("end"), method_9156, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("size"), method_9161, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("max_size"), method_9162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696, type_945), Reflex::Literal("resize"), method_9163, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("capacity"), method_9164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("empty"), method_9165, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2696), Reflex::Literal("reserve"), method_9166, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9135, type_2696), Reflex::Literal("operator[]"), operator_9167, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9137, type_2696), Reflex::Literal("operator[]"), operator_9168, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9135, type_2696), Reflex::Literal("at"), method_9170, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9137, type_2696), Reflex::Literal("at"), method_9171, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9135), Reflex::Literal("front"), method_9172, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9137), Reflex::Literal("front"), method_9173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9135), Reflex::Literal("back"), method_9174, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9137), Reflex::Literal("back"), method_9175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6179), Reflex::Literal("data"), method_9176, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9133), Reflex::Literal("data"), method_9177, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_9137), Reflex::Literal("push_back"), method_9178, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("pop_back"), method_9179, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5130, type_5130, type_9137), Reflex::Literal("insert"), method_9180, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_5130, type_2696, type_9137), Reflex::Literal("insert"), method_9181, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5130, type_5130), Reflex::Literal("erase"), method_9182, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5130, type_5130, type_5130), Reflex::Literal("erase"), method_9183, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_18592), Reflex::Literal("swap"), method_9184, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_9185, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<unsigned int,RPRootDumpReconstructedProton,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > -------------------------------
static void destructor_10595(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->::std::map<unsigned int,RPRootDumpReconstructedProton>::~map)();
}
static void constructor_10596( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>();
  else ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>();
}

static void constructor_10597( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[1]);
  }
}

static void constructor_10598( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
}

static  void operator_10599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_10600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->get_allocator)();
}

static  void method_10601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->begin)());
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->begin)();
}

static  void method_10602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->begin)();
}

static  void method_10603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->end)());
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->end)();
}

static  void method_10604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->end)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->end)();
}

static  void method_10609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->empty)();
}

static  void method_10610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->size)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->size)();
}

static  void method_10611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->max_size)();
}

static  void operator_10612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_10613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,bool>)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpReconstructedProton>*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_10616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpReconstructedProton>*)arg[1]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpReconstructedProton>*)arg[1]);
}

static  void method_10617( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[0]);
}

static  void method_10618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_10619( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[1]);
}

static  void method_10620( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->swap)(*(::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_10621( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->clear)();
}

static  void method_10622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->key_comp)();
}

static  void method_10624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10626( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_10627( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10630( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_10632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2657( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::Generate();
}

//------Dictionary for class map<unsigned int,RPRootDumpReconstructedProton,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > -------------------------------
void __std__map_unsignedsint_RPRootDumpReconstructedProton__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpReconstructedProton__datamem_bld(&__std__map_unsignedsint_RPRootDumpReconstructedProton__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpReconstructedProton__funcmem_bld(&__std__map_unsignedsint_RPRootDumpReconstructedProton__db_funcmem);
void __std__map_unsignedsint_RPRootDumpReconstructedProton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>"), typeid(::std::map<unsigned int,RPRootDumpReconstructedProton>), sizeof(::std::map<unsigned int,RPRootDumpReconstructedProton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_199, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::key_type"))
  .AddTypedef(type_528, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::mapped_type"))
  .AddTypedef(type_2482, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::value_type"))
  .AddTypedef(type_2257, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::key_compare"))
  .AddTypedef(type_2715, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::allocator_type"))
  .AddTypedef(type_2482, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::_Alloc_value_type"))
  .AddTypedef(type_2715, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::_Pair_alloc_type"))
  .AddTypedef(type_2300, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::_Rep_type"))
  .AddTypedef(type_7449, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::pointer"))
  .AddTypedef(type_7451, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::const_pointer"))
  .AddTypedef(type_7453, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::reference"))
  .AddTypedef(type_7455, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::const_reference"))
  .AddTypedef(type_2605, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::iterator"))
  .AddTypedef(type_2698, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::const_iterator"))
  .AddTypedef(type_2696, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::size_type"))
  .AddTypedef(type_2631, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::difference_type"))
  .AddTypedef(type_2860, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::reverse_iterator"))
  .AddTypedef(type_2859, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_10595, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_10596, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18316, type_18388), Reflex::Literal("map"), constructor_10597, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18743), Reflex::Literal("map"), constructor_10598, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2657, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RPRootDumpReconstructedProton__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RPRootDumpReconstructedProton__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RPRootDumpReconstructedProton,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > -------------------
void __std__map_unsignedsint_RPRootDumpReconstructedProton__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2300, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RPRootDumpReconstructedProton_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RPRootDumpReconstructedProton,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > -------------------
void __std__map_unsignedsint_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18744, type_18743), Reflex::Literal("operator="), operator_10599, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2715), Reflex::Literal("get_allocator"), method_10600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2605), Reflex::Literal("begin"), method_10601, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2698), Reflex::Literal("begin"), method_10602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2605), Reflex::Literal("end"), method_10603, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2698), Reflex::Literal("end"), method_10604, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("empty"), method_10609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("size"), method_10610, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("max_size"), method_10611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9005, type_18317), Reflex::Literal("operator[]"), operator_10612, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9005, type_18317), Reflex::Literal("at"), method_10613, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9007, type_18317), Reflex::Literal("at"), method_10614, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2491, type_7455), Reflex::Literal("insert"), method_10615, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2605, type_2605, type_7455), Reflex::Literal("insert"), method_10616, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2605), Reflex::Literal("erase"), method_10617, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696, type_18317), Reflex::Literal("erase"), method_10618, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2605, type_2605), Reflex::Literal("erase"), method_10619, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_18744), Reflex::Literal("swap"), method_10620, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_10621, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2257), Reflex::Literal("key_comp"), method_10622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2605, type_18317), Reflex::Literal("find"), method_10624, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2698, type_18317), Reflex::Literal("find"), method_10625, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696, type_18317), Reflex::Literal("count"), method_10626, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2605, type_18317), Reflex::Literal("lower_bound"), method_10627, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2698, type_18317), Reflex::Literal("lower_bound"), method_10628, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2605, type_18317), Reflex::Literal("upper_bound"), method_10629, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2698, type_18317), Reflex::Literal("upper_bound"), method_10630, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2490, type_18317), Reflex::Literal("equal_range"), method_10631, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2489, type_18317), Reflex::Literal("equal_range"), method_10632, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > -------------------------------
static void destructor_10653(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::~map)();
}
static void constructor_10654( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >();
  else ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >();
}

static void constructor_10655( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[1]);
  }
}

static void constructor_10656( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void operator_10657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_10658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->get_allocator)();
}

static  void method_10659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->begin)();
}

static  void method_10660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->begin)();
}

static  void method_10661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->end)();
}

static  void method_10662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->end)();
}

static  void method_10667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->empty)();
}

static  void method_10668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->size)();
}

static  void method_10669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->max_size)();
}

static  void operator_10670( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_10671( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10673( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,bool>)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_10674( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[1]);
}

static  void method_10675( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0]);
}

static  void method_10676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_10677( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[1]);
}

static  void method_10678( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->swap)(*(::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_10679( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->clear)();
}

static  void method_10680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->key_comp)();
}

static  void method_10682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_10685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10687( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_10690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2658( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > -------------------------------
void __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__datamem_bld(&__std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__funcmem_bld(&__std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_funcmem);
void __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >"), typeid(::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >), sizeof(::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_199, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::key_type"))
  .AddTypedef(type_2535, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::mapped_type"))
  .AddTypedef(type_2483, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::value_type"))
  .AddTypedef(type_2257, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::key_compare"))
  .AddTypedef(type_2716, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::allocator_type"))
  .AddTypedef(type_2483, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::_Alloc_value_type"))
  .AddTypedef(type_2716, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::_Pair_alloc_type"))
  .AddTypedef(type_2301, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::_Rep_type"))
  .AddTypedef(type_7558, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::pointer"))
  .AddTypedef(type_7560, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::const_pointer"))
  .AddTypedef(type_7562, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::reference"))
  .AddTypedef(type_7564, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::const_reference"))
  .AddTypedef(type_2606, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::iterator"))
  .AddTypedef(type_2699, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::const_iterator"))
  .AddTypedef(type_2696, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::size_type"))
  .AddTypedef(type_2631, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::difference_type"))
  .AddTypedef(type_2862, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::reverse_iterator"))
  .AddTypedef(type_2861, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_10653, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_10654, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18316, type_18396), Reflex::Literal("map"), constructor_10655, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18745), Reflex::Literal("map"), constructor_10656, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2658, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18746, type_18745), Reflex::Literal("operator="), operator_10657, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2716), Reflex::Literal("get_allocator"), method_10658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606), Reflex::Literal("begin"), method_10659, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699), Reflex::Literal("begin"), method_10660, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606), Reflex::Literal("end"), method_10661, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699), Reflex::Literal("end"), method_10662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("empty"), method_10667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("size"), method_10668, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("max_size"), method_10669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18583, type_18317), Reflex::Literal("operator[]"), operator_10670, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18583, type_18317), Reflex::Literal("at"), method_10671, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18582, type_18317), Reflex::Literal("at"), method_10672, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2495, type_7564), Reflex::Literal("insert"), method_10673, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606, type_2606, type_7564), Reflex::Literal("insert"), method_10674, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2606), Reflex::Literal("erase"), method_10675, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696, type_18317), Reflex::Literal("erase"), method_10676, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2606, type_2606), Reflex::Literal("erase"), method_10677, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_18746), Reflex::Literal("swap"), method_10678, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_10679, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2257), Reflex::Literal("key_comp"), method_10680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606, type_18317), Reflex::Literal("find"), method_10682, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_18317), Reflex::Literal("find"), method_10683, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696, type_18317), Reflex::Literal("count"), method_10684, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606, type_18317), Reflex::Literal("lower_bound"), method_10685, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_18317), Reflex::Literal("lower_bound"), method_10686, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2606, type_18317), Reflex::Literal("upper_bound"), method_10687, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_18317), Reflex::Literal("upper_bound"), method_10688, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2494, type_18317), Reflex::Literal("equal_range"), method_10689, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2493, type_18317), Reflex::Literal("equal_range"), method_10690, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,RPRootDumpPatternInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > -------------------------------
static void destructor_10711(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->::std::map<unsigned int,RPRootDumpPatternInfo>::~map)();
}
static void constructor_10712( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>();
  else ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>();
}

static void constructor_10713( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[1]);
  }
}

static void constructor_10714( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
}

static  void operator_10715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_10716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->get_allocator)();
}

static  void method_10717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->begin)());
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->begin)();
}

static  void method_10718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->begin)();
}

static  void method_10719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->end)());
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->end)();
}

static  void method_10720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->end)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->end)();
}

static  void method_10725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->empty)();
}

static  void method_10726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->size)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->size)();
}

static  void method_10727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->max_size)();
}

static  void operator_10728( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_10729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,bool>)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpPatternInfo>*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_10732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpPatternInfo>*)arg[1]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpPatternInfo>*)arg[1]);
}

static  void method_10733( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[0]);
}

static  void method_10734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_10735( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[1]);
}

static  void method_10736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->swap)(*(::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_10737( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->clear)();
}

static  void method_10738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->key_comp)();
}

static  void method_10740( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10742( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_10743( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10744( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_10748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2659( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpPatternInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpPatternInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpPatternInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpPatternInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpPatternInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpPatternInfo> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpPatternInfo> >::Generate();
}

//------Dictionary for class map<unsigned int,RPRootDumpPatternInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > -------------------------------
void __std__map_unsignedsint_RPRootDumpPatternInfo__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RPRootDumpPatternInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpPatternInfo__datamem_bld(&__std__map_unsignedsint_RPRootDumpPatternInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpPatternInfo__funcmem_bld(&__std__map_unsignedsint_RPRootDumpPatternInfo__db_funcmem);
void __std__map_unsignedsint_RPRootDumpPatternInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>"), typeid(::std::map<unsigned int,RPRootDumpPatternInfo>), sizeof(::std::map<unsigned int,RPRootDumpPatternInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_199, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::key_type"))
  .AddTypedef(type_574, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::mapped_type"))
  .AddTypedef(type_2484, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::value_type"))
  .AddTypedef(type_2257, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::key_compare"))
  .AddTypedef(type_2718, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::allocator_type"))
  .AddTypedef(type_2484, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::_Alloc_value_type"))
  .AddTypedef(type_2718, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::_Pair_alloc_type"))
  .AddTypedef(type_2302, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::_Rep_type"))
  .AddTypedef(type_7667, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::pointer"))
  .AddTypedef(type_7669, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::const_pointer"))
  .AddTypedef(type_7671, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::reference"))
  .AddTypedef(type_7673, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::const_reference"))
  .AddTypedef(type_2607, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::const_iterator"))
  .AddTypedef(type_2696, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::size_type"))
  .AddTypedef(type_2631, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::difference_type"))
  .AddTypedef(type_2864, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::reverse_iterator"))
  .AddTypedef(type_2863, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_10711, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_10712, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18316, type_18403), Reflex::Literal("map"), constructor_10713, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18747), Reflex::Literal("map"), constructor_10714, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2659, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RPRootDumpPatternInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RPRootDumpPatternInfo__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RPRootDumpPatternInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpPatternInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2302, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RPRootDumpPatternInfo_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RPRootDumpPatternInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpPatternInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18748, type_18747), Reflex::Literal("operator="), operator_10715, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2718), Reflex::Literal("get_allocator"), method_10716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607), Reflex::Literal("begin"), method_10717, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("begin"), method_10718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607), Reflex::Literal("end"), method_10719, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("end"), method_10720, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("empty"), method_10725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("size"), method_10726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("max_size"), method_10727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9070, type_18317), Reflex::Literal("operator[]"), operator_10728, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9070, type_18317), Reflex::Literal("at"), method_10729, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9072, type_18317), Reflex::Literal("at"), method_10730, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2498, type_7673), Reflex::Literal("insert"), method_10731, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607, type_2607, type_7673), Reflex::Literal("insert"), method_10732, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2607), Reflex::Literal("erase"), method_10733, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696, type_18317), Reflex::Literal("erase"), method_10734, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2607, type_2607), Reflex::Literal("erase"), method_10735, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_18748), Reflex::Literal("swap"), method_10736, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_10737, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2257), Reflex::Literal("key_comp"), method_10738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607, type_18317), Reflex::Literal("find"), method_10740, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18317), Reflex::Literal("find"), method_10741, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696, type_18317), Reflex::Literal("count"), method_10742, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607, type_18317), Reflex::Literal("lower_bound"), method_10743, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18317), Reflex::Literal("lower_bound"), method_10744, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2607, type_18317), Reflex::Literal("upper_bound"), method_10745, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18317), Reflex::Literal("upper_bound"), method_10746, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2497, type_18317), Reflex::Literal("equal_range"), method_10747, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2496, type_18317), Reflex::Literal("equal_range"), method_10748, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,RPRootDumpDigiInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > -------------------------------
static void destructor_10769(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->::std::map<unsigned int,RPRootDumpDigiInfo>::~map)();
}
static void constructor_10770( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>();
  else ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>();
}

static void constructor_10771( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[1]);
  }
}

static void constructor_10772( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
}

static  void operator_10773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_10774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->get_allocator)();
}

static  void method_10775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->begin)());
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->begin)();
}

static  void method_10776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->begin)();
}

static  void method_10777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->end)());
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->end)();
}

static  void method_10778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->end)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->end)();
}

static  void method_10783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->empty)();
}

static  void method_10784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->size)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->size)();
}

static  void method_10785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->max_size)();
}

static  void operator_10786( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_10787( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,bool>)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpDigiInfo>*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_10790( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpDigiInfo>*)arg[1]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpDigiInfo>*)arg[1]);
}

static  void method_10791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[0]);
}

static  void method_10792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_10793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[1]);
}

static  void method_10794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->swap)(*(::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_10795( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->clear)();
}

static  void method_10796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->key_comp)();
}

static  void method_10798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_10801( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_10806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2660( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpDigiInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpDigiInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpDigiInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpDigiInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpDigiInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpDigiInfo> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpDigiInfo> >::Generate();
}

//------Dictionary for class map<unsigned int,RPRootDumpDigiInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > -------------------------------
void __std__map_unsignedsint_RPRootDumpDigiInfo__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RPRootDumpDigiInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpDigiInfo__datamem_bld(&__std__map_unsignedsint_RPRootDumpDigiInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpDigiInfo__funcmem_bld(&__std__map_unsignedsint_RPRootDumpDigiInfo__db_funcmem);
void __std__map_unsignedsint_RPRootDumpDigiInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>"), typeid(::std::map<unsigned int,RPRootDumpDigiInfo>), sizeof(::std::map<unsigned int,RPRootDumpDigiInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_199, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::key_type"))
  .AddTypedef(type_945, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::mapped_type"))
  .AddTypedef(type_2485, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::value_type"))
  .AddTypedef(type_2257, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::key_compare"))
  .AddTypedef(type_2719, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::allocator_type"))
  .AddTypedef(type_2485, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::_Alloc_value_type"))
  .AddTypedef(type_2719, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::_Pair_alloc_type"))
  .AddTypedef(type_2303, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::_Rep_type"))
  .AddTypedef(type_7776, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::pointer"))
  .AddTypedef(type_7778, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::const_pointer"))
  .AddTypedef(type_7780, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::reference"))
  .AddTypedef(type_7782, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::const_reference"))
  .AddTypedef(type_2608, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::iterator"))
  .AddTypedef(type_2701, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::const_iterator"))
  .AddTypedef(type_2696, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::size_type"))
  .AddTypedef(type_2631, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::difference_type"))
  .AddTypedef(type_2866, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::reverse_iterator"))
  .AddTypedef(type_2865, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_10769, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_10770, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18316, type_18410), Reflex::Literal("map"), constructor_10771, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18749), Reflex::Literal("map"), constructor_10772, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2660, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RPRootDumpDigiInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RPRootDumpDigiInfo__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RPRootDumpDigiInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpDigiInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2303, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RPRootDumpDigiInfo_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RPRootDumpDigiInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpDigiInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18750, type_18749), Reflex::Literal("operator="), operator_10773, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2719), Reflex::Literal("get_allocator"), method_10774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608), Reflex::Literal("begin"), method_10775, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2701), Reflex::Literal("begin"), method_10776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608), Reflex::Literal("end"), method_10777, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2701), Reflex::Literal("end"), method_10778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("empty"), method_10783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("size"), method_10784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("max_size"), method_10785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9135, type_18317), Reflex::Literal("operator[]"), operator_10786, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9135, type_18317), Reflex::Literal("at"), method_10787, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9137, type_18317), Reflex::Literal("at"), method_10788, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2501, type_7782), Reflex::Literal("insert"), method_10789, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608, type_2608, type_7782), Reflex::Literal("insert"), method_10790, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2608), Reflex::Literal("erase"), method_10791, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696, type_18317), Reflex::Literal("erase"), method_10792, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2608, type_2608), Reflex::Literal("erase"), method_10793, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_18750), Reflex::Literal("swap"), method_10794, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_10795, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2257), Reflex::Literal("key_comp"), method_10796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608, type_18317), Reflex::Literal("find"), method_10798, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2701, type_18317), Reflex::Literal("find"), method_10799, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696, type_18317), Reflex::Literal("count"), method_10800, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608, type_18317), Reflex::Literal("lower_bound"), method_10801, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2701, type_18317), Reflex::Literal("lower_bound"), method_10802, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2608, type_18317), Reflex::Literal("upper_bound"), method_10803, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2701, type_18317), Reflex::Literal("upper_bound"), method_10804, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2500, type_18317), Reflex::Literal("equal_range"), method_10805, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2499, type_18317), Reflex::Literal("equal_range"), method_10806, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,RPRootDumpTrackInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > -------------------------------
static void destructor_10827(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->::std::map<unsigned int,RPRootDumpTrackInfo>::~map)();
}
static void constructor_10828( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>();
  else ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>();
}

static void constructor_10829( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[1]);
  }
}

static void constructor_10830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
}

static  void operator_10831( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_10832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->get_allocator)();
}

static  void method_10833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->begin)());
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->begin)();
}

static  void method_10834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->begin)();
}

static  void method_10835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->end)());
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->end)();
}

static  void method_10836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->end)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->end)();
}

static  void method_10841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->empty)();
}

static  void method_10842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->size)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->size)();
}

static  void method_10843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->max_size)();
}

static  void operator_10844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_10845( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10847( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,bool>)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpTrackInfo>*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_10848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpTrackInfo>*)arg[1]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpTrackInfo>*)arg[1]);
}

static  void method_10849( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_10850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_10851( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[1]);
}

static  void method_10852( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->swap)(*(::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_10853( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->clear)();
}

static  void method_10854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->key_comp)();
}

static  void method_10856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_10859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_10864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2661( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpTrackInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpTrackInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpTrackInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpTrackInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpTrackInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpTrackInfo> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpTrackInfo> >::Generate();
}

//------Dictionary for class map<unsigned int,RPRootDumpTrackInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > -------------------------------
void __std__map_unsignedsint_RPRootDumpTrackInfo__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RPRootDumpTrackInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpTrackInfo__datamem_bld(&__std__map_unsignedsint_RPRootDumpTrackInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpTrackInfo__funcmem_bld(&__std__map_unsignedsint_RPRootDumpTrackInfo__db_funcmem);
void __std__map_unsignedsint_RPRootDumpTrackInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>"), typeid(::std::map<unsigned int,RPRootDumpTrackInfo>), sizeof(::std::map<unsigned int,RPRootDumpTrackInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_199, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::key_type"))
  .AddTypedef(type_1901, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::mapped_type"))
  .AddTypedef(type_2486, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::value_type"))
  .AddTypedef(type_2257, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::key_compare"))
  .AddTypedef(type_2720, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::allocator_type"))
  .AddTypedef(type_2486, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::_Alloc_value_type"))
  .AddTypedef(type_2720, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::_Pair_alloc_type"))
  .AddTypedef(type_2304, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::_Rep_type"))
  .AddTypedef(type_7885, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::pointer"))
  .AddTypedef(type_7887, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::const_pointer"))
  .AddTypedef(type_7889, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::reference"))
  .AddTypedef(type_7891, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::const_reference"))
  .AddTypedef(type_2609, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::iterator"))
  .AddTypedef(type_2702, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::const_iterator"))
  .AddTypedef(type_2696, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::size_type"))
  .AddTypedef(type_2631, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::difference_type"))
  .AddTypedef(type_2868, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::reverse_iterator"))
  .AddTypedef(type_2867, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_10827, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_10828, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18316, type_18417), Reflex::Literal("map"), constructor_10829, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18751), Reflex::Literal("map"), constructor_10830, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2661, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RPRootDumpTrackInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RPRootDumpTrackInfo__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RPRootDumpTrackInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpTrackInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2304, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RPRootDumpTrackInfo_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RPRootDumpTrackInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpTrackInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18752, type_18751), Reflex::Literal("operator="), operator_10831, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2720), Reflex::Literal("get_allocator"), method_10832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609), Reflex::Literal("begin"), method_10833, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702), Reflex::Literal("begin"), method_10834, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609), Reflex::Literal("end"), method_10835, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702), Reflex::Literal("end"), method_10836, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("empty"), method_10841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("size"), method_10842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696), Reflex::Literal("max_size"), method_10843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8940, type_18317), Reflex::Literal("operator[]"), operator_10844, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8940, type_18317), Reflex::Literal("at"), method_10845, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8942, type_18317), Reflex::Literal("at"), method_10846, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504, type_7891), Reflex::Literal("insert"), method_10847, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609, type_2609, type_7891), Reflex::Literal("insert"), method_10848, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2609), Reflex::Literal("erase"), method_10849, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696, type_18317), Reflex::Literal("erase"), method_10850, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2609, type_2609), Reflex::Literal("erase"), method_10851, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_18752), Reflex::Literal("swap"), method_10852, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_10853, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2257), Reflex::Literal("key_comp"), method_10854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609, type_18317), Reflex::Literal("find"), method_10856, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702, type_18317), Reflex::Literal("find"), method_10857, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2696, type_18317), Reflex::Literal("count"), method_10858, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609, type_18317), Reflex::Literal("lower_bound"), method_10859, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702, type_18317), Reflex::Literal("lower_bound"), method_10860, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609, type_18317), Reflex::Literal("upper_bound"), method_10861, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702, type_18317), Reflex::Literal("upper_bound"), method_10862, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2503, type_18317), Reflex::Literal("equal_range"), method_10863, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2502, type_18317), Reflex::Literal("equal_range"), method_10864, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, RPRootDumpReconstructedProton, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > > -------------------------------
static void constructor_13698( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >();
}

static void constructor_13699( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpReconstructedProton> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpReconstructedProton> >*)arg[0]);
}

static void destructor_13700(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >::~Wrapper)();
}
static  void method_13701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->product)();
}

static  void operator_13702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->operator->)();
}

static  void method_13703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->productTypeInfo)();
}

static  void method_13704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->typeInfo)();
}

static void constructor_13705( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >((::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >((::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_13706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->getInterface)();
}

static  void method_13707( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13708( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13709( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo)();
}

static  void method_13711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->isPresent)();
}

static  void method_13712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3389( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, RPRootDumpReconstructedProton, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >"), typeid(::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >), sizeof(::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2657, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >::value_type"))
  .AddTypedef(type_2657, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13698, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2348), Reflex::Literal("Wrapper"), constructor_13699, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13700, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20492), Reflex::Literal("Wrapper"), constructor_13705, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3389, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, RPRootDumpReconstructedProton, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2657, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, RPRootDumpReconstructedProton, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20491), Reflex::Literal("product"), method_13701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20491), Reflex::Literal("operator->"), operator_13702, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13703, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13704, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20493), Reflex::Literal("getInterface"), method_13706, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13707, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13708, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13709, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > > -------------------------------
static void constructor_13719( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >();
}

static void constructor_13720( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >(*(::std::auto_ptr<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >(*(::std::auto_ptr<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0]);
}

static void destructor_13721(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::~Wrapper)();
}
static  void method_13722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->product)();
}

static  void operator_13723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->operator->)();
}

static  void method_13724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->productTypeInfo)();
}

static  void method_13725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->typeInfo)();
}

static void constructor_13726( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_13727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->getInterface)();
}

static  void method_13728( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->dynamicTypeInfo)();
}

static  void method_13732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->isPresent)();
}

static  void method_13733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3390( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >"), typeid(::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >), sizeof(::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2658, Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::value_type"))
  .AddTypedef(type_2658, Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13719, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2349), Reflex::Literal("Wrapper"), constructor_13720, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13721, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20497), Reflex::Literal("Wrapper"), constructor_13726, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3390, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2658, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20496), Reflex::Literal("product"), method_13722, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20496), Reflex::Literal("operator->"), operator_13723, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13724, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13725, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20498), Reflex::Literal("getInterface"), method_13727, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13728, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13729, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13730, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, RPRootDumpPatternInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > > -------------------------------
static void constructor_13740( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >();
}

static void constructor_13741( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpPatternInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpPatternInfo> >*)arg[0]);
}

static void destructor_13742(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >::~Wrapper)();
}
static  void method_13743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->product)();
}

static  void operator_13744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->operator->)();
}

static  void method_13745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->productTypeInfo)();
}

static  void method_13746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->typeInfo)();
}

static void constructor_13747( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >((::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >((::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_13748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->getInterface)();
}

static  void method_13749( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13750( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13751( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->isPresent)();
}

static  void method_13754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3391( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, RPRootDumpPatternInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >"), typeid(::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >), sizeof(::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2659, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >::value_type"))
  .AddTypedef(type_2659, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13740, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2350), Reflex::Literal("Wrapper"), constructor_13741, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13742, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20502), Reflex::Literal("Wrapper"), constructor_13747, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3391, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, RPRootDumpPatternInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2659, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, RPRootDumpPatternInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20501), Reflex::Literal("product"), method_13743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20501), Reflex::Literal("operator->"), operator_13744, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13745, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13746, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20503), Reflex::Literal("getInterface"), method_13748, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13749, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13750, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13751, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, RPRootDumpDigiInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > > -------------------------------
static void constructor_13761( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >();
}

static void constructor_13762( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpDigiInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpDigiInfo> >*)arg[0]);
}

static void destructor_13763(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >::~Wrapper)();
}
static  void method_13764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->product)();
}

static  void operator_13765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->operator->)();
}

static  void method_13766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->productTypeInfo)();
}

static  void method_13767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->typeInfo)();
}

static void constructor_13768( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >((::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >((::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_13769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->getInterface)();
}

static  void method_13770( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13771( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13772( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->isPresent)();
}

static  void method_13775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3392( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, RPRootDumpDigiInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >"), typeid(::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >), sizeof(::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2660, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >::value_type"))
  .AddTypedef(type_2660, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13761, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2351), Reflex::Literal("Wrapper"), constructor_13762, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13763, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20507), Reflex::Literal("Wrapper"), constructor_13768, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3392, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, RPRootDumpDigiInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2660, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, RPRootDumpDigiInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20506), Reflex::Literal("product"), method_13764, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20506), Reflex::Literal("operator->"), operator_13765, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13766, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13767, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20508), Reflex::Literal("getInterface"), method_13769, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13770, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13771, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13772, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, RPRootDumpTrackInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > > -------------------------------
static void constructor_13782( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >();
}

static void constructor_13783( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpTrackInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpTrackInfo> >*)arg[0]);
}

static void destructor_13784(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >::~Wrapper)();
}
static  void method_13785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->product)();
}

static  void operator_13786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->operator->)();
}

static  void method_13787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->productTypeInfo)();
}

static  void method_13788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->typeInfo)();
}

static void constructor_13789( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >((::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >((::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_13790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->getInterface)();
}

static  void method_13791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13792( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->isPresent)();
}

static  void method_13796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3393( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, RPRootDumpTrackInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >"), typeid(::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >), sizeof(::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2661, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >::value_type"))
  .AddTypedef(type_2661, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13782, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2352), Reflex::Literal("Wrapper"), constructor_13783, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13784, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20512), Reflex::Literal("Wrapper"), constructor_13789, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3393, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, RPRootDumpTrackInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2661, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, RPRootDumpTrackInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20511), Reflex::Literal("product"), method_13785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20511), Reflex::Literal("operator->"), operator_13786, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13787, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13788, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20513), Reflex::Literal("getInterface"), method_13790, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13791, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13792, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13793, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13794, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<RPRootDumpReconstructedProton, std::allocator<RPRootDumpReconstructedProton> > > -------------------------------
static void constructor_13803( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >();
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >();
}

static void constructor_13804( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >(*(::std::auto_ptr<std::vector<RPRootDumpReconstructedProton> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >(*(::std::auto_ptr<std::vector<RPRootDumpReconstructedProton> >*)arg[0]);
}

static void destructor_13805(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >::~Wrapper)();
}
static  void method_13806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->product)();
}

static  void operator_13807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->operator->)();
}

static  void method_13808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->productTypeInfo)();
}

static  void method_13809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->typeInfo)();
}

static void constructor_13810( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >((::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >((::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_13811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->getInterface)();
}

static  void method_13812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13813( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13814( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo)();
}

static  void method_13816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->isPresent)();
}

static  void method_13817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3394( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<RPRootDumpReconstructedProton, std::allocator<RPRootDumpReconstructedProton> > > -------------------------------
void __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__datamem_bld(&__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__funcmem_bld(&__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_funcmem);
void __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >"), typeid(::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >), sizeof(::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2536, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >::value_type"))
  .AddTypedef(type_2536, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13803, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2353), Reflex::Literal("Wrapper"), constructor_13804, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13805, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20517), Reflex::Literal("Wrapper"), constructor_13810, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3394, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<RPRootDumpReconstructedProton, std::allocator<RPRootDumpReconstructedProton> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2536, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<RPRootDumpReconstructedProton, std::allocator<RPRootDumpReconstructedProton> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516), Reflex::Literal("product"), method_13806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20516), Reflex::Literal("operator->"), operator_13807, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13808, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13809, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20518), Reflex::Literal("getInterface"), method_13811, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13812, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13813, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13814, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13815, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<RPRootDumpPatternInfo, std::allocator<RPRootDumpPatternInfo> > > -------------------------------
static void constructor_13824( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >();
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >();
}

static void constructor_13825( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpPatternInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpPatternInfo> >*)arg[0]);
}

static void destructor_13826(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >::~Wrapper)();
}
static  void method_13827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->product)();
}

static  void operator_13828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->operator->)();
}

static  void method_13829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->productTypeInfo)();
}

static  void method_13830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->typeInfo)();
}

static void constructor_13831( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >((::std::vector<RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >((::std::vector<RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_13832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->getInterface)();
}

static  void method_13833( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13834( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13835( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->isPresent)();
}

static  void method_13838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3395( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<RPRootDumpPatternInfo, std::allocator<RPRootDumpPatternInfo> > > -------------------------------
void __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__datamem_bld(&__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__funcmem_bld(&__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_funcmem);
void __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpPatternInfo> >"), typeid(::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >), sizeof(::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2537, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpPatternInfo> >::value_type"))
  .AddTypedef(type_2537, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpPatternInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13824, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2354), Reflex::Literal("Wrapper"), constructor_13825, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13826, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20522), Reflex::Literal("Wrapper"), constructor_13831, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3395, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<RPRootDumpPatternInfo, std::allocator<RPRootDumpPatternInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2537, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<RPRootDumpPatternInfo, std::allocator<RPRootDumpPatternInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20521), Reflex::Literal("product"), method_13827, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20521), Reflex::Literal("operator->"), operator_13828, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13829, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13830, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20523), Reflex::Literal("getInterface"), method_13832, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13833, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13834, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13835, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13836, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<RPRootDumpDigiInfo, std::allocator<RPRootDumpDigiInfo> > > -------------------------------
static void constructor_13845( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >();
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >();
}

static void constructor_13846( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpDigiInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpDigiInfo> >*)arg[0]);
}

static void destructor_13847(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >::~Wrapper)();
}
static  void method_13848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->product)();
}

static  void operator_13849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->operator->)();
}

static  void method_13850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->productTypeInfo)();
}

static  void method_13851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->typeInfo)();
}

static void constructor_13852( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >((::std::vector<RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >((::std::vector<RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_13853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->getInterface)();
}

static  void method_13854( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13855( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13856( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->isPresent)();
}

static  void method_13859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3396( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<RPRootDumpDigiInfo, std::allocator<RPRootDumpDigiInfo> > > -------------------------------
void __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__datamem_bld(&__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__funcmem_bld(&__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_funcmem);
void __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpDigiInfo> >"), typeid(::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >), sizeof(::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2538, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpDigiInfo> >::value_type"))
  .AddTypedef(type_2538, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpDigiInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13845, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2355), Reflex::Literal("Wrapper"), constructor_13846, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13847, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20527), Reflex::Literal("Wrapper"), constructor_13852, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3396, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<RPRootDumpDigiInfo, std::allocator<RPRootDumpDigiInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2538, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<RPRootDumpDigiInfo, std::allocator<RPRootDumpDigiInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20526), Reflex::Literal("product"), method_13848, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20526), Reflex::Literal("operator->"), operator_13849, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13850, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13851, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20528), Reflex::Literal("getInterface"), method_13853, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13854, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13855, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13856, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > -------------------------------
static void constructor_13866( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >();
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >();
}

static void constructor_13867( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpTrackInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static void destructor_13868(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >::~Wrapper)();
}
static  void method_13869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->product)();
}

static  void operator_13870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->operator->)();
}

static  void method_13871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->productTypeInfo)();
}

static  void method_13872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->typeInfo)();
}

static void constructor_13873( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >((::std::vector<RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >((::std::vector<RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_13874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->getInterface)();
}

static  void method_13875( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13876( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13877( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->isPresent)();
}

static  void method_13880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3397( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > -------------------------------
void __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__datamem_bld(&__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__funcmem_bld(&__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_funcmem);
void __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpTrackInfo> >"), typeid(::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >), sizeof(::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2535, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpTrackInfo> >::value_type"))
  .AddTypedef(type_2535, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpTrackInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13866, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2356), Reflex::Literal("Wrapper"), constructor_13867, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13868, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20532), Reflex::Literal("Wrapper"), constructor_13873, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3397, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2535, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20531), Reflex::Literal("product"), method_13869, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20531), Reflex::Literal("operator->"), operator_13870, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13871, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13872, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20533), Reflex::Literal("getInterface"), method_13874, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13875, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13876, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13877, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13878, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13880, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpPatternInfo> -------------------------------
static void constructor_13887( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>();
}

static void constructor_13888( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>(*(::std::auto_ptr<RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>(*(::std::auto_ptr<RPRootDumpPatternInfo>*)arg[0]);
}

static void destructor_13889(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->::edm::Wrapper<RPRootDumpPatternInfo>::~Wrapper)();
}
static  void method_13890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->product)();
}

static  void operator_13891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->operator->)();
}

static  void method_13892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->productTypeInfo)();
}

static  void method_13893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->typeInfo)();
}

static void constructor_13894( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>((::RPRootDumpPatternInfo*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>((::RPRootDumpPatternInfo*)arg[0]);
}

static  void method_13895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->getInterface)();
}

static  void method_13896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13897( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13898( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->dynamicTypeInfo)();
}

static  void method_13900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->isPresent)();
}

static  void method_13901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3398( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPatternInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPatternInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPatternInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPatternInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPatternInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpPatternInfo> -------------------------------
void __edm__Wrapper_RPRootDumpPatternInfo__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpPatternInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpPatternInfo__datamem_bld(&__edm__Wrapper_RPRootDumpPatternInfo__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpPatternInfo__funcmem_bld(&__edm__Wrapper_RPRootDumpPatternInfo__db_funcmem);
void __edm__Wrapper_RPRootDumpPatternInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpPatternInfo>"), typeid(::edm::Wrapper<RPRootDumpPatternInfo>), sizeof(::edm::Wrapper<RPRootDumpPatternInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_574, Reflex::Literal("edm::Wrapper<RPRootDumpPatternInfo>::value_type"))
  .AddTypedef(type_574, Reflex::Literal("edm::Wrapper<RPRootDumpPatternInfo>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13887, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2357), Reflex::Literal("Wrapper"), constructor_13888, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13889, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6160), Reflex::Literal("Wrapper"), constructor_13894, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3398, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpPatternInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpPatternInfo__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpPatternInfo> -------------------
void __edm__Wrapper_RPRootDumpPatternInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpPatternInfo_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_574, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpPatternInfo_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpPatternInfo> -------------------
void __edm__Wrapper_RPRootDumpPatternInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9068), Reflex::Literal("product"), method_13890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9068), Reflex::Literal("operator->"), operator_13891, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13892, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13893, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20536), Reflex::Literal("getInterface"), method_13895, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13896, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13897, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13898, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpPattern> -------------------------------
static void constructor_13908( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPattern>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpPattern>();
}

static void constructor_13909( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPattern>(*(::std::auto_ptr<RPRootDumpPattern>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpPattern>(*(::std::auto_ptr<RPRootDumpPattern>*)arg[0]);
}

static void destructor_13910(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpPattern>*)o)->::edm::Wrapper<RPRootDumpPattern>::~Wrapper)();
}
static  void method_13911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpPattern>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->product)();
}

static  void operator_13912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpPattern>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->operator->)();
}

static  void method_13913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpPattern>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpPattern>*)o)->productTypeInfo)();
}

static  void method_13914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpPattern>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpPattern>*)o)->typeInfo)();
}

static void constructor_13915( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPattern>((::RPRootDumpPattern*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpPattern>((::RPRootDumpPattern*)arg[0]);
}

static  void method_13916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpPattern>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpPattern>*)o)->getInterface)();
}

static  void method_13917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13918( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13919( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpPattern>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->dynamicTypeInfo)();
}

static  void method_13921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpPattern>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->isPresent)();
}

static  void method_13922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpPattern>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3399( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPattern> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPattern> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPattern> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPattern> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPattern> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpPattern> -------------------------------
void __edm__Wrapper_RPRootDumpPattern__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpPattern__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpPattern__datamem_bld(&__edm__Wrapper_RPRootDumpPattern__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpPattern__funcmem_bld(&__edm__Wrapper_RPRootDumpPattern__db_funcmem);
void __edm__Wrapper_RPRootDumpPattern__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpPattern>"), typeid(::edm::Wrapper<RPRootDumpPattern>), sizeof(::edm::Wrapper<RPRootDumpPattern>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_812, Reflex::Literal("edm::Wrapper<RPRootDumpPattern>::value_type"))
  .AddTypedef(type_812, Reflex::Literal("edm::Wrapper<RPRootDumpPattern>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13908, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2358), Reflex::Literal("Wrapper"), constructor_13909, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13910, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6482), Reflex::Literal("Wrapper"), constructor_13915, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3399, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpPattern__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpPattern__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpPattern> -------------------
void __edm__Wrapper_RPRootDumpPattern__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpPattern_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_812, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpPattern_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpPattern> -------------------
void __edm__Wrapper_RPRootDumpPattern__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9958), Reflex::Literal("product"), method_13911, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9958), Reflex::Literal("operator->"), operator_13912, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13913, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13914, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20539), Reflex::Literal("getInterface"), method_13916, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13917, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13918, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13919, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13922, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpReconstructedProtonPair> -------------------------------
static void constructor_13929( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>();
}

static void constructor_13930( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>(*(::std::auto_ptr<RPRootDumpReconstructedProtonPair>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>(*(::std::auto_ptr<RPRootDumpReconstructedProtonPair>*)arg[0]);
}

static void destructor_13931(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->::edm::Wrapper<RPRootDumpReconstructedProtonPair>::~Wrapper)();
}
static  void method_13932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->product)();
}

static  void operator_13933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->operator->)();
}

static  void method_13934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->productTypeInfo)();
}

static  void method_13935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->typeInfo)();
}

static void constructor_13936( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>((::RPRootDumpReconstructedProtonPair*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>((::RPRootDumpReconstructedProtonPair*)arg[0]);
}

static  void method_13937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->getInterface)();
}

static  void method_13938( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13939( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13940( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->dynamicTypeInfo)();
}

static  void method_13942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->isPresent)();
}

static  void method_13943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3400( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProtonPair> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProtonPair> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProtonPair> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProtonPair> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProtonPair> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpReconstructedProtonPair> -------------------------------
void __edm__Wrapper_RPRootDumpReconstructedProtonPair__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpReconstructedProtonPair__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpReconstructedProtonPair__datamem_bld(&__edm__Wrapper_RPRootDumpReconstructedProtonPair__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpReconstructedProtonPair__funcmem_bld(&__edm__Wrapper_RPRootDumpReconstructedProtonPair__db_funcmem);
void __edm__Wrapper_RPRootDumpReconstructedProtonPair__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProtonPair>"), typeid(::edm::Wrapper<RPRootDumpReconstructedProtonPair>), sizeof(::edm::Wrapper<RPRootDumpReconstructedProtonPair>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1681, Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProtonPair>::value_type"))
  .AddTypedef(type_1681, Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProtonPair>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13929, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2359), Reflex::Literal("Wrapper"), constructor_13930, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13931, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20543), Reflex::Literal("Wrapper"), constructor_13936, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3400, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpReconstructedProtonPair__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpReconstructedProtonPair__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpReconstructedProtonPair> -------------------
void __edm__Wrapper_RPRootDumpReconstructedProtonPair__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpReconstructedProtonPair_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1681, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpReconstructedProtonPair_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpReconstructedProtonPair> -------------------
void __edm__Wrapper_RPRootDumpReconstructedProtonPair__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20542), Reflex::Literal("product"), method_13932, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20542), Reflex::Literal("operator->"), operator_13933, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13934, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13935, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20544), Reflex::Literal("getInterface"), method_13937, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13938, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13939, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13940, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13941, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13942, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13943, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpReconstructedProton> -------------------------------
static void constructor_13950( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>();
}

static void constructor_13951( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>(*(::std::auto_ptr<RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>(*(::std::auto_ptr<RPRootDumpReconstructedProton>*)arg[0]);
}

static void destructor_13952(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->::edm::Wrapper<RPRootDumpReconstructedProton>::~Wrapper)();
}
static  void method_13953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->product)();
}

static  void operator_13954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->operator->)();
}

static  void method_13955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->productTypeInfo)();
}

static  void method_13956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->typeInfo)();
}

static void constructor_13957( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>((::RPRootDumpReconstructedProton*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>((::RPRootDumpReconstructedProton*)arg[0]);
}

static  void method_13958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->getInterface)();
}

static  void method_13959( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13960( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13961( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->dynamicTypeInfo)();
}

static  void method_13963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->isPresent)();
}

static  void method_13964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3401( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpReconstructedProton> -------------------------------
void __edm__Wrapper_RPRootDumpReconstructedProton__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpReconstructedProton__datamem_bld(&__edm__Wrapper_RPRootDumpReconstructedProton__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpReconstructedProton__funcmem_bld(&__edm__Wrapper_RPRootDumpReconstructedProton__db_funcmem);
void __edm__Wrapper_RPRootDumpReconstructedProton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProton>"), typeid(::edm::Wrapper<RPRootDumpReconstructedProton>), sizeof(::edm::Wrapper<RPRootDumpReconstructedProton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_528, Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProton>::value_type"))
  .AddTypedef(type_528, Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProton>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13950, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2360), Reflex::Literal("Wrapper"), constructor_13951, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13952, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6141), Reflex::Literal("Wrapper"), constructor_13957, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3401, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpReconstructedProton__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpReconstructedProton__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpReconstructedProton> -------------------
void __edm__Wrapper_RPRootDumpReconstructedProton__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpReconstructedProton_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_528, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpReconstructedProton_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpReconstructedProton> -------------------
void __edm__Wrapper_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9003), Reflex::Literal("product"), method_13953, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9003), Reflex::Literal("operator->"), operator_13954, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13955, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13956, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20547), Reflex::Literal("getInterface"), method_13958, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13959, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13960, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13961, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13962, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13963, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpDigiInfo> -------------------------------
static void constructor_13971( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>();
}

static void constructor_13972( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>(*(::std::auto_ptr<RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>(*(::std::auto_ptr<RPRootDumpDigiInfo>*)arg[0]);
}

static void destructor_13973(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->::edm::Wrapper<RPRootDumpDigiInfo>::~Wrapper)();
}
static  void method_13974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->product)();
}

static  void operator_13975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->operator->)();
}

static  void method_13976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->productTypeInfo)();
}

static  void method_13977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->typeInfo)();
}

static void constructor_13978( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>((::RPRootDumpDigiInfo*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>((::RPRootDumpDigiInfo*)arg[0]);
}

static  void method_13979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->getInterface)();
}

static  void method_13980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13981( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13982( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->dynamicTypeInfo)();
}

static  void method_13984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->isPresent)();
}

static  void method_13985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3402( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpDigiInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpDigiInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpDigiInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpDigiInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpDigiInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpDigiInfo> -------------------------------
void __edm__Wrapper_RPRootDumpDigiInfo__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpDigiInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpDigiInfo__datamem_bld(&__edm__Wrapper_RPRootDumpDigiInfo__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpDigiInfo__funcmem_bld(&__edm__Wrapper_RPRootDumpDigiInfo__db_funcmem);
void __edm__Wrapper_RPRootDumpDigiInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpDigiInfo>"), typeid(::edm::Wrapper<RPRootDumpDigiInfo>), sizeof(::edm::Wrapper<RPRootDumpDigiInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_945, Reflex::Literal("edm::Wrapper<RPRootDumpDigiInfo>::value_type"))
  .AddTypedef(type_945, Reflex::Literal("edm::Wrapper<RPRootDumpDigiInfo>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13971, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2361), Reflex::Literal("Wrapper"), constructor_13972, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13973, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6179), Reflex::Literal("Wrapper"), constructor_13978, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3402, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpDigiInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpDigiInfo__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpDigiInfo> -------------------
void __edm__Wrapper_RPRootDumpDigiInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpDigiInfo_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_945, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpDigiInfo_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpDigiInfo> -------------------
void __edm__Wrapper_RPRootDumpDigiInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9133), Reflex::Literal("product"), method_13974, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9133), Reflex::Literal("operator->"), operator_13975, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13976, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13977, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20550), Reflex::Literal("getInterface"), method_13979, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_13980, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_13981, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_13982, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_13983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_13984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_13985, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpTrackInfo> -------------------------------
static void constructor_13992( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>();
}

static void constructor_13993( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>(*(::std::auto_ptr<RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>(*(::std::auto_ptr<RPRootDumpTrackInfo>*)arg[0]);
}

static void destructor_13994(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->::edm::Wrapper<RPRootDumpTrackInfo>::~Wrapper)();
}
static  void method_13995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->product)();
}

static  void operator_13996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->operator->)();
}

static  void method_13997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->productTypeInfo)();
}

static  void method_13998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->typeInfo)();
}

static void constructor_13999( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>((::RPRootDumpTrackInfo*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>((::RPRootDumpTrackInfo*)arg[0]);
}

static  void method_14000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->getInterface)();
}

static  void method_14001( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_14002( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_14003( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_14004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->dynamicTypeInfo)();
}

static  void method_14005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->isPresent)();
}

static  void method_14006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3403( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpTrackInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpTrackInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpTrackInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpTrackInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpTrackInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpTrackInfo> -------------------------------
void __edm__Wrapper_RPRootDumpTrackInfo__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpTrackInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpTrackInfo__datamem_bld(&__edm__Wrapper_RPRootDumpTrackInfo__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpTrackInfo__funcmem_bld(&__edm__Wrapper_RPRootDumpTrackInfo__db_funcmem);
void __edm__Wrapper_RPRootDumpTrackInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpTrackInfo>"), typeid(::edm::Wrapper<RPRootDumpTrackInfo>), sizeof(::edm::Wrapper<RPRootDumpTrackInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1901, Reflex::Literal("edm::Wrapper<RPRootDumpTrackInfo>::value_type"))
  .AddTypedef(type_1901, Reflex::Literal("edm::Wrapper<RPRootDumpTrackInfo>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13992, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2362), Reflex::Literal("Wrapper"), constructor_13993, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13994, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6198), Reflex::Literal("Wrapper"), constructor_13999, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3403, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpTrackInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpTrackInfo__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpTrackInfo> -------------------
void __edm__Wrapper_RPRootDumpTrackInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpTrackInfo_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1901, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpTrackInfo_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpTrackInfo> -------------------
void __edm__Wrapper_RPRootDumpTrackInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8938), Reflex::Literal("product"), method_13995, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8938), Reflex::Literal("operator->"), operator_13996, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_13997, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_13998, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20553), Reflex::Literal("getInterface"), method_14000, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_14001, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_14002, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_14003, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_14004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_14005, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_14006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TotemRPEvent> -------------------------------
static void constructor_14013( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemRPEvent>();
  else ::new(mem) ::edm::Wrapper<TotemRPEvent>();
}

static void constructor_14014( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemRPEvent>(*(::std::auto_ptr<TotemRPEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemRPEvent>(*(::std::auto_ptr<TotemRPEvent>*)arg[0]);
}

static void destructor_14015(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TotemRPEvent>*)o)->::edm::Wrapper<TotemRPEvent>::~Wrapper)();
}
static  void method_14016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemRPEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<TotemRPEvent>*)o)->product)();
}

static  void operator_14017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemRPEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<TotemRPEvent>*)o)->operator->)();
}

static  void method_14018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemRPEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TotemRPEvent>*)o)->productTypeInfo)();
}

static  void method_14019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemRPEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<TotemRPEvent>*)o)->typeInfo)();
}

static void constructor_14020( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemRPEvent>((::TotemRPEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemRPEvent>((::TotemRPEvent*)arg[0]);
}

static  void method_14021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TotemRPEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<TotemRPEvent>*)o)->getInterface)();
}

static  void method_14022( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemRPEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_14023( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemRPEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_14024( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemRPEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_14025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemRPEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TotemRPEvent>*)o)->dynamicTypeInfo)();
}

static  void method_14026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TotemRPEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TotemRPEvent>*)o)->isPresent)();
}

static  void method_14027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemRPEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TotemRPEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3404( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemRPEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemRPEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemRPEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemRPEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemRPEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TotemRPEvent> -------------------------------
void __edm__Wrapper_TotemRPEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_TotemRPEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemRPEvent__datamem_bld(&__edm__Wrapper_TotemRPEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemRPEvent__funcmem_bld(&__edm__Wrapper_TotemRPEvent__db_funcmem);
void __edm__Wrapper_TotemRPEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TotemRPEvent>"), typeid(::edm::Wrapper<TotemRPEvent>), sizeof(::edm::Wrapper<TotemRPEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1960, Reflex::Literal("edm::Wrapper<TotemRPEvent>::value_type"))
  .AddTypedef(type_1960, Reflex::Literal("edm::Wrapper<TotemRPEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_14013, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2363), Reflex::Literal("Wrapper"), constructor_14014, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_14015, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20557), Reflex::Literal("Wrapper"), constructor_14020, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3404, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TotemRPEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TotemRPEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TotemRPEvent> -------------------
void __edm__Wrapper_TotemRPEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1354, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TotemRPEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1960, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TotemRPEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TotemRPEvent> -------------------
void __edm__Wrapper_TotemRPEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20556), Reflex::Literal("product"), method_14016, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20556), Reflex::Literal("operator->"), operator_14017, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("productTypeInfo"), method_14018, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("typeInfo"), method_14019, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20558), Reflex::Literal("getInterface"), method_14021, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_14055, type_18578, type_20419), Reflex::Literal("fillView"), method_14022, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_291, type_6956), Reflex::Literal("setPtr"), method_14023, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_12524, type_18579, type_18578), Reflex::Literal("fillPtrVector"), method_14024, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo"), method_14025, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1354), Reflex::Literal("isPresent"), method_14026, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12524), Reflex::Literal("dynamicTypeInfo_"), method_14027, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __RPRootDumpReconstructedProton_dict(); 
      __RPRootDumpPatternInfo_dict(); 
      __RPRootDumpPattern_dict(); 
      __RPRootDumpDigiInfo_dict(); 
      __RPRootDumpReconstructedProtonPair_dict(); 
      __RPRootDumpTrackInfo_dict(); 
      __TotemRPEvent_dict(); 
      __std__vector_RPRootDumpTrackInfo__dict(); 
      __std__vector_RPRootDumpReconstructedProton__dict(); 
      __std__vector_RPRootDumpPatternInfo__dict(); 
      __std__vector_RPRootDumpDigiInfo__dict(); 
      __std__map_unsignedsint_RPRootDumpReconstructedProton__dict(); 
      __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__dict(); 
      __std__map_unsignedsint_RPRootDumpPatternInfo__dict(); 
      __std__map_unsignedsint_RPRootDumpDigiInfo__dict(); 
      __std__map_unsignedsint_RPRootDumpTrackInfo__dict(); 
      __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__dict(); 
      __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__dict(); 
      __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__dict(); 
      __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__dict(); 
      __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__dict(); 
      __edm__Wrapper_RPRootDumpPatternInfo__dict(); 
      __edm__Wrapper_RPRootDumpPattern__dict(); 
      __edm__Wrapper_RPRootDumpReconstructedProtonPair__dict(); 
      __edm__Wrapper_RPRootDumpReconstructedProton__dict(); 
      __edm__Wrapper_RPRootDumpDigiInfo__dict(); 
      __edm__Wrapper_RPRootDumpTrackInfo__dict(); 
      __edm__Wrapper_TotemRPEvent__dict(); 
    }
    ~Dictionaries() {
      type_528.Unload(); // class RPRootDumpReconstructedProton 
      type_574.Unload(); // class RPRootDumpPatternInfo 
      type_812.Unload(); // class RPRootDumpPattern 
      type_945.Unload(); // class RPRootDumpDigiInfo 
      type_1681.Unload(); // class RPRootDumpReconstructedProtonPair 
      type_1901.Unload(); // class RPRootDumpTrackInfo 
      type_1960.Unload(); // class TotemRPEvent 
      type_2535.Unload(); // class std::vector<RPRootDumpTrackInfo> 
      type_2536.Unload(); // class std::vector<RPRootDumpReconstructedProton> 
      type_2537.Unload(); // class std::vector<RPRootDumpPatternInfo> 
      type_2538.Unload(); // class std::vector<RPRootDumpDigiInfo> 
      type_2657.Unload(); // class std::map<unsigned int,RPRootDumpReconstructedProton> 
      type_2658.Unload(); // class std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > 
      type_2659.Unload(); // class std::map<unsigned int,RPRootDumpPatternInfo> 
      type_2660.Unload(); // class std::map<unsigned int,RPRootDumpDigiInfo> 
      type_2661.Unload(); // class std::map<unsigned int,RPRootDumpTrackInfo> 
      type_3389.Unload(); // class edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > 
      type_3390.Unload(); // class edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > 
      type_3391.Unload(); // class edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > 
      type_3392.Unload(); // class edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > 
      type_3393.Unload(); // class edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > 
      type_3394.Unload(); // class edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > 
      type_3395.Unload(); // class edm::Wrapper<std::vector<RPRootDumpPatternInfo> > 
      type_3396.Unload(); // class edm::Wrapper<std::vector<RPRootDumpDigiInfo> > 
      type_3397.Unload(); // class edm::Wrapper<std::vector<RPRootDumpTrackInfo> > 
      type_3398.Unload(); // class edm::Wrapper<RPRootDumpPatternInfo> 
      type_3399.Unload(); // class edm::Wrapper<RPRootDumpPattern> 
      type_3400.Unload(); // class edm::Wrapper<RPRootDumpReconstructedProtonPair> 
      type_3401.Unload(); // class edm::Wrapper<RPRootDumpReconstructedProton> 
      type_3402.Unload(); // class edm::Wrapper<RPRootDumpDigiInfo> 
      type_3403.Unload(); // class edm::Wrapper<RPRootDumpTrackInfo> 
      type_3404.Unload(); // class edm::Wrapper<TotemRPEvent> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
