// Generated at Mon Jul 11 23:17:01 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/TotemAlignment/RPTrackBased/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_19 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_583 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_210 = ::Reflex::TypeBuilder(Reflex::Literal("TH1D"));
  ::Reflex::Type type_220 = ::Reflex::TypeBuilder(Reflex::Literal("TH2D"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_158 = ::Reflex::TypeBuilder(Reflex::Literal("Mille"));
  ::Reflex::Type type_1697 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_205 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1602 = ::Reflex::TypeBuilder(Reflex::Literal("TGraph"));
  ::Reflex::Type type_2403 = ::Reflex::TypeBuilder(Reflex::Literal("TDirectory"));
  ::Reflex::Type type_58 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1512 = ::Reflex::TypeBuilder(Reflex::Literal("IdealResult"));
  ::Reflex::Type type_2443 = ::Reflex::TypeBuilder(Reflex::Literal("DetGeometry"));
  ::Reflex::Type type_22 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_877 = ::Reflex::TypeBuilder(Reflex::Literal("AlignmentTask"));
  ::Reflex::Type type_1586 = ::Reflex::TypeBuilder(Reflex::Literal("SingularMode"));
  ::Reflex::Type type_1408 = ::Reflex::TypeBuilder(Reflex::Literal("LocalTrackFit"));
  ::Reflex::Type type_4991 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EventSetup"));
  ::Reflex::Type type_2003 = ::Reflex::TypeBuilder(Reflex::Literal("TotemRPGeometry"));
  ::Reflex::Type type_137 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixT<double>"));
  ::Reflex::Type type_95 = ::Reflex::TypeBuilder(Reflex::Literal("MillepedeAlgorithm"));
  ::Reflex::Type type_1097 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Hit>"));
  ::Reflex::Type type_1866 = ::Reflex::TypeBuilder(Reflex::Literal("TVectorT<double>"));
  ::Reflex::Type type_2266 = ::Reflex::TypeBuilder(Reflex::Literal("LocalTrackFitter"));
  ::Reflex::Type type_746 = ::Reflex::TypeBuilder(Reflex::Literal("AlignmentAlgorithm"));
  ::Reflex::Type type_5045 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ParameterSet"));
  ::Reflex::Type type_1596 = ::Reflex::TypeBuilder(Reflex::Literal("AlignmentGeometry"));
  ::Reflex::Type type_2627 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TH1D*>"));
  ::Reflex::Type type_1094 = ::Reflex::TypeBuilder(Reflex::Literal("AlignmentConstraint"));
  ::Reflex::Type type_2626 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TGraph*>"));
  ::Reflex::Type type_2188 = ::Reflex::TypeBuilder(Reflex::Literal("JanAlignmentAlgorithm"));
  ::Reflex::Type type_3240 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TH1D*>"));
  ::Reflex::Type type_2366 = ::Reflex::TypeBuilder(Reflex::Literal("RPAlignmentCorrections"));
  ::Reflex::Type type_2798 = ::Reflex::TypeBuilder(Reflex::Literal("std::set<unsigned int>"));
  ::Reflex::Type type_2688 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_3239 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TGraph*>"));
  ::Reflex::Type type_2959 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned int>"));
  ::Reflex::Type type_2628 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SingularMode>"));
  ::Reflex::Type type_2654 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_3242 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SingularMode>"));
  ::Reflex::Type type_3238 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned int>"));
  ::Reflex::Type type_5024 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ESHandle<TotemRPGeometry>"));
  ::Reflex::Type type_8021 = ::Reflex::TypeBuilder(Reflex::Literal("JanAlignmentAlgorithm::DetStat"));
  ::Reflex::Type type_2629 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<AlignmentConstraint>"));
  ::Reflex::Type type_5175 = ::Reflex::EnumTypeBuilder(Reflex::Literal("AlignmentTask::QuantityClass"));
  ::Reflex::Type type_2899 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,DetGeometry>"));
  ::Reflex::Type type_8020 = ::Reflex::TypeBuilder(Reflex::Literal("JanAlignmentAlgorithm::ScatterPlot"));
  ::Reflex::Type type_2958 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<std::set<unsigned int> >"));
  ::Reflex::Type type_3244 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<AlignmentConstraint>"));
  ::Reflex::Type type_2900 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,TVectorT<double> >"));
  ::Reflex::Type type_2653 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<AlignmentTask::QuantityClass>"));
  ::Reflex::Type type_3038 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,DetGeometry>"));
  ::Reflex::Type type_3595 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<unsigned int>"));
  ::Reflex::Type type_2574 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TH1D*,std::allocator<TH1D*> >"));
  ::Reflex::Type type_3039 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,TVectorT<double> >"));
  ::Reflex::Type type_6969 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<TH1D*> >"));
  ::Reflex::Type type_2573 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TGraph*,std::allocator<TGraph*> >"));
  ::Reflex::Type type_6968 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<TGraph*> >"));
  ::Reflex::Type type_2898 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>"));
  ::Reflex::Type type_6834 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >"));
  ::Reflex::Type type_6967 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<SingularMode> >"));
  ::Reflex::Type type_3129 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<unsigned int>,bool>"));
  ::Reflex::Type type_3243 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,DetGeometry> >"));
  ::Reflex::Type type_6832 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >"));
  ::Reflex::Type type_3037 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat>"));
  ::Reflex::Type type_2572 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SingularMode,std::allocator<SingularMode> >"));
  ::Reflex::Type type_6835 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TH1D* const*,std::vector<TH1D*> >"));
  ::Reflex::Type type_6966 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<AlignmentConstraint> >"));
  ::Reflex::Type type_3245 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,TVectorT<double> > >"));
  ::Reflex::Type type_6833 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TGraph* const*,std::vector<TGraph*> >"));
  ::Reflex::Type type_3530 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<unsigned int> >"));
  ::Reflex::Type type_2731 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >"));
  ::Reflex::Type type_2897 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>"));
  ::Reflex::Type type_6830 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >"));
  ::Reflex::Type type_3596 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> >"));
  ::Reflex::Type type_2729 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >"));
  ::Reflex::Type type_3036 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>"));
  ::Reflex::Type type_2571 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<AlignmentConstraint,std::allocator<AlignmentConstraint> >"));
  ::Reflex::Type type_6831 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SingularMode*,std::vector<SingularMode> >"));
  ::Reflex::Type type_3241 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >"));
  ::Reflex::Type type_3594 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,TVectorT<double> > >"));
  ::Reflex::Type type_3463 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> > >"));
  ::Reflex::Type type_3130 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >,bool>"));
  ::Reflex::Type type_3461 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> > >"));
  ::Reflex::Type type_6828 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >"));
  ::Reflex::Type type_2712 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >"));
  ::Reflex::Type type_3462 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TH1D* const*,std::vector<TH1D*> > >"));
  ::Reflex::Type type_3128 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >,bool>"));
  ::Reflex::Type type_3460 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TGraph* const*,std::vector<TGraph*> > >"));
  ::Reflex::Type type_6829 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const AlignmentConstraint*,std::vector<AlignmentConstraint> >"));
  ::Reflex::Type type_3533 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> > >"));
  ::Reflex::Type type_3237 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >"));
  ::Reflex::Type type_3577 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >"));
  ::Reflex::Type type_3457 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> > >"));
  ::Reflex::Type type_3532 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> > >"));
  ::Reflex::Type type_3523 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > > >"));
  ::Reflex::Type type_3131 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<unsigned int>,std::_Rb_tree_const_iterator<unsigned int> >"));
  ::Reflex::Type type_2713 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >"));
  ::Reflex::Type type_3456 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SingularMode*,std::vector<SingularMode> > >"));
  ::Reflex::Type type_3042 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >,bool>"));
  ::Reflex::Type type_3522 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,TVectorT<double> > > >"));
  ::Reflex::Type type_3578 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >"));
  ::Reflex::Type type_3453 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> > >"));
  ::Reflex::Type type_3455 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> > >"));
  ::Reflex::Type type_3452 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const AlignmentConstraint*,std::vector<AlignmentConstraint> > >"));
  ::Reflex::Type type_3046 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >,bool>"));
  ::Reflex::Type type_3454 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> > >"));
  ::Reflex::Type type_3170 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,unsigned int,std::_Identity<unsigned int>,std::less<unsigned int>,std::allocator<unsigned int> >"));
  ::Reflex::Type type_3459 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> > >"));
  ::Reflex::Type type_3458 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> > >"));
  ::Reflex::Type type_3135 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >,std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> > >"));
  ::Reflex::Type type_3134 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> > >"));
  ::Reflex::Type type_3127 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > > >"));
  ::Reflex::Type type_3126 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,TVectorT<double> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,TVectorT<double> > > >"));
  ::Reflex::Type type_3041 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >,std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> > >"));
  ::Reflex::Type type_3040 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> > >"));
  ::Reflex::Type type_3045 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >,std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> > >"));
  ::Reflex::Type type_3171 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,DetGeometry>,std::_Select1st<std::pair<const unsigned int,DetGeometry> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,DetGeometry> > >"));
  ::Reflex::Type type_3044 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >,std::_Rb_tree_const_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> > >"));
  ::Reflex::Type type_3169 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,TVectorT<double> >,std::_Select1st<std::pair<const unsigned int,TVectorT<double> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,TVectorT<double> > > >"));
  ::Reflex::Type type_3152 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat>,std::_Select1st<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> > >"));
  ::Reflex::Type type_3153 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::set<unsigned int>,std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>,std::_Select1st<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >,std::less<std::set<unsigned int> >,std::allocator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> > >"));
  ::Reflex::Type type_2703 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2688);
  ::Reflex::Type type_19623 = ::Reflex::PointerBuilder(type_158);
  ::Reflex::Type type_19624 = ::Reflex::ReferenceBuilder(type_95);
  ::Reflex::Type type_95c = ::Reflex::ConstBuilder(type_95);
  ::Reflex::Type type_19625 = ::Reflex::ReferenceBuilder(type_95c);
  ::Reflex::Type type_5045c = ::Reflex::ConstBuilder(type_5045);
  ::Reflex::Type type_11203 = ::Reflex::ReferenceBuilder(type_5045c);
  ::Reflex::Type type_19626 = ::Reflex::PointerBuilder(type_877);
  ::Reflex::Type type_4991c = ::Reflex::ConstBuilder(type_4991);
  ::Reflex::Type type_19627 = ::Reflex::ReferenceBuilder(type_4991c);
  ::Reflex::Type type_1098 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("HitCollection"), type_1097);
  ::Reflex::Type type_1098c = ::Reflex::ConstBuilder(type_1098);
  ::Reflex::Type type_19628 = ::Reflex::ReferenceBuilder(type_1098c);
  ::Reflex::Type type_1408c = ::Reflex::ConstBuilder(type_1408);
  ::Reflex::Type type_19629 = ::Reflex::ReferenceBuilder(type_1408c);
  ::Reflex::Type type_19630 = ::Reflex::PointerBuilder(type_2403);
  ::Reflex::Type type_2629c = ::Reflex::ConstBuilder(type_2629);
  ::Reflex::Type type_19631 = ::Reflex::ReferenceBuilder(type_2629c);
  ::Reflex::Type type_19632 = ::Reflex::ReferenceBuilder(type_2366);
  ::Reflex::Type type_20980 = ::Reflex::ReferenceBuilder(type_877);
  ::Reflex::Type type_877c = ::Reflex::ConstBuilder(type_877);
  ::Reflex::Type type_20981 = ::Reflex::ReferenceBuilder(type_877c);
  ::Reflex::Type type_2654c = ::Reflex::ConstBuilder(type_2654);
  ::Reflex::Type type_20982 = ::Reflex::ReferenceBuilder(type_2654c);
  ::Reflex::Type type_2003c = ::Reflex::ConstBuilder(type_2003);
  ::Reflex::Type type_20984 = ::Reflex::PointerBuilder(type_2003c);
  ::Reflex::Type type_20985 = ::Reflex::ReferenceBuilder(type_1596);
  ::Reflex::Type type_20986 = ::Reflex::ReferenceBuilder(type_2629);
  ::Reflex::Type type_10236 = ::Reflex::ReferenceBuilder(type_1094);
  ::Reflex::Type type_1094c = ::Reflex::ConstBuilder(type_1094);
  ::Reflex::Type type_10238 = ::Reflex::ReferenceBuilder(type_1094c);
  ::Reflex::Type type_22102 = ::Reflex::ReferenceBuilder(type_1512);
  ::Reflex::Type type_1512c = ::Reflex::ConstBuilder(type_1512);
  ::Reflex::Type type_22103 = ::Reflex::ReferenceBuilder(type_1512c);
  ::Reflex::Type type_1867 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TVectorD"), type_1866);
  ::Reflex::Type type_10171 = ::Reflex::ReferenceBuilder(type_1586);
  ::Reflex::Type type_1586c = ::Reflex::ConstBuilder(type_1586);
  ::Reflex::Type type_10173 = ::Reflex::ReferenceBuilder(type_1586c);
  ::Reflex::Type type_1596c = ::Reflex::ConstBuilder(type_1596);
  ::Reflex::Type type_24081 = ::Reflex::ReferenceBuilder(type_1596c);
  ::Reflex::Type type_2443c = ::Reflex::ConstBuilder(type_2443);
  ::Reflex::Type type_24082 = ::Reflex::ReferenceBuilder(type_2443c);
  ::Reflex::Type type_2703c = ::Reflex::ConstBuilder(type_2703);
  ::Reflex::Type type_138 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TMatrixD"), type_137);
  ::Reflex::Type type_28552 = ::Reflex::PointerBuilder(type_138);
  ::Reflex::Type type_24575 = ::Reflex::PointerBuilder(type_28552);
  ::Reflex::Type type_24576 = ::Reflex::PointerBuilder(type_1867);
  ::Reflex::Type type_24591 = ::Reflex::ReferenceBuilder(type_2188);
  ::Reflex::Type type_2188c = ::Reflex::ConstBuilder(type_2188);
  ::Reflex::Type type_24592 = ::Reflex::ReferenceBuilder(type_2188c);
  ::Reflex::Type type_25710 = ::Reflex::ReferenceBuilder(type_2266);
  ::Reflex::Type type_2266c = ::Reflex::ConstBuilder(type_2266);
  ::Reflex::Type type_25711 = ::Reflex::ReferenceBuilder(type_2266c);
  ::Reflex::Type type_25712 = ::Reflex::ReferenceBuilder(type_1098);
  ::Reflex::Type type_22090 = ::Reflex::ReferenceBuilder(type_1408);
  ::Reflex::Type type_26223 = ::Reflex::ReferenceBuilder(type_2443);
  ::Reflex::Type type_10031 = ::Reflex::PointerBuilder(type_1602);
  ::Reflex::Type type_9593 = ::Reflex::PointerBuilder(type_10031);
  ::Reflex::Type type_10031c = ::Reflex::ConstBuilder(type_10031);
  ::Reflex::Type type_10038 = ::Reflex::PointerBuilder(type_10031c);
  ::Reflex::Type type_10040 = ::Reflex::ReferenceBuilder(type_10031);
  ::Reflex::Type type_10042 = ::Reflex::ReferenceBuilder(type_10031c);
  ::Reflex::Type type_3214 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_22);
  ::Reflex::Type type_2802 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_19);
  ::Reflex::Type type_3239c = ::Reflex::ConstBuilder(type_3239);
  ::Reflex::Type type_26342 = ::Reflex::ReferenceBuilder(type_3239c);
  ::Reflex::Type type_2626c = ::Reflex::ConstBuilder(type_2626);
  ::Reflex::Type type_26602 = ::Reflex::ReferenceBuilder(type_2626c);
  ::Reflex::Type type_26603 = ::Reflex::ReferenceBuilder(type_2626);
  ::Reflex::Type type_10097 = ::Reflex::PointerBuilder(type_210);
  ::Reflex::Type type_9612 = ::Reflex::PointerBuilder(type_10097);
  ::Reflex::Type type_10097c = ::Reflex::ConstBuilder(type_10097);
  ::Reflex::Type type_10104 = ::Reflex::PointerBuilder(type_10097c);
  ::Reflex::Type type_10106 = ::Reflex::ReferenceBuilder(type_10097);
  ::Reflex::Type type_10108 = ::Reflex::ReferenceBuilder(type_10097c);
  ::Reflex::Type type_3240c = ::Reflex::ConstBuilder(type_3240);
  ::Reflex::Type type_26355 = ::Reflex::ReferenceBuilder(type_3240c);
  ::Reflex::Type type_2627c = ::Reflex::ConstBuilder(type_2627);
  ::Reflex::Type type_26605 = ::Reflex::ReferenceBuilder(type_2627c);
  ::Reflex::Type type_26606 = ::Reflex::ReferenceBuilder(type_2627);
  ::Reflex::Type type_9574 = ::Reflex::PointerBuilder(type_1586);
  ::Reflex::Type type_10169 = ::Reflex::PointerBuilder(type_1586c);
  ::Reflex::Type type_3242c = ::Reflex::ConstBuilder(type_3242);
  ::Reflex::Type type_26329 = ::Reflex::ReferenceBuilder(type_3242c);
  ::Reflex::Type type_2628c = ::Reflex::ConstBuilder(type_2628);
  ::Reflex::Type type_26608 = ::Reflex::ReferenceBuilder(type_2628c);
  ::Reflex::Type type_26609 = ::Reflex::ReferenceBuilder(type_2628);
  ::Reflex::Type type_9555 = ::Reflex::PointerBuilder(type_1094);
  ::Reflex::Type type_10234 = ::Reflex::PointerBuilder(type_1094c);
  ::Reflex::Type type_3244c = ::Reflex::ConstBuilder(type_3244);
  ::Reflex::Type type_26316 = ::Reflex::ReferenceBuilder(type_3244c);
  ::Reflex::Type type_7748 = ::Reflex::PointerBuilder(type_58);
  ::Reflex::Type type_58c = ::Reflex::ConstBuilder(type_58);
  ::Reflex::Type type_12157 = ::Reflex::PointerBuilder(type_58c);
  ::Reflex::Type type_11945 = ::Reflex::ReferenceBuilder(type_58);
  ::Reflex::Type type_12160 = ::Reflex::ReferenceBuilder(type_58c);
  ::Reflex::Type type_2959c = ::Reflex::ConstBuilder(type_2959);
  ::Reflex::Type type_26825 = ::Reflex::ReferenceBuilder(type_2959c);
  ::Reflex::Type type_3238c = ::Reflex::ConstBuilder(type_3238);
  ::Reflex::Type type_26826 = ::Reflex::ReferenceBuilder(type_3238c);
  ::Reflex::Type type_2798c = ::Reflex::ConstBuilder(type_2798);
  ::Reflex::Type type_26827 = ::Reflex::ReferenceBuilder(type_2798c);
  ::Reflex::Type type_26828 = ::Reflex::ReferenceBuilder(type_2798);
  ::Reflex::Type type_12722 = ::Reflex::PointerBuilder(type_3036);
  ::Reflex::Type type_3036c = ::Reflex::ConstBuilder(type_3036);
  ::Reflex::Type type_12724 = ::Reflex::PointerBuilder(type_3036c);
  ::Reflex::Type type_12726 = ::Reflex::ReferenceBuilder(type_3036);
  ::Reflex::Type type_12728 = ::Reflex::ReferenceBuilder(type_3036c);
  ::Reflex::Type type_2958c = ::Reflex::ConstBuilder(type_2958);
  ::Reflex::Type type_26946 = ::Reflex::ReferenceBuilder(type_2958c);
  ::Reflex::Type type_3237c = ::Reflex::ConstBuilder(type_3237);
  ::Reflex::Type type_26947 = ::Reflex::ReferenceBuilder(type_3237c);
  ::Reflex::Type type_2897c = ::Reflex::ConstBuilder(type_2897);
  ::Reflex::Type type_26948 = ::Reflex::ReferenceBuilder(type_2897c);
  ::Reflex::Type type_26949 = ::Reflex::ReferenceBuilder(type_2897);
  ::Reflex::Type type_26950 = ::Reflex::ReferenceBuilder(type_8020);
  ::Reflex::Type type_8020c = ::Reflex::ConstBuilder(type_8020);
  ::Reflex::Type type_26951 = ::Reflex::ReferenceBuilder(type_8020c);
  ::Reflex::Type type_12784 = ::Reflex::PointerBuilder(type_3037);
  ::Reflex::Type type_3037c = ::Reflex::ConstBuilder(type_3037);
  ::Reflex::Type type_12786 = ::Reflex::PointerBuilder(type_3037c);
  ::Reflex::Type type_12788 = ::Reflex::ReferenceBuilder(type_3037);
  ::Reflex::Type type_12790 = ::Reflex::ReferenceBuilder(type_3037c);
  ::Reflex::Type type_3241c = ::Reflex::ConstBuilder(type_3241);
  ::Reflex::Type type_26953 = ::Reflex::ReferenceBuilder(type_3241c);
  ::Reflex::Type type_2898c = ::Reflex::ConstBuilder(type_2898);
  ::Reflex::Type type_26954 = ::Reflex::ReferenceBuilder(type_2898c);
  ::Reflex::Type type_26955 = ::Reflex::ReferenceBuilder(type_2898);
  ::Reflex::Type type_26956 = ::Reflex::ReferenceBuilder(type_8021);
  ::Reflex::Type type_8021c = ::Reflex::ConstBuilder(type_8021);
  ::Reflex::Type type_26957 = ::Reflex::ReferenceBuilder(type_8021c);
  ::Reflex::Type type_11970 = ::Reflex::PointerBuilder(type_3038);
  ::Reflex::Type type_3038c = ::Reflex::ConstBuilder(type_3038);
  ::Reflex::Type type_12847 = ::Reflex::PointerBuilder(type_3038c);
  ::Reflex::Type type_11968 = ::Reflex::ReferenceBuilder(type_3038);
  ::Reflex::Type type_12850 = ::Reflex::ReferenceBuilder(type_3038c);
  ::Reflex::Type type_3243c = ::Reflex::ConstBuilder(type_3243);
  ::Reflex::Type type_26959 = ::Reflex::ReferenceBuilder(type_3243c);
  ::Reflex::Type type_2899c = ::Reflex::ConstBuilder(type_2899);
  ::Reflex::Type type_26960 = ::Reflex::ReferenceBuilder(type_2899c);
  ::Reflex::Type type_26961 = ::Reflex::ReferenceBuilder(type_2899);
  ::Reflex::Type type_28553 = ::Reflex::PointerBuilder(type_220);
  ::Reflex::Type type_12906 = ::Reflex::PointerBuilder(type_3039);
  ::Reflex::Type type_3039c = ::Reflex::ConstBuilder(type_3039);
  ::Reflex::Type type_12908 = ::Reflex::PointerBuilder(type_3039c);
  ::Reflex::Type type_12910 = ::Reflex::ReferenceBuilder(type_3039);
  ::Reflex::Type type_12912 = ::Reflex::ReferenceBuilder(type_3039c);
  ::Reflex::Type type_3245c = ::Reflex::ConstBuilder(type_3245);
  ::Reflex::Type type_26963 = ::Reflex::ReferenceBuilder(type_3245c);
  ::Reflex::Type type_2900c = ::Reflex::ConstBuilder(type_2900);
  ::Reflex::Type type_26964 = ::Reflex::ReferenceBuilder(type_2900c);
  ::Reflex::Type type_26965 = ::Reflex::ReferenceBuilder(type_2900);
  ::Reflex::Type type_19660 = ::Reflex::ReferenceBuilder(type_1866);
  ::Reflex::Type type_1866c = ::Reflex::ConstBuilder(type_1866);
  ::Reflex::Type type_19654 = ::Reflex::ReferenceBuilder(type_1866c);
  ::Reflex::Type type_2900f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::map<unsigned int, TVectorD>"), type_2900);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __MillepedeAlgorithm
#undef __MillepedeAlgorithm
#endif
class __MillepedeAlgorithm : public ::AlignmentAlgorithm {
  public:
  __MillepedeAlgorithm();
  virtual ~__MillepedeAlgorithm() throw();
  ::std::string workingDir;
  void* mille;
};
#ifdef __AlignmentTask
#undef __AlignmentTask
#endif
class __AlignmentTask {
  public:
  __AlignmentTask();
  ::std::vector<AlignmentTask::QuantityClass> quantityClasses;
  bool resolveShR;
  bool resolveShZ;
  bool resolveRotZ;
  bool resolveRPShZ;
  bool oneRotZPerPot;
  bool useExtendedRotZConstraint;
  bool useZeroThetaRotZConstraint;
  bool useExtendedShZConstraints;
  bool useExtendedRPShZConstraint;
  ::AlignmentGeometry geometry;
  ::edm::ParameterSet homogeneousConstraints;
  ::edm::ParameterSet fixedDetectorsConstraints;
};
#ifdef __AlignmentConstraint
#undef __AlignmentConstraint
#endif
struct __AlignmentConstraint {
  public:
  __AlignmentConstraint();
  double val;
  ::std::map<unsigned int,TVectorT<double> > coef;
  ::AlignmentTask::QuantityClass forClass;
  bool extended;
  ::std::string name;
};
#ifdef __IdealResult
#undef __IdealResult
#endif
class __IdealResult : public ::AlignmentAlgorithm {
  public:
  __IdealResult();
  virtual ~__IdealResult() throw();
  ::edm::ESHandle<TotemRPGeometry> gReal;
  ::edm::ESHandle<TotemRPGeometry> gMisaligned;
  bool useExtendedConstraints;
};
#ifdef __SingularMode
#undef __SingularMode
#endif
struct __SingularMode {
  public:
  __SingularMode();
  double val;
  ::TVectorD vec;
  unsigned int idx;
};
#ifdef __AlignmentGeometry
#undef __AlignmentGeometry
#endif
class __AlignmentGeometry : public ::std::map<unsigned int,DetGeometry> {
  public:
  __AlignmentGeometry();
  ::std::set<unsigned int> rps;
  double z0;
};
#ifdef __JanAlignmentAlgorithm
#undef __JanAlignmentAlgorithm
#endif
class __JanAlignmentAlgorithm : public ::AlignmentAlgorithm {
  public:
  __JanAlignmentAlgorithm();
  virtual ~__JanAlignmentAlgorithm() throw();
  void* Sc;
  void* Mc;
  ::TMatrixD S;
  ::TVectorD M;
  ::TVectorD S_eigVal;
  ::TMatrixD S_eigVec;
  ::std::vector<SingularMode> singularModes;
  bool stopOnSingularModes;
  double weakLimit;
  unsigned int events;
  ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat> statistics;
  bool buildDiagnosticPlots;
};
#ifdef __LocalTrackFitter
#undef __LocalTrackFitter
#endif
class __LocalTrackFitter {
  public:
  __LocalTrackFitter();
  virtual ~__LocalTrackFitter() throw();
  unsigned int verbosity;
  unsigned int minimumHitsPerProjectionPerRP;
  double maxResidualToSigma;
};
#ifdef __DetGeometry
#undef __DetGeometry
#endif
struct __DetGeometry {
  public:
  __DetGeometry();
  double z;
  double dx;
  double dy;
  double sx;
  double sy;
  double s;
  unsigned int matrixIndex;
  unsigned int rpMatrixIndex;
  bool isU;
};
#ifdef __std__vector_TGraphp_
#undef __std__vector_TGraphp_
#endif
class __std__vector_TGraphp_ : protected ::std::_Vector_base<TGraph*,std::allocator<TGraph*> > {
  public:
  __std__vector_TGraphp_();
};
#ifdef __std__vector_TH1Dp_
#undef __std__vector_TH1Dp_
#endif
class __std__vector_TH1Dp_ : protected ::std::_Vector_base<TH1D*,std::allocator<TH1D*> > {
  public:
  __std__vector_TH1Dp_();
};
#ifdef __std__vector_SingularMode_
#undef __std__vector_SingularMode_
#endif
class __std__vector_SingularMode_ : protected ::std::_Vector_base<SingularMode,std::allocator<SingularMode> > {
  public:
  __std__vector_SingularMode_();
};
#ifdef __std__vector_AlignmentConstraint_
#undef __std__vector_AlignmentConstraint_
#endif
class __std__vector_AlignmentConstraint_ : protected ::std::_Vector_base<AlignmentConstraint,std::allocator<AlignmentConstraint> > {
  public:
  __std__vector_AlignmentConstraint_();
};
#ifdef __std__set_unsignedsint_
#undef __std__set_unsignedsint_
#endif
class __std__set_unsignedsint_ {
  public:
  __std__set_unsignedsint_();
  ::std::_Rb_tree<unsigned int,unsigned int,std::_Identity<unsigned int>,std::less<unsigned int>,std::allocator<unsigned int> > _M_t;
};
#ifdef __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot_
#undef __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot_
#endif
class __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot_ {
  public:
  __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot_();
  ::std::_Rb_tree<std::set<unsigned int>,std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>,std::_Select1st<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >,std::less<std::set<unsigned int> >,std::allocator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> > > _M_t;
};
#ifdef __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat_
#undef __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat_
#endif
class __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat_ {
  public:
  __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat>,std::_Select1st<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> > > _M_t;
};
#ifdef __std__map_unsignedsint_DetGeometry_
#undef __std__map_unsignedsint_DetGeometry_
#endif
class __std__map_unsignedsint_DetGeometry_ {
  public:
  __std__map_unsignedsint_DetGeometry_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,DetGeometry>,std::_Select1st<std::pair<const unsigned int,DetGeometry> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,DetGeometry> > > _M_t;
};
#ifdef __JanAlignmentAlgorithm__ScatterPlot
#undef __JanAlignmentAlgorithm__ScatterPlot
#endif
struct __JanAlignmentAlgorithm__ScatterPlot {
  public:
  __JanAlignmentAlgorithm__ScatterPlot();
  void* g;
  void* h;
};
#ifdef __JanAlignmentAlgorithm__DetStat
#undef __JanAlignmentAlgorithm__DetStat
#endif
struct __JanAlignmentAlgorithm__DetStat {
  public:
  __JanAlignmentAlgorithm__DetStat();
  void* m_dist;
  ::std::vector<TH1D*> coefHist;
  ::std::vector<TGraph*> resVsCoef;
  ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> resVsCoefRot_perRPSet;
};
#ifdef __std__map_unsignedsint_TVectorT_double_s_
#undef __std__map_unsignedsint_TVectorT_double_s_
#endif
class __std__map_unsignedsint_TVectorT_double_s_ {
  public:
  __std__map_unsignedsint_TVectorT_double_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,TVectorT<double> >,std::_Select1st<std::pair<const unsigned int,TVectorT<double> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,TVectorT<double> > > > _M_t;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class MillepedeAlgorithm -------------------------------
static  void operator_3825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::MillepedeAlgorithm*)o)->operator=)(*(const ::MillepedeAlgorithm*)arg[0]);
  else   (((::MillepedeAlgorithm*)o)->operator=)(*(const ::MillepedeAlgorithm*)arg[0]);
}

static void constructor_3826( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MillepedeAlgorithm(*(const ::MillepedeAlgorithm*)arg[0]);
  else ::new(mem) ::MillepedeAlgorithm(*(const ::MillepedeAlgorithm*)arg[0]);
}

static void constructor_3827( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MillepedeAlgorithm();
  else ::new(mem) ::MillepedeAlgorithm();
}

static void constructor_3828( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MillepedeAlgorithm(*(const ::edm::ParameterSet*)arg[0],
      (::AlignmentTask*)arg[1]);
  else ::new(mem) ::MillepedeAlgorithm(*(const ::edm::ParameterSet*)arg[0],
      (::AlignmentTask*)arg[1]);
}

static void destructor_3829(void*, void * o, const std::vector<void*>&, void *) {
(((::MillepedeAlgorithm*)o)->::MillepedeAlgorithm::~MillepedeAlgorithm)();
}
static  void method_3830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::MillepedeAlgorithm*)o)->GetName)());
  else   (((::MillepedeAlgorithm*)o)->GetName)();
}

static  void method_3831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::MillepedeAlgorithm*)o)->HasErrorEstimate)());
  else   (((::MillepedeAlgorithm*)o)->HasErrorEstimate)();
}

static  void method_3832( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MillepedeAlgorithm*)o)->Begin)(*(const ::edm::EventSetup*)arg[0]);
}

static  void method_3833( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MillepedeAlgorithm*)o)->Feed)(*(const ::HitCollection*)arg[0],
    *(const ::LocalTrackFit*)arg[1],
    *(const ::LocalTrackFit*)arg[2]);
}

static  void method_3834( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MillepedeAlgorithm*)o)->SaveDiagnostics)((::TDirectory*)arg[0]);
}

static  void method_3835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<SingularMode>)((((::MillepedeAlgorithm*)o)->Analyze)());
  else   (((::MillepedeAlgorithm*)o)->Analyze)();
}

static  void method_3836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::MillepedeAlgorithm*)o)->Solve)(*(const ::std::vector<AlignmentConstraint>*)arg[0],
    *(::RPAlignmentCorrections*)arg[1],
    (::TDirectory*)arg[2]));
  else   (((::MillepedeAlgorithm*)o)->Solve)(*(const ::std::vector<AlignmentConstraint>*)arg[0],
    *(::RPAlignmentCorrections*)arg[1],
    (::TDirectory*)arg[2]);
}

static  void method_3837( void*, void* o, const std::vector<void*>&, void*)
{
  (((::MillepedeAlgorithm*)o)->End)();
}

static void method_newdel_95( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::MillepedeAlgorithm >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::MillepedeAlgorithm >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::MillepedeAlgorithm >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::MillepedeAlgorithm >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::MillepedeAlgorithm >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("AlignmentAlgorithm")), ::Reflex::BaseOffset< ::MillepedeAlgorithm,::AlignmentAlgorithm >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class MillepedeAlgorithm -------------------------------
void __MillepedeAlgorithm_db_datamem(Reflex::Class*);
void __MillepedeAlgorithm_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __MillepedeAlgorithm_datamem_bld(&__MillepedeAlgorithm_db_datamem);
Reflex::GenreflexMemberBuilder __MillepedeAlgorithm_funcmem_bld(&__MillepedeAlgorithm_db_funcmem);
void __MillepedeAlgorithm_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("MillepedeAlgorithm"), typeid(::MillepedeAlgorithm), sizeof(::MillepedeAlgorithm), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_746, ::Reflex::BaseOffset< ::MillepedeAlgorithm, ::AlignmentAlgorithm >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19624, type_19625), Reflex::Literal("operator="), operator_3825, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19625), Reflex::Literal("MillepedeAlgorithm"), constructor_3826, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MillepedeAlgorithm"), constructor_3827, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11203, type_19626), Reflex::Literal("MillepedeAlgorithm"), constructor_3828, 0, "ps;_t", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MillepedeAlgorithm"), destructor_3829, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_95, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__MillepedeAlgorithm_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__MillepedeAlgorithm_funcmem_bld);
}

//------Delayed data member builder for class MillepedeAlgorithm -------------------
void __MillepedeAlgorithm_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2703, Reflex::Literal("workingDir"), OffsetOf(__shadow__::__MillepedeAlgorithm, workingDir), ::Reflex::PRIVATE)
  .AddDataMember(type_19623, Reflex::Literal("mille"), OffsetOf(__shadow__::__MillepedeAlgorithm, mille), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class MillepedeAlgorithm -------------------
void __MillepedeAlgorithm_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703), Reflex::Literal("GetName"), method_3830, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("HasErrorEstimate"), method_3831, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_19627), Reflex::Literal("Begin"), method_3832, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_19628, type_19629, type_19629), Reflex::Literal("Feed"), method_3833, 0, ";;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_19630), Reflex::Literal("SaveDiagnostics"), method_3834, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2628), Reflex::Literal("Analyze"), method_3835, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58, type_19631, type_19632, type_19630), Reflex::Literal("Solve"), method_3836, 0, ";result;dir", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("End"), method_3837, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class AlignmentTask -------------------------------
static void destructor_5176(void*, void * o, const std::vector<void*>&, void *) {
(((::AlignmentTask*)o)->::AlignmentTask::~AlignmentTask)();
}
static  void operator_5177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::AlignmentTask*)o)->operator=)(*(const ::AlignmentTask*)arg[0]);
  else   (((::AlignmentTask*)o)->operator=)(*(const ::AlignmentTask*)arg[0]);
}

static void constructor_5178( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AlignmentTask(*(const ::AlignmentTask*)arg[0]);
  else ::new(mem) ::AlignmentTask(*(const ::AlignmentTask*)arg[0]);
}

static  void method_5179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::AlignmentTask*)o)->QuantityClassTag)(*(::AlignmentTask::QuantityClass*)arg[0]));
  else   (((::AlignmentTask*)o)->QuantityClassTag)(*(::AlignmentTask::QuantityClass*)arg[0]);
}

static void constructor_5180( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AlignmentTask();
  else ::new(mem) ::AlignmentTask();
}

static void constructor_5181( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AlignmentTask(*(const ::edm::ParameterSet*)arg[0]);
  else ::new(mem) ::AlignmentTask(*(const ::edm::ParameterSet*)arg[0]);
}

static  void method_5182( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::AlignmentTask*)o)->BuildGeometry)(*(const ::std::vector<unsigned int>*)arg[0],
    *(const ::std::vector<unsigned int>*)arg[1],
    (const ::TotemRPGeometry*)arg[2],
    *(double*)arg[3],
    *(::AlignmentGeometry*)arg[4]);
}

static  void method_5183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::AlignmentTask*)o)->QuantitiesOfClass)(*(::AlignmentTask::QuantityClass*)arg[0]));
  else   (((::AlignmentTask*)o)->QuantitiesOfClass)(*(::AlignmentTask::QuantityClass*)arg[0]);
}

static  void method_5184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::AlignmentTask*)o)->ConstraintsForClass)(*(::AlignmentTask::QuantityClass*)arg[0]));
  else   (((::AlignmentTask*)o)->ConstraintsForClass)(*(::AlignmentTask::QuantityClass*)arg[0]);
}

static  void method_5185( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::AlignmentTask*)o)->BuildHomogeneousConstraints)(*(::std::vector<AlignmentConstraint>*)arg[0]);
}

static  void method_5186( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::AlignmentTask*)o)->BuildFixedDetectorsConstraints)(*(::std::vector<AlignmentConstraint>*)arg[0]);
}

static  void method_5187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::AlignmentTask*)o)->BuildOfficialConstraints)(*(::std::vector<AlignmentConstraint>*)arg[0]);
}

static  void method_5188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::AlignmentTask*)o)->BuildOneRotZPerPotConstraints)(*(::std::vector<AlignmentConstraint>*)arg[0]);
}

static void method_newdel_877( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::AlignmentTask >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::AlignmentTask >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::AlignmentTask >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::AlignmentTask >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::AlignmentTask >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class AlignmentTask -------------------------------
void __AlignmentTask_db_datamem(Reflex::Class*);
void __AlignmentTask_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __AlignmentTask_datamem_bld(&__AlignmentTask_db_datamem);
Reflex::GenreflexMemberBuilder __AlignmentTask_funcmem_bld(&__AlignmentTask_db_funcmem);
void __AlignmentTask_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("AlignmentTask"), typeid(::AlignmentTask), sizeof(::AlignmentTask), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("AlignmentTask::QuantityClass"), Reflex::Literal("qcShR=0;qcShZ=1;qcRotZ=2;qcRPShZ=3"), &typeid(AlignmentTask::QuantityClass), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AlignmentTask"), destructor_5176, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20980, type_20981), Reflex::Literal("operator="), operator_5177, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20981), Reflex::Literal("AlignmentTask"), constructor_5178, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AlignmentTask"), constructor_5180, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11203), Reflex::Literal("AlignmentTask"), constructor_5181, 0, "ps", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_877, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__AlignmentTask_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__AlignmentTask_funcmem_bld);
}

//------Delayed data member builder for class AlignmentTask -------------------
void __AlignmentTask_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2653, Reflex::Literal("quantityClasses"), OffsetOf(__shadow__::__AlignmentTask, quantityClasses), ::Reflex::PUBLIC)
  .AddDataMember(type_583, Reflex::Literal("resolveShR"), OffsetOf(__shadow__::__AlignmentTask, resolveShR), ::Reflex::PUBLIC)
  .AddDataMember(type_583, Reflex::Literal("resolveShZ"), OffsetOf(__shadow__::__AlignmentTask, resolveShZ), ::Reflex::PUBLIC)
  .AddDataMember(type_583, Reflex::Literal("resolveRotZ"), OffsetOf(__shadow__::__AlignmentTask, resolveRotZ), ::Reflex::PUBLIC)
  .AddDataMember(type_583, Reflex::Literal("resolveRPShZ"), OffsetOf(__shadow__::__AlignmentTask, resolveRPShZ), ::Reflex::PUBLIC)
  .AddDataMember(type_583, Reflex::Literal("oneRotZPerPot"), OffsetOf(__shadow__::__AlignmentTask, oneRotZPerPot), ::Reflex::PUBLIC)
  .AddDataMember(type_583, Reflex::Literal("useExtendedRotZConstraint"), OffsetOf(__shadow__::__AlignmentTask, useExtendedRotZConstraint), ::Reflex::PUBLIC)
  .AddDataMember(type_583, Reflex::Literal("useZeroThetaRotZConstraint"), OffsetOf(__shadow__::__AlignmentTask, useZeroThetaRotZConstraint), ::Reflex::PUBLIC)
  .AddDataMember(type_583, Reflex::Literal("useExtendedShZConstraints"), OffsetOf(__shadow__::__AlignmentTask, useExtendedShZConstraints), ::Reflex::PUBLIC)
  .AddDataMember(type_583, Reflex::Literal("useExtendedRPShZConstraint"), OffsetOf(__shadow__::__AlignmentTask, useExtendedRPShZConstraint), ::Reflex::PUBLIC)
  .AddDataMember(type_1596, Reflex::Literal("geometry"), OffsetOf(__shadow__::__AlignmentTask, geometry), ::Reflex::PUBLIC)
  .AddDataMember(type_5045, Reflex::Literal("homogeneousConstraints"), OffsetOf(__shadow__::__AlignmentTask, homogeneousConstraints), ::Reflex::PUBLIC | ::Reflex::TRANSIENT)
  .AddDataMember(type_5045, Reflex::Literal("fixedDetectorsConstraints"), OffsetOf(__shadow__::__AlignmentTask, fixedDetectorsConstraints), ::Reflex::PUBLIC | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class AlignmentTask -------------------
void __AlignmentTask_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703, type_5175), Reflex::Literal("QuantityClassTag"), method_5179, 0, "", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_20982, type_2654c, type_20984, type_205, type_20985), Reflex::Literal("BuildGeometry"), method_5182, 0, "RPIds;excludePlanes;;z0;geometry", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58, type_5175), Reflex::Literal("QuantitiesOfClass"), method_5183, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58, type_5175), Reflex::Literal("ConstraintsForClass"), method_5184, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_20986), Reflex::Literal("BuildHomogeneousConstraints"), method_5185, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_20986), Reflex::Literal("BuildFixedDetectorsConstraints"), method_5186, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_20986), Reflex::Literal("BuildOfficialConstraints"), method_5187, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_20986), Reflex::Literal("BuildOneRotZPerPotConstraints"), method_5188, 0, "", ::Reflex::PUBLIC);
}
//------Stub functions for class AlignmentConstraint -------------------------------
static void destructor_6224(void*, void * o, const std::vector<void*>&, void *) {
(((::AlignmentConstraint*)o)->::AlignmentConstraint::~AlignmentConstraint)();
}
static  void operator_6225( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::AlignmentConstraint*)o)->operator=)(*(const ::AlignmentConstraint*)arg[0]);
  else   (((::AlignmentConstraint*)o)->operator=)(*(const ::AlignmentConstraint*)arg[0]);
}

static void constructor_6226( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AlignmentConstraint(*(const ::AlignmentConstraint*)arg[0]);
  else ::new(mem) ::AlignmentConstraint(*(const ::AlignmentConstraint*)arg[0]);
}

static void constructor_6227( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AlignmentConstraint();
  else ::new(mem) ::AlignmentConstraint();
}

static void method_newdel_1094( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::AlignmentConstraint >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::AlignmentConstraint >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::AlignmentConstraint >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::AlignmentConstraint >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::AlignmentConstraint >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class AlignmentConstraint -------------------------------
void __AlignmentConstraint_db_datamem(Reflex::Class*);
void __AlignmentConstraint_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __AlignmentConstraint_datamem_bld(&__AlignmentConstraint_db_datamem);
Reflex::GenreflexMemberBuilder __AlignmentConstraint_funcmem_bld(&__AlignmentConstraint_db_funcmem);
void __AlignmentConstraint_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("AlignmentConstraint"), typeid(::AlignmentConstraint), sizeof(::AlignmentConstraint), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AlignmentConstraint"), destructor_6224, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10236, type_10238), Reflex::Literal("operator="), operator_6225, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10238), Reflex::Literal("AlignmentConstraint"), constructor_6226, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AlignmentConstraint"), constructor_6227, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1094, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__AlignmentConstraint_datamem_bld);
}

//------Delayed data member builder for class AlignmentConstraint -------------------
void __AlignmentConstraint_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_205, Reflex::Literal("val"), OffsetOf(__shadow__::__AlignmentConstraint, val), ::Reflex::PUBLIC)
  .AddDataMember(type_2900, Reflex::Literal("coef"), OffsetOf(__shadow__::__AlignmentConstraint, coef), ::Reflex::PUBLIC)
  .AddDataMember(type_5175, Reflex::Literal("forClass"), OffsetOf(__shadow__::__AlignmentConstraint, forClass), ::Reflex::PUBLIC)
  .AddDataMember(type_583, Reflex::Literal("extended"), OffsetOf(__shadow__::__AlignmentConstraint, extended), ::Reflex::PUBLIC)
  .AddDataMember(type_2703, Reflex::Literal("name"), OffsetOf(__shadow__::__AlignmentConstraint, name), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class AlignmentConstraint -------------------
void __AlignmentConstraint_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class IdealResult -------------------------------
static  void operator_6786( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IdealResult*)o)->operator=)(*(const ::IdealResult*)arg[0]);
  else   (((::IdealResult*)o)->operator=)(*(const ::IdealResult*)arg[0]);
}

static void constructor_6787( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IdealResult(*(const ::IdealResult*)arg[0]);
  else ::new(mem) ::IdealResult(*(const ::IdealResult*)arg[0]);
}

static void constructor_6788( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IdealResult();
  else ::new(mem) ::IdealResult();
}

static void constructor_6789( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IdealResult(*(const ::edm::ParameterSet*)arg[0],
      (::AlignmentTask*)arg[1]);
  else ::new(mem) ::IdealResult(*(const ::edm::ParameterSet*)arg[0],
      (::AlignmentTask*)arg[1]);
}

static void destructor_6790(void*, void * o, const std::vector<void*>&, void *) {
(((::IdealResult*)o)->::IdealResult::~IdealResult)();
}
static  void method_6791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::IdealResult*)o)->GetName)());
  else   (((::IdealResult*)o)->GetName)();
}

static  void method_6792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::IdealResult*)o)->HasErrorEstimate)());
  else   (((::IdealResult*)o)->HasErrorEstimate)();
}

static  void method_6793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IdealResult*)o)->Begin)(*(const ::edm::EventSetup*)arg[0]);
}

static  void method_6794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IdealResult*)o)->Feed)(*(const ::HitCollection*)arg[0],
    *(const ::LocalTrackFit*)arg[1],
    *(const ::LocalTrackFit*)arg[2]);
}

static  void method_6795( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IdealResult*)o)->SaveDiagnostics)((::TDirectory*)arg[0]);
}

static  void method_6796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<SingularMode>)((((::IdealResult*)o)->Analyze)());
  else   (((::IdealResult*)o)->Analyze)();
}

static  void method_6797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::IdealResult*)o)->Solve)(*(const ::std::vector<AlignmentConstraint>*)arg[0],
    *(::RPAlignmentCorrections*)arg[1],
    (::TDirectory*)arg[2]));
  else   (((::IdealResult*)o)->Solve)(*(const ::std::vector<AlignmentConstraint>*)arg[0],
    *(::RPAlignmentCorrections*)arg[1],
    (::TDirectory*)arg[2]);
}

static  void method_6798( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IdealResult*)o)->End)();
}

static void method_newdel_1512( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::IdealResult >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::IdealResult >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::IdealResult >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::IdealResult >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::IdealResult >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("AlignmentAlgorithm")), ::Reflex::BaseOffset< ::IdealResult,::AlignmentAlgorithm >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IdealResult -------------------------------
void __IdealResult_db_datamem(Reflex::Class*);
void __IdealResult_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IdealResult_datamem_bld(&__IdealResult_db_datamem);
Reflex::GenreflexMemberBuilder __IdealResult_funcmem_bld(&__IdealResult_db_funcmem);
void __IdealResult_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IdealResult"), typeid(::IdealResult), sizeof(::IdealResult), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_746, ::Reflex::BaseOffset< ::IdealResult, ::AlignmentAlgorithm >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22102, type_22103), Reflex::Literal("operator="), operator_6786, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22103), Reflex::Literal("IdealResult"), constructor_6787, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IdealResult"), constructor_6788, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11203, type_19626), Reflex::Literal("IdealResult"), constructor_6789, 0, "ps;_t", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IdealResult"), destructor_6790, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1512, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__IdealResult_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__IdealResult_funcmem_bld);
}

//------Delayed data member builder for class IdealResult -------------------
void __IdealResult_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5024, Reflex::Literal("gReal"), OffsetOf(__shadow__::__IdealResult, gReal), ::Reflex::PROTECTED)
  .AddDataMember(type_5024, Reflex::Literal("gMisaligned"), OffsetOf(__shadow__::__IdealResult, gMisaligned), ::Reflex::PROTECTED)
  .AddDataMember(type_583, Reflex::Literal("useExtendedConstraints"), OffsetOf(__shadow__::__IdealResult, useExtendedConstraints), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class IdealResult -------------------
void __IdealResult_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703), Reflex::Literal("GetName"), method_6791, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("HasErrorEstimate"), method_6792, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_19627), Reflex::Literal("Begin"), method_6793, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_19628, type_19629, type_19629), Reflex::Literal("Feed"), method_6794, 0, ";;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_19630), Reflex::Literal("SaveDiagnostics"), method_6795, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2628), Reflex::Literal("Analyze"), method_6796, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58, type_19631, type_19632, type_19630), Reflex::Literal("Solve"), method_6797, 0, ";result;dir", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("End"), method_6798, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class SingularMode -------------------------------
static void destructor_7056(void*, void * o, const std::vector<void*>&, void *) {
(((::SingularMode*)o)->::SingularMode::~SingularMode)();
}
static  void operator_7057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SingularMode*)o)->operator=)(*(const ::SingularMode*)arg[0]);
  else   (((::SingularMode*)o)->operator=)(*(const ::SingularMode*)arg[0]);
}

static void constructor_7058( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SingularMode(*(const ::SingularMode*)arg[0]);
  else ::new(mem) ::SingularMode(*(const ::SingularMode*)arg[0]);
}

static void constructor_7059( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SingularMode();
  else ::new(mem) ::SingularMode();
}

static void method_newdel_1586( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SingularMode >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SingularMode >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SingularMode >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SingularMode >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SingularMode >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SingularMode -------------------------------
void __SingularMode_db_datamem(Reflex::Class*);
void __SingularMode_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SingularMode_datamem_bld(&__SingularMode_db_datamem);
Reflex::GenreflexMemberBuilder __SingularMode_funcmem_bld(&__SingularMode_db_funcmem);
void __SingularMode_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SingularMode"), typeid(::SingularMode), sizeof(::SingularMode), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SingularMode"), destructor_7056, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10171, type_10173), Reflex::Literal("operator="), operator_7057, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10173), Reflex::Literal("SingularMode"), constructor_7058, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SingularMode"), constructor_7059, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1586, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SingularMode_datamem_bld);
}

//------Delayed data member builder for class SingularMode -------------------
void __SingularMode_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_205, Reflex::Literal("val"), OffsetOf(__shadow__::__SingularMode, val), ::Reflex::PUBLIC)
  .AddDataMember(type_1867, Reflex::Literal("vec"), OffsetOf(__shadow__::__SingularMode, vec), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("idx"), OffsetOf(__shadow__::__SingularMode, idx), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class SingularMode -------------------
void __SingularMode_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class AlignmentGeometry -------------------------------
static void destructor_7062(void*, void * o, const std::vector<void*>&, void *) {
(((::AlignmentGeometry*)o)->::AlignmentGeometry::~AlignmentGeometry)();
}
static  void operator_7063( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::AlignmentGeometry*)o)->operator=)(*(const ::AlignmentGeometry*)arg[0]);
  else   (((::AlignmentGeometry*)o)->operator=)(*(const ::AlignmentGeometry*)arg[0]);
}

static void constructor_7064( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AlignmentGeometry(*(const ::AlignmentGeometry*)arg[0]);
  else ::new(mem) ::AlignmentGeometry(*(const ::AlignmentGeometry*)arg[0]);
}

static void constructor_7065( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AlignmentGeometry();
  else ::new(mem) ::AlignmentGeometry();
}

static  void method_7066( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::AlignmentGeometry*)o)->Insert)(*(unsigned int*)arg[0],
    *(const ::DetGeometry*)arg[1]);
}

static  void method_7067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::AlignmentGeometry*)o)->RPs)());
  else   (((::AlignmentGeometry*)o)->RPs)();
}

static  void method_7068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::AlignmentGeometry*)o)->Detectors)());
  else   (((::AlignmentGeometry*)o)->Detectors)();
}

static  void method_7069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::AlignmentGeometry*)o)->MatrixIndexToDetId)(*(unsigned int*)arg[0]));
  else   (((const ::AlignmentGeometry*)o)->MatrixIndexToDetId)(*(unsigned int*)arg[0]);
}

static  void method_7070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> >)((((const ::AlignmentGeometry*)o)->FindByMatrixIndex)(*(unsigned int*)arg[0]));
  else   (((const ::AlignmentGeometry*)o)->FindByMatrixIndex)(*(unsigned int*)arg[0]);
}

static  void method_7071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> >)((((const ::AlignmentGeometry*)o)->FindFirstByRPMatrixIndex)(*(unsigned int*)arg[0]));
  else   (((const ::AlignmentGeometry*)o)->FindFirstByRPMatrixIndex)(*(unsigned int*)arg[0]);
}

static  void method_7072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::AlignmentGeometry*)o)->ValidSensorId)(*(unsigned int*)arg[0]));
  else   (((const ::AlignmentGeometry*)o)->ValidSensorId)(*(unsigned int*)arg[0]);
}

static  void method_7073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::AlignmentGeometry*)o)->ValidRPId)(*(unsigned int*)arg[0]));
  else   (((const ::AlignmentGeometry*)o)->ValidRPId)(*(unsigned int*)arg[0]);
}

static  void method_7074( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::AlignmentGeometry*)o)->Print)();
}

static  void method_7075( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::AlignmentGeometry*)o)->LoadFromFile)(*(const ::std::string*)arg[0]);
}

static void method_newdel_1596( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::AlignmentGeometry >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::AlignmentGeometry >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::AlignmentGeometry >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::AlignmentGeometry >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::AlignmentGeometry >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,DetGeometry>")), ::Reflex::BaseOffset< ::AlignmentGeometry,::std::map<unsigned int,DetGeometry> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class AlignmentGeometry -------------------------------
void __AlignmentGeometry_db_datamem(Reflex::Class*);
void __AlignmentGeometry_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __AlignmentGeometry_datamem_bld(&__AlignmentGeometry_db_datamem);
Reflex::GenreflexMemberBuilder __AlignmentGeometry_funcmem_bld(&__AlignmentGeometry_db_funcmem);
void __AlignmentGeometry_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("AlignmentGeometry"), typeid(::AlignmentGeometry), sizeof(::AlignmentGeometry), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2899, ::Reflex::BaseOffset< ::AlignmentGeometry, ::std::map<unsigned int,DetGeometry> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AlignmentGeometry"), destructor_7062, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20985, type_24081), Reflex::Literal("operator="), operator_7063, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24081), Reflex::Literal("AlignmentGeometry"), constructor_7064, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AlignmentGeometry"), constructor_7065, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1596, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__AlignmentGeometry_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__AlignmentGeometry_funcmem_bld);
}

//------Delayed data member builder for class AlignmentGeometry -------------------
void __AlignmentGeometry_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2798, Reflex::Literal("rps"), OffsetOf(__shadow__::__AlignmentGeometry, rps), ::Reflex::PROTECTED)
  .AddDataMember(type_205, Reflex::Literal("z0"), OffsetOf(__shadow__::__AlignmentGeometry, z0), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class AlignmentGeometry -------------------
void __AlignmentGeometry_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_58, type_24082), Reflex::Literal("Insert"), method_7066, 0, "id;g", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58), Reflex::Literal("RPs"), method_7067, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58), Reflex::Literal("Detectors"), method_7068, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58, type_58), Reflex::Literal("MatrixIndexToDetId"), method_7069, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3596, type_58), Reflex::Literal("FindByMatrixIndex"), method_7070, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3596, type_58), Reflex::Literal("FindFirstByRPMatrixIndex"), method_7071, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583, type_58), Reflex::Literal("ValidSensorId"), method_7072, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583, type_58), Reflex::Literal("ValidRPId"), method_7073, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("Print"), method_7074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_2703c), Reflex::Literal("LoadFromFile"), method_7075, 0, "filename", ::Reflex::PUBLIC);
}
//------Stub functions for class JanAlignmentAlgorithm -------------------------------
static  void operator_8022( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::JanAlignmentAlgorithm*)o)->operator=)(*(const ::JanAlignmentAlgorithm*)arg[0]);
  else   (((::JanAlignmentAlgorithm*)o)->operator=)(*(const ::JanAlignmentAlgorithm*)arg[0]);
}

static void constructor_8023( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JanAlignmentAlgorithm(*(const ::JanAlignmentAlgorithm*)arg[0]);
  else ::new(mem) ::JanAlignmentAlgorithm(*(const ::JanAlignmentAlgorithm*)arg[0]);
}

static void constructor_8024( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JanAlignmentAlgorithm();
  else ::new(mem) ::JanAlignmentAlgorithm();
}

static void constructor_8025( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JanAlignmentAlgorithm(*(const ::edm::ParameterSet*)arg[0],
      (::AlignmentTask*)arg[1]);
  else ::new(mem) ::JanAlignmentAlgorithm(*(const ::edm::ParameterSet*)arg[0],
      (::AlignmentTask*)arg[1]);
}

static void destructor_8026(void*, void * o, const std::vector<void*>&, void *) {
(((::JanAlignmentAlgorithm*)o)->::JanAlignmentAlgorithm::~JanAlignmentAlgorithm)();
}
static  void method_8027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((::JanAlignmentAlgorithm*)o)->GetName)());
  else   (((::JanAlignmentAlgorithm*)o)->GetName)();
}

static  void method_8028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::JanAlignmentAlgorithm*)o)->HasErrorEstimate)());
  else   (((::JanAlignmentAlgorithm*)o)->HasErrorEstimate)();
}

static  void method_8029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::JanAlignmentAlgorithm*)o)->Begin)(*(const ::edm::EventSetup*)arg[0]);
}

static  void method_8030( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::JanAlignmentAlgorithm*)o)->Feed)(*(const ::HitCollection*)arg[0],
    *(const ::LocalTrackFit*)arg[1],
    *(const ::LocalTrackFit*)arg[2]);
}

static  void method_8031( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::JanAlignmentAlgorithm*)o)->SaveDiagnostics)((::TDirectory*)arg[0]);
}

static  void method_8032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<SingularMode>)((((::JanAlignmentAlgorithm*)o)->Analyze)());
  else   (((::JanAlignmentAlgorithm*)o)->Analyze)();
}

static  void method_8033( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((::JanAlignmentAlgorithm*)o)->Solve)(*(const ::std::vector<AlignmentConstraint>*)arg[0],
    *(::RPAlignmentCorrections*)arg[1],
    (::TDirectory*)arg[2]));
  else   (((::JanAlignmentAlgorithm*)o)->Solve)(*(const ::std::vector<AlignmentConstraint>*)arg[0],
    *(::RPAlignmentCorrections*)arg[1],
    (::TDirectory*)arg[2]);
}

static  void method_8034( void*, void* o, const std::vector<void*>&, void*)
{
  (((::JanAlignmentAlgorithm*)o)->End)();
}

static void method_newdel_2188( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("AlignmentAlgorithm")), ::Reflex::BaseOffset< ::JanAlignmentAlgorithm,::AlignmentAlgorithm >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class JanAlignmentAlgorithm -------------------------------
void __JanAlignmentAlgorithm_db_datamem(Reflex::Class*);
void __JanAlignmentAlgorithm_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __JanAlignmentAlgorithm_datamem_bld(&__JanAlignmentAlgorithm_db_datamem);
Reflex::GenreflexMemberBuilder __JanAlignmentAlgorithm_funcmem_bld(&__JanAlignmentAlgorithm_db_funcmem);
void __JanAlignmentAlgorithm_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("JanAlignmentAlgorithm"), typeid(::JanAlignmentAlgorithm), sizeof(::JanAlignmentAlgorithm), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_746, ::Reflex::BaseOffset< ::JanAlignmentAlgorithm, ::AlignmentAlgorithm >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24591, type_24592), Reflex::Literal("operator="), operator_8022, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24592), Reflex::Literal("JanAlignmentAlgorithm"), constructor_8023, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("JanAlignmentAlgorithm"), constructor_8024, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11203, type_19626), Reflex::Literal("JanAlignmentAlgorithm"), constructor_8025, 0, "ps;_t", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~JanAlignmentAlgorithm"), destructor_8026, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2188, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__JanAlignmentAlgorithm_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__JanAlignmentAlgorithm_funcmem_bld);
}

//------Delayed data member builder for class JanAlignmentAlgorithm -------------------
void __JanAlignmentAlgorithm_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_24575, Reflex::Literal("Sc"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, Sc), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_24576, Reflex::Literal("Mc"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, Mc), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_138, Reflex::Literal("S"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, S), ::Reflex::PRIVATE)
  .AddDataMember(type_1867, Reflex::Literal("M"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, M), ::Reflex::PRIVATE)
  .AddDataMember(type_1867, Reflex::Literal("S_eigVal"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, S_eigVal), ::Reflex::PRIVATE)
  .AddDataMember(type_138, Reflex::Literal("S_eigVec"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, S_eigVec), ::Reflex::PRIVATE)
  .AddDataMember(type_2628, Reflex::Literal("singularModes"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, singularModes), ::Reflex::PRIVATE)
  .AddDataMember(type_583, Reflex::Literal("stopOnSingularModes"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, stopOnSingularModes), ::Reflex::PRIVATE)
  .AddDataMember(type_205, Reflex::Literal("weakLimit"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, weakLimit), ::Reflex::PRIVATE)
  .AddDataMember(type_58, Reflex::Literal("events"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, events), ::Reflex::PRIVATE)
  .AddDataMember(type_2898, Reflex::Literal("statistics"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, statistics), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_583, Reflex::Literal("buildDiagnosticPlots"), OffsetOf(__shadow__::__JanAlignmentAlgorithm, buildDiagnosticPlots), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class JanAlignmentAlgorithm -------------------
void __JanAlignmentAlgorithm_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703), Reflex::Literal("GetName"), method_8027, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("HasErrorEstimate"), method_8028, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_19627), Reflex::Literal("Begin"), method_8029, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_19628, type_19629, type_19629), Reflex::Literal("Feed"), method_8030, 0, ";;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_19630), Reflex::Literal("SaveDiagnostics"), method_8031, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2628), Reflex::Literal("Analyze"), method_8032, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_58, type_19631, type_19632, type_19630), Reflex::Literal("Solve"), method_8033, 0, ";result;dir", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("End"), method_8034, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL);
}
//------Stub functions for class LocalTrackFitter -------------------------------
static  void operator_8150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::LocalTrackFitter*)o)->operator=)(*(const ::LocalTrackFitter*)arg[0]);
  else   (((::LocalTrackFitter*)o)->operator=)(*(const ::LocalTrackFitter*)arg[0]);
}

static void constructor_8151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFitter(*(const ::LocalTrackFitter*)arg[0]);
  else ::new(mem) ::LocalTrackFitter(*(const ::LocalTrackFitter*)arg[0]);
}

static void constructor_8152( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFitter();
  else ::new(mem) ::LocalTrackFitter();
}

static void constructor_8153( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFitter(*(const ::edm::ParameterSet*)arg[0]);
  else ::new(mem) ::LocalTrackFitter(*(const ::edm::ParameterSet*)arg[0]);
}

static void destructor_8154(void*, void * o, const std::vector<void*>&, void *) {
(((::LocalTrackFitter*)o)->::LocalTrackFitter::~LocalTrackFitter)();
}
static  void method_8155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::LocalTrackFitter*)o)->Fit)(*(::HitCollection*)arg[0],
    *(const ::AlignmentGeometry*)arg[1],
    *(::LocalTrackFit*)arg[2]));
  else   (((::LocalTrackFitter*)o)->Fit)(*(::HitCollection*)arg[0],
    *(const ::AlignmentGeometry*)arg[1],
    *(::LocalTrackFit*)arg[2]);
}

static void method_newdel_2266( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::LocalTrackFitter >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::LocalTrackFitter >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::LocalTrackFitter >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::LocalTrackFitter >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::LocalTrackFitter >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class LocalTrackFitter -------------------------------
void __LocalTrackFitter_db_datamem(Reflex::Class*);
void __LocalTrackFitter_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __LocalTrackFitter_datamem_bld(&__LocalTrackFitter_db_datamem);
Reflex::GenreflexMemberBuilder __LocalTrackFitter_funcmem_bld(&__LocalTrackFitter_db_funcmem);
void __LocalTrackFitter_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("LocalTrackFitter"), typeid(::LocalTrackFitter), sizeof(::LocalTrackFitter), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25710, type_25711), Reflex::Literal("operator="), operator_8150, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25711), Reflex::Literal("LocalTrackFitter"), constructor_8151, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("LocalTrackFitter"), constructor_8152, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11203), Reflex::Literal("LocalTrackFitter"), constructor_8153, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~LocalTrackFitter"), destructor_8154, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2266, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__LocalTrackFitter_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__LocalTrackFitter_funcmem_bld);
}

//------Delayed data member builder for class LocalTrackFitter -------------------
void __LocalTrackFitter_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_58, Reflex::Literal("verbosity"), OffsetOf(__shadow__::__LocalTrackFitter, verbosity), ::Reflex::PROTECTED)
  .AddDataMember(type_58, Reflex::Literal("minimumHitsPerProjectionPerRP"), OffsetOf(__shadow__::__LocalTrackFitter, minimumHitsPerProjectionPerRP), ::Reflex::PROTECTED)
  .AddDataMember(type_205, Reflex::Literal("maxResidualToSigma"), OffsetOf(__shadow__::__LocalTrackFitter, maxResidualToSigma), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class LocalTrackFitter -------------------
void __LocalTrackFitter_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583, type_25712, type_24081, type_22090), Reflex::Literal("Fit"), method_8155, 0, ";;", ::Reflex::PUBLIC);
}
//------Stub functions for class DetGeometry -------------------------------
static void destructor_8888(void*, void * o, const std::vector<void*>&, void *) {
(((::DetGeometry*)o)->::DetGeometry::~DetGeometry)();
}
static  void operator_8889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::DetGeometry*)o)->operator=)(*(const ::DetGeometry*)arg[0]);
  else   (((::DetGeometry*)o)->operator=)(*(const ::DetGeometry*)arg[0]);
}

static void constructor_8890( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DetGeometry(*(const ::DetGeometry*)arg[0]);
  else ::new(mem) ::DetGeometry(*(const ::DetGeometry*)arg[0]);
}

static void constructor_8891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::DetGeometry();
  else ::new(mem) ::DetGeometry();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::DetGeometry(*(double*)arg[0]);
  else ::new(mem) ::DetGeometry(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::DetGeometry(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::DetGeometry(*(double*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::DetGeometry(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::DetGeometry(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::DetGeometry(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  else ::new(mem) ::DetGeometry(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::DetGeometry(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
  else ::new(mem) ::DetGeometry(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::DetGeometry(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(bool*)arg[5]);
  else ::new(mem) ::DetGeometry(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(bool*)arg[5]);
  }
}

static void constructor_x12( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DetGeometry();
  else ::new(mem) ::DetGeometry();
}

static void method_newdel_2443( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::DetGeometry >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::DetGeometry >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::DetGeometry >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::DetGeometry >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::DetGeometry >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DetGeometry -------------------------------
void __DetGeometry_db_datamem(Reflex::Class*);
void __DetGeometry_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __DetGeometry_datamem_bld(&__DetGeometry_db_datamem);
Reflex::GenreflexMemberBuilder __DetGeometry_funcmem_bld(&__DetGeometry_db_funcmem);
void __DetGeometry_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("DetGeometry"), typeid(::DetGeometry), sizeof(::DetGeometry), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetGeometry"), destructor_8888, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26223, type_24082), Reflex::Literal("operator="), operator_8889, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24082), Reflex::Literal("DetGeometry"), constructor_8890, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_205, type_205, type_205, type_205, type_205, type_583), Reflex::Literal("DetGeometry"), constructor_8891, 0, "_z=0.0;_dx=0.0;_dy=0.0;_sx=0.0;_sy=0.0;_isU=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetGeometry"), constructor_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2443, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__DetGeometry_datamem_bld);
}

//------Delayed data member builder for class DetGeometry -------------------
void __DetGeometry_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_205, Reflex::Literal("z"), OffsetOf(__shadow__::__DetGeometry, z), ::Reflex::PUBLIC)
  .AddDataMember(type_205, Reflex::Literal("dx"), OffsetOf(__shadow__::__DetGeometry, dx), ::Reflex::PUBLIC)
  .AddDataMember(type_205, Reflex::Literal("dy"), OffsetOf(__shadow__::__DetGeometry, dy), ::Reflex::PUBLIC)
  .AddDataMember(type_205, Reflex::Literal("sx"), OffsetOf(__shadow__::__DetGeometry, sx), ::Reflex::PUBLIC)
  .AddDataMember(type_205, Reflex::Literal("sy"), OffsetOf(__shadow__::__DetGeometry, sy), ::Reflex::PUBLIC)
  .AddDataMember(type_205, Reflex::Literal("s"), OffsetOf(__shadow__::__DetGeometry, s), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("matrixIndex"), OffsetOf(__shadow__::__DetGeometry, matrixIndex), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("rpMatrixIndex"), OffsetOf(__shadow__::__DetGeometry, rpMatrixIndex), ::Reflex::PUBLIC)
  .AddDataMember(type_583, Reflex::Literal("isU"), OffsetOf(__shadow__::__DetGeometry, isU), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class DetGeometry -------------------
void __DetGeometry_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<TGraph*,std::allocator<TGraph*> > -------------------------------
static void constructor_10051( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TGraph*>();
  else ::new(mem) ::std::vector<TGraph*>();
}

static void constructor_10052( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TGraph*>(*(const ::std::allocator<TGraph*>*)arg[0]);
  else ::new(mem) ::std::vector<TGraph*>(*(const ::std::allocator<TGraph*>*)arg[0]);
}

static void constructor_10053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TGraph*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TGraph*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TGraph*>(*(::std::size_t*)arg[0],
      *(::TGraph* const*)arg[1]);
  else ::new(mem) ::std::vector<TGraph*>(*(::std::size_t*)arg[0],
      *(::TGraph* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TGraph*>(*(::std::size_t*)arg[0],
      *(::TGraph* const*)arg[1],
      *(const ::std::allocator<TGraph*>*)arg[2]);
  else ::new(mem) ::std::vector<TGraph*>(*(::std::size_t*)arg[0],
      *(::TGraph* const*)arg[1],
      *(const ::std::allocator<TGraph*>*)arg[2]);
  }
}

static void constructor_10054( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TGraph*>(*(const ::std::vector<TGraph*>*)arg[0]);
  else ::new(mem) ::std::vector<TGraph*>(*(const ::std::vector<TGraph*>*)arg[0]);
}

static void destructor_10055(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TGraph*>*)o)->::std::vector<TGraph*>::~vector)();
}
static  void operator_10056( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TGraph*>*)o)->operator=)(*(const ::std::vector<TGraph*>*)arg[0]);
  else   (((::std::vector<TGraph*>*)o)->operator=)(*(const ::std::vector<TGraph*>*)arg[0]);
}

static  void method_10057( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TGraph*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::TGraph* const*)arg[1]);
}

static  void method_10058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >)((((::std::vector<TGraph*>*)o)->begin)());
  else   (((::std::vector<TGraph*>*)o)->begin)();
}

static  void method_10059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TGraph* const*,std::vector<TGraph*> >)((((const ::std::vector<TGraph*>*)o)->begin)());
  else   (((const ::std::vector<TGraph*>*)o)->begin)();
}

static  void method_10060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >)((((::std::vector<TGraph*>*)o)->end)());
  else   (((::std::vector<TGraph*>*)o)->end)();
}

static  void method_10061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TGraph* const*,std::vector<TGraph*> >)((((const ::std::vector<TGraph*>*)o)->end)());
  else   (((const ::std::vector<TGraph*>*)o)->end)();
}

static  void method_10066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TGraph*>*)o)->size)());
  else   (((const ::std::vector<TGraph*>*)o)->size)();
}

static  void method_10067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TGraph*>*)o)->max_size)());
  else   (((const ::std::vector<TGraph*>*)o)->max_size)();
}

static  void method_10068( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TGraph*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TGraph*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::TGraph*)arg[1]);
  }
}

static  void method_10069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TGraph*>*)o)->capacity)());
  else   (((const ::std::vector<TGraph*>*)o)->capacity)();
}

static  void method_10070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TGraph*>*)o)->empty)());
  else   (((const ::std::vector<TGraph*>*)o)->empty)();
}

static  void method_10071( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TGraph*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TGraph*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TGraph*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TGraph*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TGraph*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TGraph*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TGraph*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TGraph*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TGraph*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TGraph*>*)o)->front)();
  else   (((::std::vector<TGraph*>*)o)->front)();
}

static  void method_10078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TGraph*>*)o)->front)();
  else   (((const ::std::vector<TGraph*>*)o)->front)();
}

static  void method_10079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TGraph*>*)o)->back)();
  else   (((::std::vector<TGraph*>*)o)->back)();
}

static  void method_10080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TGraph*>*)o)->back)();
  else   (((const ::std::vector<TGraph*>*)o)->back)();
}

static  void method_10081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TGraph*>*)o)->data)());
  else   (((::std::vector<TGraph*>*)o)->data)();
}

static  void method_10082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TGraph*>*)o)->data)());
  else   (((const ::std::vector<TGraph*>*)o)->data)();
}

static  void method_10083( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TGraph*>*)o)->push_back)(*(::TGraph* const*)arg[0]);
}

static  void method_10084( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TGraph*>*)o)->pop_back)();
}

static  void method_10085( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >)((((::std::vector<TGraph*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >*)arg[0],
    *(::TGraph* const*)arg[1]));
  else   (((::std::vector<TGraph*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >*)arg[0],
    *(::TGraph* const*)arg[1]);
}

static  void method_10086( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TGraph*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::TGraph* const*)arg[2]);
}

static  void method_10087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >)((((::std::vector<TGraph*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >*)arg[0]));
  else   (((::std::vector<TGraph*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >*)arg[0]);
}

static  void method_10088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >)((((::std::vector<TGraph*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >*)arg[1]));
  else   (((::std::vector<TGraph*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TGraph**,std::vector<TGraph*> >*)arg[1]);
}

static  void method_10089( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TGraph*>*)o)->swap)(*(::std::vector<TGraph*>*)arg[0]);
}

static  void method_10090( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TGraph*>*)o)->clear)();
}

static void method_newdel_2626( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TGraph*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TGraph*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TGraph*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TGraph*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TGraph*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TGraph*,std::allocator<TGraph*> >")), ::Reflex::BaseOffset< ::std::vector<TGraph*>,::std::_Vector_base<TGraph*,std::allocator<TGraph*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TGraph*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TGraph*> >::Generate();
}

//------Dictionary for class vector<TGraph*,std::allocator<TGraph*> > -------------------------------
void __std__vector_TGraphp__db_datamem(Reflex::Class*);
void __std__vector_TGraphp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TGraphp__datamem_bld(&__std__vector_TGraphp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TGraphp__funcmem_bld(&__std__vector_TGraphp__db_funcmem);
void __std__vector_TGraphp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TGraph*>"), typeid(::std::vector<TGraph*>), sizeof(::std::vector<TGraph*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2573, ::Reflex::BaseOffset< ::std::vector<TGraph*>, ::std::_Vector_base<TGraph*,std::allocator<TGraph*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_10031, Reflex::Literal("std::vector<TGraph*>::_Alloc_value_type"))
  .AddTypedef(type_2573, Reflex::Literal("std::vector<TGraph*>::_Base"))
  .AddTypedef(type_3239, Reflex::Literal("std::vector<TGraph*>::_Tp_alloc_type"))
  .AddTypedef(type_6968, Reflex::Literal("std::vector<TGraph*>::_Alloc_traits"))
  .AddTypedef(type_10031, Reflex::Literal("std::vector<TGraph*>::value_type"))
  .AddTypedef(type_9593, Reflex::Literal("std::vector<TGraph*>::pointer"))
  .AddTypedef(type_10038, Reflex::Literal("std::vector<TGraph*>::const_pointer"))
  .AddTypedef(type_10040, Reflex::Literal("std::vector<TGraph*>::reference"))
  .AddTypedef(type_10042, Reflex::Literal("std::vector<TGraph*>::const_reference"))
  .AddTypedef(type_6832, Reflex::Literal("std::vector<TGraph*>::iterator"))
  .AddTypedef(type_6833, Reflex::Literal("std::vector<TGraph*>::const_iterator"))
  .AddTypedef(type_3460, Reflex::Literal("std::vector<TGraph*>::const_reverse_iterator"))
  .AddTypedef(type_3461, Reflex::Literal("std::vector<TGraph*>::reverse_iterator"))
  .AddTypedef(type_3214, Reflex::Literal("std::vector<TGraph*>::size_type"))
  .AddTypedef(type_2802, Reflex::Literal("std::vector<TGraph*>::difference_type"))
  .AddTypedef(type_3239, Reflex::Literal("std::vector<TGraph*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10051, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26342), Reflex::Literal("vector"), constructor_10052, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3214, type_10042, type_26342), Reflex::Literal("vector"), constructor_10053, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26602), Reflex::Literal("vector"), constructor_10054, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10055, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2626, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TGraphp__funcmem_bld);
}

//------Delayed data member builder for class vector<TGraph*,std::allocator<TGraph*> > -------------------
void __std__vector_TGraphp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TGraph*,std::allocator<TGraph*> > -------------------
void __std__vector_TGraphp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26603, type_26602), Reflex::Literal("operator="), operator_10056, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214, type_10042), Reflex::Literal("assign"), method_10057, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6832), Reflex::Literal("begin"), method_10058, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6833), Reflex::Literal("begin"), method_10059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6832), Reflex::Literal("end"), method_10060, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6833), Reflex::Literal("end"), method_10061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("size"), method_10066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("max_size"), method_10067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214, type_10031), Reflex::Literal("resize"), method_10068, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("capacity"), method_10069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("empty"), method_10070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214), Reflex::Literal("reserve"), method_10071, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10040, type_3214), Reflex::Literal("operator[]"), operator_10072, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10042, type_3214), Reflex::Literal("operator[]"), operator_10073, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10040, type_3214), Reflex::Literal("at"), method_10075, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10042, type_3214), Reflex::Literal("at"), method_10076, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10040), Reflex::Literal("front"), method_10077, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10042), Reflex::Literal("front"), method_10078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10040), Reflex::Literal("back"), method_10079, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10042), Reflex::Literal("back"), method_10080, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9593), Reflex::Literal("data"), method_10081, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10038), Reflex::Literal("data"), method_10082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_10042), Reflex::Literal("push_back"), method_10083, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("pop_back"), method_10084, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6832, type_6832, type_10042), Reflex::Literal("insert"), method_10085, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_6832, type_3214, type_10042), Reflex::Literal("insert"), method_10086, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6832, type_6832), Reflex::Literal("erase"), method_10087, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6832, type_6832, type_6832), Reflex::Literal("erase"), method_10088, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_26603), Reflex::Literal("swap"), method_10089, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("clear"), method_10090, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<TH1D*,std::allocator<TH1D*> > -------------------------------
static void constructor_10117( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TH1D*>();
  else ::new(mem) ::std::vector<TH1D*>();
}

static void constructor_10118( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TH1D*>(*(const ::std::allocator<TH1D*>*)arg[0]);
  else ::new(mem) ::std::vector<TH1D*>(*(const ::std::allocator<TH1D*>*)arg[0]);
}

static void constructor_10119( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TH1D*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TH1D*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TH1D*>(*(::std::size_t*)arg[0],
      *(::TH1D* const*)arg[1]);
  else ::new(mem) ::std::vector<TH1D*>(*(::std::size_t*)arg[0],
      *(::TH1D* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TH1D*>(*(::std::size_t*)arg[0],
      *(::TH1D* const*)arg[1],
      *(const ::std::allocator<TH1D*>*)arg[2]);
  else ::new(mem) ::std::vector<TH1D*>(*(::std::size_t*)arg[0],
      *(::TH1D* const*)arg[1],
      *(const ::std::allocator<TH1D*>*)arg[2]);
  }
}

static void constructor_10120( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TH1D*>(*(const ::std::vector<TH1D*>*)arg[0]);
  else ::new(mem) ::std::vector<TH1D*>(*(const ::std::vector<TH1D*>*)arg[0]);
}

static void destructor_10121(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TH1D*>*)o)->::std::vector<TH1D*>::~vector)();
}
static  void operator_10122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TH1D*>*)o)->operator=)(*(const ::std::vector<TH1D*>*)arg[0]);
  else   (((::std::vector<TH1D*>*)o)->operator=)(*(const ::std::vector<TH1D*>*)arg[0]);
}

static  void method_10123( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TH1D*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::TH1D* const*)arg[1]);
}

static  void method_10124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >)((((::std::vector<TH1D*>*)o)->begin)());
  else   (((::std::vector<TH1D*>*)o)->begin)();
}

static  void method_10125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TH1D* const*,std::vector<TH1D*> >)((((const ::std::vector<TH1D*>*)o)->begin)());
  else   (((const ::std::vector<TH1D*>*)o)->begin)();
}

static  void method_10126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >)((((::std::vector<TH1D*>*)o)->end)());
  else   (((::std::vector<TH1D*>*)o)->end)();
}

static  void method_10127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TH1D* const*,std::vector<TH1D*> >)((((const ::std::vector<TH1D*>*)o)->end)());
  else   (((const ::std::vector<TH1D*>*)o)->end)();
}

static  void method_10132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TH1D*>*)o)->size)());
  else   (((const ::std::vector<TH1D*>*)o)->size)();
}

static  void method_10133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TH1D*>*)o)->max_size)());
  else   (((const ::std::vector<TH1D*>*)o)->max_size)();
}

static  void method_10134( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TH1D*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TH1D*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::TH1D*)arg[1]);
  }
}

static  void method_10135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TH1D*>*)o)->capacity)());
  else   (((const ::std::vector<TH1D*>*)o)->capacity)();
}

static  void method_10136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TH1D*>*)o)->empty)());
  else   (((const ::std::vector<TH1D*>*)o)->empty)();
}

static  void method_10137( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TH1D*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TH1D*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TH1D*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TH1D*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TH1D*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TH1D*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TH1D*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TH1D*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TH1D*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TH1D*>*)o)->front)();
  else   (((::std::vector<TH1D*>*)o)->front)();
}

static  void method_10144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TH1D*>*)o)->front)();
  else   (((const ::std::vector<TH1D*>*)o)->front)();
}

static  void method_10145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TH1D*>*)o)->back)();
  else   (((::std::vector<TH1D*>*)o)->back)();
}

static  void method_10146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TH1D*>*)o)->back)();
  else   (((const ::std::vector<TH1D*>*)o)->back)();
}

static  void method_10147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TH1D*>*)o)->data)());
  else   (((::std::vector<TH1D*>*)o)->data)();
}

static  void method_10148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TH1D*>*)o)->data)());
  else   (((const ::std::vector<TH1D*>*)o)->data)();
}

static  void method_10149( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TH1D*>*)o)->push_back)(*(::TH1D* const*)arg[0]);
}

static  void method_10150( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TH1D*>*)o)->pop_back)();
}

static  void method_10151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >)((((::std::vector<TH1D*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >*)arg[0],
    *(::TH1D* const*)arg[1]));
  else   (((::std::vector<TH1D*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >*)arg[0],
    *(::TH1D* const*)arg[1]);
}

static  void method_10152( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TH1D*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::TH1D* const*)arg[2]);
}

static  void method_10153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >)((((::std::vector<TH1D*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >*)arg[0]));
  else   (((::std::vector<TH1D*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >*)arg[0]);
}

static  void method_10154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >)((((::std::vector<TH1D*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >*)arg[1]));
  else   (((::std::vector<TH1D*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TH1D**,std::vector<TH1D*> >*)arg[1]);
}

static  void method_10155( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TH1D*>*)o)->swap)(*(::std::vector<TH1D*>*)arg[0]);
}

static  void method_10156( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TH1D*>*)o)->clear)();
}

static void method_newdel_2627( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TH1D*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TH1D*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TH1D*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TH1D*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TH1D*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TH1D*,std::allocator<TH1D*> >")), ::Reflex::BaseOffset< ::std::vector<TH1D*>,::std::_Vector_base<TH1D*,std::allocator<TH1D*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TH1D*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TH1D*> >::Generate();
}

//------Dictionary for class vector<TH1D*,std::allocator<TH1D*> > -------------------------------
void __std__vector_TH1Dp__db_datamem(Reflex::Class*);
void __std__vector_TH1Dp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TH1Dp__datamem_bld(&__std__vector_TH1Dp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TH1Dp__funcmem_bld(&__std__vector_TH1Dp__db_funcmem);
void __std__vector_TH1Dp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TH1D*>"), typeid(::std::vector<TH1D*>), sizeof(::std::vector<TH1D*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2574, ::Reflex::BaseOffset< ::std::vector<TH1D*>, ::std::_Vector_base<TH1D*,std::allocator<TH1D*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_10097, Reflex::Literal("std::vector<TH1D*>::_Alloc_value_type"))
  .AddTypedef(type_2574, Reflex::Literal("std::vector<TH1D*>::_Base"))
  .AddTypedef(type_3240, Reflex::Literal("std::vector<TH1D*>::_Tp_alloc_type"))
  .AddTypedef(type_6969, Reflex::Literal("std::vector<TH1D*>::_Alloc_traits"))
  .AddTypedef(type_10097, Reflex::Literal("std::vector<TH1D*>::value_type"))
  .AddTypedef(type_9612, Reflex::Literal("std::vector<TH1D*>::pointer"))
  .AddTypedef(type_10104, Reflex::Literal("std::vector<TH1D*>::const_pointer"))
  .AddTypedef(type_10106, Reflex::Literal("std::vector<TH1D*>::reference"))
  .AddTypedef(type_10108, Reflex::Literal("std::vector<TH1D*>::const_reference"))
  .AddTypedef(type_6834, Reflex::Literal("std::vector<TH1D*>::iterator"))
  .AddTypedef(type_6835, Reflex::Literal("std::vector<TH1D*>::const_iterator"))
  .AddTypedef(type_3462, Reflex::Literal("std::vector<TH1D*>::const_reverse_iterator"))
  .AddTypedef(type_3463, Reflex::Literal("std::vector<TH1D*>::reverse_iterator"))
  .AddTypedef(type_3214, Reflex::Literal("std::vector<TH1D*>::size_type"))
  .AddTypedef(type_2802, Reflex::Literal("std::vector<TH1D*>::difference_type"))
  .AddTypedef(type_3240, Reflex::Literal("std::vector<TH1D*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10117, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26355), Reflex::Literal("vector"), constructor_10118, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3214, type_10108, type_26355), Reflex::Literal("vector"), constructor_10119, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26605), Reflex::Literal("vector"), constructor_10120, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10121, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2627, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TH1Dp__funcmem_bld);
}

//------Delayed data member builder for class vector<TH1D*,std::allocator<TH1D*> > -------------------
void __std__vector_TH1Dp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TH1D*,std::allocator<TH1D*> > -------------------
void __std__vector_TH1Dp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26606, type_26605), Reflex::Literal("operator="), operator_10122, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214, type_10108), Reflex::Literal("assign"), method_10123, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6834), Reflex::Literal("begin"), method_10124, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6835), Reflex::Literal("begin"), method_10125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6834), Reflex::Literal("end"), method_10126, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6835), Reflex::Literal("end"), method_10127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("size"), method_10132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("max_size"), method_10133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214, type_10097), Reflex::Literal("resize"), method_10134, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("capacity"), method_10135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("empty"), method_10136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214), Reflex::Literal("reserve"), method_10137, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10106, type_3214), Reflex::Literal("operator[]"), operator_10138, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10108, type_3214), Reflex::Literal("operator[]"), operator_10139, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10106, type_3214), Reflex::Literal("at"), method_10141, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10108, type_3214), Reflex::Literal("at"), method_10142, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10106), Reflex::Literal("front"), method_10143, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10108), Reflex::Literal("front"), method_10144, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10106), Reflex::Literal("back"), method_10145, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10108), Reflex::Literal("back"), method_10146, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9612), Reflex::Literal("data"), method_10147, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10104), Reflex::Literal("data"), method_10148, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_10108), Reflex::Literal("push_back"), method_10149, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("pop_back"), method_10150, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6834, type_6834, type_10108), Reflex::Literal("insert"), method_10151, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_6834, type_3214, type_10108), Reflex::Literal("insert"), method_10152, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6834, type_6834), Reflex::Literal("erase"), method_10153, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6834, type_6834, type_6834), Reflex::Literal("erase"), method_10154, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_26606), Reflex::Literal("swap"), method_10155, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("clear"), method_10156, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SingularMode,std::allocator<SingularMode> > -------------------------------
static void constructor_10182( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SingularMode>();
  else ::new(mem) ::std::vector<SingularMode>();
}

static void constructor_10183( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SingularMode>(*(const ::std::allocator<SingularMode>*)arg[0]);
  else ::new(mem) ::std::vector<SingularMode>(*(const ::std::allocator<SingularMode>*)arg[0]);
}

static void constructor_10184( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SingularMode>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SingularMode>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SingularMode>(*(::std::size_t*)arg[0],
      *(const ::SingularMode*)arg[1]);
  else ::new(mem) ::std::vector<SingularMode>(*(::std::size_t*)arg[0],
      *(const ::SingularMode*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SingularMode>(*(::std::size_t*)arg[0],
      *(const ::SingularMode*)arg[1],
      *(const ::std::allocator<SingularMode>*)arg[2]);
  else ::new(mem) ::std::vector<SingularMode>(*(::std::size_t*)arg[0],
      *(const ::SingularMode*)arg[1],
      *(const ::std::allocator<SingularMode>*)arg[2]);
  }
}

static void constructor_10185( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SingularMode>(*(const ::std::vector<SingularMode>*)arg[0]);
  else ::new(mem) ::std::vector<SingularMode>(*(const ::std::vector<SingularMode>*)arg[0]);
}

static void destructor_10186(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SingularMode>*)o)->::std::vector<SingularMode>::~vector)();
}
static  void operator_10187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SingularMode>*)o)->operator=)(*(const ::std::vector<SingularMode>*)arg[0]);
  else   (((::std::vector<SingularMode>*)o)->operator=)(*(const ::std::vector<SingularMode>*)arg[0]);
}

static  void method_10188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SingularMode>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SingularMode*)arg[1]);
}

static  void method_10189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >)((((::std::vector<SingularMode>*)o)->begin)());
  else   (((::std::vector<SingularMode>*)o)->begin)();
}

static  void method_10190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SingularMode*,std::vector<SingularMode> >)((((const ::std::vector<SingularMode>*)o)->begin)());
  else   (((const ::std::vector<SingularMode>*)o)->begin)();
}

static  void method_10191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >)((((::std::vector<SingularMode>*)o)->end)());
  else   (((::std::vector<SingularMode>*)o)->end)();
}

static  void method_10192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SingularMode*,std::vector<SingularMode> >)((((const ::std::vector<SingularMode>*)o)->end)());
  else   (((const ::std::vector<SingularMode>*)o)->end)();
}

static  void method_10197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SingularMode>*)o)->size)());
  else   (((const ::std::vector<SingularMode>*)o)->size)();
}

static  void method_10198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SingularMode>*)o)->max_size)());
  else   (((const ::std::vector<SingularMode>*)o)->max_size)();
}

static  void method_10199( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SingularMode>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SingularMode>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SingularMode*)arg[1]);
  }
}

static  void method_10200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SingularMode>*)o)->capacity)());
  else   (((const ::std::vector<SingularMode>*)o)->capacity)();
}

static  void method_10201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SingularMode>*)o)->empty)());
  else   (((const ::std::vector<SingularMode>*)o)->empty)();
}

static  void method_10202( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SingularMode>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10203( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SingularMode>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SingularMode>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SingularMode>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SingularMode>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10206( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SingularMode>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SingularMode>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SingularMode>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SingularMode>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SingularMode>*)o)->front)();
  else   (((::std::vector<SingularMode>*)o)->front)();
}

static  void method_10209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SingularMode>*)o)->front)();
  else   (((const ::std::vector<SingularMode>*)o)->front)();
}

static  void method_10210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SingularMode>*)o)->back)();
  else   (((::std::vector<SingularMode>*)o)->back)();
}

static  void method_10211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SingularMode>*)o)->back)();
  else   (((const ::std::vector<SingularMode>*)o)->back)();
}

static  void method_10212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SingularMode>*)o)->data)());
  else   (((::std::vector<SingularMode>*)o)->data)();
}

static  void method_10213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SingularMode>*)o)->data)());
  else   (((const ::std::vector<SingularMode>*)o)->data)();
}

static  void method_10214( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SingularMode>*)o)->push_back)(*(const ::SingularMode*)arg[0]);
}

static  void method_10215( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SingularMode>*)o)->pop_back)();
}

static  void method_10216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >)((((::std::vector<SingularMode>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >*)arg[0],
    *(const ::SingularMode*)arg[1]));
  else   (((::std::vector<SingularMode>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >*)arg[0],
    *(const ::SingularMode*)arg[1]);
}

static  void method_10217( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SingularMode>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SingularMode*)arg[2]);
}

static  void method_10218( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >)((((::std::vector<SingularMode>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >*)arg[0]));
  else   (((::std::vector<SingularMode>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >*)arg[0]);
}

static  void method_10219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >)((((::std::vector<SingularMode>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >*)arg[1]));
  else   (((::std::vector<SingularMode>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SingularMode*,std::vector<SingularMode> >*)arg[1]);
}

static  void method_10220( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SingularMode>*)o)->swap)(*(::std::vector<SingularMode>*)arg[0]);
}

static  void method_10221( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SingularMode>*)o)->clear)();
}

static void method_newdel_2628( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SingularMode> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SingularMode> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SingularMode> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SingularMode> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SingularMode> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SingularMode,std::allocator<SingularMode> >")), ::Reflex::BaseOffset< ::std::vector<SingularMode>,::std::_Vector_base<SingularMode,std::allocator<SingularMode> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SingularMode> >::Generate();
  else ::Reflex::Proxy< ::std::vector<SingularMode> >::Generate();
}

//------Dictionary for class vector<SingularMode,std::allocator<SingularMode> > -------------------------------
void __std__vector_SingularMode__db_datamem(Reflex::Class*);
void __std__vector_SingularMode__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SingularMode__datamem_bld(&__std__vector_SingularMode__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SingularMode__funcmem_bld(&__std__vector_SingularMode__db_funcmem);
void __std__vector_SingularMode__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SingularMode>"), typeid(::std::vector<SingularMode>), sizeof(::std::vector<SingularMode>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2572, ::Reflex::BaseOffset< ::std::vector<SingularMode>, ::std::_Vector_base<SingularMode,std::allocator<SingularMode> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1586, Reflex::Literal("std::vector<SingularMode>::_Alloc_value_type"))
  .AddTypedef(type_2572, Reflex::Literal("std::vector<SingularMode>::_Base"))
  .AddTypedef(type_3242, Reflex::Literal("std::vector<SingularMode>::_Tp_alloc_type"))
  .AddTypedef(type_6967, Reflex::Literal("std::vector<SingularMode>::_Alloc_traits"))
  .AddTypedef(type_1586, Reflex::Literal("std::vector<SingularMode>::value_type"))
  .AddTypedef(type_9574, Reflex::Literal("std::vector<SingularMode>::pointer"))
  .AddTypedef(type_10169, Reflex::Literal("std::vector<SingularMode>::const_pointer"))
  .AddTypedef(type_10171, Reflex::Literal("std::vector<SingularMode>::reference"))
  .AddTypedef(type_10173, Reflex::Literal("std::vector<SingularMode>::const_reference"))
  .AddTypedef(type_6830, Reflex::Literal("std::vector<SingularMode>::iterator"))
  .AddTypedef(type_6831, Reflex::Literal("std::vector<SingularMode>::const_iterator"))
  .AddTypedef(type_3456, Reflex::Literal("std::vector<SingularMode>::const_reverse_iterator"))
  .AddTypedef(type_3457, Reflex::Literal("std::vector<SingularMode>::reverse_iterator"))
  .AddTypedef(type_3214, Reflex::Literal("std::vector<SingularMode>::size_type"))
  .AddTypedef(type_2802, Reflex::Literal("std::vector<SingularMode>::difference_type"))
  .AddTypedef(type_3242, Reflex::Literal("std::vector<SingularMode>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10182, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26329), Reflex::Literal("vector"), constructor_10183, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3214, type_10173, type_26329), Reflex::Literal("vector"), constructor_10184, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26608), Reflex::Literal("vector"), constructor_10185, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10186, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2628, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SingularMode__funcmem_bld);
}

//------Delayed data member builder for class vector<SingularMode,std::allocator<SingularMode> > -------------------
void __std__vector_SingularMode__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SingularMode,std::allocator<SingularMode> > -------------------
void __std__vector_SingularMode__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26609, type_26608), Reflex::Literal("operator="), operator_10187, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214, type_10173), Reflex::Literal("assign"), method_10188, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6830), Reflex::Literal("begin"), method_10189, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6831), Reflex::Literal("begin"), method_10190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6830), Reflex::Literal("end"), method_10191, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6831), Reflex::Literal("end"), method_10192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("size"), method_10197, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("max_size"), method_10198, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214, type_1586), Reflex::Literal("resize"), method_10199, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("capacity"), method_10200, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("empty"), method_10201, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214), Reflex::Literal("reserve"), method_10202, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10171, type_3214), Reflex::Literal("operator[]"), operator_10203, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10173, type_3214), Reflex::Literal("operator[]"), operator_10204, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10171, type_3214), Reflex::Literal("at"), method_10206, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10173, type_3214), Reflex::Literal("at"), method_10207, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10171), Reflex::Literal("front"), method_10208, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10173), Reflex::Literal("front"), method_10209, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10171), Reflex::Literal("back"), method_10210, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10173), Reflex::Literal("back"), method_10211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9574), Reflex::Literal("data"), method_10212, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10169), Reflex::Literal("data"), method_10213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_10173), Reflex::Literal("push_back"), method_10214, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("pop_back"), method_10215, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6830, type_6830, type_10173), Reflex::Literal("insert"), method_10216, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_6830, type_3214, type_10173), Reflex::Literal("insert"), method_10217, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6830, type_6830), Reflex::Literal("erase"), method_10218, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6830, type_6830, type_6830), Reflex::Literal("erase"), method_10219, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_26609), Reflex::Literal("swap"), method_10220, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("clear"), method_10221, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<AlignmentConstraint,std::allocator<AlignmentConstraint> > -------------------------------
static void constructor_10247( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<AlignmentConstraint>();
  else ::new(mem) ::std::vector<AlignmentConstraint>();
}

static void constructor_10248( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<AlignmentConstraint>(*(const ::std::allocator<AlignmentConstraint>*)arg[0]);
  else ::new(mem) ::std::vector<AlignmentConstraint>(*(const ::std::allocator<AlignmentConstraint>*)arg[0]);
}

static void constructor_10249( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<AlignmentConstraint>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<AlignmentConstraint>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<AlignmentConstraint>(*(::std::size_t*)arg[0],
      *(const ::AlignmentConstraint*)arg[1]);
  else ::new(mem) ::std::vector<AlignmentConstraint>(*(::std::size_t*)arg[0],
      *(const ::AlignmentConstraint*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<AlignmentConstraint>(*(::std::size_t*)arg[0],
      *(const ::AlignmentConstraint*)arg[1],
      *(const ::std::allocator<AlignmentConstraint>*)arg[2]);
  else ::new(mem) ::std::vector<AlignmentConstraint>(*(::std::size_t*)arg[0],
      *(const ::AlignmentConstraint*)arg[1],
      *(const ::std::allocator<AlignmentConstraint>*)arg[2]);
  }
}

static void constructor_10250( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<AlignmentConstraint>(*(const ::std::vector<AlignmentConstraint>*)arg[0]);
  else ::new(mem) ::std::vector<AlignmentConstraint>(*(const ::std::vector<AlignmentConstraint>*)arg[0]);
}

static void destructor_10251(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<AlignmentConstraint>*)o)->::std::vector<AlignmentConstraint>::~vector)();
}
static  void operator_10252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<AlignmentConstraint>*)o)->operator=)(*(const ::std::vector<AlignmentConstraint>*)arg[0]);
  else   (((::std::vector<AlignmentConstraint>*)o)->operator=)(*(const ::std::vector<AlignmentConstraint>*)arg[0]);
}

static  void method_10253( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<AlignmentConstraint>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::AlignmentConstraint*)arg[1]);
}

static  void method_10254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >)((((::std::vector<AlignmentConstraint>*)o)->begin)());
  else   (((::std::vector<AlignmentConstraint>*)o)->begin)();
}

static  void method_10255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const AlignmentConstraint*,std::vector<AlignmentConstraint> >)((((const ::std::vector<AlignmentConstraint>*)o)->begin)());
  else   (((const ::std::vector<AlignmentConstraint>*)o)->begin)();
}

static  void method_10256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >)((((::std::vector<AlignmentConstraint>*)o)->end)());
  else   (((::std::vector<AlignmentConstraint>*)o)->end)();
}

static  void method_10257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const AlignmentConstraint*,std::vector<AlignmentConstraint> >)((((const ::std::vector<AlignmentConstraint>*)o)->end)());
  else   (((const ::std::vector<AlignmentConstraint>*)o)->end)();
}

static  void method_10262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<AlignmentConstraint>*)o)->size)());
  else   (((const ::std::vector<AlignmentConstraint>*)o)->size)();
}

static  void method_10263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<AlignmentConstraint>*)o)->max_size)());
  else   (((const ::std::vector<AlignmentConstraint>*)o)->max_size)();
}

static  void method_10264( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<AlignmentConstraint>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<AlignmentConstraint>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::AlignmentConstraint*)arg[1]);
  }
}

static  void method_10265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<AlignmentConstraint>*)o)->capacity)());
  else   (((const ::std::vector<AlignmentConstraint>*)o)->capacity)();
}

static  void method_10266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<AlignmentConstraint>*)o)->empty)());
  else   (((const ::std::vector<AlignmentConstraint>*)o)->empty)();
}

static  void method_10267( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<AlignmentConstraint>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<AlignmentConstraint>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<AlignmentConstraint>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<AlignmentConstraint>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<AlignmentConstraint>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<AlignmentConstraint>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<AlignmentConstraint>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10272( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<AlignmentConstraint>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<AlignmentConstraint>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<AlignmentConstraint>*)o)->front)();
  else   (((::std::vector<AlignmentConstraint>*)o)->front)();
}

static  void method_10274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<AlignmentConstraint>*)o)->front)();
  else   (((const ::std::vector<AlignmentConstraint>*)o)->front)();
}

static  void method_10275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<AlignmentConstraint>*)o)->back)();
  else   (((::std::vector<AlignmentConstraint>*)o)->back)();
}

static  void method_10276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<AlignmentConstraint>*)o)->back)();
  else   (((const ::std::vector<AlignmentConstraint>*)o)->back)();
}

static  void method_10277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<AlignmentConstraint>*)o)->data)());
  else   (((::std::vector<AlignmentConstraint>*)o)->data)();
}

static  void method_10278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<AlignmentConstraint>*)o)->data)());
  else   (((const ::std::vector<AlignmentConstraint>*)o)->data)();
}

static  void method_10279( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<AlignmentConstraint>*)o)->push_back)(*(const ::AlignmentConstraint*)arg[0]);
}

static  void method_10280( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<AlignmentConstraint>*)o)->pop_back)();
}

static  void method_10281( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >)((((::std::vector<AlignmentConstraint>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >*)arg[0],
    *(const ::AlignmentConstraint*)arg[1]));
  else   (((::std::vector<AlignmentConstraint>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >*)arg[0],
    *(const ::AlignmentConstraint*)arg[1]);
}

static  void method_10282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<AlignmentConstraint>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::AlignmentConstraint*)arg[2]);
}

static  void method_10283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >)((((::std::vector<AlignmentConstraint>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >*)arg[0]));
  else   (((::std::vector<AlignmentConstraint>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >*)arg[0]);
}

static  void method_10284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >)((((::std::vector<AlignmentConstraint>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >*)arg[1]));
  else   (((::std::vector<AlignmentConstraint>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<AlignmentConstraint*,std::vector<AlignmentConstraint> >*)arg[1]);
}

static  void method_10285( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<AlignmentConstraint>*)o)->swap)(*(::std::vector<AlignmentConstraint>*)arg[0]);
}

static  void method_10286( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<AlignmentConstraint>*)o)->clear)();
}

static void method_newdel_2629( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<AlignmentConstraint> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<AlignmentConstraint> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<AlignmentConstraint> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<AlignmentConstraint> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<AlignmentConstraint> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<AlignmentConstraint,std::allocator<AlignmentConstraint> >")), ::Reflex::BaseOffset< ::std::vector<AlignmentConstraint>,::std::_Vector_base<AlignmentConstraint,std::allocator<AlignmentConstraint> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<AlignmentConstraint> >::Generate();
  else ::Reflex::Proxy< ::std::vector<AlignmentConstraint> >::Generate();
}

//------Dictionary for class vector<AlignmentConstraint,std::allocator<AlignmentConstraint> > -------------------------------
void __std__vector_AlignmentConstraint__db_datamem(Reflex::Class*);
void __std__vector_AlignmentConstraint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_AlignmentConstraint__datamem_bld(&__std__vector_AlignmentConstraint__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_AlignmentConstraint__funcmem_bld(&__std__vector_AlignmentConstraint__db_funcmem);
void __std__vector_AlignmentConstraint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<AlignmentConstraint>"), typeid(::std::vector<AlignmentConstraint>), sizeof(::std::vector<AlignmentConstraint>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2571, ::Reflex::BaseOffset< ::std::vector<AlignmentConstraint>, ::std::_Vector_base<AlignmentConstraint,std::allocator<AlignmentConstraint> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1094, Reflex::Literal("std::vector<AlignmentConstraint>::_Alloc_value_type"))
  .AddTypedef(type_2571, Reflex::Literal("std::vector<AlignmentConstraint>::_Base"))
  .AddTypedef(type_3244, Reflex::Literal("std::vector<AlignmentConstraint>::_Tp_alloc_type"))
  .AddTypedef(type_6966, Reflex::Literal("std::vector<AlignmentConstraint>::_Alloc_traits"))
  .AddTypedef(type_1094, Reflex::Literal("std::vector<AlignmentConstraint>::value_type"))
  .AddTypedef(type_9555, Reflex::Literal("std::vector<AlignmentConstraint>::pointer"))
  .AddTypedef(type_10234, Reflex::Literal("std::vector<AlignmentConstraint>::const_pointer"))
  .AddTypedef(type_10236, Reflex::Literal("std::vector<AlignmentConstraint>::reference"))
  .AddTypedef(type_10238, Reflex::Literal("std::vector<AlignmentConstraint>::const_reference"))
  .AddTypedef(type_6828, Reflex::Literal("std::vector<AlignmentConstraint>::iterator"))
  .AddTypedef(type_6829, Reflex::Literal("std::vector<AlignmentConstraint>::const_iterator"))
  .AddTypedef(type_3452, Reflex::Literal("std::vector<AlignmentConstraint>::const_reverse_iterator"))
  .AddTypedef(type_3453, Reflex::Literal("std::vector<AlignmentConstraint>::reverse_iterator"))
  .AddTypedef(type_3214, Reflex::Literal("std::vector<AlignmentConstraint>::size_type"))
  .AddTypedef(type_2802, Reflex::Literal("std::vector<AlignmentConstraint>::difference_type"))
  .AddTypedef(type_3244, Reflex::Literal("std::vector<AlignmentConstraint>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10247, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26316), Reflex::Literal("vector"), constructor_10248, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3214, type_10238, type_26316), Reflex::Literal("vector"), constructor_10249, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19631), Reflex::Literal("vector"), constructor_10250, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10251, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2629, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_AlignmentConstraint__funcmem_bld);
}

//------Delayed data member builder for class vector<AlignmentConstraint,std::allocator<AlignmentConstraint> > -------------------
void __std__vector_AlignmentConstraint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<AlignmentConstraint,std::allocator<AlignmentConstraint> > -------------------
void __std__vector_AlignmentConstraint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20986, type_19631), Reflex::Literal("operator="), operator_10252, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214, type_10238), Reflex::Literal("assign"), method_10253, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6828), Reflex::Literal("begin"), method_10254, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6829), Reflex::Literal("begin"), method_10255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6828), Reflex::Literal("end"), method_10256, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6829), Reflex::Literal("end"), method_10257, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("size"), method_10262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("max_size"), method_10263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214, type_1094), Reflex::Literal("resize"), method_10264, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("capacity"), method_10265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("empty"), method_10266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3214), Reflex::Literal("reserve"), method_10267, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10236, type_3214), Reflex::Literal("operator[]"), operator_10268, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10238, type_3214), Reflex::Literal("operator[]"), operator_10269, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10236, type_3214), Reflex::Literal("at"), method_10271, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10238, type_3214), Reflex::Literal("at"), method_10272, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10236), Reflex::Literal("front"), method_10273, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10238), Reflex::Literal("front"), method_10274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10236), Reflex::Literal("back"), method_10275, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10238), Reflex::Literal("back"), method_10276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9555), Reflex::Literal("data"), method_10277, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10234), Reflex::Literal("data"), method_10278, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_10238), Reflex::Literal("push_back"), method_10279, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("pop_back"), method_10280, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6828, type_6828, type_10238), Reflex::Literal("insert"), method_10281, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_6828, type_3214, type_10238), Reflex::Literal("insert"), method_10282, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6828, type_6828), Reflex::Literal("erase"), method_10283, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6828, type_6828, type_6828), Reflex::Literal("erase"), method_10284, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_20986), Reflex::Literal("swap"), method_10285, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("clear"), method_10286, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class set<unsigned int,std::less<unsigned int>,std::allocator<unsigned int> > -------------------------------
static void destructor_12168(void*, void * o, const std::vector<void*>&, void *) {
(((::std::set<unsigned int>*)o)->::std::set<unsigned int>::~set)();
}
static void constructor_12169( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<unsigned int>();
  else ::new(mem) ::std::set<unsigned int>();
}

static void constructor_12170( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<unsigned int>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::set<unsigned int>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<unsigned int>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<unsigned int>*)arg[1]);
  else ::new(mem) ::std::set<unsigned int>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<unsigned int>*)arg[1]);
  }
}

static void constructor_12171( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<unsigned int>(*(const ::std::set<unsigned int>*)arg[0]);
  else ::new(mem) ::std::set<unsigned int>(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void operator_12172( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::set<unsigned int>*)o)->operator=)(*(const ::std::set<unsigned int>*)arg[0]);
  else   (((::std::set<unsigned int>*)o)->operator=)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::set<unsigned int>*)o)->key_comp)());
  else   (((const ::std::set<unsigned int>*)o)->key_comp)();
}

static  void method_12175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<unsigned int>)((((const ::std::set<unsigned int>*)o)->get_allocator)());
  else   (((const ::std::set<unsigned int>*)o)->get_allocator)();
}

static  void method_12176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<unsigned int>)((((const ::std::set<unsigned int>*)o)->begin)());
  else   (((const ::std::set<unsigned int>*)o)->begin)();
}

static  void method_12177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<unsigned int>)((((const ::std::set<unsigned int>*)o)->end)());
  else   (((const ::std::set<unsigned int>*)o)->end)();
}

static  void method_12180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::set<unsigned int>*)o)->empty)());
  else   (((const ::std::set<unsigned int>*)o)->empty)();
}

static  void method_12181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::set<unsigned int>*)o)->size)());
  else   (((const ::std::set<unsigned int>*)o)->size)();
}

static  void method_12182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::set<unsigned int>*)o)->max_size)());
  else   (((const ::std::set<unsigned int>*)o)->max_size)();
}

static  void method_12183( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::set<unsigned int>*)o)->swap)(*(::std::set<unsigned int>*)arg[0]);
}

static  void method_12184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<unsigned int>,bool>)((((::std::set<unsigned int>*)o)->insert)(*(const unsigned int*)arg[0]));
  else   (((::std::set<unsigned int>*)o)->insert)(*(const unsigned int*)arg[0]);
}

static  void method_12185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<unsigned int>)((((::std::set<unsigned int>*)o)->insert)(*(::std::_Rb_tree_const_iterator<unsigned int>*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((::std::set<unsigned int>*)o)->insert)(*(::std::_Rb_tree_const_iterator<unsigned int>*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_12186( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::set<unsigned int>*)o)->erase)(*(::std::_Rb_tree_const_iterator<unsigned int>*)arg[0]);
}

static  void method_12187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::set<unsigned int>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::set<unsigned int>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_12188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::set<unsigned int>*)o)->erase)(*(::std::_Rb_tree_const_iterator<unsigned int>*)arg[0],
    *(::std::_Rb_tree_const_iterator<unsigned int>*)arg[1]);
}

static  void method_12189( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::set<unsigned int>*)o)->clear)();
}

static  void method_12190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::set<unsigned int>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::set<unsigned int>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_12191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<unsigned int>)((((::std::set<unsigned int>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::set<unsigned int>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_12192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<unsigned int>)((((const ::std::set<unsigned int>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::set<unsigned int>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_12193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<unsigned int>)((((::std::set<unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::set<unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<unsigned int>)((((const ::std::set<unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::set<unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<unsigned int>)((((::std::set<unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::set<unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<unsigned int>)((((const ::std::set<unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::set<unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<unsigned int>,std::_Rb_tree_const_iterator<unsigned int> >)((((::std::set<unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::set<unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_12198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<unsigned int>,std::_Rb_tree_const_iterator<unsigned int> >)((((const ::std::set<unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::set<unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2798( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::set<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::set<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::set<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::set<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::set<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::set<unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::set<unsigned int> >::Generate();
}

//------Dictionary for class set<unsigned int,std::less<unsigned int>,std::allocator<unsigned int> > -------------------------------
void __std__set_unsignedsint__db_datamem(Reflex::Class*);
void __std__set_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__set_unsignedsint__datamem_bld(&__std__set_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__set_unsignedsint__funcmem_bld(&__std__set_unsignedsint__db_funcmem);
void __std__set_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::set<unsigned int>"), typeid(::std::set<unsigned int>), sizeof(::std::set<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_58, Reflex::Literal("std::set<unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_58, Reflex::Literal("std::set<unsigned int>::key_type"))
  .AddTypedef(type_58, Reflex::Literal("std::set<unsigned int>::value_type"))
  .AddTypedef(type_2959, Reflex::Literal("std::set<unsigned int>::key_compare"))
  .AddTypedef(type_2959, Reflex::Literal("std::set<unsigned int>::value_compare"))
  .AddTypedef(type_3238, Reflex::Literal("std::set<unsigned int>::allocator_type"))
  .AddTypedef(type_3238, Reflex::Literal("std::set<unsigned int>::_Key_alloc_type"))
  .AddTypedef(type_3170, Reflex::Literal("std::set<unsigned int>::_Rep_type"))
  .AddTypedef(type_7748, Reflex::Literal("std::set<unsigned int>::pointer"))
  .AddTypedef(type_12157, Reflex::Literal("std::set<unsigned int>::const_pointer"))
  .AddTypedef(type_11945, Reflex::Literal("std::set<unsigned int>::reference"))
  .AddTypedef(type_12160, Reflex::Literal("std::set<unsigned int>::const_reference"))
  .AddTypedef(type_3595, Reflex::Literal("std::set<unsigned int>::iterator"))
  .AddTypedef(type_3595, Reflex::Literal("std::set<unsigned int>::const_iterator"))
  .AddTypedef(type_3530, Reflex::Literal("std::set<unsigned int>::reverse_iterator"))
  .AddTypedef(type_3530, Reflex::Literal("std::set<unsigned int>::const_reverse_iterator"))
  .AddTypedef(type_3214, Reflex::Literal("std::set<unsigned int>::size_type"))
  .AddTypedef(type_2802, Reflex::Literal("std::set<unsigned int>::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~set"), destructor_12168, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("set"), constructor_12169, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26825, type_26826), Reflex::Literal("set"), constructor_12170, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26827), Reflex::Literal("set"), constructor_12171, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2798, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__set_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__set_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class set<unsigned int,std::less<unsigned int>,std::allocator<unsigned int> > -------------------
void __std__set_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3170, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__set_unsignedsint_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class set<unsigned int,std::less<unsigned int>,std::allocator<unsigned int> > -------------------
void __std__set_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26828, type_26827), Reflex::Literal("operator="), operator_12172, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2959), Reflex::Literal("key_comp"), method_12173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3238), Reflex::Literal("get_allocator"), method_12175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3595), Reflex::Literal("begin"), method_12176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3595), Reflex::Literal("end"), method_12177, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("empty"), method_12180, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("size"), method_12181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("max_size"), method_12182, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_26828), Reflex::Literal("swap"), method_12183, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3129, type_12160), Reflex::Literal("insert"), method_12184, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3595, type_3595, type_12160), Reflex::Literal("insert"), method_12185, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3595), Reflex::Literal("erase"), method_12186, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_12160), Reflex::Literal("erase"), method_12187, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_3595, type_3595), Reflex::Literal("erase"), method_12188, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("clear"), method_12189, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_12160), Reflex::Literal("count"), method_12190, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3595, type_12160), Reflex::Literal("find"), method_12191, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3595, type_12160), Reflex::Literal("find"), method_12192, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3595, type_12160), Reflex::Literal("lower_bound"), method_12193, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3595, type_12160), Reflex::Literal("lower_bound"), method_12194, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3595, type_12160), Reflex::Literal("upper_bound"), method_12195, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3595, type_12160), Reflex::Literal("upper_bound"), method_12196, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3131, type_12160), Reflex::Literal("equal_range"), method_12197, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3131, type_12160), Reflex::Literal("equal_range"), method_12198, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> >,JanAlignmentAlgorithm::ScatterPlot,std::less<std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > >,std::allocator<std::pair<const std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> >, JanAlignmentAlgorithm::ScatterPlot> > > -------------------------------
static void destructor_12736(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::~map)();
}
static void constructor_12737( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>();
  else ::new(mem) ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>();
}

static void constructor_12738( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>(*(const ::std::less<std::set<unsigned int> >*)arg[0]);
  else ::new(mem) ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>(*(const ::std::less<std::set<unsigned int> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>(*(const ::std::less<std::set<unsigned int> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >*)arg[1]);
  else ::new(mem) ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>(*(const ::std::less<std::set<unsigned int> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >*)arg[1]);
  }
}

static void constructor_12739( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>(*(const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)arg[0]);
  else ::new(mem) ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>(*(const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)arg[0]);
}

static  void operator_12740( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->operator=)(*(const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)arg[0]);
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->operator=)(*(const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)arg[0]);
}

static  void method_12741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->get_allocator)());
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->get_allocator)();
}

static  void method_12742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->begin)());
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->begin)();
}

static  void method_12743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->begin)());
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->begin)();
}

static  void method_12744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->end)());
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->end)();
}

static  void method_12745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->end)());
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->end)();
}

static  void method_12750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->empty)());
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->empty)();
}

static  void method_12751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->size)());
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->size)();
}

static  void method_12752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->max_size)());
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->max_size)();
}

static  void operator_12753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->operator[])(*(const ::std::set<unsigned int>*)arg[0]);
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->operator[])(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->at)(*(const ::std::set<unsigned int>*)arg[0]);
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->at)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12755( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->at)(*(const ::std::set<unsigned int>*)arg[0]);
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->at)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12756( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >,bool>)((((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->insert)(*(const ::std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)arg[0]));
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->insert)(*(const ::std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)arg[0]);
}

static  void method_12757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >*)arg[0],
    *(const ::std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)arg[1]));
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >*)arg[0],
    *(const ::std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)arg[1]);
}

static  void method_12758( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >*)arg[0]);
}

static  void method_12759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->erase)(*(const ::std::set<unsigned int>*)arg[0]));
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->erase)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12760( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >*)arg[1]);
}

static  void method_12761( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->swap)(*(::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)arg[0]);
}

static  void method_12762( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->clear)();
}

static  void method_12763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::set<unsigned int> >)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->key_comp)());
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->key_comp)();
}

static  void method_12765( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->find)(*(const ::std::set<unsigned int>*)arg[0]));
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->find)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12766( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->find)(*(const ::std::set<unsigned int>*)arg[0]));
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->find)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12767( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->count)(*(const ::std::set<unsigned int>*)arg[0]));
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->count)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->lower_bound)(*(const ::std::set<unsigned int>*)arg[0]));
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->lower_bound)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12769( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->lower_bound)(*(const ::std::set<unsigned int>*)arg[0]));
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->lower_bound)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->upper_bound)(*(const ::std::set<unsigned int>*)arg[0]));
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->upper_bound)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->upper_bound)(*(const ::std::set<unsigned int>*)arg[0]));
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->upper_bound)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >,std::_Rb_tree_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> > >)((((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->equal_range)(*(const ::std::set<unsigned int>*)arg[0]));
  else   (((::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->equal_range)(*(const ::std::set<unsigned int>*)arg[0]);
}

static  void method_12773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >,std::_Rb_tree_const_iterator<std::pair<const std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> > >)((((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->equal_range)(*(const ::std::set<unsigned int>*)arg[0]));
  else   (((const ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>*)o)->equal_range)(*(const ::std::set<unsigned int>*)arg[0]);
}

static void method_newdel_2897( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x29( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >::Generate();
  else ::Reflex::Proxy< ::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> >::Generate();
}

//------Dictionary for class map<std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> >,JanAlignmentAlgorithm::ScatterPlot,std::less<std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > >,std::allocator<std::pair<const std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> >, JanAlignmentAlgorithm::ScatterPlot> > > -------------------------------
void __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__db_datamem(Reflex::Class*);
void __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__datamem_bld(&__std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__funcmem_bld(&__std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__db_funcmem);
void __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>"), typeid(::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>), sizeof(::std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2798, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::key_type"))
  .AddTypedef(type_8020, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::mapped_type"))
  .AddTypedef(type_3036, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::value_type"))
  .AddTypedef(type_2958, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::key_compare"))
  .AddTypedef(type_3237, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::allocator_type"))
  .AddTypedef(type_3036, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::_Alloc_value_type"))
  .AddTypedef(type_3237, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::_Pair_alloc_type"))
  .AddTypedef(type_3153, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::_Rep_type"))
  .AddTypedef(type_12722, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::pointer"))
  .AddTypedef(type_12724, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::const_pointer"))
  .AddTypedef(type_12726, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::reference"))
  .AddTypedef(type_12728, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::const_reference"))
  .AddTypedef(type_2713, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::iterator"))
  .AddTypedef(type_3578, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::const_iterator"))
  .AddTypedef(type_3214, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::size_type"))
  .AddTypedef(type_2802, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::difference_type"))
  .AddTypedef(type_3459, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::reverse_iterator"))
  .AddTypedef(type_3458, Reflex::Literal("std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12736, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12737, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26946, type_26947), Reflex::Literal("map"), constructor_12738, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26948), Reflex::Literal("map"), constructor_12739, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2897, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__funcmem_bld);
}

//------Delayed data member builder for class map<std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> >,JanAlignmentAlgorithm::ScatterPlot,std::less<std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > >,std::allocator<std::pair<const std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> >, JanAlignmentAlgorithm::ScatterPlot> > > -------------------
void __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3153, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> >,JanAlignmentAlgorithm::ScatterPlot,std::less<std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > >,std::allocator<std::pair<const std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> >, JanAlignmentAlgorithm::ScatterPlot> > > -------------------
void __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26949, type_26948), Reflex::Literal("operator="), operator_12740, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3237), Reflex::Literal("get_allocator"), method_12741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2713), Reflex::Literal("begin"), method_12742, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3578), Reflex::Literal("begin"), method_12743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2713), Reflex::Literal("end"), method_12744, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3578), Reflex::Literal("end"), method_12745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("empty"), method_12750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("size"), method_12751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("max_size"), method_12752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26950, type_26827), Reflex::Literal("operator[]"), operator_12753, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26950, type_26827), Reflex::Literal("at"), method_12754, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26951, type_26827), Reflex::Literal("at"), method_12755, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3046, type_12728), Reflex::Literal("insert"), method_12756, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2713, type_2713, type_12728), Reflex::Literal("insert"), method_12757, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_2713), Reflex::Literal("erase"), method_12758, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_26827), Reflex::Literal("erase"), method_12759, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_2713, type_2713), Reflex::Literal("erase"), method_12760, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_26949), Reflex::Literal("swap"), method_12761, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("clear"), method_12762, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2958), Reflex::Literal("key_comp"), method_12763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2713, type_26827), Reflex::Literal("find"), method_12765, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3578, type_26827), Reflex::Literal("find"), method_12766, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_26827), Reflex::Literal("count"), method_12767, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2713, type_26827), Reflex::Literal("lower_bound"), method_12768, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3578, type_26827), Reflex::Literal("lower_bound"), method_12769, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2713, type_26827), Reflex::Literal("upper_bound"), method_12770, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3578, type_26827), Reflex::Literal("upper_bound"), method_12771, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3045, type_26827), Reflex::Literal("equal_range"), method_12772, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3044, type_26827), Reflex::Literal("equal_range"), method_12773, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,JanAlignmentAlgorithm::DetStat,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, JanAlignmentAlgorithm::DetStat> > > -------------------------------
static void destructor_12798(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::~map)();
}
static void constructor_12799( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>();
  else ::new(mem) ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>();
}

static void constructor_12800( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >*)arg[1]);
  }
}

static void constructor_12801( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>(*(const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>(*(const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)arg[0]);
}

static  void operator_12802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->operator=)(*(const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)arg[0]);
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->operator=)(*(const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)arg[0]);
}

static  void method_12803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->get_allocator)();
}

static  void method_12804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->begin)());
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->begin)();
}

static  void method_12805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->begin)());
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->begin)();
}

static  void method_12806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->end)());
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->end)();
}

static  void method_12807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->end)());
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->end)();
}

static  void method_12812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->empty)());
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->empty)();
}

static  void method_12813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->size)());
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->size)();
}

static  void method_12814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->max_size)();
}

static  void operator_12815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_12816( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_12817( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_12818( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >,bool>)((((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->insert)(*(const ::std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat>*)arg[0]));
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->insert)(*(const ::std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat>*)arg[0]);
}

static  void method_12819( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >*)arg[0],
    *(const ::std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat>*)arg[1]));
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >*)arg[0],
    *(const ::std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat>*)arg[1]);
}

static  void method_12820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >*)arg[0]);
}

static  void method_12821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_12822( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >*)arg[1]);
}

static  void method_12823( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->swap)(*(::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)arg[0]);
}

static  void method_12824( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->clear)();
}

static  void method_12825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->key_comp)();
}

static  void method_12827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_12828( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_12829( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_12830( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12831( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12832( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >,std::_Rb_tree_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> > >)((((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_12835( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,JanAlignmentAlgorithm::DetStat> > >)((((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2898( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,JanAlignmentAlgorithm::DetStat> >::Generate();
}

//------Dictionary for class map<unsigned int,JanAlignmentAlgorithm::DetStat,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, JanAlignmentAlgorithm::DetStat> > > -------------------------------
void __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__datamem_bld(&__std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__funcmem_bld(&__std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__db_funcmem);
void __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>"), typeid(::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>), sizeof(::std::map<unsigned int,JanAlignmentAlgorithm::DetStat>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_58, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::key_type"))
  .AddTypedef(type_8021, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::mapped_type"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::value_type"))
  .AddTypedef(type_2959, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::key_compare"))
  .AddTypedef(type_3241, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::allocator_type"))
  .AddTypedef(type_3037, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::_Alloc_value_type"))
  .AddTypedef(type_3241, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::_Pair_alloc_type"))
  .AddTypedef(type_3152, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::_Rep_type"))
  .AddTypedef(type_12784, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::pointer"))
  .AddTypedef(type_12786, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::const_pointer"))
  .AddTypedef(type_12788, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::reference"))
  .AddTypedef(type_12790, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::const_reference"))
  .AddTypedef(type_2712, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::iterator"))
  .AddTypedef(type_3577, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::const_iterator"))
  .AddTypedef(type_3214, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::size_type"))
  .AddTypedef(type_2802, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::difference_type"))
  .AddTypedef(type_3455, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::reverse_iterator"))
  .AddTypedef(type_3454, Reflex::Literal("std::map<unsigned int,JanAlignmentAlgorithm::DetStat>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12798, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12799, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26825, type_26953), Reflex::Literal("map"), constructor_12800, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26954), Reflex::Literal("map"), constructor_12801, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2898, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,JanAlignmentAlgorithm::DetStat,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, JanAlignmentAlgorithm::DetStat> > > -------------------
void __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3152, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_JanAlignmentAlgorithm__DetStat_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,JanAlignmentAlgorithm::DetStat,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, JanAlignmentAlgorithm::DetStat> > > -------------------
void __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26955, type_26954), Reflex::Literal("operator="), operator_12802, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3241), Reflex::Literal("get_allocator"), method_12803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2712), Reflex::Literal("begin"), method_12804, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3577), Reflex::Literal("begin"), method_12805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2712), Reflex::Literal("end"), method_12806, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3577), Reflex::Literal("end"), method_12807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("empty"), method_12812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("size"), method_12813, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("max_size"), method_12814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26956, type_12160), Reflex::Literal("operator[]"), operator_12815, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26956, type_12160), Reflex::Literal("at"), method_12816, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26957, type_12160), Reflex::Literal("at"), method_12817, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3042, type_12790), Reflex::Literal("insert"), method_12818, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2712, type_2712, type_12790), Reflex::Literal("insert"), method_12819, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_2712), Reflex::Literal("erase"), method_12820, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_12160), Reflex::Literal("erase"), method_12821, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_2712, type_2712), Reflex::Literal("erase"), method_12822, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_26955), Reflex::Literal("swap"), method_12823, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("clear"), method_12824, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2959), Reflex::Literal("key_comp"), method_12825, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2712, type_12160), Reflex::Literal("find"), method_12827, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3577, type_12160), Reflex::Literal("find"), method_12828, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_12160), Reflex::Literal("count"), method_12829, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2712, type_12160), Reflex::Literal("lower_bound"), method_12830, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3577, type_12160), Reflex::Literal("lower_bound"), method_12831, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2712, type_12160), Reflex::Literal("upper_bound"), method_12832, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3577, type_12160), Reflex::Literal("upper_bound"), method_12833, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3041, type_12160), Reflex::Literal("equal_range"), method_12834, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3040, type_12160), Reflex::Literal("equal_range"), method_12835, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,DetGeometry,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, DetGeometry> > > -------------------------------
static void destructor_12858(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,DetGeometry>*)o)->::std::map<unsigned int,DetGeometry>::~map)();
}
static void constructor_12859( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,DetGeometry>();
  else ::new(mem) ::std::map<unsigned int,DetGeometry>();
}

static void constructor_12860( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,DetGeometry>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,DetGeometry>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,DetGeometry>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,DetGeometry> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,DetGeometry>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,DetGeometry> >*)arg[1]);
  }
}

static void constructor_12861( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,DetGeometry>(*(const ::std::map<unsigned int,DetGeometry>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,DetGeometry>(*(const ::std::map<unsigned int,DetGeometry>*)arg[0]);
}

static  void operator_12862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,DetGeometry>*)o)->operator=)(*(const ::std::map<unsigned int,DetGeometry>*)arg[0]);
  else   (((::std::map<unsigned int,DetGeometry>*)o)->operator=)(*(const ::std::map<unsigned int,DetGeometry>*)arg[0]);
}

static  void method_12863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,DetGeometry> >)((((const ::std::map<unsigned int,DetGeometry>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->get_allocator)();
}

static  void method_12864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >)((((::std::map<unsigned int,DetGeometry>*)o)->begin)());
  else   (((::std::map<unsigned int,DetGeometry>*)o)->begin)();
}

static  void method_12865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> >)((((const ::std::map<unsigned int,DetGeometry>*)o)->begin)());
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->begin)();
}

static  void method_12866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >)((((::std::map<unsigned int,DetGeometry>*)o)->end)());
  else   (((::std::map<unsigned int,DetGeometry>*)o)->end)();
}

static  void method_12867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> >)((((const ::std::map<unsigned int,DetGeometry>*)o)->end)());
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->end)();
}

static  void method_12872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,DetGeometry>*)o)->empty)());
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->empty)();
}

static  void method_12873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,DetGeometry>*)o)->size)());
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->size)();
}

static  void method_12874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,DetGeometry>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->max_size)();
}

static  void operator_12875( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,DetGeometry>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,DetGeometry>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_12876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,DetGeometry>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,DetGeometry>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_12877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,DetGeometry>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_12878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >,bool>)((((::std::map<unsigned int,DetGeometry>*)o)->insert)(*(const ::std::pair<const unsigned int,DetGeometry>*)arg[0]));
  else   (((::std::map<unsigned int,DetGeometry>*)o)->insert)(*(const ::std::pair<const unsigned int,DetGeometry>*)arg[0]);
}

static  void method_12879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >)((((::std::map<unsigned int,DetGeometry>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >*)arg[0],
    *(const ::std::pair<const unsigned int,DetGeometry>*)arg[1]));
  else   (((::std::map<unsigned int,DetGeometry>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >*)arg[0],
    *(const ::std::pair<const unsigned int,DetGeometry>*)arg[1]);
}

static  void method_12880( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,DetGeometry>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >*)arg[0]);
}

static  void method_12881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,DetGeometry>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,DetGeometry>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_12882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,DetGeometry>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >*)arg[1]);
}

static  void method_12883( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,DetGeometry>*)o)->swap)(*(::std::map<unsigned int,DetGeometry>*)arg[0]);
}

static  void method_12884( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,DetGeometry>*)o)->clear)();
}

static  void method_12885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,DetGeometry>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->key_comp)();
}

static  void method_12887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >)((((::std::map<unsigned int,DetGeometry>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,DetGeometry>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_12888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> >)((((const ::std::map<unsigned int,DetGeometry>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_12889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,DetGeometry>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_12890( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >)((((::std::map<unsigned int,DetGeometry>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,DetGeometry>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> >)((((const ::std::map<unsigned int,DetGeometry>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12892( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >)((((::std::map<unsigned int,DetGeometry>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,DetGeometry>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> >)((((const ::std::map<unsigned int,DetGeometry>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> >,std::_Rb_tree_iterator<std::pair<const unsigned int,DetGeometry> > >)((((::std::map<unsigned int,DetGeometry>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,DetGeometry>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_12895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,DetGeometry> > >)((((const ::std::map<unsigned int,DetGeometry>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,DetGeometry>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2899( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,DetGeometry> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,DetGeometry> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,DetGeometry> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,DetGeometry> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,DetGeometry> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,DetGeometry> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,DetGeometry> >::Generate();
}

//------Dictionary for class map<unsigned int,DetGeometry,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, DetGeometry> > > -------------------------------
void __std__map_unsignedsint_DetGeometry__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_DetGeometry__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_DetGeometry__datamem_bld(&__std__map_unsignedsint_DetGeometry__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_DetGeometry__funcmem_bld(&__std__map_unsignedsint_DetGeometry__db_funcmem);
void __std__map_unsignedsint_DetGeometry__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,DetGeometry>"), typeid(::std::map<unsigned int,DetGeometry>), sizeof(::std::map<unsigned int,DetGeometry>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_58, Reflex::Literal("std::map<unsigned int,DetGeometry>::key_type"))
  .AddTypedef(type_2443, Reflex::Literal("std::map<unsigned int,DetGeometry>::mapped_type"))
  .AddTypedef(type_3038, Reflex::Literal("std::map<unsigned int,DetGeometry>::value_type"))
  .AddTypedef(type_2959, Reflex::Literal("std::map<unsigned int,DetGeometry>::key_compare"))
  .AddTypedef(type_3243, Reflex::Literal("std::map<unsigned int,DetGeometry>::allocator_type"))
  .AddTypedef(type_3038, Reflex::Literal("std::map<unsigned int,DetGeometry>::_Alloc_value_type"))
  .AddTypedef(type_3243, Reflex::Literal("std::map<unsigned int,DetGeometry>::_Pair_alloc_type"))
  .AddTypedef(type_3171, Reflex::Literal("std::map<unsigned int,DetGeometry>::_Rep_type"))
  .AddTypedef(type_11970, Reflex::Literal("std::map<unsigned int,DetGeometry>::pointer"))
  .AddTypedef(type_12847, Reflex::Literal("std::map<unsigned int,DetGeometry>::const_pointer"))
  .AddTypedef(type_11968, Reflex::Literal("std::map<unsigned int,DetGeometry>::reference"))
  .AddTypedef(type_12850, Reflex::Literal("std::map<unsigned int,DetGeometry>::const_reference"))
  .AddTypedef(type_2731, Reflex::Literal("std::map<unsigned int,DetGeometry>::iterator"))
  .AddTypedef(type_3596, Reflex::Literal("std::map<unsigned int,DetGeometry>::const_iterator"))
  .AddTypedef(type_3214, Reflex::Literal("std::map<unsigned int,DetGeometry>::size_type"))
  .AddTypedef(type_2802, Reflex::Literal("std::map<unsigned int,DetGeometry>::difference_type"))
  .AddTypedef(type_3533, Reflex::Literal("std::map<unsigned int,DetGeometry>::reverse_iterator"))
  .AddTypedef(type_3532, Reflex::Literal("std::map<unsigned int,DetGeometry>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12858, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12859, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26825, type_26959), Reflex::Literal("map"), constructor_12860, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26960), Reflex::Literal("map"), constructor_12861, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2899, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_DetGeometry__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_DetGeometry__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,DetGeometry,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, DetGeometry> > > -------------------
void __std__map_unsignedsint_DetGeometry__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3171, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_DetGeometry_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,DetGeometry,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, DetGeometry> > > -------------------
void __std__map_unsignedsint_DetGeometry__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26961, type_26960), Reflex::Literal("operator="), operator_12862, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3243), Reflex::Literal("get_allocator"), method_12863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731), Reflex::Literal("begin"), method_12864, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3596), Reflex::Literal("begin"), method_12865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731), Reflex::Literal("end"), method_12866, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3596), Reflex::Literal("end"), method_12867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("empty"), method_12872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("size"), method_12873, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("max_size"), method_12874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26223, type_12160), Reflex::Literal("operator[]"), operator_12875, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26223, type_12160), Reflex::Literal("at"), method_12876, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24082, type_12160), Reflex::Literal("at"), method_12877, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3130, type_12850), Reflex::Literal("insert"), method_12878, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_2731, type_12850), Reflex::Literal("insert"), method_12879, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_2731), Reflex::Literal("erase"), method_12880, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_12160), Reflex::Literal("erase"), method_12881, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_2731, type_2731), Reflex::Literal("erase"), method_12882, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_26961), Reflex::Literal("swap"), method_12883, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("clear"), method_12884, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2959), Reflex::Literal("key_comp"), method_12885, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_12160), Reflex::Literal("find"), method_12887, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3596, type_12160), Reflex::Literal("find"), method_12888, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_12160), Reflex::Literal("count"), method_12889, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_12160), Reflex::Literal("lower_bound"), method_12890, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3596, type_12160), Reflex::Literal("lower_bound"), method_12891, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2731, type_12160), Reflex::Literal("upper_bound"), method_12892, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3596, type_12160), Reflex::Literal("upper_bound"), method_12893, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3135, type_12160), Reflex::Literal("equal_range"), method_12894, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3134, type_12160), Reflex::Literal("equal_range"), method_12895, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ScatterPlot -------------------------------
static void destructor_24579(void*, void * o, const std::vector<void*>&, void *) {
(((::JanAlignmentAlgorithm::ScatterPlot*)o)->::JanAlignmentAlgorithm::ScatterPlot::~ScatterPlot)();
}
static  void operator_24580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::JanAlignmentAlgorithm::ScatterPlot*)o)->operator=)(*(const ::JanAlignmentAlgorithm::ScatterPlot*)arg[0]);
  else   (((::JanAlignmentAlgorithm::ScatterPlot*)o)->operator=)(*(const ::JanAlignmentAlgorithm::ScatterPlot*)arg[0]);
}

static void constructor_24581( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JanAlignmentAlgorithm::ScatterPlot(*(const ::JanAlignmentAlgorithm::ScatterPlot*)arg[0]);
  else ::new(mem) ::JanAlignmentAlgorithm::ScatterPlot(*(const ::JanAlignmentAlgorithm::ScatterPlot*)arg[0]);
}

static void constructor_24582( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JanAlignmentAlgorithm::ScatterPlot();
  else ::new(mem) ::JanAlignmentAlgorithm::ScatterPlot();
}

static void method_newdel_8020( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm::ScatterPlot >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm::ScatterPlot >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm::ScatterPlot >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm::ScatterPlot >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm::ScatterPlot >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ScatterPlot -------------------------------
void __JanAlignmentAlgorithm__ScatterPlot_db_datamem(Reflex::Class*);
void __JanAlignmentAlgorithm__ScatterPlot_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __JanAlignmentAlgorithm__ScatterPlot_datamem_bld(&__JanAlignmentAlgorithm__ScatterPlot_db_datamem);
Reflex::GenreflexMemberBuilder __JanAlignmentAlgorithm__ScatterPlot_funcmem_bld(&__JanAlignmentAlgorithm__ScatterPlot_db_funcmem);
void __JanAlignmentAlgorithm__ScatterPlot_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("JanAlignmentAlgorithm::ScatterPlot"), typeid(::JanAlignmentAlgorithm::ScatterPlot), sizeof(::JanAlignmentAlgorithm::ScatterPlot), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ScatterPlot"), destructor_24579, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26950, type_26951), Reflex::Literal("operator="), operator_24580, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26951), Reflex::Literal("ScatterPlot"), constructor_24581, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ScatterPlot"), constructor_24582, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8020, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__JanAlignmentAlgorithm__ScatterPlot_datamem_bld);
}

//------Delayed data member builder for class ScatterPlot -------------------
void __JanAlignmentAlgorithm__ScatterPlot_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10031, Reflex::Literal("g"), OffsetOf(__shadow__::__JanAlignmentAlgorithm__ScatterPlot, g), ::Reflex::PUBLIC)
  .AddDataMember(type_28553, Reflex::Literal("h"), OffsetOf(__shadow__::__JanAlignmentAlgorithm__ScatterPlot, h), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class ScatterPlot -------------------
void __JanAlignmentAlgorithm__ScatterPlot_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class DetStat -------------------------------
static void destructor_24587(void*, void * o, const std::vector<void*>&, void *) {
(((::JanAlignmentAlgorithm::DetStat*)o)->::JanAlignmentAlgorithm::DetStat::~DetStat)();
}
static  void operator_24588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::JanAlignmentAlgorithm::DetStat*)o)->operator=)(*(const ::JanAlignmentAlgorithm::DetStat*)arg[0]);
  else   (((::JanAlignmentAlgorithm::DetStat*)o)->operator=)(*(const ::JanAlignmentAlgorithm::DetStat*)arg[0]);
}

static void constructor_24589( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JanAlignmentAlgorithm::DetStat(*(const ::JanAlignmentAlgorithm::DetStat*)arg[0]);
  else ::new(mem) ::JanAlignmentAlgorithm::DetStat(*(const ::JanAlignmentAlgorithm::DetStat*)arg[0]);
}

static void constructor_24590( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JanAlignmentAlgorithm::DetStat();
  else ::new(mem) ::JanAlignmentAlgorithm::DetStat();
}

static void method_newdel_8021( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm::DetStat >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm::DetStat >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm::DetStat >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm::DetStat >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::JanAlignmentAlgorithm::DetStat >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DetStat -------------------------------
void __JanAlignmentAlgorithm__DetStat_db_datamem(Reflex::Class*);
void __JanAlignmentAlgorithm__DetStat_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __JanAlignmentAlgorithm__DetStat_datamem_bld(&__JanAlignmentAlgorithm__DetStat_db_datamem);
Reflex::GenreflexMemberBuilder __JanAlignmentAlgorithm__DetStat_funcmem_bld(&__JanAlignmentAlgorithm__DetStat_db_funcmem);
void __JanAlignmentAlgorithm__DetStat_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("JanAlignmentAlgorithm::DetStat"), typeid(::JanAlignmentAlgorithm::DetStat), sizeof(::JanAlignmentAlgorithm::DetStat), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetStat"), destructor_24587, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26956, type_26957), Reflex::Literal("operator="), operator_24588, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26957), Reflex::Literal("DetStat"), constructor_24589, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetStat"), constructor_24590, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8021, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__JanAlignmentAlgorithm__DetStat_datamem_bld);
}

//------Delayed data member builder for class DetStat -------------------
void __JanAlignmentAlgorithm__DetStat_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10097, Reflex::Literal("m_dist"), OffsetOf(__shadow__::__JanAlignmentAlgorithm__DetStat, m_dist), ::Reflex::PUBLIC)
  .AddDataMember(type_2627, Reflex::Literal("coefHist"), OffsetOf(__shadow__::__JanAlignmentAlgorithm__DetStat, coefHist), ::Reflex::PUBLIC)
  .AddDataMember(type_2626, Reflex::Literal("resVsCoef"), OffsetOf(__shadow__::__JanAlignmentAlgorithm__DetStat, resVsCoef), ::Reflex::PUBLIC)
  .AddDataMember(type_2897, Reflex::Literal("resVsCoefRot_perRPSet"), OffsetOf(__shadow__::__JanAlignmentAlgorithm__DetStat, resVsCoefRot_perRPSet), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class DetStat -------------------
void __JanAlignmentAlgorithm__DetStat_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class map<unsigned int,TVectorT<double>,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, TVectorT<double> > > > -------------------------------
static void destructor_12920(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,TVectorT<double> >*)o)->::std::map<unsigned int,TVectorT<double> >::~map)();
}
static void constructor_12921( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,TVectorT<double> >();
  else ::new(mem) ::std::map<unsigned int,TVectorT<double> >();
}

static void constructor_12922( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,TVectorT<double> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,TVectorT<double> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,TVectorT<double> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,TVectorT<double> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,TVectorT<double> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,TVectorT<double> > >*)arg[1]);
  }
}

static void constructor_12923( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,TVectorT<double> >(*(const ::std::map<unsigned int,TVectorT<double> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,TVectorT<double> >(*(const ::std::map<unsigned int,TVectorT<double> >*)arg[0]);
}

static  void operator_12924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,TVectorT<double> >*)o)->operator=)(*(const ::std::map<unsigned int,TVectorT<double> >*)arg[0]);
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->operator=)(*(const ::std::map<unsigned int,TVectorT<double> >*)arg[0]);
}

static  void method_12925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,TVectorT<double> > >)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->get_allocator)();
}

static  void method_12926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >)((((::std::map<unsigned int,TVectorT<double> >*)o)->begin)());
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->begin)();
}

static  void method_12927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,TVectorT<double> > >)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->begin)();
}

static  void method_12928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >)((((::std::map<unsigned int,TVectorT<double> >*)o)->end)());
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->end)();
}

static  void method_12929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,TVectorT<double> > >)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->end)());
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->end)();
}

static  void method_12934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->empty)();
}

static  void method_12935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->size)());
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->size)();
}

static  void method_12936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->max_size)();
}

static  void operator_12937( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,TVectorT<double> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_12938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,TVectorT<double> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_12939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,TVectorT<double> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_12940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >,bool>)((((::std::map<unsigned int,TVectorT<double> >*)o)->insert)(*(const ::std::pair<const unsigned int,TVectorT<double> >*)arg[0]));
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->insert)(*(const ::std::pair<const unsigned int,TVectorT<double> >*)arg[0]);
}

static  void method_12941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >)((((::std::map<unsigned int,TVectorT<double> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >*)arg[0],
    *(const ::std::pair<const unsigned int,TVectorT<double> >*)arg[1]));
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >*)arg[0],
    *(const ::std::pair<const unsigned int,TVectorT<double> >*)arg[1]);
}

static  void method_12942( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,TVectorT<double> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >*)arg[0]);
}

static  void method_12943( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,TVectorT<double> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_12944( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,TVectorT<double> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >*)arg[1]);
}

static  void method_12945( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,TVectorT<double> >*)o)->swap)(*(::std::map<unsigned int,TVectorT<double> >*)arg[0]);
}

static  void method_12946( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,TVectorT<double> >*)o)->clear)();
}

static  void method_12947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->key_comp)();
}

static  void method_12949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >)((((::std::map<unsigned int,TVectorT<double> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_12950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,TVectorT<double> > >)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_12951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_12952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >)((((::std::map<unsigned int,TVectorT<double> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,TVectorT<double> > >)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12954( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >)((((::std::map<unsigned int,TVectorT<double> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12955( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,TVectorT<double> > >)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_12956( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,TVectorT<double> > > >)((((::std::map<unsigned int,TVectorT<double> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,TVectorT<double> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_12957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,TVectorT<double> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,TVectorT<double> > > >)((((const ::std::map<unsigned int,TVectorT<double> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,TVectorT<double> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2900( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,TVectorT<double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,TVectorT<double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,TVectorT<double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,TVectorT<double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,TVectorT<double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,TVectorT<double> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,TVectorT<double> > >::Generate();
}

//------Dictionary for class map<unsigned int,TVectorT<double>,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, TVectorT<double> > > > -------------------------------
void __std__map_unsignedsint_TVectorT_double_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_TVectorT_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_TVectorT_double_s__datamem_bld(&__std__map_unsignedsint_TVectorT_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_TVectorT_double_s__funcmem_bld(&__std__map_unsignedsint_TVectorT_double_s__db_funcmem);
void __std__map_unsignedsint_TVectorT_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,TVectorT<double> >"), typeid(::std::map<unsigned int,TVectorT<double> >), sizeof(::std::map<unsigned int,TVectorT<double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "std::map<unsigned int, TVectorD>")
  .AddTypedef(type_58, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::key_type"))
  .AddTypedef(type_1866, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::mapped_type"))
  .AddTypedef(type_3039, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::value_type"))
  .AddTypedef(type_2959, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::key_compare"))
  .AddTypedef(type_3245, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::allocator_type"))
  .AddTypedef(type_3039, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::_Alloc_value_type"))
  .AddTypedef(type_3245, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::_Pair_alloc_type"))
  .AddTypedef(type_3169, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::_Rep_type"))
  .AddTypedef(type_12906, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::pointer"))
  .AddTypedef(type_12908, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::const_pointer"))
  .AddTypedef(type_12910, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::reference"))
  .AddTypedef(type_12912, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::const_reference"))
  .AddTypedef(type_2729, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::iterator"))
  .AddTypedef(type_3594, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::const_iterator"))
  .AddTypedef(type_3214, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::size_type"))
  .AddTypedef(type_2802, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::difference_type"))
  .AddTypedef(type_3523, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::reverse_iterator"))
  .AddTypedef(type_3522, Reflex::Literal("std::map<unsigned int,TVectorT<double> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_12920, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_12921, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26825, type_26963), Reflex::Literal("map"), constructor_12922, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26964), Reflex::Literal("map"), constructor_12923, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2900, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_TVectorT_double_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_TVectorT_double_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,TVectorT<double>,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, TVectorT<double> > > > -------------------
void __std__map_unsignedsint_TVectorT_double_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3169, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_TVectorT_double_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,TVectorT<double>,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, TVectorT<double> > > > -------------------
void __std__map_unsignedsint_TVectorT_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26965, type_26964), Reflex::Literal("operator="), operator_12924, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3245), Reflex::Literal("get_allocator"), method_12925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2729), Reflex::Literal("begin"), method_12926, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3594), Reflex::Literal("begin"), method_12927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2729), Reflex::Literal("end"), method_12928, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3594), Reflex::Literal("end"), method_12929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_583), Reflex::Literal("empty"), method_12934, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("size"), method_12935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("max_size"), method_12936, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19660, type_12160), Reflex::Literal("operator[]"), operator_12937, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19660, type_12160), Reflex::Literal("at"), method_12938, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19654, type_12160), Reflex::Literal("at"), method_12939, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3128, type_12912), Reflex::Literal("insert"), method_12940, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2729, type_2729, type_12912), Reflex::Literal("insert"), method_12941, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_2729), Reflex::Literal("erase"), method_12942, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_12160), Reflex::Literal("erase"), method_12943, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_2729, type_2729), Reflex::Literal("erase"), method_12944, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697, type_26965), Reflex::Literal("swap"), method_12945, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1697), Reflex::Literal("clear"), method_12946, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2959), Reflex::Literal("key_comp"), method_12947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2729, type_12160), Reflex::Literal("find"), method_12949, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3594, type_12160), Reflex::Literal("find"), method_12950, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_12160), Reflex::Literal("count"), method_12951, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2729, type_12160), Reflex::Literal("lower_bound"), method_12952, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3594, type_12160), Reflex::Literal("lower_bound"), method_12953, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2729, type_12160), Reflex::Literal("upper_bound"), method_12954, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3594, type_12160), Reflex::Literal("upper_bound"), method_12955, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3127, type_12160), Reflex::Literal("equal_range"), method_12956, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3126, type_12160), Reflex::Literal("equal_range"), method_12957, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __MillepedeAlgorithm_dict(); 
      __AlignmentTask_dict(); 
      __AlignmentConstraint_dict(); 
      __IdealResult_dict(); 
      __SingularMode_dict(); 
      __AlignmentGeometry_dict(); 
      __JanAlignmentAlgorithm_dict(); 
      __LocalTrackFitter_dict(); 
      __DetGeometry_dict(); 
      __std__vector_TGraphp__dict(); 
      __std__vector_TH1Dp__dict(); 
      __std__vector_SingularMode__dict(); 
      __std__vector_AlignmentConstraint__dict(); 
      __std__set_unsignedsint__dict(); 
      __std__map_std__set_unsignedsint__JanAlignmentAlgorithm__ScatterPlot__dict(); 
      __std__map_unsignedsint_JanAlignmentAlgorithm__DetStat__dict(); 
      __std__map_unsignedsint_DetGeometry__dict(); 
      __JanAlignmentAlgorithm__ScatterPlot_dict(); 
      __JanAlignmentAlgorithm__DetStat_dict(); 
      __std__map_unsignedsint_TVectorT_double_s__dict(); 
    }
    ~Dictionaries() {
      type_95.Unload(); // class MillepedeAlgorithm 
      type_877.Unload(); // class AlignmentTask 
      type_1094.Unload(); // class AlignmentConstraint 
      type_1512.Unload(); // class IdealResult 
      type_1586.Unload(); // class SingularMode 
      type_1596.Unload(); // class AlignmentGeometry 
      type_2188.Unload(); // class JanAlignmentAlgorithm 
      type_2266.Unload(); // class LocalTrackFitter 
      type_2443.Unload(); // class DetGeometry 
      type_2626.Unload(); // class std::vector<TGraph*> 
      type_2627.Unload(); // class std::vector<TH1D*> 
      type_2628.Unload(); // class std::vector<SingularMode> 
      type_2629.Unload(); // class std::vector<AlignmentConstraint> 
      type_2798.Unload(); // class std::set<unsigned int> 
      type_2897.Unload(); // class std::map<std::set<unsigned int>,JanAlignmentAlgorithm::ScatterPlot> 
      type_2898.Unload(); // class std::map<unsigned int,JanAlignmentAlgorithm::DetStat> 
      type_2899.Unload(); // class std::map<unsigned int,DetGeometry> 
      type_8020.Unload(); // class JanAlignmentAlgorithm::ScatterPlot 
      type_8021.Unload(); // class JanAlignmentAlgorithm::DetStat 
      type_2900.Unload(); // class std::map<unsigned int,TVectorT<double> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
