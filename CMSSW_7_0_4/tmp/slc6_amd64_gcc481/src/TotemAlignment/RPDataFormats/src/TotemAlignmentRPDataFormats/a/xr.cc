// Generated at Mon Jul 11 23:11:09 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/TotemAlignment/RPDataFormats/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("edm") );
  ::Reflex::Type type_64 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_597 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_98 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1400 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_645 = ::Reflex::TypeBuilder(Reflex::Literal("_IO_FILE"));
  ::Reflex::Type type_188 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_279 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1737 = ::Reflex::TypeBuilder(Reflex::Literal("LocalTrackFit"));
  ::Reflex::Type type_402 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3560 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_1816 = ::Reflex::TypeBuilder(Reflex::Literal("AlignmentGeometry"));
  ::Reflex::Type type_2616 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_837 = ::Reflex::TypeBuilder(Reflex::Literal("RPAlignmentCorrection"));
  ::Reflex::Type type_5749 = ::Reflex::TypeBuilder(Reflex::Literal("xercesc_2_8::DOMNode"));
  ::Reflex::Type type_2218 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::Rotation3D"));
  ::Reflex::Type type_1069 = ::Reflex::TypeBuilder(Reflex::Literal("RPAlignmentCorrections"));
  ::Reflex::Type type_2256 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_2614 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2615 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3460 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<LocalTrackFit>"));
  ::Reflex::Type type_2439 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<LocalTrackFit>"));
  ::Reflex::Type type_3489 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<LocalTrackFit>"));
  ::Reflex::Type type_2716 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPAlignmentCorrection>"));
  ::Reflex::Type type_3541 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_91 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_2188 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("DDTranslation"), type_91);
  ::Reflex::Type type_12548 = ::Reflex::ReferenceBuilder(type_837);
  ::Reflex::Type type_837c = ::Reflex::ConstBuilder(type_837);
  ::Reflex::Type type_12549 = ::Reflex::ReferenceBuilder(type_837c);
  ::Reflex::Type type_2188c = ::Reflex::ConstBuilder(type_2188);
  ::Reflex::Type type_12550 = ::Reflex::ReferenceBuilder(type_2188c);
  ::Reflex::Type type_2219 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("DDRotationMatrix"), type_2218);
  ::Reflex::Type type_1945 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("FILE"), type_645);
  ::Reflex::Type type_2995 = ::Reflex::PointerBuilder(type_1945);
  ::Reflex::Type type_2616c = ::Reflex::ConstBuilder(type_2616);
  ::Reflex::Type type_12551 = ::Reflex::ReferenceBuilder(type_2616c);
  ::Reflex::Type type_12597 = ::Reflex::ReferenceBuilder(type_1069);
  ::Reflex::Type type_1069c = ::Reflex::ConstBuilder(type_1069);
  ::Reflex::Type type_12598 = ::Reflex::ReferenceBuilder(type_1069c);
  ::Reflex::Type type_2257 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2256);
  ::Reflex::Type type_2257c = ::Reflex::ConstBuilder(type_2257);
  ::Reflex::Type type_9693 = ::Reflex::ReferenceBuilder(type_2257c);
  ::Reflex::Type type_12599 = ::Reflex::PointerBuilder(type_5749);
  ::Reflex::Type type_2716c = ::Reflex::ConstBuilder(type_2716);
  ::Reflex::Type type_12600 = ::Reflex::ReferenceBuilder(type_2716c);
  ::Reflex::Type type_1816c = ::Reflex::ConstBuilder(type_1816);
  ::Reflex::Type type_12601 = ::Reflex::ReferenceBuilder(type_1816c);
  ::Reflex::Type type_12669 = ::Reflex::ReferenceBuilder(type_1737);
  ::Reflex::Type type_1737c = ::Reflex::ConstBuilder(type_1737);
  ::Reflex::Type type_12670 = ::Reflex::ReferenceBuilder(type_1737c);
  ::Reflex::Type type_10097 = ::Reflex::ReferenceBuilder(type_98);
  ::Reflex::Type type_18338 = ::Reflex::PointerBuilder(type_1737c);
  ::Reflex::Type type_402c = ::Reflex::ConstBuilder(type_402);
  ::Reflex::Type type_11490 = ::Reflex::ReferenceBuilder(type_402c);
  ::Reflex::Type type_18339 = ::Reflex::PointerBuilder(type_1737);
  ::Reflex::Type type_3489c = ::Reflex::ConstBuilder(type_3489);
  ::Reflex::Type type_18340 = ::Reflex::PointerBuilder(type_3489c);
  ::Reflex::Type type_3560c = ::Reflex::ConstBuilder(type_3560);
  ::Reflex::Type type_11813 = ::Reflex::ReferenceBuilder(type_3560c);
  ::Reflex::Type type_17866 = ::Reflex::ReferenceBuilder(type_2614);
  ::Reflex::Type type_18341 = ::Reflex::ReferenceBuilder(type_3541);
  ::Reflex::Type type_597c = ::Reflex::ConstBuilder(type_597);
  ::Reflex::Type type_3288 = ::Reflex::PointerBuilder(type_597c);
  ::Reflex::Type type_7069 = ::Reflex::ReferenceBuilder(type_3288);
  ::Reflex::Type type_2615c = ::Reflex::ConstBuilder(type_2615);
  ::Reflex::Type type_17867 = ::Reflex::ReferenceBuilder(type_2615c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __RPAlignmentCorrection
#undef __RPAlignmentCorrection
#endif
class __RPAlignmentCorrection {
  public:
  __RPAlignmentCorrection();
  ::DDTranslation translation;
  ::DDTranslation translation_error;
  double translation_r;
  double translation_r_error;
  double rotation_x;
  double rotation_y;
  double rotation_z;
  double rotation_x_error;
  double rotation_y_error;
  double rotation_z_error;
};
#ifdef __RPAlignmentCorrections
#undef __RPAlignmentCorrections
#endif
class __RPAlignmentCorrections {
  public:
  __RPAlignmentCorrections();
  ::std::map<unsigned int,RPAlignmentCorrection> rps;
  ::std::map<unsigned int,RPAlignmentCorrection> sensors;
};
#ifdef __LocalTrackFit
#undef __LocalTrackFit
#endif
struct __LocalTrackFit {
  public:
  __LocalTrackFit();
  double z0;
  double ax;
  double ay;
  double bx;
  double by;
  int ndf;
  double chi_sq;
};
#ifdef __edm__Wrapper_LocalTrackFit_
#undef __edm__Wrapper_LocalTrackFit_
#endif
class __edm__Wrapper_LocalTrackFit_ {
  public:
  __edm__Wrapper_LocalTrackFit_();
  bool present;
  ::LocalTrackFit obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class RPAlignmentCorrection -------------------------------
static void destructor_4304(void*, void * o, const std::vector<void*>&, void *) {
(((::RPAlignmentCorrection*)o)->::RPAlignmentCorrection::~RPAlignmentCorrection)();
}
static  void operator_4305( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPAlignmentCorrection*)o)->operator=)(*(const ::RPAlignmentCorrection*)arg[0]);
  else   (((::RPAlignmentCorrection*)o)->operator=)(*(const ::RPAlignmentCorrection*)arg[0]);
}

static void constructor_4306( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrection(*(const ::RPAlignmentCorrection*)arg[0]);
  else ::new(mem) ::RPAlignmentCorrection(*(const ::RPAlignmentCorrection*)arg[0]);
}

static void constructor_4307( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13]);
  else ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13]);
}

static void constructor_4308( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9]);
  else ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9]);
}

static void constructor_4309( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrection();
  else ::new(mem) ::RPAlignmentCorrection();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0]);
  else ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  else ::new(mem) ::RPAlignmentCorrection(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  }
}

static  void method_4310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RPAlignmentCorrection*)o)->Translation)();
  else   (((const ::RPAlignmentCorrection*)o)->Translation)();
}

static  void method_4311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RPAlignmentCorrection*)o)->TranslationError)();
  else   (((const ::RPAlignmentCorrection*)o)->TranslationError)();
}

static  void method_4312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->RotationZ)());
  else   (((const ::RPAlignmentCorrection*)o)->RotationZ)();
}

static  void method_4313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->RotationZError)());
  else   (((const ::RPAlignmentCorrection*)o)->RotationZError)();
}

static  void method_4314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (DDRotationMatrix)((((const ::RPAlignmentCorrection*)o)->RotationMatrix)());
  else   (((const ::RPAlignmentCorrection*)o)->RotationMatrix)();
}

static  void method_4315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->sh_r)());
  else   (((const ::RPAlignmentCorrection*)o)->sh_r)();
}

static  void method_4316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->sh_r_e)());
  else   (((const ::RPAlignmentCorrection*)o)->sh_r_e)();
}

static  void method_4317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->sh_x)());
  else   (((const ::RPAlignmentCorrection*)o)->sh_x)();
}

static  void method_4318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->sh_x_e)());
  else   (((const ::RPAlignmentCorrection*)o)->sh_x_e)();
}

static  void method_4319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->sh_y)());
  else   (((const ::RPAlignmentCorrection*)o)->sh_y)();
}

static  void method_4320( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->sh_y_e)());
  else   (((const ::RPAlignmentCorrection*)o)->sh_y_e)();
}

static  void method_4321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->sh_z)());
  else   (((const ::RPAlignmentCorrection*)o)->sh_z)();
}

static  void method_4322( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->sh_z_e)());
  else   (((const ::RPAlignmentCorrection*)o)->sh_z_e)();
}

static  void method_4323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->rot_z)());
  else   (((const ::RPAlignmentCorrection*)o)->rot_z)();
}

static  void method_4324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RPAlignmentCorrection*)o)->rot_z_e)());
  else   (((const ::RPAlignmentCorrection*)o)->rot_z_e)();
}

static  void method_4325( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::RPAlignmentCorrection*)o)->SetTranslationR)(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::RPAlignmentCorrection*)o)->SetTranslationR)(*(double*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4326( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::RPAlignmentCorrection*)o)->SetTranslationZ)(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::RPAlignmentCorrection*)o)->SetTranslationZ)(*(double*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4327( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::RPAlignmentCorrection*)o)->SetRotationZ)(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::RPAlignmentCorrection*)o)->SetRotationZ)(*(double*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4328( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::RPAlignmentCorrection*)o)->Add)(*(const ::RPAlignmentCorrection*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::RPAlignmentCorrection*)o)->Add)(*(const ::RPAlignmentCorrection*)arg[0],
      *(bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RPAlignmentCorrection*)o)->Add)(*(const ::RPAlignmentCorrection*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::RPAlignmentCorrection*)o)->Add)(*(const ::RPAlignmentCorrection*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::RPAlignmentCorrection*)o)->Add)(*(const ::RPAlignmentCorrection*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  }
}

static  void method_4329( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPAlignmentCorrection*)o)->ReadoutTranslationToXY)(*(double*)arg[0],
    *(double*)arg[1]);
}

static  void method_4330( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPAlignmentCorrection*)o)->XYTranslationToReadout)(*(double*)arg[0],
    *(double*)arg[1]);
}

static  void method_4331( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RPAlignmentCorrection*)o)->NormalizeRotationZ)();
}

static  void method_4332( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::RPAlignmentCorrection*)o)->Print)();
}

static  void method_4333( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::RPAlignmentCorrection*)o)->WriteXML)((::FILE*)arg[0],
    *(bool*)arg[1],
    *(bool*)arg[2],
    *(bool*)arg[3],
    *(bool*)arg[4],
    *(bool*)arg[5],
    *(bool*)arg[6]);
}

static  void method_4334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<double>)((((const ::RPAlignmentCorrection*)o)->getValues)());
  else   (((const ::RPAlignmentCorrection*)o)->getValues)();
}

static  void method_4335( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPAlignmentCorrection*)o)->setValues)(*(const ::std::vector<double>*)arg[0]);
}

static void constructor_x0( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrection();
  else ::new(mem) ::RPAlignmentCorrection();
}

static void method_newdel_837( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPAlignmentCorrection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPAlignmentCorrection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPAlignmentCorrection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPAlignmentCorrection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPAlignmentCorrection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPAlignmentCorrection -------------------------------
void __RPAlignmentCorrection_db_datamem(Reflex::Class*);
void __RPAlignmentCorrection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPAlignmentCorrection_datamem_bld(&__RPAlignmentCorrection_db_datamem);
Reflex::GenreflexMemberBuilder __RPAlignmentCorrection_funcmem_bld(&__RPAlignmentCorrection_db_funcmem);
void __RPAlignmentCorrection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPAlignmentCorrection"), typeid(::RPAlignmentCorrection), sizeof(::RPAlignmentCorrection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPAlignmentCorrection"), destructor_4304, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12548, type_12549), Reflex::Literal("operator="), operator_4305, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12549), Reflex::Literal("RPAlignmentCorrection"), constructor_4306, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_98, type_98, type_98, type_98, type_98, type_98, type_98, type_98, type_98, type_98, type_98, type_98, type_98, type_98), Reflex::Literal("RPAlignmentCorrection"), constructor_4307, 0, "sh_r;sh_r_e;sh_x;sh_x_e;sh_y;sh_y_e;sh_z;sh_z_e;rot_x;rot_x_e;rot_y;rot_y_e;rot_z;rot_z_e", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_98, type_98, type_98, type_98, type_98, type_98, type_98, type_98, type_98, type_98), Reflex::Literal("RPAlignmentCorrection"), constructor_4308, 0, "sh_r;sh_r_e;sh_x;sh_x_e;sh_y;sh_y_e;sh_z;sh_z_e;rot_z;rot_z_e", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_98, type_98, type_98, type_98), Reflex::Literal("RPAlignmentCorrection"), constructor_4309, 0, "sh_x=0.0;sh_y=0.0;sh_z=0.0;rot_z=0.0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPAlignmentCorrection"), constructor_x0, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_837, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPAlignmentCorrection_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPAlignmentCorrection_funcmem_bld);
}

//------Delayed data member builder for class RPAlignmentCorrection -------------------
void __RPAlignmentCorrection_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2188, Reflex::Literal("translation"), OffsetOf(__shadow__::__RPAlignmentCorrection, translation), ::Reflex::PROTECTED)
  .AddDataMember(type_2188, Reflex::Literal("translation_error"), OffsetOf(__shadow__::__RPAlignmentCorrection, translation_error), ::Reflex::PROTECTED)
  .AddDataMember(type_98, Reflex::Literal("translation_r"), OffsetOf(__shadow__::__RPAlignmentCorrection, translation_r), ::Reflex::PROTECTED)
  .AddDataMember(type_98, Reflex::Literal("translation_r_error"), OffsetOf(__shadow__::__RPAlignmentCorrection, translation_r_error), ::Reflex::PROTECTED)
  .AddDataMember(type_98, Reflex::Literal("rotation_x"), OffsetOf(__shadow__::__RPAlignmentCorrection, rotation_x), ::Reflex::PROTECTED)
  .AddDataMember(type_98, Reflex::Literal("rotation_y"), OffsetOf(__shadow__::__RPAlignmentCorrection, rotation_y), ::Reflex::PROTECTED)
  .AddDataMember(type_98, Reflex::Literal("rotation_z"), OffsetOf(__shadow__::__RPAlignmentCorrection, rotation_z), ::Reflex::PROTECTED)
  .AddDataMember(type_98, Reflex::Literal("rotation_x_error"), OffsetOf(__shadow__::__RPAlignmentCorrection, rotation_x_error), ::Reflex::PROTECTED)
  .AddDataMember(type_98, Reflex::Literal("rotation_y_error"), OffsetOf(__shadow__::__RPAlignmentCorrection, rotation_y_error), ::Reflex::PROTECTED)
  .AddDataMember(type_98, Reflex::Literal("rotation_z_error"), OffsetOf(__shadow__::__RPAlignmentCorrection, rotation_z_error), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RPAlignmentCorrection -------------------
void __RPAlignmentCorrection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12550), Reflex::Literal("Translation"), method_4310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12550), Reflex::Literal("TranslationError"), method_4311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("RotationZ"), method_4312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("RotationZError"), method_4313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2219), Reflex::Literal("RotationMatrix"), method_4314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("sh_r"), method_4315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("sh_r_e"), method_4316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("sh_x"), method_4317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("sh_x_e"), method_4318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("sh_y"), method_4319, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("sh_y_e"), method_4320, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("sh_z"), method_4321, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("sh_z_e"), method_4322, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("rot_z"), method_4323, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("rot_z_e"), method_4324, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_98, type_98), Reflex::Literal("SetTranslationR"), method_4325, 0, "sh_r;sh_r_e=0.0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_98, type_98), Reflex::Literal("SetTranslationZ"), method_4326, 0, "sh_z;sh_z_e=0.0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_98, type_98), Reflex::Literal("SetRotationZ"), method_4327, 0, "rot_z;rot_z_e=0.0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_12549, type_1400, type_1400, type_1400, type_1400), Reflex::Literal("Add"), method_4328, 0, ";sumErrors=true;addShR=true;addShZ=true;addRotZ=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_98, type_98), Reflex::Literal("ReadoutTranslationToXY"), method_4329, 0, "dx;dy", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_98, type_98), Reflex::Literal("XYTranslationToReadout"), method_4330, 0, "dx;dy", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597), Reflex::Literal("NormalizeRotationZ"), method_4331, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597), Reflex::Literal("Print"), method_4332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_2995, type_1400, type_1400, type_1400, type_1400, type_1400, type_1400), Reflex::Literal("WriteXML"), method_4333, 0, "f;precise;wrErrors;wrSh_r;wrSh_xy;wrSh_z;wrRot_z", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2616), Reflex::Literal("getValues"), method_4334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_12551), Reflex::Literal("setValues"), method_4335, 0, "", ::Reflex::PUBLIC);
}
//------Stub functions for class RPAlignmentCorrections -------------------------------
static void destructor_4511(void*, void * o, const std::vector<void*>&, void *) {
(((::RPAlignmentCorrections*)o)->::RPAlignmentCorrections::~RPAlignmentCorrections)();
}
static  void operator_4512( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPAlignmentCorrections*)o)->operator=)(*(const ::RPAlignmentCorrections*)arg[0]);
  else   (((::RPAlignmentCorrections*)o)->operator=)(*(const ::RPAlignmentCorrections*)arg[0]);
}

static void constructor_4513( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrections(*(const ::RPAlignmentCorrections*)arg[0]);
  else ::new(mem) ::RPAlignmentCorrections(*(const ::RPAlignmentCorrections*)arg[0]);
}

static void constructor_4514( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrections();
  else ::new(mem) ::RPAlignmentCorrections();
}

static void constructor_4515( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrections(*(const ::std::string*)arg[0]);
  else ::new(mem) ::RPAlignmentCorrections(*(const ::std::string*)arg[0]);
}

static void constructor_4516( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPAlignmentCorrections((::xercesc_2_8::DOMNode*)arg[0]);
  else ::new(mem) ::RPAlignmentCorrections((::xercesc_2_8::DOMNode*)arg[0]);
}

static  void method_4517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPAlignmentCorrections*)o)->LoadXMLFile)(*(const ::std::string*)arg[0]);
}

static  void method_4518( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPAlignmentCorrections*)o)->LoadXMLBlock)((::xercesc_2_8::DOMNode*)arg[0]);
}

static  void method_4519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RPAlignmentCorrections*)o)->GetRPMap)();
  else   (((const ::RPAlignmentCorrections*)o)->GetRPMap)();
}

static  void method_4520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RPAlignmentCorrections*)o)->GetSensorMap)();
  else   (((const ::RPAlignmentCorrections*)o)->GetSensorMap)();
}

static  void method_4521( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPAlignmentCorrections*)o)->GetRPCorrection)(*(unsigned int*)arg[0]);
  else   (((::RPAlignmentCorrections*)o)->GetRPCorrection)(*(unsigned int*)arg[0]);
}

static  void method_4522( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RPAlignmentCorrection)((((const ::RPAlignmentCorrections*)o)->GetRPCorrection)(*(unsigned int*)arg[0]));
  else   (((const ::RPAlignmentCorrections*)o)->GetRPCorrection)(*(unsigned int*)arg[0]);
}

static  void method_4523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPAlignmentCorrections*)o)->GetSensorCorrection)(*(unsigned int*)arg[0]);
  else   (((::RPAlignmentCorrections*)o)->GetSensorCorrection)(*(unsigned int*)arg[0]);
}

static  void method_4524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RPAlignmentCorrection)((((const ::RPAlignmentCorrections*)o)->GetSensorCorrection)(*(unsigned int*)arg[0]));
  else   (((const ::RPAlignmentCorrections*)o)->GetSensorCorrection)(*(unsigned int*)arg[0]);
}

static  void method_4525( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (RPAlignmentCorrection)((((const ::RPAlignmentCorrections*)o)->GetFullSensorCorrection)(*(unsigned int*)arg[0]));
    else     (((const ::RPAlignmentCorrections*)o)->GetFullSensorCorrection)(*(unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (RPAlignmentCorrection)((((const ::RPAlignmentCorrections*)o)->GetFullSensorCorrection)(*(unsigned int*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::RPAlignmentCorrections*)o)->GetFullSensorCorrection)(*(unsigned int*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_4526( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPAlignmentCorrections*)o)->SetRPCorrection)(*(unsigned int*)arg[0],
    *(const ::RPAlignmentCorrection*)arg[1]);
}

static  void method_4527( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPAlignmentCorrections*)o)->SetSensorCorrection)(*(unsigned int*)arg[0],
    *(const ::RPAlignmentCorrection*)arg[1]);
}

static  void method_4528( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::RPAlignmentCorrections*)o)->AddRPCorrection)(*(unsigned int*)arg[0],
      *(const ::RPAlignmentCorrection*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RPAlignmentCorrections*)o)->AddRPCorrection)(*(unsigned int*)arg[0],
      *(const ::RPAlignmentCorrection*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::RPAlignmentCorrections*)o)->AddRPCorrection)(*(unsigned int*)arg[0],
      *(const ::RPAlignmentCorrection*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::RPAlignmentCorrections*)o)->AddRPCorrection)(*(unsigned int*)arg[0],
      *(const ::RPAlignmentCorrection*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((::RPAlignmentCorrections*)o)->AddRPCorrection)(*(unsigned int*)arg[0],
      *(const ::RPAlignmentCorrection*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5]);
  }
}

static  void method_4529( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::RPAlignmentCorrections*)o)->AddSensorCorrection)(*(unsigned int*)arg[0],
      *(const ::RPAlignmentCorrection*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RPAlignmentCorrections*)o)->AddSensorCorrection)(*(unsigned int*)arg[0],
      *(const ::RPAlignmentCorrection*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::RPAlignmentCorrections*)o)->AddSensorCorrection)(*(unsigned int*)arg[0],
      *(const ::RPAlignmentCorrection*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::RPAlignmentCorrections*)o)->AddSensorCorrection)(*(unsigned int*)arg[0],
      *(const ::RPAlignmentCorrection*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((::RPAlignmentCorrections*)o)->AddSensorCorrection)(*(unsigned int*)arg[0],
      *(const ::RPAlignmentCorrection*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5]);
  }
}

static  void method_4530( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::RPAlignmentCorrections*)o)->AddCorrections)(*(const ::RPAlignmentCorrections*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::RPAlignmentCorrections*)o)->AddCorrections)(*(const ::RPAlignmentCorrections*)arg[0],
      *(bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RPAlignmentCorrections*)o)->AddCorrections)(*(const ::RPAlignmentCorrections*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::RPAlignmentCorrections*)o)->AddCorrections)(*(const ::RPAlignmentCorrections*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::RPAlignmentCorrections*)o)->AddCorrections)(*(const ::RPAlignmentCorrections*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  }
}

static  void method_4531( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::RPAlignmentCorrections*)o)->WriteXMLFile)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLFile)(*(const ::std::string*)arg[0],
      *(bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLFile)(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLFile)(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLFile)(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLFile)(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLFile)(*(const ::std::string*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5],
      *(bool*)arg[6]);
  }
}

static  void method_4532( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::RPAlignmentCorrections*)o)->WriteXMLBlock)((::FILE*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLBlock)((::FILE*)arg[0],
      *(bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLBlock)((::FILE*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLBlock)((::FILE*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLBlock)((::FILE*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLBlock)((::FILE*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    (((const ::RPAlignmentCorrections*)o)->WriteXMLBlock)((::FILE*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5],
      *(bool*)arg[6]);
  }
}

static  void method_4533( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RPAlignmentCorrections*)o)->Clear)();
}

static  void method_4534( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    (((const ::RPAlignmentCorrections*)o)->FactorRPFromSensorCorrections)(*(::RPAlignmentCorrections*)arg[0],
      *(::RPAlignmentCorrections*)arg[1],
      *(const ::AlignmentGeometry*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((const ::RPAlignmentCorrections*)o)->FactorRPFromSensorCorrections)(*(::RPAlignmentCorrections*)arg[0],
      *(::RPAlignmentCorrections*)arg[1],
      *(const ::AlignmentGeometry*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((const ::RPAlignmentCorrections*)o)->FactorRPFromSensorCorrections)(*(::RPAlignmentCorrections*)arg[0],
      *(::RPAlignmentCorrections*)arg[1],
      *(const ::AlignmentGeometry*)arg[2],
      *(bool*)arg[3],
      *(unsigned int*)arg[4]);
  }
}

static  void method_4535( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RPAlignmentCorrections*)o)->insertValues)(*(const ::std::string*)arg[0],
    *(const ::std::vector<double>*)arg[1]);
}

static void method_newdel_1069( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPAlignmentCorrections >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPAlignmentCorrections >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPAlignmentCorrections >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPAlignmentCorrections >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPAlignmentCorrections >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPAlignmentCorrections -------------------------------
void __RPAlignmentCorrections_db_datamem(Reflex::Class*);
void __RPAlignmentCorrections_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPAlignmentCorrections_datamem_bld(&__RPAlignmentCorrections_db_datamem);
Reflex::GenreflexMemberBuilder __RPAlignmentCorrections_funcmem_bld(&__RPAlignmentCorrections_db_funcmem);
void __RPAlignmentCorrections_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPAlignmentCorrections"), typeid(::RPAlignmentCorrections), sizeof(::RPAlignmentCorrections), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2716, Reflex::Literal("RPAlignmentCorrections::mapType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPAlignmentCorrections"), destructor_4511, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12597, type_12598), Reflex::Literal("operator="), operator_4512, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12598), Reflex::Literal("RPAlignmentCorrections"), constructor_4513, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPAlignmentCorrections"), constructor_4514, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9693), Reflex::Literal("RPAlignmentCorrections"), constructor_4515, 0, "fileName", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12599), Reflex::Literal("RPAlignmentCorrections"), constructor_4516, 0, "e", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1069, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPAlignmentCorrections_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPAlignmentCorrections_funcmem_bld);
}

//------Delayed data member builder for class RPAlignmentCorrections -------------------
void __RPAlignmentCorrections_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2716, Reflex::Literal("rps"), OffsetOf(__shadow__::__RPAlignmentCorrections, rps), ::Reflex::PRIVATE)
  .AddDataMember(type_2716, Reflex::Literal("sensors"), OffsetOf(__shadow__::__RPAlignmentCorrections, sensors), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RPAlignmentCorrections -------------------
void __RPAlignmentCorrections_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_9693), Reflex::Literal("LoadXMLFile"), method_4517, 0, "fileName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_12599), Reflex::Literal("LoadXMLBlock"), method_4518, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12600), Reflex::Literal("GetRPMap"), method_4519, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12600), Reflex::Literal("GetSensorMap"), method_4520, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12548, type_188), Reflex::Literal("GetRPCorrection"), method_4521, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_837, type_188), Reflex::Literal("GetRPCorrection"), method_4522, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12548, type_188), Reflex::Literal("GetSensorCorrection"), method_4523, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_837, type_188), Reflex::Literal("GetSensorCorrection"), method_4524, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_837, type_188, type_1400), Reflex::Literal("GetFullSensorCorrection"), method_4525, 0, "id;useRPErrors=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_188, type_12549), Reflex::Literal("SetRPCorrection"), method_4526, 0, "id;ac", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_188, type_12549), Reflex::Literal("SetSensorCorrection"), method_4527, 0, "id;ac", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_188, type_12549, type_1400, type_1400, type_1400, type_1400), Reflex::Literal("AddRPCorrection"), method_4528, 0, ";;sumErrors=true;addShR=true;addShZ=true;addRotZ=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_188, type_12549, type_1400, type_1400, type_1400, type_1400), Reflex::Literal("AddSensorCorrection"), method_4529, 0, ";;sumErrors=true;addShR=true;addShZ=true;addRotZ=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_12598, type_1400, type_1400, type_1400, type_1400), Reflex::Literal("AddCorrections"), method_4530, 0, ";sumErrors=true;addShR=true;addShZ=true;addRotZ=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_9693, type_1400, type_1400, type_1400, type_1400, type_1400, type_1400), Reflex::Literal("WriteXMLFile"), method_4531, 0, "fileName;precise=false;wrErrors=true;wrSh_r=true;wrSh_xy=true;wrSh_z=true;wrRot_z=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_2995, type_1400, type_1400, type_1400, type_1400, type_1400, type_1400), Reflex::Literal("WriteXMLBlock"), method_4532, 0, ";precise=false;wrErrors=true;wrSh_r=true;wrSh_xy=true;wrSh_z=true;wrRot_z=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597), Reflex::Literal("Clear"), method_4533, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_12597, type_12597, type_12601, type_1400, type_188), Reflex::Literal("FactorRPFromSensorCorrections"), method_4534, 0, "expanded;factored;;equalWeights=false;verbosity=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_9693, type_12551), Reflex::Literal("insertValues"), method_4535, 0, "identifier;values", ::Reflex::PUBLIC);
}
//------Stub functions for class LocalTrackFit -------------------------------
static void destructor_5139(void*, void * o, const std::vector<void*>&, void *) {
(((::LocalTrackFit*)o)->::LocalTrackFit::~LocalTrackFit)();
}
static  void operator_5140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::LocalTrackFit*)o)->operator=)(*(const ::LocalTrackFit*)arg[0]);
  else   (((::LocalTrackFit*)o)->operator=)(*(const ::LocalTrackFit*)arg[0]);
}

static void constructor_5141( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFit(*(const ::LocalTrackFit*)arg[0]);
  else ::new(mem) ::LocalTrackFit(*(const ::LocalTrackFit*)arg[0]);
}

static void constructor_5142( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFit();
  else ::new(mem) ::LocalTrackFit();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFit(*(double*)arg[0]);
  else ::new(mem) ::LocalTrackFit(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  else ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
  else ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(unsigned int*)arg[5]);
  else ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(unsigned int*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(unsigned int*)arg[5],
      *(double*)arg[6]);
  else ::new(mem) ::LocalTrackFit(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(unsigned int*)arg[5],
      *(double*)arg[6]);
  }
}

static  void method_5143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::LocalTrackFit*)o)->PValue)());
  else   (((const ::LocalTrackFit*)o)->PValue)();
}

static  void method_5144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::LocalTrackFit*)o)->ChiSqPerNdf)());
  else   (((const ::LocalTrackFit*)o)->ChiSqPerNdf)();
}

static  void method_5145( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::LocalTrackFit*)o)->Eval)(*(double*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static void constructor_x3( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LocalTrackFit();
  else ::new(mem) ::LocalTrackFit();
}

static void method_newdel_1737( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::LocalTrackFit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::LocalTrackFit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::LocalTrackFit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::LocalTrackFit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::LocalTrackFit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class LocalTrackFit -------------------------------
void __LocalTrackFit_db_datamem(Reflex::Class*);
void __LocalTrackFit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __LocalTrackFit_datamem_bld(&__LocalTrackFit_db_datamem);
Reflex::GenreflexMemberBuilder __LocalTrackFit_funcmem_bld(&__LocalTrackFit_db_funcmem);
void __LocalTrackFit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("LocalTrackFit"), typeid(::LocalTrackFit), sizeof(::LocalTrackFit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~LocalTrackFit"), destructor_5139, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12669, type_12670), Reflex::Literal("operator="), operator_5140, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12670), Reflex::Literal("LocalTrackFit"), constructor_5141, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_98, type_98, type_98, type_98, type_98, type_188, type_98), Reflex::Literal("LocalTrackFit"), constructor_5142, 0, "_z0=0.0;_ax=0.0;_ay=0.0;_bx=0.0;_by=0.0;_ndf=0;_chi_sq=0.0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("LocalTrackFit"), constructor_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1737, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__LocalTrackFit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__LocalTrackFit_funcmem_bld);
}

//------Delayed data member builder for class LocalTrackFit -------------------
void __LocalTrackFit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_98, Reflex::Literal("z0"), OffsetOf(__shadow__::__LocalTrackFit, z0), ::Reflex::PUBLIC)
  .AddDataMember(type_98, Reflex::Literal("ax"), OffsetOf(__shadow__::__LocalTrackFit, ax), ::Reflex::PUBLIC)
  .AddDataMember(type_98, Reflex::Literal("ay"), OffsetOf(__shadow__::__LocalTrackFit, ay), ::Reflex::PUBLIC)
  .AddDataMember(type_98, Reflex::Literal("bx"), OffsetOf(__shadow__::__LocalTrackFit, bx), ::Reflex::PUBLIC)
  .AddDataMember(type_98, Reflex::Literal("by"), OffsetOf(__shadow__::__LocalTrackFit, by), ::Reflex::PUBLIC)
  .AddDataMember(type_64, Reflex::Literal("ndf"), OffsetOf(__shadow__::__LocalTrackFit, ndf), ::Reflex::PUBLIC)
  .AddDataMember(type_98, Reflex::Literal("chi_sq"), OffsetOf(__shadow__::__LocalTrackFit, chi_sq), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class LocalTrackFit -------------------
void __LocalTrackFit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("PValue"), method_5143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_98), Reflex::Literal("ChiSqPerNdf"), method_5144, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_98, type_10097, type_10097), Reflex::Literal("Eval"), method_5145, 0, "z;x;y", ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<LocalTrackFit> -------------------------------
static void constructor_11750( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LocalTrackFit>();
  else ::new(mem) ::edm::Wrapper<LocalTrackFit>();
}

static void constructor_11751( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LocalTrackFit>(*(::std::auto_ptr<LocalTrackFit>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<LocalTrackFit>(*(::std::auto_ptr<LocalTrackFit>*)arg[0]);
}

static void destructor_11752(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<LocalTrackFit>*)o)->::edm::Wrapper<LocalTrackFit>::~Wrapper)();
}
static  void method_11753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<LocalTrackFit>*)o)->product)());
  else   (((const ::edm::Wrapper<LocalTrackFit>*)o)->product)();
}

static  void operator_11754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<LocalTrackFit>*)o)->operator->)());
  else   (((const ::edm::Wrapper<LocalTrackFit>*)o)->operator->)();
}

static  void method_11755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<LocalTrackFit>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<LocalTrackFit>*)o)->productTypeInfo)();
}

static  void method_11756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<LocalTrackFit>*)o)->typeInfo)();
  else   (((::edm::Wrapper<LocalTrackFit>*)o)->typeInfo)();
}

static void constructor_11757( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<LocalTrackFit>((::LocalTrackFit*)arg[0]);
  else ::new(mem) ::edm::Wrapper<LocalTrackFit>((::LocalTrackFit*)arg[0]);
}

static  void method_11758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<LocalTrackFit>*)o)->getInterface)());
  else   (((::edm::Wrapper<LocalTrackFit>*)o)->getInterface)();
}

static  void method_11759( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LocalTrackFit>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_11760( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LocalTrackFit>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_11761( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<LocalTrackFit>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_11762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<LocalTrackFit>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<LocalTrackFit>*)o)->dynamicTypeInfo)();
}

static  void method_11763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<LocalTrackFit>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<LocalTrackFit>*)o)->isPresent)();
}

static  void method_11764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<LocalTrackFit>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<LocalTrackFit>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3460( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LocalTrackFit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LocalTrackFit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LocalTrackFit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LocalTrackFit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<LocalTrackFit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<LocalTrackFit> -------------------------------
void __edm__Wrapper_LocalTrackFit__db_datamem(Reflex::Class*);
void __edm__Wrapper_LocalTrackFit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_LocalTrackFit__datamem_bld(&__edm__Wrapper_LocalTrackFit__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_LocalTrackFit__funcmem_bld(&__edm__Wrapper_LocalTrackFit__db_funcmem);
void __edm__Wrapper_LocalTrackFit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<LocalTrackFit>"), typeid(::edm::Wrapper<LocalTrackFit>), sizeof(::edm::Wrapper<LocalTrackFit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1737, Reflex::Literal("edm::Wrapper<LocalTrackFit>::value_type"))
  .AddTypedef(type_1737, Reflex::Literal("edm::Wrapper<LocalTrackFit>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_11750, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2439), Reflex::Literal("Wrapper"), constructor_11751, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_11752, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18339), Reflex::Literal("Wrapper"), constructor_11757, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3460, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_LocalTrackFit__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_LocalTrackFit__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<LocalTrackFit> -------------------
void __edm__Wrapper_LocalTrackFit__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1400, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_LocalTrackFit_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1737, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_LocalTrackFit_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<LocalTrackFit> -------------------
void __edm__Wrapper_LocalTrackFit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18338), Reflex::Literal("product"), method_11753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18338), Reflex::Literal("operator->"), operator_11754, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11490), Reflex::Literal("productTypeInfo"), method_11755, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11490), Reflex::Literal("typeInfo"), method_11756, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18340), Reflex::Literal("getInterface"), method_11758, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_11813, type_17866, type_18341), Reflex::Literal("fillView"), method_11759, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_11490, type_279, type_7069), Reflex::Literal("setPtr"), method_11760, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_597, type_11490, type_17867, type_17866), Reflex::Literal("fillPtrVector"), method_11761, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11490), Reflex::Literal("dynamicTypeInfo"), method_11762, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1400), Reflex::Literal("isPresent"), method_11763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11490), Reflex::Literal("dynamicTypeInfo_"), method_11764, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __RPAlignmentCorrection_dict(); 
      __RPAlignmentCorrections_dict(); 
      __LocalTrackFit_dict(); 
      __edm__Wrapper_LocalTrackFit__dict(); 
    }
    ~Dictionaries() {
      type_837.Unload(); // class RPAlignmentCorrection 
      type_1069.Unload(); // class RPAlignmentCorrections 
      type_1737.Unload(); // class LocalTrackFit 
      type_3460.Unload(); // class edm::Wrapper<LocalTrackFit> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
