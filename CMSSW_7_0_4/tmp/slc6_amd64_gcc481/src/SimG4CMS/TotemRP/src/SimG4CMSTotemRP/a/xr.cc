// Generated at Mon Jul 11 23:08:25 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/SimG4CMS/TotemRP/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_70 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_64 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_575 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1342 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_100 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_271 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1531 = ::Reflex::TypeBuilder(Reflex::Literal("TotemRPHistoClass"));
  ::Reflex::Type type_4729 = ::Reflex::TypeBuilder(Reflex::Literal("TotemRPHistoClass::Hit"));
  ::Reflex::Type type_2482 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TotemRPHistoClass::Hit>"));
  ::Reflex::Type type_2639 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TotemRPHistoClass::Hit>"));
  ::Reflex::Type type_4978 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<TotemRPHistoClass::Hit> >"));
  ::Reflex::Type type_2132 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TotemRPHistoClass::Hit,std::allocator<TotemRPHistoClass::Hit> >"));
  ::Reflex::Type type_4932 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >"));
  ::Reflex::Type type_4933 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >"));
  ::Reflex::Type type_2732 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> > >"));
  ::Reflex::Type type_2731 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> > >"));
  ::Reflex::Type type_12658 = ::Reflex::ReferenceBuilder(type_1531);
  ::Reflex::Type type_1531c = ::Reflex::ConstBuilder(type_1531);
  ::Reflex::Type type_12659 = ::Reflex::ReferenceBuilder(type_1531c);
  ::Reflex::Type type_8776 = ::Reflex::ReferenceBuilder(type_4729);
  ::Reflex::Type type_4729c = ::Reflex::ConstBuilder(type_4729);
  ::Reflex::Type type_8778 = ::Reflex::ReferenceBuilder(type_4729c);
  ::Reflex::Type type_6088 = ::Reflex::PointerBuilder(type_4729);
  ::Reflex::Type type_8774 = ::Reflex::PointerBuilder(type_4729c);
  ::Reflex::Type type_2602 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_271);
  ::Reflex::Type type_2540 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_64);
  ::Reflex::Type type_2639c = ::Reflex::ConstBuilder(type_2639);
  ::Reflex::Type type_15485 = ::Reflex::ReferenceBuilder(type_2639c);
  ::Reflex::Type type_2482c = ::Reflex::ConstBuilder(type_2482);
  ::Reflex::Type type_15927 = ::Reflex::ReferenceBuilder(type_2482c);
  ::Reflex::Type type_15928 = ::Reflex::ReferenceBuilder(type_2482);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TotemRPHistoClass
#undef __TotemRPHistoClass
#endif
class __TotemRPHistoClass {
  public:
  __TotemRPHistoClass();
  int evt;
  int hits;
  ::std::vector<TotemRPHistoClass::Hit> hit;
};
#ifdef __TotemRPHistoClass__Hit
#undef __TotemRPHistoClass__Hit
#endif
struct __TotemRPHistoClass__Hit {
  public:
  __TotemRPHistoClass__Hit();
  double x;
  double y;
  double z;
  double ELoss;
  double PABS;
  double vx;
  double vy;
  double vz;
  double lx;
  double ly;
  double lz;
  double x_ex;
  double y_ex;
  double z_ex;
  double lx_ex;
  double ly_ex;
  double lz_ex;
  double p_x;
  double p_y;
  double p_z;
  int UID;
  int Ptype;
  int TID;
  int PID;
  int prim_ver_id;
};
#ifdef __std__vector_TotemRPHistoClass__Hit_
#undef __std__vector_TotemRPHistoClass__Hit_
#endif
class __std__vector_TotemRPHistoClass__Hit_ : protected ::std::_Vector_base<TotemRPHistoClass::Hit,std::allocator<TotemRPHistoClass::Hit> > {
  public:
  __std__vector_TotemRPHistoClass__Hit_();
};
}


#endif // __CINT__
namespace {
//------Stub functions for class TotemRPHistoClass -------------------------------
static  void operator_4730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TotemRPHistoClass*)o)->operator=)(*(const ::TotemRPHistoClass*)arg[0]);
  else   (((::TotemRPHistoClass*)o)->operator=)(*(const ::TotemRPHistoClass*)arg[0]);
}

static void constructor_4731( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRPHistoClass(*(const ::TotemRPHistoClass*)arg[0]);
  else ::new(mem) ::TotemRPHistoClass(*(const ::TotemRPHistoClass*)arg[0]);
}

static void constructor_4732( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRPHistoClass();
  else ::new(mem) ::TotemRPHistoClass();
}

static void destructor_4733(void*, void * o, const std::vector<void*>&, void *) {
(((::TotemRPHistoClass*)o)->::TotemRPHistoClass::~TotemRPHistoClass)();
}
static  void method_4734( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TotemRPHistoClass*)o)->setEVT)(*(int*)arg[0]);
}

static  void method_4735( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TotemRPHistoClass*)o)->fillHit)(*(int*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2],
    *(int*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(double*)arg[14],
    *(double*)arg[15],
    *(double*)arg[16],
    *(double*)arg[17],
    *(double*)arg[18],
    *(double*)arg[19],
    *(double*)arg[20],
    *(double*)arg[21],
    *(double*)arg[22],
    *(double*)arg[23],
    *(int*)arg[24]);
}

static void method_newdel_1531( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TotemRPHistoClass >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TotemRPHistoClass >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TotemRPHistoClass >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TotemRPHistoClass >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TotemRPHistoClass >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TotemRPHistoClass -------------------------------
void __TotemRPHistoClass_db_datamem(Reflex::Class*);
void __TotemRPHistoClass_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TotemRPHistoClass_datamem_bld(&__TotemRPHistoClass_db_datamem);
Reflex::GenreflexMemberBuilder __TotemRPHistoClass_funcmem_bld(&__TotemRPHistoClass_db_funcmem);
void __TotemRPHistoClass_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TotemRPHistoClass"), typeid(::TotemRPHistoClass), sizeof(::TotemRPHistoClass), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12658, type_12659), Reflex::Literal("operator="), operator_4730, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12659), Reflex::Literal("TotemRPHistoClass"), constructor_4731, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TotemRPHistoClass"), constructor_4732, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TotemRPHistoClass"), destructor_4733, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1531, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TotemRPHistoClass_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TotemRPHistoClass_funcmem_bld);
}

//------Delayed data member builder for class TotemRPHistoClass -------------------
void __TotemRPHistoClass_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_70, Reflex::Literal("evt"), OffsetOf(__shadow__::__TotemRPHistoClass, evt), ::Reflex::PRIVATE)
  .AddDataMember(type_70, Reflex::Literal("hits"), OffsetOf(__shadow__::__TotemRPHistoClass, hits), ::Reflex::PRIVATE)
  .AddDataMember(type_2482, Reflex::Literal("hit"), OffsetOf(__shadow__::__TotemRPHistoClass, hit), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TotemRPHistoClass -------------------
void __TotemRPHistoClass_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_70), Reflex::Literal("setEVT"), method_4734, 0, "v", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_70, type_70, type_70, type_70, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_100, type_70), Reflex::Literal("fillHit"), method_4735, 0, "UID_;Ptype_;TID_;PID_;ELoss_;PABS_;p_x_;p_y_;p_z_;vx_;vy_;vz_;x_;y_;z_;lx_;ly_;lz_;x_ex_;y_ex_;z_ex_;lx_ex_;ly_ex_;lz_ex_;prim_ver_id_", ::Reflex::PUBLIC);
}
//------Stub functions for class Hit -------------------------------
static void destructor_12654(void*, void * o, const std::vector<void*>&, void *) {
(((::TotemRPHistoClass::Hit*)o)->::TotemRPHistoClass::Hit::~Hit)();
}
static  void operator_12655( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TotemRPHistoClass::Hit*)o)->operator=)(*(const ::TotemRPHistoClass::Hit*)arg[0]);
  else   (((::TotemRPHistoClass::Hit*)o)->operator=)(*(const ::TotemRPHistoClass::Hit*)arg[0]);
}

static void constructor_12656( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRPHistoClass::Hit(*(const ::TotemRPHistoClass::Hit*)arg[0]);
  else ::new(mem) ::TotemRPHistoClass::Hit(*(const ::TotemRPHistoClass::Hit*)arg[0]);
}

static void constructor_12657( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRPHistoClass::Hit();
  else ::new(mem) ::TotemRPHistoClass::Hit();
}

static void method_newdel_4729( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TotemRPHistoClass::Hit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TotemRPHistoClass::Hit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TotemRPHistoClass::Hit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TotemRPHistoClass::Hit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TotemRPHistoClass::Hit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Hit -------------------------------
void __TotemRPHistoClass__Hit_db_datamem(Reflex::Class*);
void __TotemRPHistoClass__Hit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TotemRPHistoClass__Hit_datamem_bld(&__TotemRPHistoClass__Hit_db_datamem);
Reflex::GenreflexMemberBuilder __TotemRPHistoClass__Hit_funcmem_bld(&__TotemRPHistoClass__Hit_db_funcmem);
void __TotemRPHistoClass__Hit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TotemRPHistoClass::Hit"), typeid(::TotemRPHistoClass::Hit), sizeof(::TotemRPHistoClass::Hit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Hit"), destructor_12654, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8776, type_8778), Reflex::Literal("operator="), operator_12655, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8778), Reflex::Literal("Hit"), constructor_12656, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Hit"), constructor_12657, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4729, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TotemRPHistoClass__Hit_datamem_bld);
}

//------Delayed data member builder for class Hit -------------------
void __TotemRPHistoClass__Hit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_100, Reflex::Literal("x"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, x), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("y"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, y), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("z"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, z), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("ELoss"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, ELoss), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("PABS"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, PABS), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("vx"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, vx), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("vy"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, vy), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("vz"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, vz), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("lx"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, lx), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("ly"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, ly), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("lz"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, lz), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("x_ex"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, x_ex), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("y_ex"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, y_ex), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("z_ex"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, z_ex), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("lx_ex"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, lx_ex), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("ly_ex"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, ly_ex), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("lz_ex"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, lz_ex), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("p_x"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, p_x), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("p_y"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, p_y), ::Reflex::PUBLIC)
  .AddDataMember(type_100, Reflex::Literal("p_z"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, p_z), ::Reflex::PUBLIC)
  .AddDataMember(type_70, Reflex::Literal("UID"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, UID), ::Reflex::PUBLIC)
  .AddDataMember(type_70, Reflex::Literal("Ptype"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, Ptype), ::Reflex::PUBLIC)
  .AddDataMember(type_70, Reflex::Literal("TID"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, TID), ::Reflex::PUBLIC)
  .AddDataMember(type_70, Reflex::Literal("PID"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, PID), ::Reflex::PUBLIC)
  .AddDataMember(type_70, Reflex::Literal("prim_ver_id"), OffsetOf(__shadow__::__TotemRPHistoClass__Hit, prim_ver_id), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class Hit -------------------
void __TotemRPHistoClass__Hit_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<TotemRPHistoClass::Hit,std::allocator<TotemRPHistoClass::Hit> > -------------------------------
static void constructor_8787( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRPHistoClass::Hit>();
  else ::new(mem) ::std::vector<TotemRPHistoClass::Hit>();
}

static void constructor_8788( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRPHistoClass::Hit>(*(const ::std::allocator<TotemRPHistoClass::Hit>*)arg[0]);
  else ::new(mem) ::std::vector<TotemRPHistoClass::Hit>(*(const ::std::allocator<TotemRPHistoClass::Hit>*)arg[0]);
}

static void constructor_8789( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRPHistoClass::Hit>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TotemRPHistoClass::Hit>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRPHistoClass::Hit>(*(::std::size_t*)arg[0],
      *(const ::TotemRPHistoClass::Hit*)arg[1]);
  else ::new(mem) ::std::vector<TotemRPHistoClass::Hit>(*(::std::size_t*)arg[0],
      *(const ::TotemRPHistoClass::Hit*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRPHistoClass::Hit>(*(::std::size_t*)arg[0],
      *(const ::TotemRPHistoClass::Hit*)arg[1],
      *(const ::std::allocator<TotemRPHistoClass::Hit>*)arg[2]);
  else ::new(mem) ::std::vector<TotemRPHistoClass::Hit>(*(::std::size_t*)arg[0],
      *(const ::TotemRPHistoClass::Hit*)arg[1],
      *(const ::std::allocator<TotemRPHistoClass::Hit>*)arg[2]);
  }
}

static void constructor_8790( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TotemRPHistoClass::Hit>(*(const ::std::vector<TotemRPHistoClass::Hit>*)arg[0]);
  else ::new(mem) ::std::vector<TotemRPHistoClass::Hit>(*(const ::std::vector<TotemRPHistoClass::Hit>*)arg[0]);
}

static void destructor_8791(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TotemRPHistoClass::Hit>*)o)->::std::vector<TotemRPHistoClass::Hit>::~vector)();
}
static  void operator_8792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TotemRPHistoClass::Hit>*)o)->operator=)(*(const ::std::vector<TotemRPHistoClass::Hit>*)arg[0]);
  else   (((::std::vector<TotemRPHistoClass::Hit>*)o)->operator=)(*(const ::std::vector<TotemRPHistoClass::Hit>*)arg[0]);
}

static  void method_8793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TotemRPHistoClass::Hit>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::TotemRPHistoClass::Hit*)arg[1]);
}

static  void method_8794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >)((((::std::vector<TotemRPHistoClass::Hit>*)o)->begin)());
  else   (((::std::vector<TotemRPHistoClass::Hit>*)o)->begin)();
}

static  void method_8795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >)((((const ::std::vector<TotemRPHistoClass::Hit>*)o)->begin)());
  else   (((const ::std::vector<TotemRPHistoClass::Hit>*)o)->begin)();
}

static  void method_8796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >)((((::std::vector<TotemRPHistoClass::Hit>*)o)->end)());
  else   (((::std::vector<TotemRPHistoClass::Hit>*)o)->end)();
}

static  void method_8797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >)((((const ::std::vector<TotemRPHistoClass::Hit>*)o)->end)());
  else   (((const ::std::vector<TotemRPHistoClass::Hit>*)o)->end)();
}

static  void method_8802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TotemRPHistoClass::Hit>*)o)->size)());
  else   (((const ::std::vector<TotemRPHistoClass::Hit>*)o)->size)();
}

static  void method_8803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TotemRPHistoClass::Hit>*)o)->max_size)());
  else   (((const ::std::vector<TotemRPHistoClass::Hit>*)o)->max_size)();
}

static  void method_8804( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TotemRPHistoClass::Hit>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TotemRPHistoClass::Hit>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::TotemRPHistoClass::Hit*)arg[1]);
  }
}

static  void method_8805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TotemRPHistoClass::Hit>*)o)->capacity)());
  else   (((const ::std::vector<TotemRPHistoClass::Hit>*)o)->capacity)();
}

static  void method_8806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TotemRPHistoClass::Hit>*)o)->empty)());
  else   (((const ::std::vector<TotemRPHistoClass::Hit>*)o)->empty)();
}

static  void method_8807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TotemRPHistoClass::Hit>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TotemRPHistoClass::Hit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TotemRPHistoClass::Hit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TotemRPHistoClass::Hit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TotemRPHistoClass::Hit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TotemRPHistoClass::Hit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TotemRPHistoClass::Hit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TotemRPHistoClass::Hit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TotemRPHistoClass::Hit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TotemRPHistoClass::Hit>*)o)->front)();
  else   (((::std::vector<TotemRPHistoClass::Hit>*)o)->front)();
}

static  void method_8814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TotemRPHistoClass::Hit>*)o)->front)();
  else   (((const ::std::vector<TotemRPHistoClass::Hit>*)o)->front)();
}

static  void method_8815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TotemRPHistoClass::Hit>*)o)->back)();
  else   (((::std::vector<TotemRPHistoClass::Hit>*)o)->back)();
}

static  void method_8816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TotemRPHistoClass::Hit>*)o)->back)();
  else   (((const ::std::vector<TotemRPHistoClass::Hit>*)o)->back)();
}

static  void method_8817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TotemRPHistoClass::Hit>*)o)->data)());
  else   (((::std::vector<TotemRPHistoClass::Hit>*)o)->data)();
}

static  void method_8818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TotemRPHistoClass::Hit>*)o)->data)());
  else   (((const ::std::vector<TotemRPHistoClass::Hit>*)o)->data)();
}

static  void method_8819( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TotemRPHistoClass::Hit>*)o)->push_back)(*(const ::TotemRPHistoClass::Hit*)arg[0]);
}

static  void method_8820( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TotemRPHistoClass::Hit>*)o)->pop_back)();
}

static  void method_8821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >)((((::std::vector<TotemRPHistoClass::Hit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >*)arg[0],
    *(const ::TotemRPHistoClass::Hit*)arg[1]));
  else   (((::std::vector<TotemRPHistoClass::Hit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >*)arg[0],
    *(const ::TotemRPHistoClass::Hit*)arg[1]);
}

static  void method_8822( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TotemRPHistoClass::Hit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::TotemRPHistoClass::Hit*)arg[2]);
}

static  void method_8823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >)((((::std::vector<TotemRPHistoClass::Hit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >*)arg[0]));
  else   (((::std::vector<TotemRPHistoClass::Hit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >*)arg[0]);
}

static  void method_8824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >)((((::std::vector<TotemRPHistoClass::Hit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >*)arg[1]));
  else   (((::std::vector<TotemRPHistoClass::Hit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TotemRPHistoClass::Hit*,std::vector<TotemRPHistoClass::Hit> >*)arg[1]);
}

static  void method_8825( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TotemRPHistoClass::Hit>*)o)->swap)(*(::std::vector<TotemRPHistoClass::Hit>*)arg[0]);
}

static  void method_8826( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TotemRPHistoClass::Hit>*)o)->clear)();
}

static void method_newdel_2482( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TotemRPHistoClass::Hit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TotemRPHistoClass::Hit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TotemRPHistoClass::Hit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TotemRPHistoClass::Hit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TotemRPHistoClass::Hit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TotemRPHistoClass::Hit,std::allocator<TotemRPHistoClass::Hit> >")), ::Reflex::BaseOffset< ::std::vector<TotemRPHistoClass::Hit>,::std::_Vector_base<TotemRPHistoClass::Hit,std::allocator<TotemRPHistoClass::Hit> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TotemRPHistoClass::Hit> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TotemRPHistoClass::Hit> >::Generate();
}

//------Dictionary for class vector<TotemRPHistoClass::Hit,std::allocator<TotemRPHistoClass::Hit> > -------------------------------
void __std__vector_TotemRPHistoClass__Hit__db_datamem(Reflex::Class*);
void __std__vector_TotemRPHistoClass__Hit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TotemRPHistoClass__Hit__datamem_bld(&__std__vector_TotemRPHistoClass__Hit__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TotemRPHistoClass__Hit__funcmem_bld(&__std__vector_TotemRPHistoClass__Hit__db_funcmem);
void __std__vector_TotemRPHistoClass__Hit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TotemRPHistoClass::Hit>"), typeid(::std::vector<TotemRPHistoClass::Hit>), sizeof(::std::vector<TotemRPHistoClass::Hit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2132, ::Reflex::BaseOffset< ::std::vector<TotemRPHistoClass::Hit>, ::std::_Vector_base<TotemRPHistoClass::Hit,std::allocator<TotemRPHistoClass::Hit> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4729, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::_Alloc_value_type"))
  .AddTypedef(type_2132, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::_Base"))
  .AddTypedef(type_2639, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::_Tp_alloc_type"))
  .AddTypedef(type_4978, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::_Alloc_traits"))
  .AddTypedef(type_4729, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::value_type"))
  .AddTypedef(type_6088, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::pointer"))
  .AddTypedef(type_8774, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::const_pointer"))
  .AddTypedef(type_8776, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::reference"))
  .AddTypedef(type_8778, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::const_reference"))
  .AddTypedef(type_4932, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::iterator"))
  .AddTypedef(type_4933, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::const_iterator"))
  .AddTypedef(type_2731, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::const_reverse_iterator"))
  .AddTypedef(type_2732, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::reverse_iterator"))
  .AddTypedef(type_2602, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::size_type"))
  .AddTypedef(type_2540, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::difference_type"))
  .AddTypedef(type_2639, Reflex::Literal("std::vector<TotemRPHistoClass::Hit>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8787, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15485), Reflex::Literal("vector"), constructor_8788, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2602, type_8778, type_15485), Reflex::Literal("vector"), constructor_8789, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15927), Reflex::Literal("vector"), constructor_8790, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8791, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2482, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TotemRPHistoClass__Hit__funcmem_bld);
}

//------Delayed data member builder for class vector<TotemRPHistoClass::Hit,std::allocator<TotemRPHistoClass::Hit> > -------------------
void __std__vector_TotemRPHistoClass__Hit__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TotemRPHistoClass::Hit,std::allocator<TotemRPHistoClass::Hit> > -------------------
void __std__vector_TotemRPHistoClass__Hit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15928, type_15927), Reflex::Literal("operator="), operator_8792, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2602, type_8778), Reflex::Literal("assign"), method_8793, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4932), Reflex::Literal("begin"), method_8794, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("begin"), method_8795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4932), Reflex::Literal("end"), method_8796, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4933), Reflex::Literal("end"), method_8797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2602), Reflex::Literal("size"), method_8802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2602), Reflex::Literal("max_size"), method_8803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2602, type_4729), Reflex::Literal("resize"), method_8804, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2602), Reflex::Literal("capacity"), method_8805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1342), Reflex::Literal("empty"), method_8806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_2602), Reflex::Literal("reserve"), method_8807, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8776, type_2602), Reflex::Literal("operator[]"), operator_8808, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8778, type_2602), Reflex::Literal("operator[]"), operator_8809, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8776, type_2602), Reflex::Literal("at"), method_8811, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8778, type_2602), Reflex::Literal("at"), method_8812, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8776), Reflex::Literal("front"), method_8813, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8778), Reflex::Literal("front"), method_8814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8776), Reflex::Literal("back"), method_8815, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8778), Reflex::Literal("back"), method_8816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6088), Reflex::Literal("data"), method_8817, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8774), Reflex::Literal("data"), method_8818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_8778), Reflex::Literal("push_back"), method_8819, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("pop_back"), method_8820, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4932, type_4932, type_8778), Reflex::Literal("insert"), method_8821, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_4932, type_2602, type_8778), Reflex::Literal("insert"), method_8822, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4932, type_4932), Reflex::Literal("erase"), method_8823, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4932, type_4932, type_4932), Reflex::Literal("erase"), method_8824, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575, type_15928), Reflex::Literal("swap"), method_8825, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_575), Reflex::Literal("clear"), method_8826, 0, 0, ::Reflex::PUBLIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TotemRPHistoClass_dict(); 
      __TotemRPHistoClass__Hit_dict(); 
      __std__vector_TotemRPHistoClass__Hit__dict(); 
    }
    ~Dictionaries() {
      type_1531.Unload(); // class TotemRPHistoClass 
      type_4729.Unload(); // class TotemRPHistoClass::Hit 
      type_2482.Unload(); // class std::vector<TotemRPHistoClass::Hit> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
