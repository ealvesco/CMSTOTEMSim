// Generated at Mon Jul 11 23:14:15 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/TotemRawData/RawToDigi/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_69 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_63 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_577 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1345 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1212 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_1749 = ::Reflex::TypeBuilder(Reflex::Literal("VFATStatus"));
  ::Reflex::Type type_271 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_395 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_2763 = ::Reflex::TypeBuilder(Reflex::Literal("std::bitset<8>"));
  ::Reflex::Type type_3408 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2443 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Base_bitset<1>"));
  ::Reflex::Type type_2931 = ::Reflex::TypeBuilder(Reflex::Literal("Totem::FramePosition"));
  ::Reflex::Type type_2141 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_2474 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_3307 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<VFATStatus>"));
  ::Reflex::Type type_2312 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<VFATStatus>"));
  ::Reflex::Type type_10249 = ::Reflex::TypeBuilder(Reflex::Literal("std::bitset<8>::reference"));
  ::Reflex::Type type_2475 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3306 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::bitset<8> >"));
  ::Reflex::Type type_2311 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::bitset<8> >"));
  ::Reflex::Type type_2224 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<Totem::FramePosition>"));
  ::Reflex::Type type_3338 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<VFATStatus>"));
  ::Reflex::Type type_3337 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::bitset<8> >"));
  ::Reflex::Type type_1595 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>"));
  ::Reflex::Type type_2449 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const Totem::FramePosition,VFATStatus>"));
  ::Reflex::Type type_3229 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3308 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >"));
  ::Reflex::Type type_2313 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<Totem::FramePosition,VFATStatus> >"));
  ::Reflex::Type type_2641 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const Totem::FramePosition,VFATStatus> >"));
  ::Reflex::Type type_3339 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<Totem::FramePosition,VFATStatus> >"));
  ::Reflex::Type type_2541 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >"));
  ::Reflex::Type type_2627 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,VFATStatus> >"));
  ::Reflex::Type type_2451 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >,bool>"));
  ::Reflex::Type type_2720 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> > >"));
  ::Reflex::Type type_2719 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,VFATStatus> > >"));
  ::Reflex::Type type_2450 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >,std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> > >"));
  ::Reflex::Type type_2448 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,VFATStatus> >,std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,VFATStatus> > >"));
  ::Reflex::Type type_2270 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<Totem::FramePosition,std::pair<const Totem::FramePosition,VFATStatus>,std::_Select1st<std::pair<const Totem::FramePosition,VFATStatus> >,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition,VFATStatus> > >"));
  ::Reflex::Type type_1596 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Raw2DigiStatus"), type_1595);
  ::Reflex::Type type_13006 = ::Reflex::ReferenceBuilder(type_1749);
  ::Reflex::Type type_1749c = ::Reflex::ConstBuilder(type_1749);
  ::Reflex::Type type_4322 = ::Reflex::ReferenceBuilder(type_1749c);
  ::Reflex::Type type_16487 = ::Reflex::ReferenceBuilder(type_2763);
  ::Reflex::Type type_2763c = ::Reflex::ConstBuilder(type_2763);
  ::Reflex::Type type_16488 = ::Reflex::ReferenceBuilder(type_2763c);
  ::Reflex::Type type_2624 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_271);
  ::Reflex::Type type_18086 = ::Reflex::PointerBuilder(type_2763c);
  ::Reflex::Type type_395c = ::Reflex::ConstBuilder(type_395);
  ::Reflex::Type type_10966 = ::Reflex::ReferenceBuilder(type_395c);
  ::Reflex::Type type_18087 = ::Reflex::PointerBuilder(type_2763);
  ::Reflex::Type type_3337c = ::Reflex::ConstBuilder(type_3337);
  ::Reflex::Type type_18088 = ::Reflex::PointerBuilder(type_3337c);
  ::Reflex::Type type_3408c = ::Reflex::ConstBuilder(type_3408);
  ::Reflex::Type type_12229 = ::Reflex::ReferenceBuilder(type_3408c);
  ::Reflex::Type type_16199 = ::Reflex::ReferenceBuilder(type_2474);
  ::Reflex::Type type_18012 = ::Reflex::ReferenceBuilder(type_3229);
  ::Reflex::Type type_577c = ::Reflex::ConstBuilder(type_577);
  ::Reflex::Type type_2932 = ::Reflex::PointerBuilder(type_577c);
  ::Reflex::Type type_6578 = ::Reflex::ReferenceBuilder(type_2932);
  ::Reflex::Type type_2475c = ::Reflex::ConstBuilder(type_2475);
  ::Reflex::Type type_16200 = ::Reflex::ReferenceBuilder(type_2475c);
  ::Reflex::Type type_18091 = ::Reflex::PointerBuilder(type_1749c);
  ::Reflex::Type type_18092 = ::Reflex::PointerBuilder(type_1749);
  ::Reflex::Type type_3338c = ::Reflex::ConstBuilder(type_3338);
  ::Reflex::Type type_18093 = ::Reflex::PointerBuilder(type_3338c);
  ::Reflex::Type type_4763 = ::Reflex::PointerBuilder(type_2449);
  ::Reflex::Type type_2449c = ::Reflex::ConstBuilder(type_2449);
  ::Reflex::Type type_4765 = ::Reflex::PointerBuilder(type_2449c);
  ::Reflex::Type type_4767 = ::Reflex::ReferenceBuilder(type_2449);
  ::Reflex::Type type_4769 = ::Reflex::ReferenceBuilder(type_2449c);
  ::Reflex::Type type_2565 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_63);
  ::Reflex::Type type_2224c = ::Reflex::ConstBuilder(type_2224);
  ::Reflex::Type type_13002 = ::Reflex::ReferenceBuilder(type_2224c);
  ::Reflex::Type type_2641c = ::Reflex::ConstBuilder(type_2641);
  ::Reflex::Type type_13003 = ::Reflex::ReferenceBuilder(type_2641c);
  ::Reflex::Type type_1595c = ::Reflex::ConstBuilder(type_1595);
  ::Reflex::Type type_13004 = ::Reflex::ReferenceBuilder(type_1595c);
  ::Reflex::Type type_13005 = ::Reflex::ReferenceBuilder(type_1595);
  ::Reflex::Type type_2931c = ::Reflex::ConstBuilder(type_2931);
  ::Reflex::Type type_10923 = ::Reflex::ReferenceBuilder(type_2931c);
  ::Reflex::Type type_18096 = ::Reflex::PointerBuilder(type_1595c);
  ::Reflex::Type type_18097 = ::Reflex::PointerBuilder(type_1595);
  ::Reflex::Type type_3339c = ::Reflex::ConstBuilder(type_3339);
  ::Reflex::Type type_18098 = ::Reflex::PointerBuilder(type_3339c);
  ::Reflex::Type type_3308f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<Raw2DigiStatus>"), type_3308);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __VFATStatus
#undef __VFATStatus
#endif
class __VFATStatus {
  public:
  __VFATStatus();
  ::std::bitset<8> status;
};
#ifdef __std__bitset_8_
#undef __std__bitset_8_
#endif
class __std__bitset_8_ : private ::std::_Base_bitset<1> {
  public:
  __std__bitset_8_();
};
#ifdef __edm__Wrapper_std__bitset_8_s_
#undef __edm__Wrapper_std__bitset_8_s_
#endif
class __edm__Wrapper_std__bitset_8_s_ {
  public:
  __edm__Wrapper_std__bitset_8_s_();
  bool present;
  ::std::bitset<8> obj;
};
#ifdef __edm__Wrapper_VFATStatus_
#undef __edm__Wrapper_VFATStatus_
#endif
class __edm__Wrapper_VFATStatus_ {
  public:
  __edm__Wrapper_VFATStatus_();
  bool present;
  ::VFATStatus obj;
};
#ifdef __std__map_Totem__FramePosition_VFATStatus_
#undef __std__map_Totem__FramePosition_VFATStatus_
#endif
class __std__map_Totem__FramePosition_VFATStatus_ {
  public:
  __std__map_Totem__FramePosition_VFATStatus_();
  ::std::_Rb_tree<Totem::FramePosition,std::pair<const Totem::FramePosition,VFATStatus>,std::_Select1st<std::pair<const Totem::FramePosition,VFATStatus> >,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition,VFATStatus> > > _M_t;
};
#ifdef __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s_
#undef __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s_
#endif
class __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s_ {
  public:
  __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s_();
  bool present;
  ::std::map<Totem::FramePosition,VFATStatus> obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class VFATStatus -------------------------------
static void destructor_5106(void*, void * o, const std::vector<void*>&, void *) {
(((::VFATStatus*)o)->::VFATStatus::~VFATStatus)();
}
static  void operator_5107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::VFATStatus*)o)->operator=)(*(const ::VFATStatus*)arg[0]);
  else   (((::VFATStatus*)o)->operator=)(*(const ::VFATStatus*)arg[0]);
}

static void constructor_5108( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::VFATStatus(*(const ::VFATStatus*)arg[0]);
  else ::new(mem) ::VFATStatus(*(const ::VFATStatus*)arg[0]);
}

static void constructor_5109( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::VFATStatus();
  else ::new(mem) ::VFATStatus();
}

static  void method_5110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::VFATStatus*)o)->isMissing)());
  else   (((::VFATStatus*)o)->isMissing)();
}

static  void method_5111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::VFATStatus*)o)->isIDMismatch)());
  else   (((::VFATStatus*)o)->isIDMismatch)();
}

static  void method_5112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::VFATStatus*)o)->isFootprintError)());
  else   (((::VFATStatus*)o)->isFootprintError)();
}

static  void method_5113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::VFATStatus*)o)->isCRCError)());
  else   (((::VFATStatus*)o)->isCRCError)();
}

static  void method_5114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::VFATStatus*)o)->isECProgressError)());
  else   (((::VFATStatus*)o)->isECProgressError)();
}

static  void method_5115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::VFATStatus*)o)->isBCProgressError)());
  else   (((::VFATStatus*)o)->isBCProgressError)();
}

static  void method_5116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::VFATStatus*)o)->isFullyMaskedOut)());
  else   (((::VFATStatus*)o)->isFullyMaskedOut)();
}

static  void method_5117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::VFATStatus*)o)->isPartiallyMaskedOut)());
  else   (((::VFATStatus*)o)->isPartiallyMaskedOut)();
}

static  void method_5118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::VFATStatus*)o)->isNotMasked)());
  else   (((::VFATStatus*)o)->isNotMasked)();
}

static  void method_5119( void*, void* o, const std::vector<void*>&, void*)
{
  (((::VFATStatus*)o)->setMissing)();
}

static  void method_5120( void*, void* o, const std::vector<void*>&, void*)
{
  (((::VFATStatus*)o)->setIDMismatch)();
}

static  void method_5121( void*, void* o, const std::vector<void*>&, void*)
{
  (((::VFATStatus*)o)->setFootprintError)();
}

static  void method_5122( void*, void* o, const std::vector<void*>&, void*)
{
  (((::VFATStatus*)o)->setCRCError)();
}

static  void method_5123( void*, void* o, const std::vector<void*>&, void*)
{
  (((::VFATStatus*)o)->setECProgressError)();
}

static  void method_5124( void*, void* o, const std::vector<void*>&, void*)
{
  (((::VFATStatus*)o)->setBCProgressError)();
}

static  void method_5125( void*, void* o, const std::vector<void*>&, void*)
{
  (((::VFATStatus*)o)->setFullyMaskedOut)();
}

static  void method_5126( void*, void* o, const std::vector<void*>&, void*)
{
  (((::VFATStatus*)o)->setPartiallyMaskedOut)();
}

static  void method_5127( void*, void* o, const std::vector<void*>&, void*)
{
  (((::VFATStatus*)o)->setNotMasked)();
}

static  void method_5128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::VFATStatus*)o)->OK)());
  else   (((::VFATStatus*)o)->OK)();
}

static  void operator_5129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::VFATStatus*)o)->operator<)(*(const ::VFATStatus*)arg[0]));
  else   (((const ::VFATStatus*)o)->operator<)(*(const ::VFATStatus*)arg[0]);
}

static void method_newdel_1749( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::VFATStatus >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::VFATStatus >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::VFATStatus >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::VFATStatus >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::VFATStatus >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class VFATStatus -------------------------------
void __VFATStatus_db_datamem(Reflex::Class*);
void __VFATStatus_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __VFATStatus_datamem_bld(&__VFATStatus_db_datamem);
Reflex::GenreflexMemberBuilder __VFATStatus_funcmem_bld(&__VFATStatus_db_funcmem);
void __VFATStatus_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("VFATStatus"), typeid(::VFATStatus), sizeof(::VFATStatus), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~VFATStatus"), destructor_5106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13006, type_4322), Reflex::Literal("operator="), operator_5107, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4322), Reflex::Literal("VFATStatus"), constructor_5108, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("VFATStatus"), constructor_5109, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1749, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__VFATStatus_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__VFATStatus_funcmem_bld);
}

//------Delayed data member builder for class VFATStatus -------------------
void __VFATStatus_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2763, Reflex::Literal("status"), OffsetOf(__shadow__::__VFATStatus, status), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class VFATStatus -------------------
void __VFATStatus_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isMissing"), method_5110, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isIDMismatch"), method_5111, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isFootprintError"), method_5112, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isCRCError"), method_5113, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isECProgressError"), method_5114, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isBCProgressError"), method_5115, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isFullyMaskedOut"), method_5116, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isPartiallyMaskedOut"), method_5117, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isNotMasked"), method_5118, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("setMissing"), method_5119, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("setIDMismatch"), method_5120, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("setFootprintError"), method_5121, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("setCRCError"), method_5122, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("setECProgressError"), method_5123, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("setBCProgressError"), method_5124, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("setFullyMaskedOut"), method_5125, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("setPartiallyMaskedOut"), method_5126, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("setNotMasked"), method_5127, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("OK"), method_5128, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345, type_4322), Reflex::Literal("operator<"), operator_5129, 0, "cmp", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class bitset<8> -------------------------------
static void destructor_10252(void*, void * o, const std::vector<void*>&, void *) {
(((::std::bitset<8>*)o)->::std::bitset<8>::~bitset)();
}
static  void operator_10253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->operator=)(*(const ::std::bitset<8>*)arg[0]);
  else   (((::std::bitset<8>*)o)->operator=)(*(const ::std::bitset<8>*)arg[0]);
}

static void constructor_10254( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::bitset<8>(*(const ::std::bitset<8>*)arg[0]);
  else ::new(mem) ::std::bitset<8>(*(const ::std::bitset<8>*)arg[0]);
}

static void constructor_10256( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::bitset<8>();
  else ::new(mem) ::std::bitset<8>();
}

static void constructor_10257( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::bitset<8>(*(unsigned long*)arg[0]);
  else ::new(mem) ::std::bitset<8>(*(unsigned long*)arg[0]);
}

static  void operator_10258( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->operator&=)(*(const ::std::bitset<8>*)arg[0]);
  else   (((::std::bitset<8>*)o)->operator&=)(*(const ::std::bitset<8>*)arg[0]);
}

static  void operator_10259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->operator|=)(*(const ::std::bitset<8>*)arg[0]);
  else   (((::std::bitset<8>*)o)->operator|=)(*(const ::std::bitset<8>*)arg[0]);
}

static  void operator_10260( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->operator^=)(*(const ::std::bitset<8>*)arg[0]);
  else   (((::std::bitset<8>*)o)->operator^=)(*(const ::std::bitset<8>*)arg[0]);
}

static  void operator_10261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->operator<<=)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<8>*)o)->operator<<=)(*(::std::size_t*)arg[0]);
}

static  void operator_10262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->operator>>=)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<8>*)o)->operator>>=)(*(::std::size_t*)arg[0]);
}

static  void method_10263( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->_Unchecked_set)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<8>*)o)->_Unchecked_set)(*(::std::size_t*)arg[0]);
}

static  void method_10264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->_Unchecked_set)(*(::std::size_t*)arg[0],
    *(int*)arg[1]);
  else   (((::std::bitset<8>*)o)->_Unchecked_set)(*(::std::size_t*)arg[0],
    *(int*)arg[1]);
}

static  void method_10265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->_Unchecked_reset)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<8>*)o)->_Unchecked_reset)(*(::std::size_t*)arg[0]);
}

static  void method_10266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->_Unchecked_flip)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<8>*)o)->_Unchecked_flip)(*(::std::size_t*)arg[0]);
}

static  void method_10267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<8>*)o)->_Unchecked_test)(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<8>*)o)->_Unchecked_test)(*(::std::size_t*)arg[0]);
}

static  void method_10268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->set)();
  else   (((::std::bitset<8>*)o)->set)();
}

static  void method_10269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->set)(*(::std::size_t*)arg[0]);
    else     (((::std::bitset<8>*)o)->set)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->set)(*(::std::size_t*)arg[0],
      *(bool*)arg[1]);
    else     (((::std::bitset<8>*)o)->set)(*(::std::size_t*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_10270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->reset)();
  else   (((::std::bitset<8>*)o)->reset)();
}

static  void method_10271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->reset)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<8>*)o)->reset)(*(::std::size_t*)arg[0]);
}

static  void method_10272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->flip)();
  else   (((::std::bitset<8>*)o)->flip)();
}

static  void method_10273( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<8>*)o)->flip)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<8>*)o)->flip)(*(::std::size_t*)arg[0]);
}

static  void operator_10274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::bitset<8>)((((const ::std::bitset<8>*)o)->operator~)());
  else   (((const ::std::bitset<8>*)o)->operator~)();
}

static  void operator_10275( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::bitset<8>::reference)((((::std::bitset<8>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((::std::bitset<8>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10276( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<8>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<8>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::std::bitset<8>*)o)->to_ulong)());
  else   (((const ::std::bitset<8>*)o)->to_ulong)();
}

static  void method_10278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::bitset<8>*)o)->to_string)());
  else   (((const ::std::bitset<8>*)o)->to_string)();
}

static  void method_10279( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::bitset<8>*)o)->to_string)(*(char*)arg[0]));
    else     (((const ::std::bitset<8>*)o)->to_string)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::bitset<8>*)o)->to_string)(*(char*)arg[0],
      *(char*)arg[1]));
    else     (((const ::std::bitset<8>*)o)->to_string)(*(char*)arg[0],
      *(char*)arg[1]);
  }
}

static  void method_10280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::bitset<8>*)o)->count)());
  else   (((const ::std::bitset<8>*)o)->count)();
}

static  void method_10281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::bitset<8>*)o)->size)());
  else   (((const ::std::bitset<8>*)o)->size)();
}

static  void operator_10282( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<8>*)o)->operator==)(*(const ::std::bitset<8>*)arg[0]));
  else   (((const ::std::bitset<8>*)o)->operator==)(*(const ::std::bitset<8>*)arg[0]);
}

static  void operator_10283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<8>*)o)->operator!=)(*(const ::std::bitset<8>*)arg[0]));
  else   (((const ::std::bitset<8>*)o)->operator!=)(*(const ::std::bitset<8>*)arg[0]);
}

static  void method_10284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<8>*)o)->test)(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<8>*)o)->test)(*(::std::size_t*)arg[0]);
}

static  void method_10285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<8>*)o)->all)());
  else   (((const ::std::bitset<8>*)o)->all)();
}

static  void method_10286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<8>*)o)->any)());
  else   (((const ::std::bitset<8>*)o)->any)();
}

static  void method_10287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<8>*)o)->none)());
  else   (((const ::std::bitset<8>*)o)->none)();
}

static  void operator_10288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::bitset<8>)((((const ::std::bitset<8>*)o)->operator<<)(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<8>*)o)->operator<<)(*(::std::size_t*)arg[0]);
}

static  void operator_10289( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::bitset<8>)((((const ::std::bitset<8>*)o)->operator>>)(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<8>*)o)->operator>>)(*(::std::size_t*)arg[0]);
}

static  void method_10290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::bitset<8>*)o)->_Find_first)());
  else   (((const ::std::bitset<8>*)o)->_Find_first)();
}

static  void method_10291( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::bitset<8>*)o)->_Find_next)(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<8>*)o)->_Find_next)(*(::std::size_t*)arg[0]);
}

static void method_newdel_2763( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::bitset<8> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::bitset<8> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::bitset<8> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::bitset<8> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::bitset<8> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Base_bitset<1>")), ::Reflex::BaseOffset< ::std::bitset<8>,::std::_Base_bitset<1> >::Get(),::Reflex::PRIVATE), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::Reflex::StdBitSetHelper< ::std::bitset<8> > >::Generate();
  else ::Reflex::Proxy< ::Reflex::StdBitSetHelper< ::std::bitset<8> > >::Generate();
}

//------Dictionary for class bitset<8> -------------------------------
void __std__bitset_8__db_datamem(Reflex::Class*);
void __std__bitset_8__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__bitset_8__datamem_bld(&__std__bitset_8__db_datamem);
Reflex::GenreflexMemberBuilder __std__bitset_8__funcmem_bld(&__std__bitset_8__db_funcmem);
void __std__bitset_8__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::bitset<8>"), typeid(::std::bitset<8>), sizeof(::std::bitset<8>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2443, ::Reflex::BaseOffset< ::std::bitset<8>, ::std::_Base_bitset<1> >::Get(), ::Reflex::PRIVATE)
  .AddTypedef(type_2443, Reflex::Literal("std::bitset<8>::_Base"))
  .AddTypedef(type_271, Reflex::Literal("std::bitset<8>::_WordT"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~bitset"), destructor_10252, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_16488), Reflex::Literal("operator="), operator_10253, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16488), Reflex::Literal("bitset"), constructor_10254, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("bitset"), constructor_10256, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_271), Reflex::Literal("bitset"), constructor_10257, 0, "__val", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2763, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__bitset_8__funcmem_bld);
}

//------Delayed data member builder for class bitset<8> -------------------
void __std__bitset_8__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class bitset<8> -------------------
void __std__bitset_8__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_16488), Reflex::Literal("operator&="), operator_10258, 0, "__rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_16488), Reflex::Literal("operator|="), operator_10259, 0, "__rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_16488), Reflex::Literal("operator^="), operator_10260, 0, "__rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_2624), Reflex::Literal("operator<<="), operator_10261, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_2624), Reflex::Literal("operator>>="), operator_10262, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_2624), Reflex::Literal("_Unchecked_set"), method_10263, 0, "__pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_2624, type_69), Reflex::Literal("_Unchecked_set"), method_10264, 0, "__pos;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_2624), Reflex::Literal("_Unchecked_reset"), method_10265, 0, "__pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_2624), Reflex::Literal("_Unchecked_flip"), method_10266, 0, "__pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345, type_2624), Reflex::Literal("_Unchecked_test"), method_10267, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487), Reflex::Literal("set"), method_10268, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_2624, type_1345), Reflex::Literal("set"), method_10269, 0, "__position;__val=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487), Reflex::Literal("reset"), method_10270, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_2624), Reflex::Literal("reset"), method_10271, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487), Reflex::Literal("flip"), method_10272, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16487, type_2624), Reflex::Literal("flip"), method_10273, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2763), Reflex::Literal("operator~"), operator_10274, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10249, type_2624), Reflex::Literal("operator[]"), operator_10275, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345, type_2624), Reflex::Literal("operator[]"), operator_10276, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_271), Reflex::Literal("to_ulong"), method_10277, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2141), Reflex::Literal("to_string"), method_10278, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2141, type_1212, type_1212), Reflex::Literal("to_string"), method_10279, 0, "__zero;__one='1'", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2624), Reflex::Literal("count"), method_10280, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2624), Reflex::Literal("size"), method_10281, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345, type_16488), Reflex::Literal("operator=="), operator_10282, 0, "__rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345, type_16488), Reflex::Literal("operator!="), operator_10283, 0, "__rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345, type_2624), Reflex::Literal("test"), method_10284, 0, "__position", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("all"), method_10285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("any"), method_10286, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("none"), method_10287, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2763, type_2624), Reflex::Literal("operator<<"), operator_10288, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2763, type_2624), Reflex::Literal("operator>>"), operator_10289, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2624), Reflex::Literal("_Find_first"), method_10290, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2624, type_2624), Reflex::Literal("_Find_next"), method_10291, 0, "__prev", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::bitset<8> > -------------------------------
static void constructor_12140( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::bitset<8> >();
  else ::new(mem) ::edm::Wrapper<std::bitset<8> >();
}

static void constructor_12141( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::bitset<8> >(*(::std::auto_ptr<std::bitset<8> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::bitset<8> >(*(::std::auto_ptr<std::bitset<8> >*)arg[0]);
}

static void destructor_12142(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::bitset<8> >*)o)->::edm::Wrapper<std::bitset<8> >::~Wrapper)();
}
static  void method_12143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::bitset<8> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::bitset<8> >*)o)->product)();
}

static  void operator_12144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::bitset<8> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::bitset<8> >*)o)->operator->)();
}

static  void method_12145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::bitset<8> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::bitset<8> >*)o)->productTypeInfo)();
}

static  void method_12146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::bitset<8> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::bitset<8> >*)o)->typeInfo)();
}

static void constructor_12147( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::bitset<8> >((::std::bitset<8>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::bitset<8> >((::std::bitset<8>*)arg[0]);
}

static  void method_12148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::bitset<8> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::bitset<8> >*)o)->getInterface)();
}

static  void method_12149( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::bitset<8> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::bitset<8> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12151( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::bitset<8> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::bitset<8> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::bitset<8> >*)o)->dynamicTypeInfo)();
}

static  void method_12153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::bitset<8> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::bitset<8> >*)o)->isPresent)();
}

static  void method_12154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::bitset<8> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::bitset<8> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3306( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::bitset<8> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::bitset<8> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::bitset<8> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::bitset<8> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::bitset<8> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::bitset<8> > -------------------------------
void __edm__Wrapper_std__bitset_8_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__bitset_8_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__bitset_8_s__datamem_bld(&__edm__Wrapper_std__bitset_8_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__bitset_8_s__funcmem_bld(&__edm__Wrapper_std__bitset_8_s__db_funcmem);
void __edm__Wrapper_std__bitset_8_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::bitset<8> >"), typeid(::edm::Wrapper<std::bitset<8> >), sizeof(::edm::Wrapper<std::bitset<8> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2763, Reflex::Literal("edm::Wrapper<std::bitset<8> >::value_type"))
  .AddTypedef(type_2763, Reflex::Literal("edm::Wrapper<std::bitset<8> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12140, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2311), Reflex::Literal("Wrapper"), constructor_12141, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12142, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18087), Reflex::Literal("Wrapper"), constructor_12147, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3306, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__bitset_8_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__bitset_8_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::bitset<8> > -------------------
void __edm__Wrapper_std__bitset_8_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1345, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__bitset_8_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2763, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__bitset_8_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::bitset<8> > -------------------
void __edm__Wrapper_std__bitset_8_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18086), Reflex::Literal("product"), method_12143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18086), Reflex::Literal("operator->"), operator_12144, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("productTypeInfo"), method_12145, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("typeInfo"), method_12146, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18088), Reflex::Literal("getInterface"), method_12148, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_12229, type_16199, type_18012), Reflex::Literal("fillView"), method_12149, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_10966, type_271, type_6578), Reflex::Literal("setPtr"), method_12150, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_10966, type_16200, type_16199), Reflex::Literal("fillPtrVector"), method_12151, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("dynamicTypeInfo"), method_12152, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isPresent"), method_12153, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("dynamicTypeInfo_"), method_12154, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<VFATStatus> -------------------------------
static void constructor_12161( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<VFATStatus>();
  else ::new(mem) ::edm::Wrapper<VFATStatus>();
}

static void constructor_12162( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<VFATStatus>(*(::std::auto_ptr<VFATStatus>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<VFATStatus>(*(::std::auto_ptr<VFATStatus>*)arg[0]);
}

static void destructor_12163(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<VFATStatus>*)o)->::edm::Wrapper<VFATStatus>::~Wrapper)();
}
static  void method_12164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<VFATStatus>*)o)->product)());
  else   (((const ::edm::Wrapper<VFATStatus>*)o)->product)();
}

static  void operator_12165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<VFATStatus>*)o)->operator->)());
  else   (((const ::edm::Wrapper<VFATStatus>*)o)->operator->)();
}

static  void method_12166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<VFATStatus>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<VFATStatus>*)o)->productTypeInfo)();
}

static  void method_12167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<VFATStatus>*)o)->typeInfo)();
  else   (((::edm::Wrapper<VFATStatus>*)o)->typeInfo)();
}

static void constructor_12168( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<VFATStatus>((::VFATStatus*)arg[0]);
  else ::new(mem) ::edm::Wrapper<VFATStatus>((::VFATStatus*)arg[0]);
}

static  void method_12169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<VFATStatus>*)o)->getInterface)());
  else   (((::edm::Wrapper<VFATStatus>*)o)->getInterface)();
}

static  void method_12170( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<VFATStatus>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12171( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<VFATStatus>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12172( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<VFATStatus>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<VFATStatus>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<VFATStatus>*)o)->dynamicTypeInfo)();
}

static  void method_12174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<VFATStatus>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<VFATStatus>*)o)->isPresent)();
}

static  void method_12175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<VFATStatus>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<VFATStatus>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3307( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<VFATStatus> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<VFATStatus> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<VFATStatus> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<VFATStatus> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<VFATStatus> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<VFATStatus> -------------------------------
void __edm__Wrapper_VFATStatus__db_datamem(Reflex::Class*);
void __edm__Wrapper_VFATStatus__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_VFATStatus__datamem_bld(&__edm__Wrapper_VFATStatus__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_VFATStatus__funcmem_bld(&__edm__Wrapper_VFATStatus__db_funcmem);
void __edm__Wrapper_VFATStatus__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<VFATStatus>"), typeid(::edm::Wrapper<VFATStatus>), sizeof(::edm::Wrapper<VFATStatus>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1749, Reflex::Literal("edm::Wrapper<VFATStatus>::value_type"))
  .AddTypedef(type_1749, Reflex::Literal("edm::Wrapper<VFATStatus>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12161, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2312), Reflex::Literal("Wrapper"), constructor_12162, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12163, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18092), Reflex::Literal("Wrapper"), constructor_12168, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3307, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_VFATStatus__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_VFATStatus__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<VFATStatus> -------------------
void __edm__Wrapper_VFATStatus__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1345, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_VFATStatus_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1749, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_VFATStatus_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<VFATStatus> -------------------
void __edm__Wrapper_VFATStatus__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18091), Reflex::Literal("product"), method_12164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18091), Reflex::Literal("operator->"), operator_12165, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("productTypeInfo"), method_12166, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("typeInfo"), method_12167, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18093), Reflex::Literal("getInterface"), method_12169, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_12229, type_16199, type_18012), Reflex::Literal("fillView"), method_12170, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_10966, type_271, type_6578), Reflex::Literal("setPtr"), method_12171, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_10966, type_16200, type_16199), Reflex::Literal("fillPtrVector"), method_12172, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("dynamicTypeInfo"), method_12173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isPresent"), method_12174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("dynamicTypeInfo_"), method_12175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<Totem::FramePosition,VFATStatus,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition, VFATStatus> > > -------------------------------
static void destructor_4777(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<Totem::FramePosition,VFATStatus>*)o)->::std::map<Totem::FramePosition,VFATStatus>::~map)();
}
static void constructor_4778( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<Totem::FramePosition,VFATStatus>();
  else ::new(mem) ::std::map<Totem::FramePosition,VFATStatus>();
}

static void constructor_4779( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<Totem::FramePosition,VFATStatus>(*(const ::std::less<Totem::FramePosition>*)arg[0]);
  else ::new(mem) ::std::map<Totem::FramePosition,VFATStatus>(*(const ::std::less<Totem::FramePosition>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<Totem::FramePosition,VFATStatus>(*(const ::std::less<Totem::FramePosition>*)arg[0],
      *(const ::std::allocator<std::pair<const Totem::FramePosition,VFATStatus> >*)arg[1]);
  else ::new(mem) ::std::map<Totem::FramePosition,VFATStatus>(*(const ::std::less<Totem::FramePosition>*)arg[0],
      *(const ::std::allocator<std::pair<const Totem::FramePosition,VFATStatus> >*)arg[1]);
  }
}

static void constructor_4780( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<Totem::FramePosition,VFATStatus>(*(const ::std::map<Totem::FramePosition,VFATStatus>*)arg[0]);
  else ::new(mem) ::std::map<Totem::FramePosition,VFATStatus>(*(const ::std::map<Totem::FramePosition,VFATStatus>*)arg[0]);
}

static  void operator_4781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<Totem::FramePosition,VFATStatus>*)o)->operator=)(*(const ::std::map<Totem::FramePosition,VFATStatus>*)arg[0]);
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->operator=)(*(const ::std::map<Totem::FramePosition,VFATStatus>*)arg[0]);
}

static  void method_4782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const Totem::FramePosition,VFATStatus> >)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->get_allocator)());
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->get_allocator)();
}

static  void method_4783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >)((((::std::map<Totem::FramePosition,VFATStatus>*)o)->begin)());
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->begin)();
}

static  void method_4784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,VFATStatus> >)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->begin)());
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->begin)();
}

static  void method_4785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >)((((::std::map<Totem::FramePosition,VFATStatus>*)o)->end)());
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->end)();
}

static  void method_4786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,VFATStatus> >)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->end)());
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->end)();
}

static  void method_4791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->empty)());
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->empty)();
}

static  void method_4792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->size)());
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->size)();
}

static  void method_4793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->max_size)());
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->max_size)();
}

static  void operator_4794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<Totem::FramePosition,VFATStatus>*)o)->operator[])(*(const ::Totem::FramePosition*)arg[0]);
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->operator[])(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<Totem::FramePosition,VFATStatus>*)o)->at)(*(const ::Totem::FramePosition*)arg[0]);
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->at)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->at)(*(const ::Totem::FramePosition*)arg[0]);
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->at)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >,bool>)((((::std::map<Totem::FramePosition,VFATStatus>*)o)->insert)(*(const ::std::pair<const Totem::FramePosition,VFATStatus>*)arg[0]));
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->insert)(*(const ::std::pair<const Totem::FramePosition,VFATStatus>*)arg[0]);
}

static  void method_4798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >)((((::std::map<Totem::FramePosition,VFATStatus>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >*)arg[0],
    *(const ::std::pair<const Totem::FramePosition,VFATStatus>*)arg[1]));
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >*)arg[0],
    *(const ::std::pair<const Totem::FramePosition,VFATStatus>*)arg[1]);
}

static  void method_4799( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<Totem::FramePosition,VFATStatus>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >*)arg[0]);
}

static  void method_4800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<Totem::FramePosition,VFATStatus>*)o)->erase)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->erase)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4801( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<Totem::FramePosition,VFATStatus>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >*)arg[1]);
}

static  void method_4802( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<Totem::FramePosition,VFATStatus>*)o)->swap)(*(::std::map<Totem::FramePosition,VFATStatus>*)arg[0]);
}

static  void method_4803( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<Totem::FramePosition,VFATStatus>*)o)->clear)();
}

static  void method_4804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<Totem::FramePosition>)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->key_comp)());
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->key_comp)();
}

static  void method_4806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >)((((::std::map<Totem::FramePosition,VFATStatus>*)o)->find)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->find)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,VFATStatus> >)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->find)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->find)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->count)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->count)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >)((((::std::map<Totem::FramePosition,VFATStatus>*)o)->lower_bound)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->lower_bound)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4810( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,VFATStatus> >)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->lower_bound)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->lower_bound)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >)((((::std::map<Totem::FramePosition,VFATStatus>*)o)->upper_bound)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->upper_bound)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,VFATStatus> >)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->upper_bound)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->upper_bound)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> >,std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,VFATStatus> > >)((((::std::map<Totem::FramePosition,VFATStatus>*)o)->equal_range)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((::std::map<Totem::FramePosition,VFATStatus>*)o)->equal_range)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_4814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,VFATStatus> >,std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,VFATStatus> > >)((((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->equal_range)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::std::map<Totem::FramePosition,VFATStatus>*)o)->equal_range)(*(const ::Totem::FramePosition*)arg[0]);
}

static void method_newdel_1595( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<Totem::FramePosition,VFATStatus> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<Totem::FramePosition,VFATStatus> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<Totem::FramePosition,VFATStatus> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<Totem::FramePosition,VFATStatus> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<Totem::FramePosition,VFATStatus> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<Totem::FramePosition,VFATStatus> >::Generate();
  else ::Reflex::Proxy< ::std::map<Totem::FramePosition,VFATStatus> >::Generate();
}

//------Dictionary for class map<Totem::FramePosition,VFATStatus,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition, VFATStatus> > > -------------------------------
void __std__map_Totem__FramePosition_VFATStatus__db_datamem(Reflex::Class*);
void __std__map_Totem__FramePosition_VFATStatus__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_Totem__FramePosition_VFATStatus__datamem_bld(&__std__map_Totem__FramePosition_VFATStatus__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_Totem__FramePosition_VFATStatus__funcmem_bld(&__std__map_Totem__FramePosition_VFATStatus__db_funcmem);
void __std__map_Totem__FramePosition_VFATStatus__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>"), typeid(::std::map<Totem::FramePosition,VFATStatus>), sizeof(::std::map<Totem::FramePosition,VFATStatus>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2931, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::key_type"))
  .AddTypedef(type_1749, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::mapped_type"))
  .AddTypedef(type_2449, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::value_type"))
  .AddTypedef(type_2224, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::key_compare"))
  .AddTypedef(type_2641, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::allocator_type"))
  .AddTypedef(type_2449, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::_Alloc_value_type"))
  .AddTypedef(type_2641, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::_Pair_alloc_type"))
  .AddTypedef(type_2270, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::_Rep_type"))
  .AddTypedef(type_4763, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::pointer"))
  .AddTypedef(type_4765, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::const_pointer"))
  .AddTypedef(type_4767, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::reference"))
  .AddTypedef(type_4769, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::const_reference"))
  .AddTypedef(type_2541, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::iterator"))
  .AddTypedef(type_2627, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::const_iterator"))
  .AddTypedef(type_2624, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::size_type"))
  .AddTypedef(type_2565, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::difference_type"))
  .AddTypedef(type_2720, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::reverse_iterator"))
  .AddTypedef(type_2719, Reflex::Literal("std::map<Totem::FramePosition,VFATStatus>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_4777, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_4778, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13002, type_13003), Reflex::Literal("map"), constructor_4779, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13004), Reflex::Literal("map"), constructor_4780, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1595, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_Totem__FramePosition_VFATStatus__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_Totem__FramePosition_VFATStatus__funcmem_bld);
}

//------Delayed data member builder for class map<Totem::FramePosition,VFATStatus,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition, VFATStatus> > > -------------------
void __std__map_Totem__FramePosition_VFATStatus__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2270, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_Totem__FramePosition_VFATStatus_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<Totem::FramePosition,VFATStatus,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition, VFATStatus> > > -------------------
void __std__map_Totem__FramePosition_VFATStatus__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13005, type_13004), Reflex::Literal("operator="), operator_4781, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2641), Reflex::Literal("get_allocator"), method_4782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2541), Reflex::Literal("begin"), method_4783, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2627), Reflex::Literal("begin"), method_4784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2541), Reflex::Literal("end"), method_4785, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2627), Reflex::Literal("end"), method_4786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("empty"), method_4791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2624), Reflex::Literal("size"), method_4792, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2624), Reflex::Literal("max_size"), method_4793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13006, type_10923), Reflex::Literal("operator[]"), operator_4794, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13006, type_10923), Reflex::Literal("at"), method_4795, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4322, type_10923), Reflex::Literal("at"), method_4796, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2451, type_4769), Reflex::Literal("insert"), method_4797, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2541, type_2541, type_4769), Reflex::Literal("insert"), method_4798, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_2541), Reflex::Literal("erase"), method_4799, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2624, type_10923), Reflex::Literal("erase"), method_4800, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_2541, type_2541), Reflex::Literal("erase"), method_4801, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_13005), Reflex::Literal("swap"), method_4802, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577), Reflex::Literal("clear"), method_4803, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2224), Reflex::Literal("key_comp"), method_4804, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2541, type_10923), Reflex::Literal("find"), method_4806, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2627, type_10923), Reflex::Literal("find"), method_4807, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2624, type_10923), Reflex::Literal("count"), method_4808, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2541, type_10923), Reflex::Literal("lower_bound"), method_4809, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2627, type_10923), Reflex::Literal("lower_bound"), method_4810, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2541, type_10923), Reflex::Literal("upper_bound"), method_4811, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2627, type_10923), Reflex::Literal("upper_bound"), method_4812, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2450, type_10923), Reflex::Literal("equal_range"), method_4813, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2448, type_10923), Reflex::Literal("equal_range"), method_4814, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<Totem::FramePosition, VFATStatus, std::less<Totem::FramePosition>, std::allocator<std::pair<const Totem::FramePosition, VFATStatus> > > > -------------------------------
static void constructor_12182( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >();
  else ::new(mem) ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >();
}

static void constructor_12183( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >(*(::std::auto_ptr<std::map<Totem::FramePosition,VFATStatus> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >(*(::std::auto_ptr<std::map<Totem::FramePosition,VFATStatus> >*)arg[0]);
}

static void destructor_12184(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >::~Wrapper)();
}
static  void method_12185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->product)();
}

static  void operator_12186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->operator->)();
}

static  void method_12187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->productTypeInfo)();
}

static  void method_12188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->typeInfo)();
}

static void constructor_12189( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >((::std::map<Totem::FramePosition,VFATStatus>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >((::std::map<Totem::FramePosition,VFATStatus>*)arg[0]);
}

static  void method_12190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->getInterface)();
}

static  void method_12191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12192( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12193( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->dynamicTypeInfo)();
}

static  void method_12195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->isPresent)();
}

static  void method_12196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3308( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<Totem::FramePosition, VFATStatus, std::less<Totem::FramePosition>, std::allocator<std::pair<const Totem::FramePosition, VFATStatus> > > > -------------------------------
void __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__datamem_bld(&__edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__funcmem_bld(&__edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__db_funcmem);
void __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >"), typeid(::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >), sizeof(::edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<Raw2DigiStatus>")
  .AddTypedef(type_1595, Reflex::Literal("edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >::value_type"))
  .AddTypedef(type_1595, Reflex::Literal("edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12182, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2313), Reflex::Literal("Wrapper"), constructor_12183, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12184, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18097), Reflex::Literal("Wrapper"), constructor_12189, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3308, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<Totem::FramePosition, VFATStatus, std::less<Totem::FramePosition>, std::allocator<std::pair<const Totem::FramePosition, VFATStatus> > > > -------------------
void __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1345, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1595, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<Totem::FramePosition, VFATStatus, std::less<Totem::FramePosition>, std::allocator<std::pair<const Totem::FramePosition, VFATStatus> > > > -------------------
void __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18096), Reflex::Literal("product"), method_12185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18096), Reflex::Literal("operator->"), operator_12186, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("productTypeInfo"), method_12187, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("typeInfo"), method_12188, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18098), Reflex::Literal("getInterface"), method_12190, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_12229, type_16199, type_18012), Reflex::Literal("fillView"), method_12191, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_10966, type_271, type_6578), Reflex::Literal("setPtr"), method_12192, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_577, type_10966, type_16200, type_16199), Reflex::Literal("fillPtrVector"), method_12193, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("dynamicTypeInfo"), method_12194, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1345), Reflex::Literal("isPresent"), method_12195, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10966), Reflex::Literal("dynamicTypeInfo_"), method_12196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __VFATStatus_dict(); 
      __std__bitset_8__dict(); 
      __edm__Wrapper_std__bitset_8_s__dict(); 
      __edm__Wrapper_VFATStatus__dict(); 
      __std__map_Totem__FramePosition_VFATStatus__dict(); 
      __edm__Wrapper_std__map_Totem__FramePosition_VFATStatus_s__dict(); 
    }
    ~Dictionaries() {
      type_1749.Unload(); // class VFATStatus 
      type_2763.Unload(); // class std::bitset<8> 
      type_3306.Unload(); // class edm::Wrapper<std::bitset<8> > 
      type_3307.Unload(); // class edm::Wrapper<VFATStatus> 
      type_1595.Unload(); // class std::map<Totem::FramePosition,VFATStatus> 
      type_3308.Unload(); // class edm::Wrapper<std::map<Totem::FramePosition,VFATStatus> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
