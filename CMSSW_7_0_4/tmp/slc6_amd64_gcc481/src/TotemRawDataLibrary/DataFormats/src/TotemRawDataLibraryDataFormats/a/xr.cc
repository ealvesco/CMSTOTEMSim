// Generated at Mon Jul 11 23:13:59 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20130702-0-cms/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/TotemRawDataLibrary/DataFormats/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

#include "TBuffer.h"
#include "TVirtualObject.h"
#include <vector>
#include "TSchemaHelper.h"


namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("Totem") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("edm") );
  ::Reflex::Type type_62 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_574 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1344 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_284 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_553 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned char"));
  ::Reflex::Type type_276 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_133 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_396 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3470 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2987 = ::Reflex::TypeBuilder(Reflex::Literal("Totem::RawEvent"));
  ::Reflex::Type type_2994 = ::Reflex::TypeBuilder(Reflex::Literal("Totem::VFATFrame"));
  ::Reflex::Type type_2989 = ::Reflex::TypeBuilder(Reflex::Literal("Totem::TriggerData"));
  ::Reflex::Type type_2993 = ::Reflex::TypeBuilder(Reflex::Literal("Totem::FramePosition"));
  ::Reflex::Type type_2990 = ::Reflex::TypeBuilder(Reflex::Literal("Totem::OptoRxMetaData"));
  ::Reflex::Type type_2253 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned int>"));
  ::Reflex::Type type_2144 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_2514 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2535 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned char>"));
  ::Reflex::Type type_2988 = ::Reflex::TypeBuilder(Reflex::Literal("Totem::VFATFrameCollection"));
  ::Reflex::Type type_2515 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_2611 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,long>"));
  ::Reflex::Type type_2516 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Totem::VFATFrame>"));
  ::Reflex::Type type_3370 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<Totem::RawEvent>"));
  ::Reflex::Type type_2347 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<Totem::RawEvent>"));
  ::Reflex::Type type_2254 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<Totem::FramePosition>"));
  ::Reflex::Type type_2681 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<Totem::VFATFrame>"));
  ::Reflex::Type type_2991 = ::Reflex::TypeBuilder(Reflex::Literal("Totem::OptoRxVFATFrameCollection"));
  ::Reflex::Type type_2995 = ::Reflex::TypeBuilder(Reflex::Literal("Totem::SimpleVFATFrameCollection"));
  ::Reflex::Type type_2474 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,long>"));
  ::Reflex::Type type_3401 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<Totem::RawEvent>"));
  ::Reflex::Type type_2612 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>"));
  ::Reflex::Type type_3368 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<Totem::OptoRxVFATFrameCollection>"));
  ::Reflex::Type type_3369 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<Totem::SimpleVFATFrameCollection>"));
  ::Reflex::Type type_2613 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>"));
  ::Reflex::Type type_2345 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<Totem::OptoRxVFATFrameCollection>"));
  ::Reflex::Type type_2346 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<Totem::SimpleVFATFrameCollection>"));
  ::Reflex::Type type_2676 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,long> >"));
  ::Reflex::Type type_2475 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,Totem::OptoRxMetaData>"));
  ::Reflex::Type type_2476 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const Totem::FramePosition,Totem::VFATFrame>"));
  ::Reflex::Type type_3293 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_2494 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<Totem::FramePosition,const Totem::VFATFrame*>"));
  ::Reflex::Type type_3399 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<Totem::OptoRxVFATFrameCollection>"));
  ::Reflex::Type type_3400 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<Totem::SimpleVFATFrameCollection>"));
  ::Reflex::Type type_2569 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,long> >"));
  ::Reflex::Type type_5004 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<Totem::VFATFrame> >"));
  ::Reflex::Type type_2665 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,long> >"));
  ::Reflex::Type type_2677 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,Totem::OptoRxMetaData> >"));
  ::Reflex::Type type_2120 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Totem::VFATFrame,std::allocator<Totem::VFATFrame> >"));
  ::Reflex::Type type_2616 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,Totem::OptoRxVFATFrameCollection::OptoRxBlock*>"));
  ::Reflex::Type type_2680 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >"));
  ::Reflex::Type type_2490 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,long> >,bool>"));
  ::Reflex::Type type_2570 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >"));
  ::Reflex::Type type_4938 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >"));
  ::Reflex::Type type_2568 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >"));
  ::Reflex::Type type_2666 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >"));
  ::Reflex::Type type_2813 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,long> > >"));
  ::Reflex::Type type_4939 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const Totem::VFATFrame*,std::vector<Totem::VFATFrame> >"));
  ::Reflex::Type type_2664 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >"));
  ::Reflex::Type type_2812 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,long> > >"));
  ::Reflex::Type type_2493 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >,bool>"));
  ::Reflex::Type type_2485 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >,bool>"));
  ::Reflex::Type type_2815 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> > >"));
  ::Reflex::Type type_2567 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxVFATFrameCollection::OptoRxBlock*> >"));
  ::Reflex::Type type_2773 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> > >"));
  ::Reflex::Type type_2811 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> > >"));
  ::Reflex::Type type_2814 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> > >"));
  ::Reflex::Type type_2772 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const Totem::VFATFrame*,std::vector<Totem::VFATFrame> > >"));
  ::Reflex::Type type_2810 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> > >"));
  ::Reflex::Type type_2489 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,long> >,std::_Rb_tree_iterator<std::pair<const unsigned int,long> > >"));
  ::Reflex::Type type_2488 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,long> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,long> > >"));
  ::Reflex::Type type_2492 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >,std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> > >"));
  ::Reflex::Type type_2487 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >,std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> > >"));
  ::Reflex::Type type_2491 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> > >"));
  ::Reflex::Type type_2486 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >,std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> > >"));
  ::Reflex::Type type_2303 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,long>,std::_Select1st<std::pair<const unsigned int,long> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,long> > >"));
  ::Reflex::Type type_2304 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,Totem::OptoRxMetaData>,std::_Select1st<std::pair<const unsigned int,Totem::OptoRxMetaData> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,Totem::OptoRxMetaData> > >"));
  ::Reflex::Type type_2302 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<Totem::FramePosition,std::pair<const Totem::FramePosition,Totem::VFATFrame>,std::_Select1st<std::pair<const Totem::FramePosition,Totem::VFATFrame> >,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition,Totem::VFATFrame> > >"));
  ::Reflex::Type type_17656 = ::Reflex::ArrayBuilder(type_133, 12);
  ::Reflex::Type type_8599 = ::Reflex::ReferenceBuilder(type_2994);
  ::Reflex::Type type_2994c = ::Reflex::ConstBuilder(type_2994);
  ::Reflex::Type type_8601 = ::Reflex::ReferenceBuilder(type_2994c);
  ::Reflex::Type type_2912 = ::Reflex::PointerBuilder(type_133);
  ::Reflex::Type type_133c = ::Reflex::ConstBuilder(type_133);
  ::Reflex::Type type_13476 = ::Reflex::PointerBuilder(type_133c);
  ::Reflex::Type type_5881 = ::Reflex::PointerBuilder(type_2994);
  ::Reflex::Type type_8391 = ::Reflex::PointerBuilder(type_2994c);
  ::Reflex::Type type_2660 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_276);
  ::Reflex::Type type_2591 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_62);
  ::Reflex::Type type_2681c = ::Reflex::ConstBuilder(type_2681);
  ::Reflex::Type type_16626 = ::Reflex::ReferenceBuilder(type_2681c);
  ::Reflex::Type type_2516c = ::Reflex::ConstBuilder(type_2516);
  ::Reflex::Type type_17294 = ::Reflex::ReferenceBuilder(type_2516c);
  ::Reflex::Type type_17295 = ::Reflex::ReferenceBuilder(type_2516);
  ::Reflex::Type type_7446 = ::Reflex::PointerBuilder(type_2474);
  ::Reflex::Type type_2474c = ::Reflex::ConstBuilder(type_2474);
  ::Reflex::Type type_7448 = ::Reflex::PointerBuilder(type_2474c);
  ::Reflex::Type type_7450 = ::Reflex::ReferenceBuilder(type_2474);
  ::Reflex::Type type_7452 = ::Reflex::ReferenceBuilder(type_2474c);
  ::Reflex::Type type_2253c = ::Reflex::ConstBuilder(type_2253);
  ::Reflex::Type type_17028 = ::Reflex::ReferenceBuilder(type_2253c);
  ::Reflex::Type type_2676c = ::Reflex::ConstBuilder(type_2676);
  ::Reflex::Type type_17122 = ::Reflex::ReferenceBuilder(type_2676c);
  ::Reflex::Type type_2611c = ::Reflex::ConstBuilder(type_2611);
  ::Reflex::Type type_17406 = ::Reflex::ReferenceBuilder(type_2611c);
  ::Reflex::Type type_17407 = ::Reflex::ReferenceBuilder(type_2611);
  ::Reflex::Type type_13687 = ::Reflex::ReferenceBuilder(type_62);
  ::Reflex::Type type_284c = ::Reflex::ConstBuilder(type_284);
  ::Reflex::Type type_17029 = ::Reflex::ReferenceBuilder(type_284c);
  ::Reflex::Type type_62c = ::Reflex::ConstBuilder(type_62);
  ::Reflex::Type type_17408 = ::Reflex::ReferenceBuilder(type_62c);
  ::Reflex::Type type_7555 = ::Reflex::PointerBuilder(type_2475);
  ::Reflex::Type type_2475c = ::Reflex::ConstBuilder(type_2475);
  ::Reflex::Type type_7557 = ::Reflex::PointerBuilder(type_2475c);
  ::Reflex::Type type_7559 = ::Reflex::ReferenceBuilder(type_2475);
  ::Reflex::Type type_7561 = ::Reflex::ReferenceBuilder(type_2475c);
  ::Reflex::Type type_2677c = ::Reflex::ConstBuilder(type_2677);
  ::Reflex::Type type_17129 = ::Reflex::ReferenceBuilder(type_2677c);
  ::Reflex::Type type_2612c = ::Reflex::ConstBuilder(type_2612);
  ::Reflex::Type type_17409 = ::Reflex::ReferenceBuilder(type_2612c);
  ::Reflex::Type type_17410 = ::Reflex::ReferenceBuilder(type_2612);
  ::Reflex::Type type_17411 = ::Reflex::ReferenceBuilder(type_2990);
  ::Reflex::Type type_2990c = ::Reflex::ConstBuilder(type_2990);
  ::Reflex::Type type_17412 = ::Reflex::ReferenceBuilder(type_2990c);
  ::Reflex::Type type_7337 = ::Reflex::PointerBuilder(type_2476);
  ::Reflex::Type type_2476c = ::Reflex::ConstBuilder(type_2476);
  ::Reflex::Type type_7339 = ::Reflex::PointerBuilder(type_2476c);
  ::Reflex::Type type_7341 = ::Reflex::ReferenceBuilder(type_2476);
  ::Reflex::Type type_7343 = ::Reflex::ReferenceBuilder(type_2476c);
  ::Reflex::Type type_2254c = ::Reflex::ConstBuilder(type_2254);
  ::Reflex::Type type_17031 = ::Reflex::ReferenceBuilder(type_2254c);
  ::Reflex::Type type_2680c = ::Reflex::ConstBuilder(type_2680);
  ::Reflex::Type type_17114 = ::Reflex::ReferenceBuilder(type_2680c);
  ::Reflex::Type type_2613c = ::Reflex::ConstBuilder(type_2613);
  ::Reflex::Type type_17413 = ::Reflex::ReferenceBuilder(type_2613c);
  ::Reflex::Type type_17414 = ::Reflex::ReferenceBuilder(type_2613);
  ::Reflex::Type type_2993c = ::Reflex::ConstBuilder(type_2993);
  ::Reflex::Type type_11735 = ::Reflex::ReferenceBuilder(type_2993c);
  ::Reflex::Type type_17620 = ::Reflex::PointerBuilder(type_2988);
  ::Reflex::Type type_1870 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("__time_t"), type_62);
  ::Reflex::Type type_1867 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("time_t"), type_1870);
  ::Reflex::Type type_17621 = ::Reflex::ReferenceBuilder(type_2987);
  ::Reflex::Type type_2987c = ::Reflex::ConstBuilder(type_2987);
  ::Reflex::Type type_17622 = ::Reflex::ReferenceBuilder(type_2987c);
  ::Reflex::Type type_17633 = ::Reflex::ReferenceBuilder(type_2988);
  ::Reflex::Type type_2988c = ::Reflex::ConstBuilder(type_2988);
  ::Reflex::Type type_17634 = ::Reflex::ReferenceBuilder(type_2988c);
  ::Reflex::Type type_2145 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2144);
  ::Reflex::Type type_17635 = ::Reflex::ReferenceBuilder(type_2989);
  ::Reflex::Type type_2989c = ::Reflex::ConstBuilder(type_2989);
  ::Reflex::Type type_17636 = ::Reflex::ReferenceBuilder(type_2989c);
  ::Reflex::Type type_17651 = ::Reflex::ReferenceBuilder(type_2991);
  ::Reflex::Type type_2991c = ::Reflex::ConstBuilder(type_2991);
  ::Reflex::Type type_17652 = ::Reflex::ReferenceBuilder(type_2991c);
  ::Reflex::Type type_17653 = ::Reflex::PointerBuilder(type_2912);
  ::Reflex::Type type_2567c = ::Reflex::ConstBuilder(type_2567);
  ::Reflex::Type type_17654 = ::Reflex::ReferenceBuilder(type_2567c);
  ::Reflex::Type type_2145c = ::Reflex::ConstBuilder(type_2145);
  ::Reflex::Type type_17655 = ::Reflex::ReferenceBuilder(type_2993);
  ::Reflex::Type type_9785 = ::Reflex::ReferenceBuilder(type_2145c);
  ::Reflex::Type type_7983 = ::Reflex::ReferenceBuilder(type_553);
  ::Reflex::Type type_17657 = ::Reflex::ReferenceBuilder(type_2995);
  ::Reflex::Type type_2995c = ::Reflex::ConstBuilder(type_2995);
  ::Reflex::Type type_17658 = ::Reflex::ReferenceBuilder(type_2995c);
  ::Reflex::Type type_19201 = ::Reflex::PointerBuilder(type_2991c);
  ::Reflex::Type type_396c = ::Reflex::ConstBuilder(type_396);
  ::Reflex::Type type_11823 = ::Reflex::ReferenceBuilder(type_396c);
  ::Reflex::Type type_19202 = ::Reflex::PointerBuilder(type_2991);
  ::Reflex::Type type_3399c = ::Reflex::ConstBuilder(type_3399);
  ::Reflex::Type type_19203 = ::Reflex::PointerBuilder(type_3399c);
  ::Reflex::Type type_3470c = ::Reflex::ConstBuilder(type_3470);
  ::Reflex::Type type_13083 = ::Reflex::ReferenceBuilder(type_3470c);
  ::Reflex::Type type_17291 = ::Reflex::ReferenceBuilder(type_2514);
  ::Reflex::Type type_19129 = ::Reflex::ReferenceBuilder(type_3293);
  ::Reflex::Type type_574c = ::Reflex::ConstBuilder(type_574);
  ::Reflex::Type type_2996 = ::Reflex::PointerBuilder(type_574c);
  ::Reflex::Type type_6602 = ::Reflex::ReferenceBuilder(type_2996);
  ::Reflex::Type type_2515c = ::Reflex::ConstBuilder(type_2515);
  ::Reflex::Type type_17292 = ::Reflex::ReferenceBuilder(type_2515c);
  ::Reflex::Type type_19206 = ::Reflex::PointerBuilder(type_2995c);
  ::Reflex::Type type_19207 = ::Reflex::PointerBuilder(type_2995);
  ::Reflex::Type type_3400c = ::Reflex::ConstBuilder(type_3400);
  ::Reflex::Type type_19208 = ::Reflex::PointerBuilder(type_3400c);
  ::Reflex::Type type_19211 = ::Reflex::PointerBuilder(type_2987c);
  ::Reflex::Type type_19212 = ::Reflex::PointerBuilder(type_2987);
  ::Reflex::Type type_3401c = ::Reflex::ConstBuilder(type_3401);
  ::Reflex::Type type_19213 = ::Reflex::PointerBuilder(type_3401c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __Totem__VFATFrame
#undef __Totem__VFATFrame
#endif
class __Totem__VFATFrame {
  public:
  __Totem__VFATFrame();
  virtual ~__Totem__VFATFrame() throw();
  unsigned short data[12];
  unsigned short presenceFlags;
  unsigned short daqErrorFlags;
};
#ifdef __std__vector_Totem__VFATFrame_
#undef __std__vector_Totem__VFATFrame_
#endif
class __std__vector_Totem__VFATFrame_ : protected ::std::_Vector_base<Totem::VFATFrame,std::allocator<Totem::VFATFrame> > {
  public:
  __std__vector_Totem__VFATFrame_();
};
#ifdef __std__map_unsignedsint_long_
#undef __std__map_unsignedsint_long_
#endif
class __std__map_unsignedsint_long_ {
  public:
  __std__map_unsignedsint_long_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,long>,std::_Select1st<std::pair<const unsigned int,long> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,long> > > _M_t;
};
#ifdef __std__map_unsignedsint_Totem__OptoRxMetaData_
#undef __std__map_unsignedsint_Totem__OptoRxMetaData_
#endif
class __std__map_unsignedsint_Totem__OptoRxMetaData_ {
  public:
  __std__map_unsignedsint_Totem__OptoRxMetaData_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,Totem::OptoRxMetaData>,std::_Select1st<std::pair<const unsigned int,Totem::OptoRxMetaData> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,Totem::OptoRxMetaData> > > _M_t;
};
#ifdef __std__map_Totem__FramePosition_Totem__VFATFrame_
#undef __std__map_Totem__FramePosition_Totem__VFATFrame_
#endif
class __std__map_Totem__FramePosition_Totem__VFATFrame_ {
  public:
  __std__map_Totem__FramePosition_Totem__VFATFrame_();
  ::std::_Rb_tree<Totem::FramePosition,std::pair<const Totem::FramePosition,Totem::VFATFrame>,std::_Select1st<std::pair<const Totem::FramePosition,Totem::VFATFrame> >,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition,Totem::VFATFrame> > > _M_t;
};
#ifdef __Totem__RawEvent
#undef __Totem__RawEvent
#endif
class __Totem__RawEvent {
  public:
  __Totem__RawEvent();
  void* frames;
  bool ownsCollection;
  unsigned long dataEventNumber;
  unsigned long dataConfNumber;
  ::time_t timestamp;
  ::std::map<unsigned int,Totem::OptoRxMetaData> optoRxMetaData;
  ::Totem::TriggerData triggerData;
  ::std::map<unsigned int,long> ldcTimeStamps;
};
#ifdef __Totem__VFATFrameCollection
#undef __Totem__VFATFrameCollection
#endif
class __Totem__VFATFrameCollection {
  public:
  __Totem__VFATFrameCollection();
  virtual ~__Totem__VFATFrameCollection() throw();
};
#ifdef __Totem__TriggerData
#undef __Totem__TriggerData
#endif
struct __Totem__TriggerData {
  public:
  __Totem__TriggerData();
  unsigned char type;
  unsigned int event_num;
  unsigned int bunch_num;
  unsigned int src_id;
  unsigned int orbit_num;
  unsigned char revision_num;
  unsigned int run_num;
  unsigned int trigger_num;
  unsigned int inhibited_triggers_num;
  unsigned int input_status_bits;
};
#ifdef __Totem__OptoRxMetaData
#undef __Totem__OptoRxMetaData
#endif
struct __Totem__OptoRxMetaData {
  public:
  __Totem__OptoRxMetaData();
  unsigned int BX;
  unsigned int LV1;
};
#ifdef __Totem__OptoRxVFATFrameCollection
#undef __Totem__OptoRxVFATFrameCollection
#endif
class __Totem__OptoRxVFATFrameCollection : public ::Totem::VFATFrameCollection {
  public:
  __Totem__OptoRxVFATFrameCollection();
  virtual ~__Totem__OptoRxVFATFrameCollection() throw();
  ::std::map<unsigned int,Totem::OptoRxVFATFrameCollection::OptoRxBlock*> data;
};
#ifdef __Totem__FramePosition
#undef __Totem__FramePosition
#endif
class __Totem__FramePosition {
  public:
  __Totem__FramePosition();
  unsigned int rawPosition;
};
#ifdef __Totem__SimpleVFATFrameCollection
#undef __Totem__SimpleVFATFrameCollection
#endif
class __Totem__SimpleVFATFrameCollection : public ::Totem::VFATFrameCollection {
  public:
  __Totem__SimpleVFATFrameCollection();
  virtual ~__Totem__SimpleVFATFrameCollection() throw();
  ::std::map<Totem::FramePosition,Totem::VFATFrame> data;
};
#ifdef __edm__Wrapper_Totem__OptoRxVFATFrameCollection_
#undef __edm__Wrapper_Totem__OptoRxVFATFrameCollection_
#endif
class __edm__Wrapper_Totem__OptoRxVFATFrameCollection_ {
  public:
  __edm__Wrapper_Totem__OptoRxVFATFrameCollection_();
  bool present;
  ::Totem::OptoRxVFATFrameCollection obj;
};
#ifdef __edm__Wrapper_Totem__SimpleVFATFrameCollection_
#undef __edm__Wrapper_Totem__SimpleVFATFrameCollection_
#endif
class __edm__Wrapper_Totem__SimpleVFATFrameCollection_ {
  public:
  __edm__Wrapper_Totem__SimpleVFATFrameCollection_();
  bool present;
  ::Totem::SimpleVFATFrameCollection obj;
};
#ifdef __edm__Wrapper_Totem__RawEvent_
#undef __edm__Wrapper_Totem__RawEvent_
#endif
class __edm__Wrapper_Totem__RawEvent_ {
  public:
  __edm__Wrapper_Totem__RawEvent_();
  bool present;
  ::Totem::RawEvent obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class VFATFrame -------------------------------
static  void operator_11772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Totem::VFATFrame*)o)->operator=)(*(const ::Totem::VFATFrame*)arg[0]);
  else   (((::Totem::VFATFrame*)o)->operator=)(*(const ::Totem::VFATFrame*)arg[0]);
}

static void constructor_11773( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::VFATFrame();
  else ::new(mem) ::Totem::VFATFrame();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::VFATFrame((unsigned short*)arg[0]);
  else ::new(mem) ::Totem::VFATFrame((unsigned short*)arg[0]);
  }
}

static void constructor_11774( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::VFATFrame(*(const ::Totem::VFATFrame*)arg[0]);
  else ::new(mem) ::Totem::VFATFrame(*(const ::Totem::VFATFrame*)arg[0]);
}

static void destructor_11775(void*, void * o, const std::vector<void*>&, void *) {
(((::Totem::VFATFrame*)o)->::Totem::VFATFrame::~VFATFrame)();
}
static  void method_11776( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Totem::VFATFrame*)o)->setData)((const unsigned short*)arg[0]);
}

static  void method_11777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Totem::VFATFrame*)o)->getData)());
  else   (((::Totem::VFATFrame*)o)->getData)();
}

static  void method_11778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::Totem::VFATFrame*)o)->getBC)());
  else   (((const ::Totem::VFATFrame*)o)->getBC)();
}

static  void method_11779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::Totem::VFATFrame*)o)->getEC)());
  else   (((const ::Totem::VFATFrame*)o)->getEC)();
}

static  void method_11780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::Totem::VFATFrame*)o)->getFlags)());
  else   (((const ::Totem::VFATFrame*)o)->getFlags)();
}

static  void method_11781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::Totem::VFATFrame*)o)->getChipID)());
  else   (((const ::Totem::VFATFrame*)o)->getChipID)();
}

static  void method_11782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::Totem::VFATFrame*)o)->getCRC)());
  else   (((const ::Totem::VFATFrame*)o)->getCRC)();
}

static  void method_11783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::VFATFrame*)o)->isBCPresent)());
  else   (((const ::Totem::VFATFrame*)o)->isBCPresent)();
}

static  void method_11784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::VFATFrame*)o)->isECPresent)());
  else   (((const ::Totem::VFATFrame*)o)->isECPresent)();
}

static  void method_11785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::VFATFrame*)o)->isIDPresent)());
  else   (((const ::Totem::VFATFrame*)o)->isIDPresent)();
}

static  void method_11786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::VFATFrame*)o)->isCRCPresent)());
  else   (((const ::Totem::VFATFrame*)o)->isCRCPresent)();
}

static  void method_11787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::VFATFrame*)o)->checkFootprint)());
  else   (((const ::Totem::VFATFrame*)o)->checkFootprint)();
}

static  void method_11788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::VFATFrame*)o)->checkCRC)());
  else   (((const ::Totem::VFATFrame*)o)->checkCRC)();
}

static  void method_11789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::VFATFrame*)o)->channelActive)(*(unsigned char*)arg[0]));
  else   (((const ::Totem::VFATFrame*)o)->channelActive)(*(unsigned char*)arg[0]);
}

static  void method_11790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<unsigned char>)((((const ::Totem::VFATFrame*)o)->getActiveChannels)());
  else   (((const ::Totem::VFATFrame*)o)->getActiveChannels)();
}

static  void method_11791( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::Totem::VFATFrame*)o)->Print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::Totem::VFATFrame*)o)->Print)(*(bool*)arg[0]);
  }
}

static  void method_11792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((::Totem::VFATFrame*)o)->calculateCRC)(*(unsigned short*)arg[0],
    *(unsigned short*)arg[1]));
  else   (((::Totem::VFATFrame*)o)->calculateCRC)(*(unsigned short*)arg[0],
    *(unsigned short*)arg[1]);
}

static void constructor_x0( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::VFATFrame();
  else ::new(mem) ::Totem::VFATFrame();
}

static void method_newdel_2994( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Totem::VFATFrame >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Totem::VFATFrame >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Totem::VFATFrame >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Totem::VFATFrame >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Totem::VFATFrame >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class VFATFrame -------------------------------
void __Totem__VFATFrame_db_datamem(Reflex::Class*);
void __Totem__VFATFrame_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Totem__VFATFrame_datamem_bld(&__Totem__VFATFrame_db_datamem);
Reflex::GenreflexMemberBuilder __Totem__VFATFrame_funcmem_bld(&__Totem__VFATFrame_db_funcmem);
void __Totem__VFATFrame_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Totem::VFATFrame"), typeid(::Totem::VFATFrame), sizeof(::Totem::VFATFrame), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddTypedef(type_133, Reflex::Literal("Totem::VFATFrame::word"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8599, type_8601), Reflex::Literal("operator="), operator_11772, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2912), Reflex::Literal("VFATFrame"), constructor_11773, 0, "_data=0l", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8601), Reflex::Literal("VFATFrame"), constructor_11774, 0, "copy", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~VFATFrame"), destructor_11775, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("VFATFrame"), constructor_x0, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2994, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Totem__VFATFrame_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Totem__VFATFrame_funcmem_bld);
}

//------Delayed data member builder for class VFATFrame -------------------
void __Totem__VFATFrame_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17656, Reflex::Literal("data"), OffsetOf(__shadow__::__Totem__VFATFrame, data), ::Reflex::PUBLIC)
  .AddDataMember(type_133, Reflex::Literal("presenceFlags"), OffsetOf(__shadow__::__Totem__VFATFrame, presenceFlags), ::Reflex::PUBLIC)
  .AddDataMember(type_133, Reflex::Literal("daqErrorFlags"), OffsetOf(__shadow__::__Totem__VFATFrame, daqErrorFlags), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class VFATFrame -------------------
void __Totem__VFATFrame_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_13476), Reflex::Literal("setData"), method_11776, 0, "_data", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2912), Reflex::Literal("getData"), method_11777, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("getBC"), method_11778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("getEC"), method_11779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("getFlags"), method_11780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("getChipID"), method_11781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("getCRC"), method_11782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("isBCPresent"), method_11783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("isECPresent"), method_11784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("isIDPresent"), method_11785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("isCRCPresent"), method_11786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("checkFootprint"), method_11787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("checkCRC"), method_11788, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344, type_553), Reflex::Literal("channelActive"), method_11789, 0, "channel", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2535), Reflex::Literal("getActiveChannels"), method_11790, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_1344), Reflex::Literal("Print"), method_11791, 0, "binary=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133, type_133, type_133), Reflex::Literal("calculateCRC"), method_11792, 0, "crc_in;dato", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<Totem::VFATFrame,std::allocator<Totem::VFATFrame> > -------------------------------
static void constructor_8610( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Totem::VFATFrame>();
  else ::new(mem) ::std::vector<Totem::VFATFrame>();
}

static void constructor_8611( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Totem::VFATFrame>(*(const ::std::allocator<Totem::VFATFrame>*)arg[0]);
  else ::new(mem) ::std::vector<Totem::VFATFrame>(*(const ::std::allocator<Totem::VFATFrame>*)arg[0]);
}

static void constructor_8612( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Totem::VFATFrame>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<Totem::VFATFrame>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Totem::VFATFrame>(*(::std::size_t*)arg[0],
      *(const ::Totem::VFATFrame*)arg[1]);
  else ::new(mem) ::std::vector<Totem::VFATFrame>(*(::std::size_t*)arg[0],
      *(const ::Totem::VFATFrame*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Totem::VFATFrame>(*(::std::size_t*)arg[0],
      *(const ::Totem::VFATFrame*)arg[1],
      *(const ::std::allocator<Totem::VFATFrame>*)arg[2]);
  else ::new(mem) ::std::vector<Totem::VFATFrame>(*(::std::size_t*)arg[0],
      *(const ::Totem::VFATFrame*)arg[1],
      *(const ::std::allocator<Totem::VFATFrame>*)arg[2]);
  }
}

static void constructor_8613( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Totem::VFATFrame>(*(const ::std::vector<Totem::VFATFrame>*)arg[0]);
  else ::new(mem) ::std::vector<Totem::VFATFrame>(*(const ::std::vector<Totem::VFATFrame>*)arg[0]);
}

static void destructor_8614(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<Totem::VFATFrame>*)o)->::std::vector<Totem::VFATFrame>::~vector)();
}
static  void operator_8615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Totem::VFATFrame>*)o)->operator=)(*(const ::std::vector<Totem::VFATFrame>*)arg[0]);
  else   (((::std::vector<Totem::VFATFrame>*)o)->operator=)(*(const ::std::vector<Totem::VFATFrame>*)arg[0]);
}

static  void method_8616( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Totem::VFATFrame>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::Totem::VFATFrame*)arg[1]);
}

static  void method_8617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >)((((::std::vector<Totem::VFATFrame>*)o)->begin)());
  else   (((::std::vector<Totem::VFATFrame>*)o)->begin)();
}

static  void method_8618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Totem::VFATFrame*,std::vector<Totem::VFATFrame> >)((((const ::std::vector<Totem::VFATFrame>*)o)->begin)());
  else   (((const ::std::vector<Totem::VFATFrame>*)o)->begin)();
}

static  void method_8619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >)((((::std::vector<Totem::VFATFrame>*)o)->end)());
  else   (((::std::vector<Totem::VFATFrame>*)o)->end)();
}

static  void method_8620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Totem::VFATFrame*,std::vector<Totem::VFATFrame> >)((((const ::std::vector<Totem::VFATFrame>*)o)->end)());
  else   (((const ::std::vector<Totem::VFATFrame>*)o)->end)();
}

static  void method_8625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Totem::VFATFrame>*)o)->size)());
  else   (((const ::std::vector<Totem::VFATFrame>*)o)->size)();
}

static  void method_8626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Totem::VFATFrame>*)o)->max_size)());
  else   (((const ::std::vector<Totem::VFATFrame>*)o)->max_size)();
}

static  void method_8627( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<Totem::VFATFrame>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<Totem::VFATFrame>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::Totem::VFATFrame*)arg[1]);
  }
}

static  void method_8628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Totem::VFATFrame>*)o)->capacity)());
  else   (((const ::std::vector<Totem::VFATFrame>*)o)->capacity)();
}

static  void method_8629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<Totem::VFATFrame>*)o)->empty)());
  else   (((const ::std::vector<Totem::VFATFrame>*)o)->empty)();
}

static  void method_8630( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Totem::VFATFrame>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Totem::VFATFrame>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Totem::VFATFrame>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Totem::VFATFrame>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Totem::VFATFrame>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Totem::VFATFrame>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Totem::VFATFrame>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Totem::VFATFrame>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Totem::VFATFrame>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Totem::VFATFrame>*)o)->front)();
  else   (((::std::vector<Totem::VFATFrame>*)o)->front)();
}

static  void method_8637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Totem::VFATFrame>*)o)->front)();
  else   (((const ::std::vector<Totem::VFATFrame>*)o)->front)();
}

static  void method_8638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Totem::VFATFrame>*)o)->back)();
  else   (((::std::vector<Totem::VFATFrame>*)o)->back)();
}

static  void method_8639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Totem::VFATFrame>*)o)->back)();
  else   (((const ::std::vector<Totem::VFATFrame>*)o)->back)();
}

static  void method_8640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<Totem::VFATFrame>*)o)->data)());
  else   (((::std::vector<Totem::VFATFrame>*)o)->data)();
}

static  void method_8641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<Totem::VFATFrame>*)o)->data)());
  else   (((const ::std::vector<Totem::VFATFrame>*)o)->data)();
}

static  void method_8642( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Totem::VFATFrame>*)o)->push_back)(*(const ::Totem::VFATFrame*)arg[0]);
}

static  void method_8643( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Totem::VFATFrame>*)o)->pop_back)();
}

static  void method_8644( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >)((((::std::vector<Totem::VFATFrame>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >*)arg[0],
    *(const ::Totem::VFATFrame*)arg[1]));
  else   (((::std::vector<Totem::VFATFrame>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >*)arg[0],
    *(const ::Totem::VFATFrame*)arg[1]);
}

static  void method_8645( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Totem::VFATFrame>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::Totem::VFATFrame*)arg[2]);
}

static  void method_8646( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >)((((::std::vector<Totem::VFATFrame>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >*)arg[0]));
  else   (((::std::vector<Totem::VFATFrame>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >*)arg[0]);
}

static  void method_8647( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >)((((::std::vector<Totem::VFATFrame>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >*)arg[1]));
  else   (((::std::vector<Totem::VFATFrame>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Totem::VFATFrame*,std::vector<Totem::VFATFrame> >*)arg[1]);
}

static  void method_8648( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Totem::VFATFrame>*)o)->swap)(*(::std::vector<Totem::VFATFrame>*)arg[0]);
}

static  void method_8649( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Totem::VFATFrame>*)o)->clear)();
}

static void method_newdel_2516( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<Totem::VFATFrame> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<Totem::VFATFrame> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<Totem::VFATFrame> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<Totem::VFATFrame> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<Totem::VFATFrame> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Totem::VFATFrame,std::allocator<Totem::VFATFrame> >")), ::Reflex::BaseOffset< ::std::vector<Totem::VFATFrame>,::std::_Vector_base<Totem::VFATFrame,std::allocator<Totem::VFATFrame> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<Totem::VFATFrame> >::Generate();
  else ::Reflex::Proxy< ::std::vector<Totem::VFATFrame> >::Generate();
}

//------Dictionary for class vector<Totem::VFATFrame,std::allocator<Totem::VFATFrame> > -------------------------------
void __std__vector_Totem__VFATFrame__db_datamem(Reflex::Class*);
void __std__vector_Totem__VFATFrame__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_Totem__VFATFrame__datamem_bld(&__std__vector_Totem__VFATFrame__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_Totem__VFATFrame__funcmem_bld(&__std__vector_Totem__VFATFrame__db_funcmem);
void __std__vector_Totem__VFATFrame__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<Totem::VFATFrame>"), typeid(::std::vector<Totem::VFATFrame>), sizeof(::std::vector<Totem::VFATFrame>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2120, ::Reflex::BaseOffset< ::std::vector<Totem::VFATFrame>, ::std::_Vector_base<Totem::VFATFrame,std::allocator<Totem::VFATFrame> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2994, Reflex::Literal("std::vector<Totem::VFATFrame>::_Alloc_value_type"))
  .AddTypedef(type_2120, Reflex::Literal("std::vector<Totem::VFATFrame>::_Base"))
  .AddTypedef(type_2681, Reflex::Literal("std::vector<Totem::VFATFrame>::_Tp_alloc_type"))
  .AddTypedef(type_5004, Reflex::Literal("std::vector<Totem::VFATFrame>::_Alloc_traits"))
  .AddTypedef(type_2994, Reflex::Literal("std::vector<Totem::VFATFrame>::value_type"))
  .AddTypedef(type_5881, Reflex::Literal("std::vector<Totem::VFATFrame>::pointer"))
  .AddTypedef(type_8391, Reflex::Literal("std::vector<Totem::VFATFrame>::const_pointer"))
  .AddTypedef(type_8599, Reflex::Literal("std::vector<Totem::VFATFrame>::reference"))
  .AddTypedef(type_8601, Reflex::Literal("std::vector<Totem::VFATFrame>::const_reference"))
  .AddTypedef(type_4938, Reflex::Literal("std::vector<Totem::VFATFrame>::iterator"))
  .AddTypedef(type_4939, Reflex::Literal("std::vector<Totem::VFATFrame>::const_iterator"))
  .AddTypedef(type_2772, Reflex::Literal("std::vector<Totem::VFATFrame>::const_reverse_iterator"))
  .AddTypedef(type_2773, Reflex::Literal("std::vector<Totem::VFATFrame>::reverse_iterator"))
  .AddTypedef(type_2660, Reflex::Literal("std::vector<Totem::VFATFrame>::size_type"))
  .AddTypedef(type_2591, Reflex::Literal("std::vector<Totem::VFATFrame>::difference_type"))
  .AddTypedef(type_2681, Reflex::Literal("std::vector<Totem::VFATFrame>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8610, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16626), Reflex::Literal("vector"), constructor_8611, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2660, type_8601, type_16626), Reflex::Literal("vector"), constructor_8612, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17294), Reflex::Literal("vector"), constructor_8613, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8614, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2516, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_Totem__VFATFrame__funcmem_bld);
}

//------Delayed data member builder for class vector<Totem::VFATFrame,std::allocator<Totem::VFATFrame> > -------------------
void __std__vector_Totem__VFATFrame__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<Totem::VFATFrame,std::allocator<Totem::VFATFrame> > -------------------
void __std__vector_Totem__VFATFrame__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17295, type_17294), Reflex::Literal("operator="), operator_8615, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2660, type_8601), Reflex::Literal("assign"), method_8616, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4938), Reflex::Literal("begin"), method_8617, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4939), Reflex::Literal("begin"), method_8618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4938), Reflex::Literal("end"), method_8619, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4939), Reflex::Literal("end"), method_8620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660), Reflex::Literal("size"), method_8625, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660), Reflex::Literal("max_size"), method_8626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2660, type_2994), Reflex::Literal("resize"), method_8627, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660), Reflex::Literal("capacity"), method_8628, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("empty"), method_8629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2660), Reflex::Literal("reserve"), method_8630, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8599, type_2660), Reflex::Literal("operator[]"), operator_8631, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8601, type_2660), Reflex::Literal("operator[]"), operator_8632, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8599, type_2660), Reflex::Literal("at"), method_8634, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8601, type_2660), Reflex::Literal("at"), method_8635, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8599), Reflex::Literal("front"), method_8636, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8601), Reflex::Literal("front"), method_8637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8599), Reflex::Literal("back"), method_8638, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8601), Reflex::Literal("back"), method_8639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5881), Reflex::Literal("data"), method_8640, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8391), Reflex::Literal("data"), method_8641, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_8601), Reflex::Literal("push_back"), method_8642, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("pop_back"), method_8643, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4938, type_4938, type_8601), Reflex::Literal("insert"), method_8644, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_4938, type_2660, type_8601), Reflex::Literal("insert"), method_8645, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4938, type_4938), Reflex::Literal("erase"), method_8646, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4938, type_4938, type_4938), Reflex::Literal("erase"), method_8647, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_17295), Reflex::Literal("swap"), method_8648, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("clear"), method_8649, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<unsigned int,long int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, long int> > > -------------------------------
static void destructor_9843(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,long>*)o)->::std::map<unsigned int,long>::~map)();
}
static void constructor_9844( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,long>();
  else ::new(mem) ::std::map<unsigned int,long>();
}

static void constructor_9845( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,long>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,long>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,long>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,long> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,long>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,long> >*)arg[1]);
  }
}

static void constructor_9846( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,long>(*(const ::std::map<unsigned int,long>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,long>(*(const ::std::map<unsigned int,long>*)arg[0]);
}

static  void operator_9847( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,long>*)o)->operator=)(*(const ::std::map<unsigned int,long>*)arg[0]);
  else   (((::std::map<unsigned int,long>*)o)->operator=)(*(const ::std::map<unsigned int,long>*)arg[0]);
}

static  void method_9848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,long> >)((((const ::std::map<unsigned int,long>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,long>*)o)->get_allocator)();
}

static  void method_9849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,long> >)((((::std::map<unsigned int,long>*)o)->begin)());
  else   (((::std::map<unsigned int,long>*)o)->begin)();
}

static  void method_9850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,long> >)((((const ::std::map<unsigned int,long>*)o)->begin)());
  else   (((const ::std::map<unsigned int,long>*)o)->begin)();
}

static  void method_9851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,long> >)((((::std::map<unsigned int,long>*)o)->end)());
  else   (((::std::map<unsigned int,long>*)o)->end)();
}

static  void method_9852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,long> >)((((const ::std::map<unsigned int,long>*)o)->end)());
  else   (((const ::std::map<unsigned int,long>*)o)->end)();
}

static  void method_9857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,long>*)o)->empty)());
  else   (((const ::std::map<unsigned int,long>*)o)->empty)();
}

static  void method_9858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,long>*)o)->size)());
  else   (((const ::std::map<unsigned int,long>*)o)->size)();
}

static  void method_9859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,long>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,long>*)o)->max_size)();
}

static  void operator_9860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,long>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,long>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_9861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,long>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,long>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_9862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,long>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,long>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_9863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,long> >,bool>)((((::std::map<unsigned int,long>*)o)->insert)(*(const ::std::pair<const unsigned int,long>*)arg[0]));
  else   (((::std::map<unsigned int,long>*)o)->insert)(*(const ::std::pair<const unsigned int,long>*)arg[0]);
}

static  void method_9864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,long> >)((((::std::map<unsigned int,long>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,long> >*)arg[0],
    *(const ::std::pair<const unsigned int,long>*)arg[1]));
  else   (((::std::map<unsigned int,long>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,long> >*)arg[0],
    *(const ::std::pair<const unsigned int,long>*)arg[1]);
}

static  void method_9865( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,long>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,long> >*)arg[0]);
}

static  void method_9866( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,long>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,long>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_9867( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,long>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,long> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,long> >*)arg[1]);
}

static  void method_9868( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,long>*)o)->swap)(*(::std::map<unsigned int,long>*)arg[0]);
}

static  void method_9869( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,long>*)o)->clear)();
}

static  void method_9870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,long>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,long>*)o)->key_comp)();
}

static  void method_9872( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,long> >)((((::std::map<unsigned int,long>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,long>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_9873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,long> >)((((const ::std::map<unsigned int,long>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,long>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_9874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,long>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,long>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_9875( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,long> >)((((::std::map<unsigned int,long>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,long>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_9876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,long> >)((((const ::std::map<unsigned int,long>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,long>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_9877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,long> >)((((::std::map<unsigned int,long>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,long>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_9878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,long> >)((((const ::std::map<unsigned int,long>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,long>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_9879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,long> >,std::_Rb_tree_iterator<std::pair<const unsigned int,long> > >)((((::std::map<unsigned int,long>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,long>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_9880( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,long> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,long> > >)((((const ::std::map<unsigned int,long>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,long>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2611( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,long> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,long> >::Generate();
}

//------Dictionary for class map<unsigned int,long int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, long int> > > -------------------------------
void __std__map_unsignedsint_long__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_long__datamem_bld(&__std__map_unsignedsint_long__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_long__funcmem_bld(&__std__map_unsignedsint_long__db_funcmem);
void __std__map_unsignedsint_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,long>"), typeid(::std::map<unsigned int,long>), sizeof(::std::map<unsigned int,long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_284, Reflex::Literal("std::map<unsigned int,long>::key_type"))
  .AddTypedef(type_62, Reflex::Literal("std::map<unsigned int,long>::mapped_type"))
  .AddTypedef(type_2474, Reflex::Literal("std::map<unsigned int,long>::value_type"))
  .AddTypedef(type_2253, Reflex::Literal("std::map<unsigned int,long>::key_compare"))
  .AddTypedef(type_2676, Reflex::Literal("std::map<unsigned int,long>::allocator_type"))
  .AddTypedef(type_2474, Reflex::Literal("std::map<unsigned int,long>::_Alloc_value_type"))
  .AddTypedef(type_2676, Reflex::Literal("std::map<unsigned int,long>::_Pair_alloc_type"))
  .AddTypedef(type_2303, Reflex::Literal("std::map<unsigned int,long>::_Rep_type"))
  .AddTypedef(type_7446, Reflex::Literal("std::map<unsigned int,long>::pointer"))
  .AddTypedef(type_7448, Reflex::Literal("std::map<unsigned int,long>::const_pointer"))
  .AddTypedef(type_7450, Reflex::Literal("std::map<unsigned int,long>::reference"))
  .AddTypedef(type_7452, Reflex::Literal("std::map<unsigned int,long>::const_reference"))
  .AddTypedef(type_2569, Reflex::Literal("std::map<unsigned int,long>::iterator"))
  .AddTypedef(type_2665, Reflex::Literal("std::map<unsigned int,long>::const_iterator"))
  .AddTypedef(type_2660, Reflex::Literal("std::map<unsigned int,long>::size_type"))
  .AddTypedef(type_2591, Reflex::Literal("std::map<unsigned int,long>::difference_type"))
  .AddTypedef(type_2813, Reflex::Literal("std::map<unsigned int,long>::reverse_iterator"))
  .AddTypedef(type_2812, Reflex::Literal("std::map<unsigned int,long>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_9843, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_9844, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17028, type_17122), Reflex::Literal("map"), constructor_9845, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17406), Reflex::Literal("map"), constructor_9846, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2611, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_long__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_long__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,long int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, long int> > > -------------------
void __std__map_unsignedsint_long__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2303, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_long_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,long int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, long int> > > -------------------
void __std__map_unsignedsint_long__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17407, type_17406), Reflex::Literal("operator="), operator_9847, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2676), Reflex::Literal("get_allocator"), method_9848, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2569), Reflex::Literal("begin"), method_9849, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2665), Reflex::Literal("begin"), method_9850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2569), Reflex::Literal("end"), method_9851, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2665), Reflex::Literal("end"), method_9852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("empty"), method_9857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660), Reflex::Literal("size"), method_9858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660), Reflex::Literal("max_size"), method_9859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13687, type_17029), Reflex::Literal("operator[]"), operator_9860, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13687, type_17029), Reflex::Literal("at"), method_9861, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17408, type_17029), Reflex::Literal("at"), method_9862, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2490, type_7452), Reflex::Literal("insert"), method_9863, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2569, type_2569, type_7452), Reflex::Literal("insert"), method_9864, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2569), Reflex::Literal("erase"), method_9865, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660, type_17029), Reflex::Literal("erase"), method_9866, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2569, type_2569), Reflex::Literal("erase"), method_9867, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_17407), Reflex::Literal("swap"), method_9868, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("clear"), method_9869, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2253), Reflex::Literal("key_comp"), method_9870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2569, type_17029), Reflex::Literal("find"), method_9872, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2665, type_17029), Reflex::Literal("find"), method_9873, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660, type_17029), Reflex::Literal("count"), method_9874, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2569, type_17029), Reflex::Literal("lower_bound"), method_9875, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2665, type_17029), Reflex::Literal("lower_bound"), method_9876, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2569, type_17029), Reflex::Literal("upper_bound"), method_9877, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2665, type_17029), Reflex::Literal("upper_bound"), method_9878, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2489, type_17029), Reflex::Literal("equal_range"), method_9879, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2488, type_17029), Reflex::Literal("equal_range"), method_9880, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,Totem::OptoRxMetaData,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, Totem::OptoRxMetaData> > > -------------------------------
static void destructor_9901(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->::std::map<unsigned int,Totem::OptoRxMetaData>::~map)();
}
static void constructor_9902( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,Totem::OptoRxMetaData>();
  else ::new(mem) ::std::map<unsigned int,Totem::OptoRxMetaData>();
}

static void constructor_9903( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,Totem::OptoRxMetaData>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,Totem::OptoRxMetaData>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,Totem::OptoRxMetaData>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,Totem::OptoRxMetaData> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,Totem::OptoRxMetaData>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,Totem::OptoRxMetaData> >*)arg[1]);
  }
}

static void constructor_9904( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,Totem::OptoRxMetaData>(*(const ::std::map<unsigned int,Totem::OptoRxMetaData>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,Totem::OptoRxMetaData>(*(const ::std::map<unsigned int,Totem::OptoRxMetaData>*)arg[0]);
}

static  void operator_9905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->operator=)(*(const ::std::map<unsigned int,Totem::OptoRxMetaData>*)arg[0]);
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->operator=)(*(const ::std::map<unsigned int,Totem::OptoRxMetaData>*)arg[0]);
}

static  void method_9906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->get_allocator)();
}

static  void method_9907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->begin)());
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->begin)();
}

static  void method_9908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->begin)());
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->begin)();
}

static  void method_9909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->end)());
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->end)();
}

static  void method_9910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->end)());
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->end)();
}

static  void method_9915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->empty)());
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->empty)();
}

static  void method_9916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->size)());
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->size)();
}

static  void method_9917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->max_size)();
}

static  void operator_9918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_9919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_9920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_9921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >,bool>)((((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->insert)(*(const ::std::pair<const unsigned int,Totem::OptoRxMetaData>*)arg[0]));
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->insert)(*(const ::std::pair<const unsigned int,Totem::OptoRxMetaData>*)arg[0]);
}

static  void method_9922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >*)arg[0],
    *(const ::std::pair<const unsigned int,Totem::OptoRxMetaData>*)arg[1]));
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >*)arg[0],
    *(const ::std::pair<const unsigned int,Totem::OptoRxMetaData>*)arg[1]);
}

static  void method_9923( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >*)arg[0]);
}

static  void method_9924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_9925( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >*)arg[1]);
}

static  void method_9926( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->swap)(*(::std::map<unsigned int,Totem::OptoRxMetaData>*)arg[0]);
}

static  void method_9927( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->clear)();
}

static  void method_9928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->key_comp)();
}

static  void method_9930( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_9931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_9932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_9933( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_9934( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_9935( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_9936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_9937( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >,std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> > >)((((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_9938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,Totem::OptoRxMetaData> > >)((((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,Totem::OptoRxMetaData>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2612( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,Totem::OptoRxMetaData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,Totem::OptoRxMetaData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,Totem::OptoRxMetaData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,Totem::OptoRxMetaData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,Totem::OptoRxMetaData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,Totem::OptoRxMetaData> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,Totem::OptoRxMetaData> >::Generate();
}

//------Dictionary for class map<unsigned int,Totem::OptoRxMetaData,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, Totem::OptoRxMetaData> > > -------------------------------
void __std__map_unsignedsint_Totem__OptoRxMetaData__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_Totem__OptoRxMetaData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_Totem__OptoRxMetaData__datamem_bld(&__std__map_unsignedsint_Totem__OptoRxMetaData__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_Totem__OptoRxMetaData__funcmem_bld(&__std__map_unsignedsint_Totem__OptoRxMetaData__db_funcmem);
void __std__map_unsignedsint_Totem__OptoRxMetaData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>"), typeid(::std::map<unsigned int,Totem::OptoRxMetaData>), sizeof(::std::map<unsigned int,Totem::OptoRxMetaData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_284, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::key_type"))
  .AddTypedef(type_2990, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::mapped_type"))
  .AddTypedef(type_2475, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::value_type"))
  .AddTypedef(type_2253, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::key_compare"))
  .AddTypedef(type_2677, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::allocator_type"))
  .AddTypedef(type_2475, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::_Alloc_value_type"))
  .AddTypedef(type_2677, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::_Pair_alloc_type"))
  .AddTypedef(type_2304, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::_Rep_type"))
  .AddTypedef(type_7555, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::pointer"))
  .AddTypedef(type_7557, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::const_pointer"))
  .AddTypedef(type_7559, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::reference"))
  .AddTypedef(type_7561, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::const_reference"))
  .AddTypedef(type_2570, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::iterator"))
  .AddTypedef(type_2666, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::const_iterator"))
  .AddTypedef(type_2660, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::size_type"))
  .AddTypedef(type_2591, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::difference_type"))
  .AddTypedef(type_2815, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::reverse_iterator"))
  .AddTypedef(type_2814, Reflex::Literal("std::map<unsigned int,Totem::OptoRxMetaData>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_9901, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_9902, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17028, type_17129), Reflex::Literal("map"), constructor_9903, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17409), Reflex::Literal("map"), constructor_9904, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2612, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_Totem__OptoRxMetaData__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_Totem__OptoRxMetaData__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,Totem::OptoRxMetaData,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, Totem::OptoRxMetaData> > > -------------------
void __std__map_unsignedsint_Totem__OptoRxMetaData__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2304, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_Totem__OptoRxMetaData_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,Totem::OptoRxMetaData,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, Totem::OptoRxMetaData> > > -------------------
void __std__map_unsignedsint_Totem__OptoRxMetaData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17410, type_17409), Reflex::Literal("operator="), operator_9905, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2677), Reflex::Literal("get_allocator"), method_9906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2570), Reflex::Literal("begin"), method_9907, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666), Reflex::Literal("begin"), method_9908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2570), Reflex::Literal("end"), method_9909, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666), Reflex::Literal("end"), method_9910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("empty"), method_9915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660), Reflex::Literal("size"), method_9916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660), Reflex::Literal("max_size"), method_9917, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17411, type_17029), Reflex::Literal("operator[]"), operator_9918, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17411, type_17029), Reflex::Literal("at"), method_9919, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17412, type_17029), Reflex::Literal("at"), method_9920, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2493, type_7561), Reflex::Literal("insert"), method_9921, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2570, type_2570, type_7561), Reflex::Literal("insert"), method_9922, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2570), Reflex::Literal("erase"), method_9923, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660, type_17029), Reflex::Literal("erase"), method_9924, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2570, type_2570), Reflex::Literal("erase"), method_9925, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_17410), Reflex::Literal("swap"), method_9926, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("clear"), method_9927, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2253), Reflex::Literal("key_comp"), method_9928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2570, type_17029), Reflex::Literal("find"), method_9930, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_17029), Reflex::Literal("find"), method_9931, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660, type_17029), Reflex::Literal("count"), method_9932, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2570, type_17029), Reflex::Literal("lower_bound"), method_9933, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_17029), Reflex::Literal("lower_bound"), method_9934, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2570, type_17029), Reflex::Literal("upper_bound"), method_9935, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2666, type_17029), Reflex::Literal("upper_bound"), method_9936, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2492, type_17029), Reflex::Literal("equal_range"), method_9937, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2491, type_17029), Reflex::Literal("equal_range"), method_9938, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<Totem::FramePosition,Totem::VFATFrame,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition, Totem::VFATFrame> > > -------------------------------
static void destructor_9959(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->::std::map<Totem::FramePosition,Totem::VFATFrame>::~map)();
}
static void constructor_9960( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<Totem::FramePosition,Totem::VFATFrame>();
  else ::new(mem) ::std::map<Totem::FramePosition,Totem::VFATFrame>();
}

static void constructor_9961( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<Totem::FramePosition,Totem::VFATFrame>(*(const ::std::less<Totem::FramePosition>*)arg[0]);
  else ::new(mem) ::std::map<Totem::FramePosition,Totem::VFATFrame>(*(const ::std::less<Totem::FramePosition>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<Totem::FramePosition,Totem::VFATFrame>(*(const ::std::less<Totem::FramePosition>*)arg[0],
      *(const ::std::allocator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >*)arg[1]);
  else ::new(mem) ::std::map<Totem::FramePosition,Totem::VFATFrame>(*(const ::std::less<Totem::FramePosition>*)arg[0],
      *(const ::std::allocator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >*)arg[1]);
  }
}

static void constructor_9962( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<Totem::FramePosition,Totem::VFATFrame>(*(const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)arg[0]);
  else ::new(mem) ::std::map<Totem::FramePosition,Totem::VFATFrame>(*(const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)arg[0]);
}

static  void operator_9963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->operator=)(*(const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)arg[0]);
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->operator=)(*(const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)arg[0]);
}

static  void method_9964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->get_allocator)());
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->get_allocator)();
}

static  void method_9965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->begin)());
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->begin)();
}

static  void method_9966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->begin)());
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->begin)();
}

static  void method_9967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->end)());
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->end)();
}

static  void method_9968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->end)());
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->end)();
}

static  void method_9973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->empty)());
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->empty)();
}

static  void method_9974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->size)());
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->size)();
}

static  void method_9975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->max_size)());
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->max_size)();
}

static  void operator_9976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->operator[])(*(const ::Totem::FramePosition*)arg[0]);
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->operator[])(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->at)(*(const ::Totem::FramePosition*)arg[0]);
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->at)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->at)(*(const ::Totem::FramePosition*)arg[0]);
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->at)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >,bool>)((((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->insert)(*(const ::std::pair<const Totem::FramePosition,Totem::VFATFrame>*)arg[0]));
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->insert)(*(const ::std::pair<const Totem::FramePosition,Totem::VFATFrame>*)arg[0]);
}

static  void method_9980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >*)arg[0],
    *(const ::std::pair<const Totem::FramePosition,Totem::VFATFrame>*)arg[1]));
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >*)arg[0],
    *(const ::std::pair<const Totem::FramePosition,Totem::VFATFrame>*)arg[1]);
}

static  void method_9981( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >*)arg[0]);
}

static  void method_9982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->erase)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->erase)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9983( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >*)arg[1]);
}

static  void method_9984( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->swap)(*(::std::map<Totem::FramePosition,Totem::VFATFrame>*)arg[0]);
}

static  void method_9985( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->clear)();
}

static  void method_9986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<Totem::FramePosition>)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->key_comp)());
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->key_comp)();
}

static  void method_9988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->find)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->find)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->find)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->find)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->count)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->count)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9991( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->lower_bound)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->lower_bound)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->lower_bound)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->lower_bound)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9993( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->upper_bound)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->upper_bound)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->upper_bound)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->upper_bound)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >,std::_Rb_tree_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> > >)((((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->equal_range)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->equal_range)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_9996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> >,std::_Rb_tree_const_iterator<std::pair<const Totem::FramePosition,Totem::VFATFrame> > >)((((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->equal_range)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::std::map<Totem::FramePosition,Totem::VFATFrame>*)o)->equal_range)(*(const ::Totem::FramePosition*)arg[0]);
}

static void method_newdel_2613( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<Totem::FramePosition,Totem::VFATFrame> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<Totem::FramePosition,Totem::VFATFrame> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<Totem::FramePosition,Totem::VFATFrame> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<Totem::FramePosition,Totem::VFATFrame> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<Totem::FramePosition,Totem::VFATFrame> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<Totem::FramePosition,Totem::VFATFrame> >::Generate();
  else ::Reflex::Proxy< ::std::map<Totem::FramePosition,Totem::VFATFrame> >::Generate();
}

//------Dictionary for class map<Totem::FramePosition,Totem::VFATFrame,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition, Totem::VFATFrame> > > -------------------------------
void __std__map_Totem__FramePosition_Totem__VFATFrame__db_datamem(Reflex::Class*);
void __std__map_Totem__FramePosition_Totem__VFATFrame__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_Totem__FramePosition_Totem__VFATFrame__datamem_bld(&__std__map_Totem__FramePosition_Totem__VFATFrame__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_Totem__FramePosition_Totem__VFATFrame__funcmem_bld(&__std__map_Totem__FramePosition_Totem__VFATFrame__db_funcmem);
void __std__map_Totem__FramePosition_Totem__VFATFrame__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>"), typeid(::std::map<Totem::FramePosition,Totem::VFATFrame>), sizeof(::std::map<Totem::FramePosition,Totem::VFATFrame>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2993, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::key_type"))
  .AddTypedef(type_2994, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::mapped_type"))
  .AddTypedef(type_2476, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::value_type"))
  .AddTypedef(type_2254, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::key_compare"))
  .AddTypedef(type_2680, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::allocator_type"))
  .AddTypedef(type_2476, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::_Alloc_value_type"))
  .AddTypedef(type_2680, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::_Pair_alloc_type"))
  .AddTypedef(type_2302, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::_Rep_type"))
  .AddTypedef(type_7337, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::pointer"))
  .AddTypedef(type_7339, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::const_pointer"))
  .AddTypedef(type_7341, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::reference"))
  .AddTypedef(type_7343, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::const_reference"))
  .AddTypedef(type_2568, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::iterator"))
  .AddTypedef(type_2664, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::const_iterator"))
  .AddTypedef(type_2660, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::size_type"))
  .AddTypedef(type_2591, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::difference_type"))
  .AddTypedef(type_2811, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::reverse_iterator"))
  .AddTypedef(type_2810, Reflex::Literal("std::map<Totem::FramePosition,Totem::VFATFrame>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_9959, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_9960, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17031, type_17114), Reflex::Literal("map"), constructor_9961, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17413), Reflex::Literal("map"), constructor_9962, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2613, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_Totem__FramePosition_Totem__VFATFrame__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_Totem__FramePosition_Totem__VFATFrame__funcmem_bld);
}

//------Delayed data member builder for class map<Totem::FramePosition,Totem::VFATFrame,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition, Totem::VFATFrame> > > -------------------
void __std__map_Totem__FramePosition_Totem__VFATFrame__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2302, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_Totem__FramePosition_Totem__VFATFrame_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<Totem::FramePosition,Totem::VFATFrame,std::less<Totem::FramePosition>,std::allocator<std::pair<const Totem::FramePosition, Totem::VFATFrame> > > -------------------
void __std__map_Totem__FramePosition_Totem__VFATFrame__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17414, type_17413), Reflex::Literal("operator="), operator_9963, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2680), Reflex::Literal("get_allocator"), method_9964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2568), Reflex::Literal("begin"), method_9965, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("begin"), method_9966, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2568), Reflex::Literal("end"), method_9967, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664), Reflex::Literal("end"), method_9968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("empty"), method_9973, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660), Reflex::Literal("size"), method_9974, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660), Reflex::Literal("max_size"), method_9975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8599, type_11735), Reflex::Literal("operator[]"), operator_9976, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8599, type_11735), Reflex::Literal("at"), method_9977, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8601, type_11735), Reflex::Literal("at"), method_9978, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2485, type_7343), Reflex::Literal("insert"), method_9979, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2568, type_2568, type_7343), Reflex::Literal("insert"), method_9980, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2568), Reflex::Literal("erase"), method_9981, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660, type_11735), Reflex::Literal("erase"), method_9982, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_2568, type_2568), Reflex::Literal("erase"), method_9983, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_17414), Reflex::Literal("swap"), method_9984, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("clear"), method_9985, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2254), Reflex::Literal("key_comp"), method_9986, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2568, type_11735), Reflex::Literal("find"), method_9988, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664, type_11735), Reflex::Literal("find"), method_9989, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2660, type_11735), Reflex::Literal("count"), method_9990, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2568, type_11735), Reflex::Literal("lower_bound"), method_9991, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664, type_11735), Reflex::Literal("lower_bound"), method_9992, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2568, type_11735), Reflex::Literal("upper_bound"), method_9993, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2664, type_11735), Reflex::Literal("upper_bound"), method_9994, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2487, type_11735), Reflex::Literal("equal_range"), method_9995, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2486, type_11735), Reflex::Literal("equal_range"), method_9996, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RawEvent -------------------------------
static  void operator_11675( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Totem::RawEvent*)o)->operator=)(*(const ::Totem::RawEvent*)arg[0]);
  else   (((::Totem::RawEvent*)o)->operator=)(*(const ::Totem::RawEvent*)arg[0]);
}

static void constructor_11676( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::RawEvent();
  else ::new(mem) ::Totem::RawEvent();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::RawEvent((::Totem::VFATFrameCollection*)arg[0]);
  else ::new(mem) ::Totem::RawEvent((::Totem::VFATFrameCollection*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::RawEvent((::Totem::VFATFrameCollection*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::Totem::RawEvent((::Totem::VFATFrameCollection*)arg[0],
      *(bool*)arg[1]);
  }
}

static void constructor_11677( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::RawEvent(*(const ::Totem::RawEvent*)arg[0]);
  else ::new(mem) ::Totem::RawEvent(*(const ::Totem::RawEvent*)arg[0]);
}

static void destructor_11678(void*, void * o, const std::vector<void*>&, void *) {
(((::Totem::RawEvent*)o)->::Totem::RawEvent::~RawEvent)();
}
static void constructor_x11( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::RawEvent();
  else ::new(mem) ::Totem::RawEvent();
}

static void method_newdel_2987( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Totem::RawEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Totem::RawEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Totem::RawEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Totem::RawEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Totem::RawEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___Totem__RawEvent_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  Totem::VFATFrameCollection* &frames = *(Totem::VFATFrameCollection**)(target + OffsetOf(__shadow__::__Totem__RawEvent, frames));

  if( oldObj ) {}
  //--- User's code ---
     frames = NULL;
    
    
}

//------Dictionary for class RawEvent -------------------------------
void __Totem__RawEvent_db_datamem(Reflex::Class*);
void __Totem__RawEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Totem__RawEvent_datamem_bld(&__Totem__RawEvent_db_datamem);
Reflex::GenreflexMemberBuilder __Totem__RawEvent_funcmem_bld(&__Totem__RawEvent_db_funcmem);
void __Totem__RawEvent_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "Totem::RawEvent";
  rule->fTarget      = "frames";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___Totem__RawEvent_0);
  rule->fCode        = "\n     frames = NULL;\n    \n    ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("Totem::RawEvent"), typeid(::Totem::RawEvent), sizeof(::Totem::RawEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty("ioread", readrules )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17621, type_17622), Reflex::Literal("operator="), operator_11675, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17620, type_1344), Reflex::Literal("RawEvent"), constructor_11676, 0, "_f=0l;_o=true", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17622), Reflex::Literal("RawEvent"), constructor_11677, 0, "orig", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RawEvent"), destructor_11678, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RawEvent"), constructor_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2987, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Totem__RawEvent_datamem_bld);
}

//------Delayed data member builder for class RawEvent -------------------
void __Totem__RawEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_17620, Reflex::Literal("frames"), OffsetOf(__shadow__::__Totem__RawEvent, frames), ::Reflex::PUBLIC | ::Reflex::TRANSIENT)
  .AddDataMember(type_1344, Reflex::Literal("ownsCollection"), OffsetOf(__shadow__::__Totem__RawEvent, ownsCollection), ::Reflex::PUBLIC)
  .AddDataMember(type_276, Reflex::Literal("dataEventNumber"), OffsetOf(__shadow__::__Totem__RawEvent, dataEventNumber), ::Reflex::PUBLIC)
  .AddDataMember(type_276, Reflex::Literal("dataConfNumber"), OffsetOf(__shadow__::__Totem__RawEvent, dataConfNumber), ::Reflex::PUBLIC)
  .AddDataMember(type_1867, Reflex::Literal("timestamp"), OffsetOf(__shadow__::__Totem__RawEvent, timestamp), ::Reflex::PUBLIC)
  .AddDataMember(type_2612, Reflex::Literal("optoRxMetaData"), OffsetOf(__shadow__::__Totem__RawEvent, optoRxMetaData), ::Reflex::PUBLIC)
  .AddDataMember(type_2989, Reflex::Literal("triggerData"), OffsetOf(__shadow__::__Totem__RawEvent, triggerData), ::Reflex::PUBLIC)
  .AddDataMember(type_2611, Reflex::Literal("ldcTimeStamps"), OffsetOf(__shadow__::__Totem__RawEvent, ldcTimeStamps), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RawEvent -------------------
void __Totem__RawEvent_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class VFATFrameCollection -------------------------------
static  void operator_11681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Totem::VFATFrameCollection*)o)->operator=)(*(const ::Totem::VFATFrameCollection*)arg[0]);
  else   (((::Totem::VFATFrameCollection*)o)->operator=)(*(const ::Totem::VFATFrameCollection*)arg[0]);
}

static void destructor_11684(void*, void * o, const std::vector<void*>&, void *) {
(((::Totem::VFATFrameCollection*)o)->::Totem::VFATFrameCollection::~VFATFrameCollection)();
}
static  void method_11685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::Totem::VFATFrameCollection*)o)->GetClassName)());
  else   (((const ::Totem::VFATFrameCollection*)o)->GetClassName)();
}

static  void method_11686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Totem::VFATFrameCollection*)o)->GetFrameByID)(*(unsigned int*)arg[0]));
  else   (((const ::Totem::VFATFrameCollection*)o)->GetFrameByID)(*(unsigned int*)arg[0]);
}

static  void method_11687( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Totem::VFATFrameCollection*)o)->GetFrameByIndex)(*(::Totem::FramePosition*)arg[0]));
  else   (((const ::Totem::VFATFrameCollection*)o)->GetFrameByIndex)(*(::Totem::FramePosition*)arg[0]);
}

static  void method_11688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Totem::VFATFrameCollection*)o)->GetFrameByIndexID)(*(::Totem::FramePosition*)arg[0],
    *(unsigned int*)arg[1]));
  else   (((::Totem::VFATFrameCollection*)o)->GetFrameByIndexID)(*(::Totem::FramePosition*)arg[0],
    *(unsigned int*)arg[1]);
}

static  void method_11689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Totem::VFATFrameCollection*)o)->Size)());
  else   (((const ::Totem::VFATFrameCollection*)o)->Size)();
}

static  void method_11690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::VFATFrameCollection*)o)->Empty)());
  else   (((const ::Totem::VFATFrameCollection*)o)->Empty)();
}

//------Dictionary for class VFATFrameCollection -------------------------------
void __Totem__VFATFrameCollection_db_datamem(Reflex::Class*);
void __Totem__VFATFrameCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Totem__VFATFrameCollection_datamem_bld(&__Totem__VFATFrameCollection_db_datamem);
Reflex::GenreflexMemberBuilder __Totem__VFATFrameCollection_funcmem_bld(&__Totem__VFATFrameCollection_db_funcmem);
void __Totem__VFATFrameCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Totem::VFATFrameCollection"), typeid(::Totem::VFATFrameCollection), sizeof(::Totem::VFATFrameCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddTypedef(type_2494, Reflex::Literal("Totem::VFATFrameCollection::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17633, type_17634), Reflex::Literal("operator="), operator_11681, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~VFATFrameCollection"), destructor_11684, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__Totem__VFATFrameCollection_funcmem_bld);
}

//------Delayed data member builder for class VFATFrameCollection -------------------
void __Totem__VFATFrameCollection_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class VFATFrameCollection -------------------
void __Totem__VFATFrameCollection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2145), Reflex::Literal("GetClassName"), method_11685, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8391, type_284), Reflex::Literal("GetFrameByID"), method_11686, 0, "ID", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8391, type_2993), Reflex::Literal("GetFrameByIndex"), method_11687, 0, "index", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8391, type_2993, type_284), Reflex::Literal("GetFrameByIndexID"), method_11688, 0, "index;ID", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_284), Reflex::Literal("Size"), method_11689, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("Empty"), method_11690, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class TriggerData -------------------------------
static void destructor_11704(void*, void * o, const std::vector<void*>&, void *) {
(((::Totem::TriggerData*)o)->::Totem::TriggerData::~TriggerData)();
}
static  void operator_11705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Totem::TriggerData*)o)->operator=)(*(const ::Totem::TriggerData*)arg[0]);
  else   (((::Totem::TriggerData*)o)->operator=)(*(const ::Totem::TriggerData*)arg[0]);
}

static void constructor_11706( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::TriggerData(*(const ::Totem::TriggerData*)arg[0]);
  else ::new(mem) ::Totem::TriggerData(*(const ::Totem::TriggerData*)arg[0]);
}

static void constructor_11707( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::TriggerData();
  else ::new(mem) ::Totem::TriggerData();
}

static void method_newdel_2989( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Totem::TriggerData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Totem::TriggerData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Totem::TriggerData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Totem::TriggerData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Totem::TriggerData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TriggerData -------------------------------
void __Totem__TriggerData_db_datamem(Reflex::Class*);
void __Totem__TriggerData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Totem__TriggerData_datamem_bld(&__Totem__TriggerData_db_datamem);
Reflex::GenreflexMemberBuilder __Totem__TriggerData_funcmem_bld(&__Totem__TriggerData_db_funcmem);
void __Totem__TriggerData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Totem::TriggerData"), typeid(::Totem::TriggerData), sizeof(::Totem::TriggerData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerData"), destructor_11704, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17635, type_17636), Reflex::Literal("operator="), operator_11705, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17636), Reflex::Literal("TriggerData"), constructor_11706, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerData"), constructor_11707, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2989, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Totem__TriggerData_datamem_bld);
}

//------Delayed data member builder for class TriggerData -------------------
void __Totem__TriggerData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_553, Reflex::Literal("type"), OffsetOf(__shadow__::__Totem__TriggerData, type), ::Reflex::PUBLIC)
  .AddDataMember(type_284, Reflex::Literal("event_num"), OffsetOf(__shadow__::__Totem__TriggerData, event_num), ::Reflex::PUBLIC)
  .AddDataMember(type_284, Reflex::Literal("bunch_num"), OffsetOf(__shadow__::__Totem__TriggerData, bunch_num), ::Reflex::PUBLIC)
  .AddDataMember(type_284, Reflex::Literal("src_id"), OffsetOf(__shadow__::__Totem__TriggerData, src_id), ::Reflex::PUBLIC)
  .AddDataMember(type_284, Reflex::Literal("orbit_num"), OffsetOf(__shadow__::__Totem__TriggerData, orbit_num), ::Reflex::PUBLIC)
  .AddDataMember(type_553, Reflex::Literal("revision_num"), OffsetOf(__shadow__::__Totem__TriggerData, revision_num), ::Reflex::PUBLIC)
  .AddDataMember(type_284, Reflex::Literal("run_num"), OffsetOf(__shadow__::__Totem__TriggerData, run_num), ::Reflex::PUBLIC)
  .AddDataMember(type_284, Reflex::Literal("trigger_num"), OffsetOf(__shadow__::__Totem__TriggerData, trigger_num), ::Reflex::PUBLIC)
  .AddDataMember(type_284, Reflex::Literal("inhibited_triggers_num"), OffsetOf(__shadow__::__Totem__TriggerData, inhibited_triggers_num), ::Reflex::PUBLIC)
  .AddDataMember(type_284, Reflex::Literal("input_status_bits"), OffsetOf(__shadow__::__Totem__TriggerData, input_status_bits), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TriggerData -------------------
void __Totem__TriggerData_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class OptoRxMetaData -------------------------------
static void destructor_11710(void*, void * o, const std::vector<void*>&, void *) {
(((::Totem::OptoRxMetaData*)o)->::Totem::OptoRxMetaData::~OptoRxMetaData)();
}
static  void operator_11711( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Totem::OptoRxMetaData*)o)->operator=)(*(const ::Totem::OptoRxMetaData*)arg[0]);
  else   (((::Totem::OptoRxMetaData*)o)->operator=)(*(const ::Totem::OptoRxMetaData*)arg[0]);
}

static void constructor_11712( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::OptoRxMetaData(*(const ::Totem::OptoRxMetaData*)arg[0]);
  else ::new(mem) ::Totem::OptoRxMetaData(*(const ::Totem::OptoRxMetaData*)arg[0]);
}

static void constructor_11713( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::OptoRxMetaData();
  else ::new(mem) ::Totem::OptoRxMetaData();
}

static void method_newdel_2990( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Totem::OptoRxMetaData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Totem::OptoRxMetaData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Totem::OptoRxMetaData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Totem::OptoRxMetaData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Totem::OptoRxMetaData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class OptoRxMetaData -------------------------------
void __Totem__OptoRxMetaData_db_datamem(Reflex::Class*);
void __Totem__OptoRxMetaData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Totem__OptoRxMetaData_datamem_bld(&__Totem__OptoRxMetaData_db_datamem);
Reflex::GenreflexMemberBuilder __Totem__OptoRxMetaData_funcmem_bld(&__Totem__OptoRxMetaData_db_funcmem);
void __Totem__OptoRxMetaData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Totem::OptoRxMetaData"), typeid(::Totem::OptoRxMetaData), sizeof(::Totem::OptoRxMetaData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OptoRxMetaData"), destructor_11710, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17411, type_17412), Reflex::Literal("operator="), operator_11711, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17412), Reflex::Literal("OptoRxMetaData"), constructor_11712, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OptoRxMetaData"), constructor_11713, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2990, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Totem__OptoRxMetaData_datamem_bld);
}

//------Delayed data member builder for class OptoRxMetaData -------------------
void __Totem__OptoRxMetaData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_284, Reflex::Literal("BX"), OffsetOf(__shadow__::__Totem__OptoRxMetaData, BX), ::Reflex::PUBLIC)
  .AddDataMember(type_284, Reflex::Literal("LV1"), OffsetOf(__shadow__::__Totem__OptoRxMetaData, LV1), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class OptoRxMetaData -------------------
void __Totem__OptoRxMetaData_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class OptoRxVFATFrameCollection -------------------------------
static  void operator_11719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Totem::OptoRxVFATFrameCollection*)o)->operator=)(*(const ::Totem::OptoRxVFATFrameCollection*)arg[0]);
  else   (((::Totem::OptoRxVFATFrameCollection*)o)->operator=)(*(const ::Totem::OptoRxVFATFrameCollection*)arg[0]);
}

static void constructor_11720( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::OptoRxVFATFrameCollection(*(const ::Totem::OptoRxVFATFrameCollection*)arg[0]);
  else ::new(mem) ::Totem::OptoRxVFATFrameCollection(*(const ::Totem::OptoRxVFATFrameCollection*)arg[0]);
}

static void constructor_11724( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::OptoRxVFATFrameCollection();
  else ::new(mem) ::Totem::OptoRxVFATFrameCollection();
}

static void destructor_11725(void*, void * o, const std::vector<void*>&, void *) {
(((::Totem::OptoRxVFATFrameCollection*)o)->::Totem::OptoRxVFATFrameCollection::~OptoRxVFATFrameCollection)();
}
static  void method_11726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::Totem::OptoRxVFATFrameCollection*)o)->GetClassName)());
  else   (((const ::Totem::OptoRxVFATFrameCollection*)o)->GetClassName)();
}

static  void method_11727( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Totem::OptoRxVFATFrameCollection*)o)->GetFrameByID)(*(unsigned int*)arg[0]));
  else   (((const ::Totem::OptoRxVFATFrameCollection*)o)->GetFrameByID)(*(unsigned int*)arg[0]);
}

static  void method_11728( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Totem::OptoRxVFATFrameCollection*)o)->GetFrameByIndex)(*(::Totem::FramePosition*)arg[0]));
  else   (((const ::Totem::OptoRxVFATFrameCollection*)o)->GetFrameByIndex)(*(::Totem::FramePosition*)arg[0]);
}

static  void method_11729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Totem::OptoRxVFATFrameCollection*)o)->Size)());
  else   (((const ::Totem::OptoRxVFATFrameCollection*)o)->Size)();
}

static  void method_11730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::OptoRxVFATFrameCollection*)o)->Empty)());
  else   (((const ::Totem::OptoRxVFATFrameCollection*)o)->Empty)();
}

static  void method_11731( void*, void* o, const std::vector<void*>&, void*)
{
  (((::Totem::OptoRxVFATFrameCollection*)o)->Clear)();
}

static  void method_11732( void*, void* o, const std::vector<void*>&, void*)
{
  (((::Totem::OptoRxVFATFrameCollection*)o)->Invalidate)();
}

static  void method_11733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxVFATFrameCollection::OptoRxBlock*> >)((((::Totem::OptoRxVFATFrameCollection*)o)->InsertOptoRxBlock)(*(unsigned int*)arg[0]));
  else   (((::Totem::OptoRxVFATFrameCollection*)o)->InsertOptoRxBlock)(*(unsigned int*)arg[0]);
}

static  void method_11734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Totem::OptoRxVFATFrameCollection*)o)->ValidateGOHBlock)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxVFATFrameCollection::OptoRxBlock*> >*)arg[0],
    *(unsigned int*)arg[1]));
  else   (((::Totem::OptoRxVFATFrameCollection*)o)->ValidateGOHBlock)(*(const ::std::_Rb_tree_iterator<std::pair<const unsigned int,Totem::OptoRxVFATFrameCollection::OptoRxBlock*> >*)arg[0],
    *(unsigned int*)arg[1]);
}

static void method_newdel_2991( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Totem::OptoRxVFATFrameCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Totem::OptoRxVFATFrameCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Totem::OptoRxVFATFrameCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Totem::OptoRxVFATFrameCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Totem::OptoRxVFATFrameCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Totem::VFATFrameCollection")), ::Reflex::BaseOffset< ::Totem::OptoRxVFATFrameCollection,::Totem::VFATFrameCollection >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class OptoRxVFATFrameCollection -------------------------------
void __Totem__OptoRxVFATFrameCollection_db_datamem(Reflex::Class*);
void __Totem__OptoRxVFATFrameCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Totem__OptoRxVFATFrameCollection_datamem_bld(&__Totem__OptoRxVFATFrameCollection_db_datamem);
Reflex::GenreflexMemberBuilder __Totem__OptoRxVFATFrameCollection_funcmem_bld(&__Totem__OptoRxVFATFrameCollection_db_funcmem);
void __Totem__OptoRxVFATFrameCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Totem::OptoRxVFATFrameCollection"), typeid(::Totem::OptoRxVFATFrameCollection), sizeof(::Totem::OptoRxVFATFrameCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_2988, ::Reflex::BaseOffset< ::Totem::OptoRxVFATFrameCollection, ::Totem::VFATFrameCollection >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2616, Reflex::Literal("Totem::OptoRxVFATFrameCollection::MapType"))
  .AddTypedef(type_2567, Reflex::Literal("Totem::OptoRxVFATFrameCollection::IteratorType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17651, type_17652), Reflex::Literal("operator="), operator_11719, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17652), Reflex::Literal("OptoRxVFATFrameCollection"), constructor_11720, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OptoRxVFATFrameCollection"), constructor_11724, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OptoRxVFATFrameCollection"), destructor_11725, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2991, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Totem__OptoRxVFATFrameCollection_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Totem__OptoRxVFATFrameCollection_funcmem_bld);
}

//------Delayed data member builder for class OptoRxVFATFrameCollection -------------------
void __Totem__OptoRxVFATFrameCollection_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2616, Reflex::Literal("data"), OffsetOf(__shadow__::__Totem__OptoRxVFATFrameCollection, data), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class OptoRxVFATFrameCollection -------------------
void __Totem__OptoRxVFATFrameCollection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2145), Reflex::Literal("GetClassName"), method_11726, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8391, type_284), Reflex::Literal("GetFrameByID"), method_11727, 0, "ID", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8391, type_2993), Reflex::Literal("GetFrameByIndex"), method_11728, 0, "index", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_284), Reflex::Literal("Size"), method_11729, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("Empty"), method_11730, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("Clear"), method_11731, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("Invalidate"), method_11732, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2567, type_284), Reflex::Literal("InsertOptoRxBlock"), method_11733, 0, "OptoRxId", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17653, type_17654, type_284), Reflex::Literal("ValidateGOHBlock"), method_11734, 0, "it;GOHId", ::Reflex::PUBLIC);
}
//------Stub functions for class FramePosition -------------------------------
static  void operator_11745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Totem::FramePosition*)o)->operator=)(*(const ::Totem::FramePosition*)arg[0]);
  else   (((::Totem::FramePosition*)o)->operator=)(*(const ::Totem::FramePosition*)arg[0]);
}

static void constructor_11746( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::FramePosition(*(const ::Totem::FramePosition*)arg[0]);
  else ::new(mem) ::Totem::FramePosition(*(const ::Totem::FramePosition*)arg[0]);
}

static void constructor_11747( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::FramePosition(*(unsigned short*)arg[0],
      *(unsigned short*)arg[1],
      *(unsigned short*)arg[2],
      *(unsigned short*)arg[3],
      *(unsigned short*)arg[4]);
  else ::new(mem) ::Totem::FramePosition(*(unsigned short*)arg[0],
      *(unsigned short*)arg[1],
      *(unsigned short*)arg[2],
      *(unsigned short*)arg[3],
      *(unsigned short*)arg[4]);
}

static void constructor_11748( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::FramePosition();
  else ::new(mem) ::Totem::FramePosition();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::FramePosition(*(unsigned int*)arg[0]);
  else ::new(mem) ::Totem::FramePosition(*(unsigned int*)arg[0]);
  }
}

static void destructor_11749(void*, void * o, const std::vector<void*>&, void *) {
(((::Totem::FramePosition*)o)->::Totem::FramePosition::~FramePosition)();
}
static  void method_11750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::Totem::FramePosition*)o)->GetSubSystemId)());
  else   (((const ::Totem::FramePosition*)o)->GetSubSystemId)();
}

static  void method_11751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::Totem::FramePosition*)o)->GetTOTFEDId)());
  else   (((const ::Totem::FramePosition*)o)->GetTOTFEDId)();
}

static  void method_11752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::Totem::FramePosition*)o)->GetOptoRxId)());
  else   (((const ::Totem::FramePosition*)o)->GetOptoRxId)();
}

static  void method_11753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::Totem::FramePosition*)o)->GetGOHId)());
  else   (((const ::Totem::FramePosition*)o)->GetGOHId)();
}

static  void method_11754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::Totem::FramePosition*)o)->GetIdxInFiber)());
  else   (((const ::Totem::FramePosition*)o)->GetIdxInFiber)();
}

static  void method_11755( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Totem::FramePosition*)o)->SetSubSystemId)(*(unsigned short*)arg[0]);
}

static  void method_11756( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Totem::FramePosition*)o)->SetTOTFEDId)(*(unsigned short*)arg[0]);
}

static  void method_11757( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Totem::FramePosition*)o)->SetOptoRxId)(*(unsigned short*)arg[0]);
}

static  void method_11758( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Totem::FramePosition*)o)->SetGOHId)(*(unsigned short*)arg[0]);
}

static  void method_11759( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Totem::FramePosition*)o)->SetIdxInFiber)(*(unsigned short*)arg[0]);
}

static  void method_11760( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Totem::FramePosition*)o)->SetAllIDs)(*(unsigned short*)arg[0],
    *(unsigned short*)arg[1],
    *(unsigned short*)arg[2],
    *(unsigned short*)arg[3],
    *(unsigned short*)arg[4]);
}

static  void method_11761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Totem::FramePosition*)o)->GetRawPosition)());
  else   (((const ::Totem::FramePosition*)o)->GetRawPosition)();
}

static  void operator_11762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::FramePosition*)o)->operator<)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::Totem::FramePosition*)o)->operator<)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void operator_11763( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::FramePosition*)o)->operator==)(*(const ::Totem::FramePosition*)arg[0]));
  else   (((const ::Totem::FramePosition*)o)->operator==)(*(const ::Totem::FramePosition*)arg[0]);
}

static  void method_11764( void*, void* o, const std::vector<void*>&, void*)
{
  (((::Totem::FramePosition*)o)->PrintXML)();
}

static  void method_11765( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned char)((((::Totem::FramePosition*)o)->SetXMLAttribute)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(unsigned char*)arg[2]));
  else   (((::Totem::FramePosition*)o)->SetXMLAttribute)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1],
    *(unsigned char*)arg[2]);
}

static  void method_11766( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::Totem::FramePosition*)o)->CheckXMLAttributeFlag)(*(unsigned char*)arg[0]));
  else   (((::Totem::FramePosition*)o)->CheckXMLAttributeFlag)(*(unsigned char*)arg[0]);
}

static  void method_11767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::Totem::FramePosition*)o)->GetFullOptoRxId)());
  else   (((const ::Totem::FramePosition*)o)->GetFullOptoRxId)();
}

static void constructor_x17( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::FramePosition();
  else ::new(mem) ::Totem::FramePosition();
}

static void method_newdel_2993( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Totem::FramePosition >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Totem::FramePosition >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Totem::FramePosition >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Totem::FramePosition >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Totem::FramePosition >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FramePosition -------------------------------
void __Totem__FramePosition_db_datamem(Reflex::Class*);
void __Totem__FramePosition_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Totem__FramePosition_datamem_bld(&__Totem__FramePosition_db_datamem);
Reflex::GenreflexMemberBuilder __Totem__FramePosition_funcmem_bld(&__Totem__FramePosition_db_funcmem);
void __Totem__FramePosition_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Totem::FramePosition"), typeid(::Totem::FramePosition), sizeof(::Totem::FramePosition), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddDataMember(type_2145c, Reflex::Literal("tagSSNone"), (size_t)&Totem::FramePosition::tagSSNone, ::Reflex::PUBLIC | ::Reflex::STATIC | Reflex::STATIC | Reflex::CONST)
  .AddDataMember(type_2145c, Reflex::Literal("tagSSTrigger"), (size_t)&Totem::FramePosition::tagSSTrigger, ::Reflex::PUBLIC | ::Reflex::STATIC | Reflex::STATIC | Reflex::CONST)
  .AddDataMember(type_2145c, Reflex::Literal("tagSST1"), (size_t)&Totem::FramePosition::tagSST1, ::Reflex::PUBLIC | ::Reflex::STATIC | Reflex::STATIC | Reflex::CONST)
  .AddDataMember(type_2145c, Reflex::Literal("tagSST2"), (size_t)&Totem::FramePosition::tagSST2, ::Reflex::PUBLIC | ::Reflex::STATIC | Reflex::STATIC | Reflex::CONST)
  .AddDataMember(type_2145c, Reflex::Literal("tagSSRP"), (size_t)&Totem::FramePosition::tagSSRP, ::Reflex::PUBLIC | ::Reflex::STATIC | Reflex::STATIC | Reflex::CONST)
  .AddDataMember(type_2145c, Reflex::Literal("tagSSTTC"), (size_t)&Totem::FramePosition::tagSSTTC, ::Reflex::PUBLIC | ::Reflex::STATIC | Reflex::STATIC | Reflex::CONST)
  .AddDataMember(type_2145c, Reflex::Literal("tagSSFEC"), (size_t)&Totem::FramePosition::tagSSFEC, ::Reflex::PUBLIC | ::Reflex::STATIC | Reflex::STATIC | Reflex::CONST)
  .AddEnum(Reflex::Literal("Totem::FramePosition::SubSystemType"), Reflex::Literal("ssNone=0;ssT1=1;ssT2=2;ssRP=3;ssTrigger=4;ssTTC=5;ssFEC=6"), &typeid(Totem::FramePosition::SubSystemType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17655, type_11735), Reflex::Literal("operator="), operator_11745, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11735), Reflex::Literal("FramePosition"), constructor_11746, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_133, type_133, type_133, type_133, type_133), Reflex::Literal("FramePosition"), constructor_11747, 0, "SubSystemId;TOTFEDId;OptoRxId;GOHId;IdxInFiber", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_284), Reflex::Literal("FramePosition"), constructor_11748, 0, "pos=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FramePosition"), destructor_11749, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FramePosition"), constructor_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2993, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Totem__FramePosition_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Totem__FramePosition_funcmem_bld);
}

//------Delayed data member builder for class FramePosition -------------------
void __Totem__FramePosition_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_284, Reflex::Literal("rawPosition"), OffsetOf(__shadow__::__Totem__FramePosition, rawPosition), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class FramePosition -------------------
void __Totem__FramePosition_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("GetSubSystemId"), method_11750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("GetTOTFEDId"), method_11751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("GetOptoRxId"), method_11752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("GetGOHId"), method_11753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("GetIdxInFiber"), method_11754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_133), Reflex::Literal("SetSubSystemId"), method_11755, 0, "v", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_133), Reflex::Literal("SetTOTFEDId"), method_11756, 0, "v", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_133), Reflex::Literal("SetOptoRxId"), method_11757, 0, "v", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_133), Reflex::Literal("SetGOHId"), method_11758, 0, "v", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_133), Reflex::Literal("SetIdxInFiber"), method_11759, 0, "v", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_133, type_133, type_133, type_133, type_133), Reflex::Literal("SetAllIDs"), method_11760, 0, "SubSystemId;TOTFEDId;OptoRxId;GOHId;IdxInFiber", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_284), Reflex::Literal("GetRawPosition"), method_11761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344, type_11735), Reflex::Literal("operator<"), operator_11762, 0, "pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344, type_11735), Reflex::Literal("operator=="), operator_11763, 0, "pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("PrintXML"), method_11764, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_553, type_9785, type_9785, type_7983), Reflex::Literal("SetXMLAttribute"), method_11765, 0, "attribute;value;flag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344, type_553), Reflex::Literal("CheckXMLAttributeFlag"), method_11766, 0, "flag", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_133), Reflex::Literal("GetFullOptoRxId"), method_11767, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SimpleVFATFrameCollection -------------------------------
static  void operator_11795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Totem::SimpleVFATFrameCollection*)o)->operator=)(*(const ::Totem::SimpleVFATFrameCollection*)arg[0]);
  else   (((::Totem::SimpleVFATFrameCollection*)o)->operator=)(*(const ::Totem::SimpleVFATFrameCollection*)arg[0]);
}

static void constructor_11796( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::SimpleVFATFrameCollection(*(const ::Totem::SimpleVFATFrameCollection*)arg[0]);
  else ::new(mem) ::Totem::SimpleVFATFrameCollection(*(const ::Totem::SimpleVFATFrameCollection*)arg[0]);
}

static void constructor_11800( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Totem::SimpleVFATFrameCollection();
  else ::new(mem) ::Totem::SimpleVFATFrameCollection();
}

static void destructor_11801(void*, void * o, const std::vector<void*>&, void *) {
(((::Totem::SimpleVFATFrameCollection*)o)->::Totem::SimpleVFATFrameCollection::~SimpleVFATFrameCollection)();
}
static  void method_11802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::Totem::SimpleVFATFrameCollection*)o)->GetClassName)());
  else   (((const ::Totem::SimpleVFATFrameCollection*)o)->GetClassName)();
}

static  void method_11803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Totem::SimpleVFATFrameCollection*)o)->GetFrameByID)(*(unsigned int*)arg[0]));
  else   (((const ::Totem::SimpleVFATFrameCollection*)o)->GetFrameByID)(*(unsigned int*)arg[0]);
}

static  void method_11804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Totem::SimpleVFATFrameCollection*)o)->GetFrameByIndex)(*(::Totem::FramePosition*)arg[0]));
  else   (((const ::Totem::SimpleVFATFrameCollection*)o)->GetFrameByIndex)(*(::Totem::FramePosition*)arg[0]);
}

static  void method_11805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::Totem::SimpleVFATFrameCollection*)o)->Size)());
  else   (((const ::Totem::SimpleVFATFrameCollection*)o)->Size)();
}

static  void method_11806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::Totem::SimpleVFATFrameCollection*)o)->Empty)());
  else   (((const ::Totem::SimpleVFATFrameCollection*)o)->Empty)();
}

static  void method_11807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Totem::SimpleVFATFrameCollection*)o)->Insert)(*(const ::Totem::FramePosition*)arg[0],
    *(const ::Totem::VFATFrame*)arg[1]);
}

static  void method_11808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Totem::SimpleVFATFrameCollection*)o)->InsertEmptyFrame)(*(::Totem::FramePosition*)arg[0]));
  else   (((::Totem::SimpleVFATFrameCollection*)o)->InsertEmptyFrame)(*(::Totem::FramePosition*)arg[0]);
}

static  void method_11809( void*, void* o, const std::vector<void*>&, void*)
{
  (((::Totem::SimpleVFATFrameCollection*)o)->Clear)();
}

static void method_newdel_2995( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Totem::SimpleVFATFrameCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Totem::SimpleVFATFrameCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Totem::SimpleVFATFrameCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Totem::SimpleVFATFrameCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Totem::SimpleVFATFrameCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("Totem::VFATFrameCollection")), ::Reflex::BaseOffset< ::Totem::SimpleVFATFrameCollection,::Totem::VFATFrameCollection >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SimpleVFATFrameCollection -------------------------------
void __Totem__SimpleVFATFrameCollection_db_datamem(Reflex::Class*);
void __Totem__SimpleVFATFrameCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Totem__SimpleVFATFrameCollection_datamem_bld(&__Totem__SimpleVFATFrameCollection_db_datamem);
Reflex::GenreflexMemberBuilder __Totem__SimpleVFATFrameCollection_funcmem_bld(&__Totem__SimpleVFATFrameCollection_db_funcmem);
void __Totem__SimpleVFATFrameCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Totem::SimpleVFATFrameCollection"), typeid(::Totem::SimpleVFATFrameCollection), sizeof(::Totem::SimpleVFATFrameCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_2988, ::Reflex::BaseOffset< ::Totem::SimpleVFATFrameCollection, ::Totem::VFATFrameCollection >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2613, Reflex::Literal("Totem::SimpleVFATFrameCollection::MapType"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17657, type_17658), Reflex::Literal("operator="), operator_11795, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17658), Reflex::Literal("SimpleVFATFrameCollection"), constructor_11796, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SimpleVFATFrameCollection"), constructor_11800, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SimpleVFATFrameCollection"), destructor_11801, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2995, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Totem__SimpleVFATFrameCollection_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Totem__SimpleVFATFrameCollection_funcmem_bld);
}

//------Delayed data member builder for class SimpleVFATFrameCollection -------------------
void __Totem__SimpleVFATFrameCollection_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2613, Reflex::Literal("data"), OffsetOf(__shadow__::__Totem__SimpleVFATFrameCollection, data), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class SimpleVFATFrameCollection -------------------
void __Totem__SimpleVFATFrameCollection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2145), Reflex::Literal("GetClassName"), method_11802, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8391, type_284), Reflex::Literal("GetFrameByID"), method_11803, 0, "ID", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8391, type_2993), Reflex::Literal("GetFrameByIndex"), method_11804, 0, "index", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_284), Reflex::Literal("Size"), method_11805, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("Empty"), method_11806, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_11735, type_8601), Reflex::Literal("Insert"), method_11807, 0, "index;frame", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5881, type_2993), Reflex::Literal("InsertEmptyFrame"), method_11808, 0, "index", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574), Reflex::Literal("Clear"), method_11809, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<Totem::OptoRxVFATFrameCollection> -------------------------------
static void constructor_12994( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>();
  else ::new(mem) ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>();
}

static void constructor_12995( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>(*(::std::auto_ptr<Totem::OptoRxVFATFrameCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>(*(::std::auto_ptr<Totem::OptoRxVFATFrameCollection>*)arg[0]);
}

static void destructor_12996(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->::edm::Wrapper<Totem::OptoRxVFATFrameCollection>::~Wrapper)();
}
static  void method_12997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->product)();
}

static  void operator_12998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->operator->)();
}

static  void method_12999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->productTypeInfo)();
}

static  void method_13000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->typeInfo)();
}

static void constructor_13001( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>((::Totem::OptoRxVFATFrameCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>((::Totem::OptoRxVFATFrameCollection*)arg[0]);
}

static  void method_13002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->getInterface)();
}

static  void method_13003( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13004( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13005( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->dynamicTypeInfo)();
}

static  void method_13007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->isPresent)();
}

static  void method_13008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<Totem::OptoRxVFATFrameCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3368( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::OptoRxVFATFrameCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::OptoRxVFATFrameCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::OptoRxVFATFrameCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::OptoRxVFATFrameCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::OptoRxVFATFrameCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<Totem::OptoRxVFATFrameCollection> -------------------------------
void __edm__Wrapper_Totem__OptoRxVFATFrameCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_Totem__OptoRxVFATFrameCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_Totem__OptoRxVFATFrameCollection__datamem_bld(&__edm__Wrapper_Totem__OptoRxVFATFrameCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_Totem__OptoRxVFATFrameCollection__funcmem_bld(&__edm__Wrapper_Totem__OptoRxVFATFrameCollection__db_funcmem);
void __edm__Wrapper_Totem__OptoRxVFATFrameCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<Totem::OptoRxVFATFrameCollection>"), typeid(::edm::Wrapper<Totem::OptoRxVFATFrameCollection>), sizeof(::edm::Wrapper<Totem::OptoRxVFATFrameCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2991, Reflex::Literal("edm::Wrapper<Totem::OptoRxVFATFrameCollection>::value_type"))
  .AddTypedef(type_2991, Reflex::Literal("edm::Wrapper<Totem::OptoRxVFATFrameCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12994, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2345), Reflex::Literal("Wrapper"), constructor_12995, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12996, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19202), Reflex::Literal("Wrapper"), constructor_13001, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3368, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_Totem__OptoRxVFATFrameCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_Totem__OptoRxVFATFrameCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<Totem::OptoRxVFATFrameCollection> -------------------
void __edm__Wrapper_Totem__OptoRxVFATFrameCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1344, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_Totem__OptoRxVFATFrameCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2991, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_Totem__OptoRxVFATFrameCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<Totem::OptoRxVFATFrameCollection> -------------------
void __edm__Wrapper_Totem__OptoRxVFATFrameCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19201), Reflex::Literal("product"), method_12997, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19201), Reflex::Literal("operator->"), operator_12998, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("productTypeInfo"), method_12999, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("typeInfo"), method_13000, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19203), Reflex::Literal("getInterface"), method_13002, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_13083, type_17291, type_19129), Reflex::Literal("fillView"), method_13003, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_11823, type_276, type_6602), Reflex::Literal("setPtr"), method_13004, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_11823, type_17292, type_17291), Reflex::Literal("fillPtrVector"), method_13005, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("dynamicTypeInfo"), method_13006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("isPresent"), method_13007, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("dynamicTypeInfo_"), method_13008, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<Totem::SimpleVFATFrameCollection> -------------------------------
static void constructor_13015( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<Totem::SimpleVFATFrameCollection>();
  else ::new(mem) ::edm::Wrapper<Totem::SimpleVFATFrameCollection>();
}

static void constructor_13016( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<Totem::SimpleVFATFrameCollection>(*(::std::auto_ptr<Totem::SimpleVFATFrameCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<Totem::SimpleVFATFrameCollection>(*(::std::auto_ptr<Totem::SimpleVFATFrameCollection>*)arg[0]);
}

static void destructor_13017(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->::edm::Wrapper<Totem::SimpleVFATFrameCollection>::~Wrapper)();
}
static  void method_13018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->product)();
}

static  void operator_13019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->operator->)();
}

static  void method_13020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->productTypeInfo)();
}

static  void method_13021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->typeInfo)();
}

static void constructor_13022( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<Totem::SimpleVFATFrameCollection>((::Totem::SimpleVFATFrameCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<Totem::SimpleVFATFrameCollection>((::Totem::SimpleVFATFrameCollection*)arg[0]);
}

static  void method_13023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->getInterface)();
}

static  void method_13024( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13025( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13026( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->dynamicTypeInfo)();
}

static  void method_13028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->isPresent)();
}

static  void method_13029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<Totem::SimpleVFATFrameCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3369( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::SimpleVFATFrameCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::SimpleVFATFrameCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::SimpleVFATFrameCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::SimpleVFATFrameCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::SimpleVFATFrameCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<Totem::SimpleVFATFrameCollection> -------------------------------
void __edm__Wrapper_Totem__SimpleVFATFrameCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_Totem__SimpleVFATFrameCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_Totem__SimpleVFATFrameCollection__datamem_bld(&__edm__Wrapper_Totem__SimpleVFATFrameCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_Totem__SimpleVFATFrameCollection__funcmem_bld(&__edm__Wrapper_Totem__SimpleVFATFrameCollection__db_funcmem);
void __edm__Wrapper_Totem__SimpleVFATFrameCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<Totem::SimpleVFATFrameCollection>"), typeid(::edm::Wrapper<Totem::SimpleVFATFrameCollection>), sizeof(::edm::Wrapper<Totem::SimpleVFATFrameCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2995, Reflex::Literal("edm::Wrapper<Totem::SimpleVFATFrameCollection>::value_type"))
  .AddTypedef(type_2995, Reflex::Literal("edm::Wrapper<Totem::SimpleVFATFrameCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13015, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2346), Reflex::Literal("Wrapper"), constructor_13016, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13017, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19207), Reflex::Literal("Wrapper"), constructor_13022, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3369, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_Totem__SimpleVFATFrameCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_Totem__SimpleVFATFrameCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<Totem::SimpleVFATFrameCollection> -------------------
void __edm__Wrapper_Totem__SimpleVFATFrameCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1344, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_Totem__SimpleVFATFrameCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2995, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_Totem__SimpleVFATFrameCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<Totem::SimpleVFATFrameCollection> -------------------
void __edm__Wrapper_Totem__SimpleVFATFrameCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19206), Reflex::Literal("product"), method_13018, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19206), Reflex::Literal("operator->"), operator_13019, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("productTypeInfo"), method_13020, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("typeInfo"), method_13021, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19208), Reflex::Literal("getInterface"), method_13023, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_13083, type_17291, type_19129), Reflex::Literal("fillView"), method_13024, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_11823, type_276, type_6602), Reflex::Literal("setPtr"), method_13025, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_11823, type_17292, type_17291), Reflex::Literal("fillPtrVector"), method_13026, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("dynamicTypeInfo"), method_13027, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("isPresent"), method_13028, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("dynamicTypeInfo_"), method_13029, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<Totem::RawEvent> -------------------------------
static void constructor_13036( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<Totem::RawEvent>();
  else ::new(mem) ::edm::Wrapper<Totem::RawEvent>();
}

static void constructor_13037( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<Totem::RawEvent>(*(::std::auto_ptr<Totem::RawEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<Totem::RawEvent>(*(::std::auto_ptr<Totem::RawEvent>*)arg[0]);
}

static void destructor_13038(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<Totem::RawEvent>*)o)->::edm::Wrapper<Totem::RawEvent>::~Wrapper)();
}
static  void method_13039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<Totem::RawEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<Totem::RawEvent>*)o)->product)();
}

static  void operator_13040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<Totem::RawEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<Totem::RawEvent>*)o)->operator->)();
}

static  void method_13041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<Totem::RawEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<Totem::RawEvent>*)o)->productTypeInfo)();
}

static  void method_13042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<Totem::RawEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<Totem::RawEvent>*)o)->typeInfo)();
}

static void constructor_13043( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<Totem::RawEvent>((::Totem::RawEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<Totem::RawEvent>((::Totem::RawEvent*)arg[0]);
}

static  void method_13044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<Totem::RawEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<Totem::RawEvent>*)o)->getInterface)();
}

static  void method_13045( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<Totem::RawEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13046( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<Totem::RawEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13047( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<Totem::RawEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<Totem::RawEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<Totem::RawEvent>*)o)->dynamicTypeInfo)();
}

static  void method_13049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<Totem::RawEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<Totem::RawEvent>*)o)->isPresent)();
}

static  void method_13050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<Totem::RawEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<Totem::RawEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3370( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::RawEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::RawEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::RawEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::RawEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<Totem::RawEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<Totem::RawEvent> -------------------------------
void __edm__Wrapper_Totem__RawEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_Totem__RawEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_Totem__RawEvent__datamem_bld(&__edm__Wrapper_Totem__RawEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_Totem__RawEvent__funcmem_bld(&__edm__Wrapper_Totem__RawEvent__db_funcmem);
void __edm__Wrapper_Totem__RawEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<Totem::RawEvent>"), typeid(::edm::Wrapper<Totem::RawEvent>), sizeof(::edm::Wrapper<Totem::RawEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2987, Reflex::Literal("edm::Wrapper<Totem::RawEvent>::value_type"))
  .AddTypedef(type_2987, Reflex::Literal("edm::Wrapper<Totem::RawEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13036, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2347), Reflex::Literal("Wrapper"), constructor_13037, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13038, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19212), Reflex::Literal("Wrapper"), constructor_13043, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3370, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_Totem__RawEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_Totem__RawEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<Totem::RawEvent> -------------------
void __edm__Wrapper_Totem__RawEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1344, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_Totem__RawEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2987, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_Totem__RawEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<Totem::RawEvent> -------------------
void __edm__Wrapper_Totem__RawEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19211), Reflex::Literal("product"), method_13039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19211), Reflex::Literal("operator->"), operator_13040, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("productTypeInfo"), method_13041, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("typeInfo"), method_13042, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19213), Reflex::Literal("getInterface"), method_13044, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_13083, type_17291, type_19129), Reflex::Literal("fillView"), method_13045, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_11823, type_276, type_6602), Reflex::Literal("setPtr"), method_13046, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_574, type_11823, type_17292, type_17291), Reflex::Literal("fillPtrVector"), method_13047, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("dynamicTypeInfo"), method_13048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1344), Reflex::Literal("isPresent"), method_13049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11823), Reflex::Literal("dynamicTypeInfo_"), method_13050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __Totem__VFATFrame_dict(); 
      __std__vector_Totem__VFATFrame__dict(); 
      __std__map_unsignedsint_long__dict(); 
      __std__map_unsignedsint_Totem__OptoRxMetaData__dict(); 
      __std__map_Totem__FramePosition_Totem__VFATFrame__dict(); 
      __Totem__RawEvent_dict(); 
      __Totem__VFATFrameCollection_dict(); 
      __Totem__TriggerData_dict(); 
      __Totem__OptoRxMetaData_dict(); 
      __Totem__OptoRxVFATFrameCollection_dict(); 
      __Totem__FramePosition_dict(); 
      __Totem__SimpleVFATFrameCollection_dict(); 
      __edm__Wrapper_Totem__OptoRxVFATFrameCollection__dict(); 
      __edm__Wrapper_Totem__SimpleVFATFrameCollection__dict(); 
      __edm__Wrapper_Totem__RawEvent__dict(); 
    }
    ~Dictionaries() {
      type_2994.Unload(); // class Totem::VFATFrame 
      type_2516.Unload(); // class std::vector<Totem::VFATFrame> 
      type_2611.Unload(); // class std::map<unsigned int,long> 
      type_2612.Unload(); // class std::map<unsigned int,Totem::OptoRxMetaData> 
      type_2613.Unload(); // class std::map<Totem::FramePosition,Totem::VFATFrame> 
      type_2987.Unload(); // class Totem::RawEvent 
      type_2988.Unload(); // class Totem::VFATFrameCollection 
      type_2989.Unload(); // class Totem::TriggerData 
      type_2990.Unload(); // class Totem::OptoRxMetaData 
      type_2991.Unload(); // class Totem::OptoRxVFATFrameCollection 
      type_2993.Unload(); // class Totem::FramePosition 
      type_2995.Unload(); // class Totem::SimpleVFATFrameCollection 
      type_3368.Unload(); // class edm::Wrapper<Totem::OptoRxVFATFrameCollection> 
      type_3369.Unload(); // class edm::Wrapper<Totem::SimpleVFATFrameCollection> 
      type_3370.Unload(); // class edm::Wrapper<Totem::RawEvent> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
