// Generated at Tue Jul 12 00:33:22 2016. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20140124-0/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20140124-0/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20140124-0/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='999999' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20140124-0/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-redhat-linux-gnu" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/x86_64-redhat-linux-gnu/4.8.1/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc6_amd64_gcc481/external/gcc/4.8.1/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc6_amd64_gcc481/external/gccxml/0.9.0-20140124-0/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/TotemAnalysis/TotemAnalysisEvent/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_68 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_11 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_580 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_252 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1362 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_99 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_198 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_1964 = ::Reflex::TypeBuilder(Reflex::Literal("TotemRPEvent"));
  ::Reflex::Type type_291 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_406 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3483 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_814 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpPattern"));
  ::Reflex::Type type_2560 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_949 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpDigiInfo"));
  ::Reflex::Type type_1905 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpTrackInfo"));
  ::Reflex::Type type_579 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpPatternInfo"));
  ::Reflex::Type type_2258 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned int>"));
  ::Reflex::Type type_2537 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2538 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3411 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TotemRPEvent>"));
  ::Reflex::Type type_2367 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TotemRPEvent>"));
  ::Reflex::Type type_532 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpReconstructedProton"));
  ::Reflex::Type type_2559 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRootDumpPattern>"));
  ::Reflex::Type type_2542 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRootDumpDigiInfo>"));
  ::Reflex::Type type_3406 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpPattern>"));
  ::Reflex::Type type_4595 = ::Reflex::TypeBuilder(Reflex::Literal("totemRPAnalysis::TotemRPAnalysis"));
  ::Reflex::Type type_2539 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRootDumpTrackInfo>"));
  ::Reflex::Type type_2362 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpPattern>"));
  ::Reflex::Type type_3409 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpDigiInfo>"));
  ::Reflex::Type type_1686 = ::Reflex::TypeBuilder(Reflex::Literal("RPRootDumpReconstructedProtonPair"));
  ::Reflex::Type type_2365 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpDigiInfo>"));
  ::Reflex::Type type_3410 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpTrackInfo>"));
  ::Reflex::Type type_2541 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRootDumpPatternInfo>"));
  ::Reflex::Type type_2727 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRootDumpDigiInfo>"));
  ::Reflex::Type type_2366 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpTrackInfo>"));
  ::Reflex::Type type_2721 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRootDumpTrackInfo>"));
  ::Reflex::Type type_3454 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TotemRPEvent>"));
  ::Reflex::Type type_3405 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpPatternInfo>"));
  ::Reflex::Type type_2361 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpPatternInfo>"));
  ::Reflex::Type type_2726 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRootDumpPatternInfo>"));
  ::Reflex::Type type_3449 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpPattern>"));
  ::Reflex::Type type_2664 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>"));
  ::Reflex::Type type_3452 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpDigiInfo>"));
  ::Reflex::Type type_2665 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>"));
  ::Reflex::Type type_2540 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_3453 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpTrackInfo>"));
  ::Reflex::Type type_3408 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_2663 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>"));
  ::Reflex::Type type_3448 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpPatternInfo>"));
  ::Reflex::Type type_2364 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_2725 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_3403 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2359 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_3404 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3407 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProtonPair>"));
  ::Reflex::Type type_2489 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RPRootDumpDigiInfo>"));
  ::Reflex::Type type_2360 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2363 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<RPRootDumpReconstructedProtonPair>"));
  ::Reflex::Type type_2490 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RPRootDumpTrackInfo>"));
  ::Reflex::Type type_3402 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2358 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2488 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RPRootDumpPatternInfo>"));
  ::Reflex::Type type_2661 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_3451 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_3319 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3446 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2662 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3447 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3450 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<RPRootDumpReconstructedProtonPair>"));
  ::Reflex::Type type_3399 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2355 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_3400 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3401 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2356 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2357 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_3445 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2486 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,RPRootDumpReconstructedProton>"));
  ::Reflex::Type type_3398 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2354 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_5235 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_5236 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2487 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_5234 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2723 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_3442 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2724 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3443 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3444 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_3396 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2722 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2352 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_3441 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_3397 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2353 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_5233 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2138 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2612 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2613 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2139 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2719 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2611 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_3439 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2137 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2705 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2720 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2706 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_3440 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_5139 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2704 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_5141 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2609 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_5137 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_5140 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >"));
  ::Reflex::Type type_2610 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2505 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,bool>"));
  ::Reflex::Type type_5142 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >"));
  ::Reflex::Type type_2702 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2508 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,bool>"));
  ::Reflex::Type type_2502 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,bool>"));
  ::Reflex::Type type_5138 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >"));
  ::Reflex::Type type_2703 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2136 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2870 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2872 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2495 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,bool>"));
  ::Reflex::Type type_2868 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2869 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_5135 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2499 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,bool>"));
  ::Reflex::Type type_2871 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2830 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2867 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2832 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2864 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_5136 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >"));
  ::Reflex::Type type_2828 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2829 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2866 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >"));
  ::Reflex::Type type_2831 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2863 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2827 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2865 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >"));
  ::Reflex::Type type_2826 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2825 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2504 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2507 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2501 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2503 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2506 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2500 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2494 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2498 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >"));
  ::Reflex::Type type_2493 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2497 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >"));
  ::Reflex::Type type_2304 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpDigiInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >"));
  ::Reflex::Type type_2305 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpTrackInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >"));
  ::Reflex::Type type_2303 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpPatternInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >"));
  ::Reflex::Type type_2301 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpReconstructedProton>,std::_Select1st<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >"));
  ::Reflex::Type type_2302 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >"));
  ::Reflex::Type type_9012 = ::Reflex::ReferenceBuilder(type_532);
  ::Reflex::Type type_532c = ::Reflex::ConstBuilder(type_532);
  ::Reflex::Type type_9014 = ::Reflex::ReferenceBuilder(type_532c);
  ::Reflex::Type type_9077 = ::Reflex::ReferenceBuilder(type_579);
  ::Reflex::Type type_579c = ::Reflex::ConstBuilder(type_579);
  ::Reflex::Type type_9079 = ::Reflex::ReferenceBuilder(type_579c);
  ::Reflex::Type type_9967 = ::Reflex::ReferenceBuilder(type_814);
  ::Reflex::Type type_814c = ::Reflex::ConstBuilder(type_814);
  ::Reflex::Type type_9969 = ::Reflex::ReferenceBuilder(type_814c);
  ::Reflex::Type type_9142 = ::Reflex::ReferenceBuilder(type_949);
  ::Reflex::Type type_949c = ::Reflex::ConstBuilder(type_949);
  ::Reflex::Type type_9144 = ::Reflex::ReferenceBuilder(type_949c);
  ::Reflex::Type type_14896 = ::Reflex::ReferenceBuilder(type_1686);
  ::Reflex::Type type_1686c = ::Reflex::ConstBuilder(type_1686);
  ::Reflex::Type type_14897 = ::Reflex::ReferenceBuilder(type_1686c);
  ::Reflex::Type type_8947 = ::Reflex::ReferenceBuilder(type_1905);
  ::Reflex::Type type_1905c = ::Reflex::ConstBuilder(type_1905);
  ::Reflex::Type type_8949 = ::Reflex::ReferenceBuilder(type_1905c);
  ::Reflex::Type type_252c = ::Reflex::ConstBuilder(type_252);
  ::Reflex::Type type_2934 = ::Reflex::PointerBuilder(type_252c);
  ::Reflex::Type type_17844 = ::Reflex::ReferenceBuilder(type_1964);
  ::Reflex::Type type_1964c = ::Reflex::ConstBuilder(type_1964);
  ::Reflex::Type type_17845 = ::Reflex::ReferenceBuilder(type_1964c);
  ::Reflex::Type type_6205 = ::Reflex::PointerBuilder(type_1905);
  ::Reflex::Type type_8945 = ::Reflex::PointerBuilder(type_1905c);
  ::Reflex::Type type_2700 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_291);
  ::Reflex::Type type_2635 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_11);
  ::Reflex::Type type_2721c = ::Reflex::ConstBuilder(type_2721);
  ::Reflex::Type type_17924 = ::Reflex::ReferenceBuilder(type_2721c);
  ::Reflex::Type type_2539c = ::Reflex::ConstBuilder(type_2539);
  ::Reflex::Type type_18588 = ::Reflex::ReferenceBuilder(type_2539c);
  ::Reflex::Type type_18589 = ::Reflex::ReferenceBuilder(type_2539);
  ::Reflex::Type type_6148 = ::Reflex::PointerBuilder(type_532);
  ::Reflex::Type type_9010 = ::Reflex::PointerBuilder(type_532c);
  ::Reflex::Type type_2725c = ::Reflex::ConstBuilder(type_2725);
  ::Reflex::Type type_17885 = ::Reflex::ReferenceBuilder(type_2725c);
  ::Reflex::Type type_2540c = ::Reflex::ConstBuilder(type_2540);
  ::Reflex::Type type_18591 = ::Reflex::ReferenceBuilder(type_2540c);
  ::Reflex::Type type_18592 = ::Reflex::ReferenceBuilder(type_2540);
  ::Reflex::Type type_6167 = ::Reflex::PointerBuilder(type_579);
  ::Reflex::Type type_9075 = ::Reflex::PointerBuilder(type_579c);
  ::Reflex::Type type_2726c = ::Reflex::ConstBuilder(type_2726);
  ::Reflex::Type type_17898 = ::Reflex::ReferenceBuilder(type_2726c);
  ::Reflex::Type type_2541c = ::Reflex::ConstBuilder(type_2541);
  ::Reflex::Type type_18594 = ::Reflex::ReferenceBuilder(type_2541c);
  ::Reflex::Type type_18595 = ::Reflex::ReferenceBuilder(type_2541);
  ::Reflex::Type type_6186 = ::Reflex::PointerBuilder(type_949);
  ::Reflex::Type type_9140 = ::Reflex::PointerBuilder(type_949c);
  ::Reflex::Type type_2727c = ::Reflex::ConstBuilder(type_2727);
  ::Reflex::Type type_17911 = ::Reflex::ReferenceBuilder(type_2727c);
  ::Reflex::Type type_2542c = ::Reflex::ConstBuilder(type_2542);
  ::Reflex::Type type_18597 = ::Reflex::ReferenceBuilder(type_2542c);
  ::Reflex::Type type_18598 = ::Reflex::ReferenceBuilder(type_2542);
  ::Reflex::Type type_7390 = ::Reflex::PointerBuilder(type_2486);
  ::Reflex::Type type_2486c = ::Reflex::ConstBuilder(type_2486);
  ::Reflex::Type type_7392 = ::Reflex::PointerBuilder(type_2486c);
  ::Reflex::Type type_7394 = ::Reflex::ReferenceBuilder(type_2486);
  ::Reflex::Type type_7396 = ::Reflex::ReferenceBuilder(type_2486c);
  ::Reflex::Type type_2258c = ::Reflex::ConstBuilder(type_2258);
  ::Reflex::Type type_18317 = ::Reflex::ReferenceBuilder(type_2258c);
  ::Reflex::Type type_2719c = ::Reflex::ConstBuilder(type_2719);
  ::Reflex::Type type_18389 = ::Reflex::ReferenceBuilder(type_2719c);
  ::Reflex::Type type_2661c = ::Reflex::ConstBuilder(type_2661);
  ::Reflex::Type type_18749 = ::Reflex::ReferenceBuilder(type_2661c);
  ::Reflex::Type type_18750 = ::Reflex::ReferenceBuilder(type_2661);
  ::Reflex::Type type_198c = ::Reflex::ConstBuilder(type_198);
  ::Reflex::Type type_18318 = ::Reflex::ReferenceBuilder(type_198c);
  ::Reflex::Type type_7499 = ::Reflex::PointerBuilder(type_2487);
  ::Reflex::Type type_2487c = ::Reflex::ConstBuilder(type_2487);
  ::Reflex::Type type_7501 = ::Reflex::PointerBuilder(type_2487c);
  ::Reflex::Type type_7503 = ::Reflex::ReferenceBuilder(type_2487);
  ::Reflex::Type type_7505 = ::Reflex::ReferenceBuilder(type_2487c);
  ::Reflex::Type type_2720c = ::Reflex::ConstBuilder(type_2720);
  ::Reflex::Type type_18397 = ::Reflex::ReferenceBuilder(type_2720c);
  ::Reflex::Type type_2662c = ::Reflex::ConstBuilder(type_2662);
  ::Reflex::Type type_18751 = ::Reflex::ReferenceBuilder(type_2662c);
  ::Reflex::Type type_18752 = ::Reflex::ReferenceBuilder(type_2662);
  ::Reflex::Type type_7608 = ::Reflex::PointerBuilder(type_2488);
  ::Reflex::Type type_2488c = ::Reflex::ConstBuilder(type_2488);
  ::Reflex::Type type_7610 = ::Reflex::PointerBuilder(type_2488c);
  ::Reflex::Type type_7612 = ::Reflex::ReferenceBuilder(type_2488);
  ::Reflex::Type type_7614 = ::Reflex::ReferenceBuilder(type_2488c);
  ::Reflex::Type type_2722c = ::Reflex::ConstBuilder(type_2722);
  ::Reflex::Type type_18404 = ::Reflex::ReferenceBuilder(type_2722c);
  ::Reflex::Type type_2663c = ::Reflex::ConstBuilder(type_2663);
  ::Reflex::Type type_18753 = ::Reflex::ReferenceBuilder(type_2663c);
  ::Reflex::Type type_18754 = ::Reflex::ReferenceBuilder(type_2663);
  ::Reflex::Type type_7717 = ::Reflex::PointerBuilder(type_2489);
  ::Reflex::Type type_2489c = ::Reflex::ConstBuilder(type_2489);
  ::Reflex::Type type_7719 = ::Reflex::PointerBuilder(type_2489c);
  ::Reflex::Type type_7721 = ::Reflex::ReferenceBuilder(type_2489);
  ::Reflex::Type type_7723 = ::Reflex::ReferenceBuilder(type_2489c);
  ::Reflex::Type type_2723c = ::Reflex::ConstBuilder(type_2723);
  ::Reflex::Type type_18411 = ::Reflex::ReferenceBuilder(type_2723c);
  ::Reflex::Type type_2664c = ::Reflex::ConstBuilder(type_2664);
  ::Reflex::Type type_18755 = ::Reflex::ReferenceBuilder(type_2664c);
  ::Reflex::Type type_18756 = ::Reflex::ReferenceBuilder(type_2664);
  ::Reflex::Type type_7826 = ::Reflex::PointerBuilder(type_2490);
  ::Reflex::Type type_2490c = ::Reflex::ConstBuilder(type_2490);
  ::Reflex::Type type_7828 = ::Reflex::PointerBuilder(type_2490c);
  ::Reflex::Type type_7830 = ::Reflex::ReferenceBuilder(type_2490);
  ::Reflex::Type type_7832 = ::Reflex::ReferenceBuilder(type_2490c);
  ::Reflex::Type type_2724c = ::Reflex::ConstBuilder(type_2724);
  ::Reflex::Type type_18418 = ::Reflex::ReferenceBuilder(type_2724c);
  ::Reflex::Type type_2665c = ::Reflex::ConstBuilder(type_2665);
  ::Reflex::Type type_18757 = ::Reflex::ReferenceBuilder(type_2665c);
  ::Reflex::Type type_18758 = ::Reflex::ReferenceBuilder(type_2665);
  ::Reflex::Type type_20497 = ::Reflex::PointerBuilder(type_2661c);
  ::Reflex::Type type_406c = ::Reflex::ConstBuilder(type_406);
  ::Reflex::Type type_12531 = ::Reflex::ReferenceBuilder(type_406c);
  ::Reflex::Type type_20498 = ::Reflex::PointerBuilder(type_2661);
  ::Reflex::Type type_3439c = ::Reflex::ConstBuilder(type_3439);
  ::Reflex::Type type_20499 = ::Reflex::PointerBuilder(type_3439c);
  ::Reflex::Type type_3483c = ::Reflex::ConstBuilder(type_3483);
  ::Reflex::Type type_14062 = ::Reflex::ReferenceBuilder(type_3483c);
  ::Reflex::Type type_18584 = ::Reflex::ReferenceBuilder(type_2537);
  ::Reflex::Type type_20425 = ::Reflex::ReferenceBuilder(type_3319);
  ::Reflex::Type type_580c = ::Reflex::ConstBuilder(type_580);
  ::Reflex::Type type_3053 = ::Reflex::PointerBuilder(type_580c);
  ::Reflex::Type type_6963 = ::Reflex::ReferenceBuilder(type_3053);
  ::Reflex::Type type_2538c = ::Reflex::ConstBuilder(type_2538);
  ::Reflex::Type type_18585 = ::Reflex::ReferenceBuilder(type_2538c);
  ::Reflex::Type type_20502 = ::Reflex::PointerBuilder(type_2662c);
  ::Reflex::Type type_20503 = ::Reflex::PointerBuilder(type_2662);
  ::Reflex::Type type_3440c = ::Reflex::ConstBuilder(type_3440);
  ::Reflex::Type type_20504 = ::Reflex::PointerBuilder(type_3440c);
  ::Reflex::Type type_20507 = ::Reflex::PointerBuilder(type_2663c);
  ::Reflex::Type type_20508 = ::Reflex::PointerBuilder(type_2663);
  ::Reflex::Type type_3441c = ::Reflex::ConstBuilder(type_3441);
  ::Reflex::Type type_20509 = ::Reflex::PointerBuilder(type_3441c);
  ::Reflex::Type type_20512 = ::Reflex::PointerBuilder(type_2664c);
  ::Reflex::Type type_20513 = ::Reflex::PointerBuilder(type_2664);
  ::Reflex::Type type_3442c = ::Reflex::ConstBuilder(type_3442);
  ::Reflex::Type type_20514 = ::Reflex::PointerBuilder(type_3442c);
  ::Reflex::Type type_20517 = ::Reflex::PointerBuilder(type_2665c);
  ::Reflex::Type type_20518 = ::Reflex::PointerBuilder(type_2665);
  ::Reflex::Type type_3443c = ::Reflex::ConstBuilder(type_3443);
  ::Reflex::Type type_20519 = ::Reflex::PointerBuilder(type_3443c);
  ::Reflex::Type type_20522 = ::Reflex::PointerBuilder(type_2540c);
  ::Reflex::Type type_20523 = ::Reflex::PointerBuilder(type_2540);
  ::Reflex::Type type_3444c = ::Reflex::ConstBuilder(type_3444);
  ::Reflex::Type type_20524 = ::Reflex::PointerBuilder(type_3444c);
  ::Reflex::Type type_20527 = ::Reflex::PointerBuilder(type_2541c);
  ::Reflex::Type type_20528 = ::Reflex::PointerBuilder(type_2541);
  ::Reflex::Type type_3445c = ::Reflex::ConstBuilder(type_3445);
  ::Reflex::Type type_20529 = ::Reflex::PointerBuilder(type_3445c);
  ::Reflex::Type type_20532 = ::Reflex::PointerBuilder(type_2542c);
  ::Reflex::Type type_20533 = ::Reflex::PointerBuilder(type_2542);
  ::Reflex::Type type_3446c = ::Reflex::ConstBuilder(type_3446);
  ::Reflex::Type type_20534 = ::Reflex::PointerBuilder(type_3446c);
  ::Reflex::Type type_20537 = ::Reflex::PointerBuilder(type_2539c);
  ::Reflex::Type type_20538 = ::Reflex::PointerBuilder(type_2539);
  ::Reflex::Type type_3447c = ::Reflex::ConstBuilder(type_3447);
  ::Reflex::Type type_20539 = ::Reflex::PointerBuilder(type_3447c);
  ::Reflex::Type type_3448c = ::Reflex::ConstBuilder(type_3448);
  ::Reflex::Type type_20542 = ::Reflex::PointerBuilder(type_3448c);
  ::Reflex::Type type_9965 = ::Reflex::PointerBuilder(type_814c);
  ::Reflex::Type type_6489 = ::Reflex::PointerBuilder(type_814);
  ::Reflex::Type type_3449c = ::Reflex::ConstBuilder(type_3449);
  ::Reflex::Type type_20545 = ::Reflex::PointerBuilder(type_3449c);
  ::Reflex::Type type_20548 = ::Reflex::PointerBuilder(type_1686c);
  ::Reflex::Type type_20549 = ::Reflex::PointerBuilder(type_1686);
  ::Reflex::Type type_3450c = ::Reflex::ConstBuilder(type_3450);
  ::Reflex::Type type_20550 = ::Reflex::PointerBuilder(type_3450c);
  ::Reflex::Type type_3451c = ::Reflex::ConstBuilder(type_3451);
  ::Reflex::Type type_20553 = ::Reflex::PointerBuilder(type_3451c);
  ::Reflex::Type type_3452c = ::Reflex::ConstBuilder(type_3452);
  ::Reflex::Type type_20556 = ::Reflex::PointerBuilder(type_3452c);
  ::Reflex::Type type_3453c = ::Reflex::ConstBuilder(type_3453);
  ::Reflex::Type type_20559 = ::Reflex::PointerBuilder(type_3453c);
  ::Reflex::Type type_20562 = ::Reflex::PointerBuilder(type_1964c);
  ::Reflex::Type type_20563 = ::Reflex::PointerBuilder(type_1964);
  ::Reflex::Type type_3454c = ::Reflex::ConstBuilder(type_3454);
  ::Reflex::Type type_20564 = ::Reflex::PointerBuilder(type_3454c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __RPRootDumpReconstructedProton
#undef __RPRootDumpReconstructedProton
#endif
struct __RPRootDumpReconstructedProton {
  public:
  __RPRootDumpReconstructedProton();
  virtual ~__RPRootDumpReconstructedProton() throw();
  bool valid;
  double thx;
  double thy;
  double phi;
  double t;
  double tx;
  double ty;
  double xi;
  double x0;
  double y0;
  double chi2;
  double chindf;
};
#ifdef __RPRootDumpPatternInfo
#undef __RPRootDumpPatternInfo
#endif
struct __RPRootDumpPatternInfo {
  public:
  __RPRootDumpPatternInfo();
  virtual ~__RPRootDumpPatternInfo() throw();
  ::std::vector<RPRootDumpPattern> u;
  ::std::vector<RPRootDumpPattern> v;
  bool fittable;
  unsigned int u_no;
  unsigned int v_no;
};
#ifdef __RPRootDumpPattern
#undef __RPRootDumpPattern
#endif
struct __RPRootDumpPattern {
  public:
  __RPRootDumpPattern();
  virtual ~__RPRootDumpPattern() throw();
  double a;
  double b;
  double w;
};
#ifdef __RPRootDumpDigiInfo
#undef __RPRootDumpDigiInfo
#endif
struct __RPRootDumpDigiInfo {
  public:
  __RPRootDumpDigiInfo();
  virtual ~__RPRootDumpDigiInfo() throw();
  ::std::vector<int> numberOfClusters;
  unsigned int numberOfPlanesOn;
  unsigned int uPlanesOn;
  unsigned int vPlanesOn;
  ::std::vector<int> planeId;
  ::std::vector<int> clusterSize;
  ::std::vector<int> centralStrip;
};
#ifdef __RPRootDumpReconstructedProtonPair
#undef __RPRootDumpReconstructedProtonPair
#endif
struct __RPRootDumpReconstructedProtonPair {
  public:
  __RPRootDumpReconstructedProtonPair();
  virtual ~__RPRootDumpReconstructedProtonPair() throw();
  bool valid;
  double thxr;
  double thyr;
  double xir;
  double phir;
  double thxl;
  double thyl;
  double xil;
  double phil;
  double x0;
  double y0;
  double z0;
  double chi2;
  double chindf;
  double tr;
  double txr;
  double tyr;
  double tl;
  double txl;
  double tyl;
  double t;
};
#ifdef __RPRootDumpTrackInfo
#undef __RPRootDumpTrackInfo
#endif
struct __RPRootDumpTrackInfo {
  public:
  __RPRootDumpTrackInfo();
  virtual ~__RPRootDumpTrackInfo() throw();
  bool valid;
  double x;
  double y;
  double z;
  double thx;
  double thy;
  double chi2;
  double chi2ndf;
  unsigned int entries;
  double res_x;
  double res_y;
  ::std::vector<int> u_sect;
  ::std::vector<int> v_sect;
  int u_sect_no;
  int v_sect_no;
  unsigned int u_id;
  unsigned int v_id;
};
#ifdef __TotemRPEvent
#undef __TotemRPEvent
#endif
struct __TotemRPEvent {
  public:
  __TotemRPEvent();
  ::std::map<unsigned int,RPRootDumpTrackInfo> track_info_;
  ::std::map<unsigned int,RPRootDumpDigiInfo> digi_info_;
  ::std::map<unsigned int,RPRootDumpPatternInfo> par_patterns_info_;
  ::std::map<unsigned int,RPRootDumpPatternInfo> nonpar_patterns_info_;
  ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > multi_track_info_;
  ::std::map<unsigned int,RPRootDumpReconstructedProton> rec_pr_info_;
  ::std::map<unsigned int,RPRootDumpReconstructedProton> sim_pr_info_;
  ::RPRootDumpReconstructedProtonPair rec_pr_pair_info_;
};
#ifdef __std__vector_RPRootDumpTrackInfo_
#undef __std__vector_RPRootDumpTrackInfo_
#endif
class __std__vector_RPRootDumpTrackInfo_ : protected ::std::_Vector_base<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > {
  public:
  __std__vector_RPRootDumpTrackInfo_();
};
#ifdef __std__vector_RPRootDumpReconstructedProton_
#undef __std__vector_RPRootDumpReconstructedProton_
#endif
class __std__vector_RPRootDumpReconstructedProton_ : protected ::std::_Vector_base<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > {
  public:
  __std__vector_RPRootDumpReconstructedProton_();
};
#ifdef __std__vector_RPRootDumpPatternInfo_
#undef __std__vector_RPRootDumpPatternInfo_
#endif
class __std__vector_RPRootDumpPatternInfo_ : protected ::std::_Vector_base<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > {
  public:
  __std__vector_RPRootDumpPatternInfo_();
};
#ifdef __std__vector_RPRootDumpDigiInfo_
#undef __std__vector_RPRootDumpDigiInfo_
#endif
class __std__vector_RPRootDumpDigiInfo_ : protected ::std::_Vector_base<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > {
  public:
  __std__vector_RPRootDumpDigiInfo_();
};
#ifdef __std__map_unsignedsint_RPRootDumpReconstructedProton_
#undef __std__map_unsignedsint_RPRootDumpReconstructedProton_
#endif
class __std__map_unsignedsint_RPRootDumpReconstructedProton_ {
  public:
  __std__map_unsignedsint_RPRootDumpReconstructedProton_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpReconstructedProton>,std::_Select1st<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > > _M_t;
};
#ifdef __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_
#undef __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_
#endif
class __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_ {
  public:
  __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >,std::_Select1st<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > > _M_t;
};
#ifdef __std__map_unsignedsint_RPRootDumpPatternInfo_
#undef __std__map_unsignedsint_RPRootDumpPatternInfo_
#endif
class __std__map_unsignedsint_RPRootDumpPatternInfo_ {
  public:
  __std__map_unsignedsint_RPRootDumpPatternInfo_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpPatternInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> > > _M_t;
};
#ifdef __std__map_unsignedsint_RPRootDumpDigiInfo_
#undef __std__map_unsignedsint_RPRootDumpDigiInfo_
#endif
class __std__map_unsignedsint_RPRootDumpDigiInfo_ {
  public:
  __std__map_unsignedsint_RPRootDumpDigiInfo_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpDigiInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> > > _M_t;
};
#ifdef __std__map_unsignedsint_RPRootDumpTrackInfo_
#undef __std__map_unsignedsint_RPRootDumpTrackInfo_
#endif
class __std__map_unsignedsint_RPRootDumpTrackInfo_ {
  public:
  __std__map_unsignedsint_RPRootDumpTrackInfo_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,RPRootDumpTrackInfo>,std::_Select1st<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> > > _M_t;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_
#undef __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_();
  bool present;
  ::std::map<unsigned int,RPRootDumpReconstructedProton> obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_
#undef __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_();
  bool present;
  ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_
#undef __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_();
  bool present;
  ::std::map<unsigned int,RPRootDumpPatternInfo> obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_
#undef __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_();
  bool present;
  ::std::map<unsigned int,RPRootDumpDigiInfo> obj;
};
#ifdef __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_
#undef __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_
#endif
class __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_ {
  public:
  __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_();
  bool present;
  ::std::map<unsigned int,RPRootDumpTrackInfo> obj;
};
#ifdef __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_
#undef __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_
#endif
class __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_ {
  public:
  __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_();
  bool present;
  ::std::vector<RPRootDumpReconstructedProton> obj;
};
#ifdef __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_
#undef __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_
#endif
class __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_ {
  public:
  __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_();
  bool present;
  ::std::vector<RPRootDumpPatternInfo> obj;
};
#ifdef __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_
#undef __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_
#endif
class __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_ {
  public:
  __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_();
  bool present;
  ::std::vector<RPRootDumpDigiInfo> obj;
};
#ifdef __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_
#undef __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_
#endif
class __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_ {
  public:
  __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_();
  bool present;
  ::std::vector<RPRootDumpTrackInfo> obj;
};
#ifdef __edm__Wrapper_RPRootDumpPatternInfo_
#undef __edm__Wrapper_RPRootDumpPatternInfo_
#endif
class __edm__Wrapper_RPRootDumpPatternInfo_ {
  public:
  __edm__Wrapper_RPRootDumpPatternInfo_();
  bool present;
  ::RPRootDumpPatternInfo obj;
};
#ifdef __edm__Wrapper_RPRootDumpPattern_
#undef __edm__Wrapper_RPRootDumpPattern_
#endif
class __edm__Wrapper_RPRootDumpPattern_ {
  public:
  __edm__Wrapper_RPRootDumpPattern_();
  bool present;
  ::RPRootDumpPattern obj;
};
#ifdef __edm__Wrapper_RPRootDumpReconstructedProtonPair_
#undef __edm__Wrapper_RPRootDumpReconstructedProtonPair_
#endif
class __edm__Wrapper_RPRootDumpReconstructedProtonPair_ {
  public:
  __edm__Wrapper_RPRootDumpReconstructedProtonPair_();
  bool present;
  ::RPRootDumpReconstructedProtonPair obj;
};
#ifdef __edm__Wrapper_RPRootDumpReconstructedProton_
#undef __edm__Wrapper_RPRootDumpReconstructedProton_
#endif
class __edm__Wrapper_RPRootDumpReconstructedProton_ {
  public:
  __edm__Wrapper_RPRootDumpReconstructedProton_();
  bool present;
  ::RPRootDumpReconstructedProton obj;
};
#ifdef __edm__Wrapper_RPRootDumpDigiInfo_
#undef __edm__Wrapper_RPRootDumpDigiInfo_
#endif
class __edm__Wrapper_RPRootDumpDigiInfo_ {
  public:
  __edm__Wrapper_RPRootDumpDigiInfo_();
  bool present;
  ::RPRootDumpDigiInfo obj;
};
#ifdef __edm__Wrapper_RPRootDumpTrackInfo_
#undef __edm__Wrapper_RPRootDumpTrackInfo_
#endif
class __edm__Wrapper_RPRootDumpTrackInfo_ {
  public:
  __edm__Wrapper_RPRootDumpTrackInfo_();
  bool present;
  ::RPRootDumpTrackInfo obj;
};
#ifdef __edm__Wrapper_TotemRPEvent_
#undef __edm__Wrapper_TotemRPEvent_
#endif
class __edm__Wrapper_TotemRPEvent_ {
  public:
  __edm__Wrapper_TotemRPEvent_();
  bool present;
  ::TotemRPEvent obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class RPRootDumpReconstructedProton -------------------------------
static  void operator_3764( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpReconstructedProton*)o)->operator=)(*(const ::RPRootDumpReconstructedProton*)arg[0]);
  else   (((::RPRootDumpReconstructedProton*)o)->operator=)(*(const ::RPRootDumpReconstructedProton*)arg[0]);
}

static void constructor_3765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpReconstructedProton(*(const ::RPRootDumpReconstructedProton*)arg[0]);
  else ::new(mem) ::RPRootDumpReconstructedProton(*(const ::RPRootDumpReconstructedProton*)arg[0]);
}

static void constructor_3766( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpReconstructedProton();
  else ::new(mem) ::RPRootDumpReconstructedProton();
}

static void destructor_3767(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpReconstructedProton*)o)->::RPRootDumpReconstructedProton::~RPRootDumpReconstructedProton)();
}
static void method_newdel_532( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProton >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProton >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProton >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProton >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProton >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpReconstructedProton -------------------------------
void __RPRootDumpReconstructedProton_db_datamem(Reflex::Class*);
void __RPRootDumpReconstructedProton_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpReconstructedProton_datamem_bld(&__RPRootDumpReconstructedProton_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpReconstructedProton_funcmem_bld(&__RPRootDumpReconstructedProton_db_funcmem);
void __RPRootDumpReconstructedProton_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpReconstructedProton"), typeid(::RPRootDumpReconstructedProton), sizeof(::RPRootDumpReconstructedProton), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9012, type_9014), Reflex::Literal("operator="), operator_3764, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9014), Reflex::Literal("RPRootDumpReconstructedProton"), constructor_3765, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpReconstructedProton"), constructor_3766, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpReconstructedProton"), destructor_3767, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_532, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpReconstructedProton_datamem_bld);
}

//------Delayed data member builder for class RPRootDumpReconstructedProton -------------------
void __RPRootDumpReconstructedProton_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("valid"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, valid), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("thx"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, thx), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("thy"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, thy), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("phi"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("t"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, t), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("tx"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, tx), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("ty"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, ty), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("xi"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, xi), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("x0"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, x0), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("y0"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, y0), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("chi2"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, chi2), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("chindf"), OffsetOf(__shadow__::__RPRootDumpReconstructedProton, chindf), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpReconstructedProton -------------------
void __RPRootDumpReconstructedProton_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPRootDumpPatternInfo -------------------------------
static  void operator_3951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpPatternInfo*)o)->operator=)(*(const ::RPRootDumpPatternInfo*)arg[0]);
  else   (((::RPRootDumpPatternInfo*)o)->operator=)(*(const ::RPRootDumpPatternInfo*)arg[0]);
}

static void constructor_3952( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPatternInfo(*(const ::RPRootDumpPatternInfo*)arg[0]);
  else ::new(mem) ::RPRootDumpPatternInfo(*(const ::RPRootDumpPatternInfo*)arg[0]);
}

static void constructor_3953( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPatternInfo();
  else ::new(mem) ::RPRootDumpPatternInfo();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPatternInfo(*(bool*)arg[0]);
  else ::new(mem) ::RPRootDumpPatternInfo(*(bool*)arg[0]);
  }
}

static void destructor_3954(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpPatternInfo*)o)->::RPRootDumpPatternInfo::~RPRootDumpPatternInfo)();
}
static  void method_3955( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RPRootDumpPatternInfo*)o)->Reset)();
}

static void constructor_x1( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPatternInfo();
  else ::new(mem) ::RPRootDumpPatternInfo();
}

static void method_newdel_579( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpPatternInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpPatternInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpPatternInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpPatternInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpPatternInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpPatternInfo -------------------------------
void __RPRootDumpPatternInfo_db_datamem(Reflex::Class*);
void __RPRootDumpPatternInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpPatternInfo_datamem_bld(&__RPRootDumpPatternInfo_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpPatternInfo_funcmem_bld(&__RPRootDumpPatternInfo_db_funcmem);
void __RPRootDumpPatternInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpPatternInfo"), typeid(::RPRootDumpPatternInfo), sizeof(::RPRootDumpPatternInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9077, type_9079), Reflex::Literal("operator="), operator_3951, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9079), Reflex::Literal("RPRootDumpPatternInfo"), constructor_3952, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1362), Reflex::Literal("RPRootDumpPatternInfo"), constructor_3953, 0, "_f=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpPatternInfo"), destructor_3954, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpPatternInfo"), constructor_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_579, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpPatternInfo_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RPRootDumpPatternInfo_funcmem_bld);
}

//------Delayed data member builder for class RPRootDumpPatternInfo -------------------
void __RPRootDumpPatternInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2559, Reflex::Literal("u"), OffsetOf(__shadow__::__RPRootDumpPatternInfo, u), ::Reflex::PUBLIC)
  .AddDataMember(type_2559, Reflex::Literal("v"), OffsetOf(__shadow__::__RPRootDumpPatternInfo, v), ::Reflex::PUBLIC)
  .AddDataMember(type_1362, Reflex::Literal("fittable"), OffsetOf(__shadow__::__RPRootDumpPatternInfo, fittable), ::Reflex::PUBLIC)
  .AddDataMember(type_198, Reflex::Literal("u_no"), OffsetOf(__shadow__::__RPRootDumpPatternInfo, u_no), ::Reflex::PUBLIC)
  .AddDataMember(type_198, Reflex::Literal("v_no"), OffsetOf(__shadow__::__RPRootDumpPatternInfo, v_no), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpPatternInfo -------------------
void __RPRootDumpPatternInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("Reset"), method_3955, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class RPRootDumpPattern -------------------------------
static  void operator_4123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpPattern*)o)->operator=)(*(const ::RPRootDumpPattern*)arg[0]);
  else   (((::RPRootDumpPattern*)o)->operator=)(*(const ::RPRootDumpPattern*)arg[0]);
}

static void constructor_4124( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern(*(const ::RPRootDumpPattern*)arg[0]);
  else ::new(mem) ::RPRootDumpPattern(*(const ::RPRootDumpPattern*)arg[0]);
}

static void constructor_4125( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern();
  else ::new(mem) ::RPRootDumpPattern();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern(*(double*)arg[0]);
  else ::new(mem) ::RPRootDumpPattern(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::RPRootDumpPattern(*(double*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::RPRootDumpPattern(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
}

static void destructor_4126(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpPattern*)o)->::RPRootDumpPattern::~RPRootDumpPattern)();
}
static void constructor_x3( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpPattern();
  else ::new(mem) ::RPRootDumpPattern();
}

static void method_newdel_814( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpPattern >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpPattern >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpPattern >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpPattern >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpPattern >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpPattern -------------------------------
void __RPRootDumpPattern_db_datamem(Reflex::Class*);
void __RPRootDumpPattern_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpPattern_datamem_bld(&__RPRootDumpPattern_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpPattern_funcmem_bld(&__RPRootDumpPattern_db_funcmem);
void __RPRootDumpPattern_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpPattern"), typeid(::RPRootDumpPattern), sizeof(::RPRootDumpPattern), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9967, type_9969), Reflex::Literal("operator="), operator_4123, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9969), Reflex::Literal("RPRootDumpPattern"), constructor_4124, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_99, type_99, type_99), Reflex::Literal("RPRootDumpPattern"), constructor_4125, 0, "_a=0.0;_b=0.0;_w=0.0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpPattern"), destructor_4126, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpPattern"), constructor_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_814, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpPattern_datamem_bld);
}

//------Delayed data member builder for class RPRootDumpPattern -------------------
void __RPRootDumpPattern_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_99, Reflex::Literal("a"), OffsetOf(__shadow__::__RPRootDumpPattern, a), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("b"), OffsetOf(__shadow__::__RPRootDumpPattern, b), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("w"), OffsetOf(__shadow__::__RPRootDumpPattern, w), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpPattern -------------------
void __RPRootDumpPattern_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPRootDumpDigiInfo -------------------------------
static  void operator_4278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpDigiInfo*)o)->operator=)(*(const ::RPRootDumpDigiInfo*)arg[0]);
  else   (((::RPRootDumpDigiInfo*)o)->operator=)(*(const ::RPRootDumpDigiInfo*)arg[0]);
}

static void constructor_4279( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpDigiInfo(*(const ::RPRootDumpDigiInfo*)arg[0]);
  else ::new(mem) ::RPRootDumpDigiInfo(*(const ::RPRootDumpDigiInfo*)arg[0]);
}

static void constructor_4280( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpDigiInfo();
  else ::new(mem) ::RPRootDumpDigiInfo();
}

static void destructor_4281(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpDigiInfo*)o)->::RPRootDumpDigiInfo::~RPRootDumpDigiInfo)();
}
static void method_newdel_949( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpDigiInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpDigiInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpDigiInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpDigiInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpDigiInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpDigiInfo -------------------------------
void __RPRootDumpDigiInfo_db_datamem(Reflex::Class*);
void __RPRootDumpDigiInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpDigiInfo_datamem_bld(&__RPRootDumpDigiInfo_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpDigiInfo_funcmem_bld(&__RPRootDumpDigiInfo_db_funcmem);
void __RPRootDumpDigiInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpDigiInfo"), typeid(::RPRootDumpDigiInfo), sizeof(::RPRootDumpDigiInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9142, type_9144), Reflex::Literal("operator="), operator_4278, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9144), Reflex::Literal("RPRootDumpDigiInfo"), constructor_4279, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpDigiInfo"), constructor_4280, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpDigiInfo"), destructor_4281, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_949, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpDigiInfo_datamem_bld);
}

//------Delayed data member builder for class RPRootDumpDigiInfo -------------------
void __RPRootDumpDigiInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2560, Reflex::Literal("numberOfClusters"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, numberOfClusters), ::Reflex::PUBLIC)
  .AddDataMember(type_198, Reflex::Literal("numberOfPlanesOn"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, numberOfPlanesOn), ::Reflex::PUBLIC)
  .AddDataMember(type_198, Reflex::Literal("uPlanesOn"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, uPlanesOn), ::Reflex::PUBLIC)
  .AddDataMember(type_198, Reflex::Literal("vPlanesOn"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, vPlanesOn), ::Reflex::PUBLIC)
  .AddDataMember(type_2560, Reflex::Literal("planeId"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, planeId), ::Reflex::PUBLIC)
  .AddDataMember(type_2560, Reflex::Literal("clusterSize"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, clusterSize), ::Reflex::PUBLIC)
  .AddDataMember(type_2560, Reflex::Literal("centralStrip"), OffsetOf(__shadow__::__RPRootDumpDigiInfo, centralStrip), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpDigiInfo -------------------
void __RPRootDumpDigiInfo_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPRootDumpReconstructedProtonPair -------------------------------
static  void operator_5088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpReconstructedProtonPair*)o)->operator=)(*(const ::RPRootDumpReconstructedProtonPair*)arg[0]);
  else   (((::RPRootDumpReconstructedProtonPair*)o)->operator=)(*(const ::RPRootDumpReconstructedProtonPair*)arg[0]);
}

static void constructor_5089( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpReconstructedProtonPair(*(const ::RPRootDumpReconstructedProtonPair*)arg[0]);
  else ::new(mem) ::RPRootDumpReconstructedProtonPair(*(const ::RPRootDumpReconstructedProtonPair*)arg[0]);
}

static void constructor_5090( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpReconstructedProtonPair();
  else ::new(mem) ::RPRootDumpReconstructedProtonPair();
}

static void destructor_5091(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpReconstructedProtonPair*)o)->::RPRootDumpReconstructedProtonPair::~RPRootDumpReconstructedProtonPair)();
}
static void method_newdel_1686( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProtonPair >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProtonPair >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProtonPair >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProtonPair >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpReconstructedProtonPair >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpReconstructedProtonPair -------------------------------
void __RPRootDumpReconstructedProtonPair_db_datamem(Reflex::Class*);
void __RPRootDumpReconstructedProtonPair_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpReconstructedProtonPair_datamem_bld(&__RPRootDumpReconstructedProtonPair_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpReconstructedProtonPair_funcmem_bld(&__RPRootDumpReconstructedProtonPair_db_funcmem);
void __RPRootDumpReconstructedProtonPair_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpReconstructedProtonPair"), typeid(::RPRootDumpReconstructedProtonPair), sizeof(::RPRootDumpReconstructedProtonPair), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14896, type_14897), Reflex::Literal("operator="), operator_5088, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14897), Reflex::Literal("RPRootDumpReconstructedProtonPair"), constructor_5089, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpReconstructedProtonPair"), constructor_5090, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpReconstructedProtonPair"), destructor_5091, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1686, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpReconstructedProtonPair_datamem_bld);
}

//------Delayed data member builder for class RPRootDumpReconstructedProtonPair -------------------
void __RPRootDumpReconstructedProtonPair_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("valid"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, valid), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("thxr"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, thxr), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("thyr"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, thyr), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("xir"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, xir), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("phir"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, phir), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("thxl"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, thxl), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("thyl"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, thyl), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("xil"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, xil), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("phil"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, phil), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("x0"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, x0), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("y0"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, y0), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("z0"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, z0), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("chi2"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, chi2), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("chindf"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, chindf), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("tr"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, tr), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("txr"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, txr), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("tyr"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, tyr), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("tl"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, tl), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("txl"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, txl), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("tyl"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, tyl), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("t"), OffsetOf(__shadow__::__RPRootDumpReconstructedProtonPair, t), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpReconstructedProtonPair -------------------
void __RPRootDumpReconstructedProtonPair_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RPRootDumpTrackInfo -------------------------------
static  void operator_5931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RPRootDumpTrackInfo*)o)->operator=)(*(const ::RPRootDumpTrackInfo*)arg[0]);
  else   (((::RPRootDumpTrackInfo*)o)->operator=)(*(const ::RPRootDumpTrackInfo*)arg[0]);
}

static void constructor_5932( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpTrackInfo(*(const ::RPRootDumpTrackInfo*)arg[0]);
  else ::new(mem) ::RPRootDumpTrackInfo(*(const ::RPRootDumpTrackInfo*)arg[0]);
}

static void constructor_5933( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RPRootDumpTrackInfo();
  else ::new(mem) ::RPRootDumpTrackInfo();
}

static void destructor_5934(void*, void * o, const std::vector<void*>&, void *) {
(((::RPRootDumpTrackInfo*)o)->::RPRootDumpTrackInfo::~RPRootDumpTrackInfo)();
}
static void method_newdel_1905( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RPRootDumpTrackInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RPRootDumpTrackInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RPRootDumpTrackInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RPRootDumpTrackInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RPRootDumpTrackInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RPRootDumpTrackInfo -------------------------------
void __RPRootDumpTrackInfo_db_datamem(Reflex::Class*);
void __RPRootDumpTrackInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RPRootDumpTrackInfo_datamem_bld(&__RPRootDumpTrackInfo_db_datamem);
Reflex::GenreflexMemberBuilder __RPRootDumpTrackInfo_funcmem_bld(&__RPRootDumpTrackInfo_db_funcmem);
void __RPRootDumpTrackInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RPRootDumpTrackInfo"), typeid(::RPRootDumpTrackInfo), sizeof(::RPRootDumpTrackInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8947, type_8949), Reflex::Literal("operator="), operator_5931, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8949), Reflex::Literal("RPRootDumpTrackInfo"), constructor_5932, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RPRootDumpTrackInfo"), constructor_5933, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RPRootDumpTrackInfo"), destructor_5934, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1905, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RPRootDumpTrackInfo_datamem_bld);
}

//------Delayed data member builder for class RPRootDumpTrackInfo -------------------
void __RPRootDumpTrackInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("valid"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, valid), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("x"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, x), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("y"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, y), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("z"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, z), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("thx"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, thx), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("thy"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, thy), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("chi2"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, chi2), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("chi2ndf"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, chi2ndf), ::Reflex::PUBLIC)
  .AddDataMember(type_198, Reflex::Literal("entries"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, entries), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("res_x"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, res_x), ::Reflex::PUBLIC)
  .AddDataMember(type_99, Reflex::Literal("res_y"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, res_y), ::Reflex::PUBLIC)
  .AddDataMember(type_2560, Reflex::Literal("u_sect"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, u_sect), ::Reflex::PUBLIC)
  .AddDataMember(type_2560, Reflex::Literal("v_sect"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, v_sect), ::Reflex::PUBLIC)
  .AddDataMember(type_68, Reflex::Literal("u_sect_no"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, u_sect_no), ::Reflex::PUBLIC)
  .AddDataMember(type_68, Reflex::Literal("v_sect_no"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, v_sect_no), ::Reflex::PUBLIC)
  .AddDataMember(type_198, Reflex::Literal("u_id"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, u_id), ::Reflex::PUBLIC)
  .AddDataMember(type_198, Reflex::Literal("v_id"), OffsetOf(__shadow__::__RPRootDumpTrackInfo, v_id), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class RPRootDumpTrackInfo -------------------
void __RPRootDumpTrackInfo_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class TotemRPEvent -------------------------------
static  void operator_5949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TotemRPEvent*)o)->operator=)(*(const ::TotemRPEvent*)arg[0]);
  else   (((::TotemRPEvent*)o)->operator=)(*(const ::TotemRPEvent*)arg[0]);
}

static void constructor_5950( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRPEvent(*(const ::TotemRPEvent*)arg[0]);
  else ::new(mem) ::TotemRPEvent(*(const ::TotemRPEvent*)arg[0]);
}

static void constructor_5951( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TotemRPEvent();
  else ::new(mem) ::TotemRPEvent();
}

static void destructor_5952(void*, void * o, const std::vector<void*>&, void *) {
(((::TotemRPEvent*)o)->::TotemRPEvent::~TotemRPEvent)();
}
static  void method_5953( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TotemRPEvent*)o)->reset)();
}

static void method_newdel_1964( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TotemRPEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TotemRPEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TotemRPEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TotemRPEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TotemRPEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TotemRPEvent -------------------------------
void __TotemRPEvent_db_datamem(Reflex::Class*);
void __TotemRPEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TotemRPEvent_datamem_bld(&__TotemRPEvent_db_datamem);
Reflex::GenreflexMemberBuilder __TotemRPEvent_funcmem_bld(&__TotemRPEvent_db_funcmem);
void __TotemRPEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TotemRPEvent"), typeid(::TotemRPEvent), sizeof(::TotemRPEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddDataMember(type_2934, Reflex::Literal("name"), (size_t)&TotemRPEvent::name, ::Reflex::PUBLIC | ::Reflex::STATIC | Reflex::STATIC)
  .AddTypedef(type_4595, Reflex::Literal("TotemRPEvent::analysis_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17844, type_17845), Reflex::Literal("operator="), operator_5949, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17845), Reflex::Literal("TotemRPEvent"), constructor_5950, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TotemRPEvent"), constructor_5951, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TotemRPEvent"), destructor_5952, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1964, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TotemRPEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TotemRPEvent_funcmem_bld);
}

//------Delayed data member builder for class TotemRPEvent -------------------
void __TotemRPEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2665, Reflex::Literal("track_info_"), OffsetOf(__shadow__::__TotemRPEvent, track_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2664, Reflex::Literal("digi_info_"), OffsetOf(__shadow__::__TotemRPEvent, digi_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2663, Reflex::Literal("par_patterns_info_"), OffsetOf(__shadow__::__TotemRPEvent, par_patterns_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2663, Reflex::Literal("nonpar_patterns_info_"), OffsetOf(__shadow__::__TotemRPEvent, nonpar_patterns_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2662, Reflex::Literal("multi_track_info_"), OffsetOf(__shadow__::__TotemRPEvent, multi_track_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2661, Reflex::Literal("rec_pr_info_"), OffsetOf(__shadow__::__TotemRPEvent, rec_pr_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_2661, Reflex::Literal("sim_pr_info_"), OffsetOf(__shadow__::__TotemRPEvent, sim_pr_info_), ::Reflex::PUBLIC)
  .AddDataMember(type_1686, Reflex::Literal("rec_pr_pair_info_"), OffsetOf(__shadow__::__TotemRPEvent, rec_pr_pair_info_), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TotemRPEvent -------------------
void __TotemRPEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("reset"), method_5953, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > -------------------------------
static void constructor_8958( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>();
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>();
}

static void constructor_8959( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(const ::std::allocator<RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(const ::std::allocator<RPRootDumpTrackInfo>*)arg[0]);
}

static void constructor_8960( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpTrackInfo*)arg[1]);
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpTrackInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpTrackInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpTrackInfo>*)arg[2]);
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpTrackInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpTrackInfo>*)arg[2]);
  }
}

static void constructor_8961( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(const ::std::vector<RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpTrackInfo>(*(const ::std::vector<RPRootDumpTrackInfo>*)arg[0]);
}

static void destructor_8962(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRootDumpTrackInfo>*)o)->::std::vector<RPRootDumpTrackInfo>::~vector)();
}
static  void operator_8963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpTrackInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpTrackInfo>*)arg[0]);
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_8964( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRootDumpTrackInfo*)arg[1]);
}

static  void method_8965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((::std::vector<RPRootDumpTrackInfo>*)o)->begin)());
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->begin)();
}

static  void method_8966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->begin)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->begin)();
}

static  void method_8967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((::std::vector<RPRootDumpTrackInfo>*)o)->end)());
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->end)();
}

static  void method_8968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->end)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->end)();
}

static  void method_8973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->size)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->size)();
}

static  void method_8974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->max_size)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->max_size)();
}

static  void method_8975( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRootDumpTrackInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRootDumpTrackInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRootDumpTrackInfo*)arg[1]);
  }
}

static  void method_8976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->capacity)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->capacity)();
}

static  void method_8977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRootDumpTrackInfo>*)o)->empty)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->empty)();
}

static  void method_8978( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpTrackInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpTrackInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpTrackInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpTrackInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpTrackInfo>*)o)->front)();
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->front)();
}

static  void method_8985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpTrackInfo>*)o)->front)();
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->front)();
}

static  void method_8986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpTrackInfo>*)o)->back)();
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->back)();
}

static  void method_8987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpTrackInfo>*)o)->back)();
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->back)();
}

static  void method_8988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRootDumpTrackInfo>*)o)->data)());
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->data)();
}

static  void method_8989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRootDumpTrackInfo>*)o)->data)());
  else   (((const ::std::vector<RPRootDumpTrackInfo>*)o)->data)();
}

static  void method_8990( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->push_back)(*(const ::RPRootDumpTrackInfo*)arg[0]);
}

static  void method_8991( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->pop_back)();
}

static  void method_8992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((::std::vector<RPRootDumpTrackInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0],
    *(const ::RPRootDumpTrackInfo*)arg[1]));
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0],
    *(const ::RPRootDumpTrackInfo*)arg[1]);
}

static  void method_8993( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRootDumpTrackInfo*)arg[2]);
}

static  void method_8994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((::std::vector<RPRootDumpTrackInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0]));
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_8995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >)((((::std::vector<RPRootDumpTrackInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[1]));
  else   (((::std::vector<RPRootDumpTrackInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpTrackInfo*,std::vector<RPRootDumpTrackInfo> >*)arg[1]);
}

static  void method_8996( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->swap)(*(::std::vector<RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_8997( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpTrackInfo>*)o)->clear)();
}

static void method_newdel_2539( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpTrackInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpTrackInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpTrackInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpTrackInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpTrackInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> >")), ::Reflex::BaseOffset< ::std::vector<RPRootDumpTrackInfo>,::std::_Vector_base<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRootDumpTrackInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRootDumpTrackInfo> >::Generate();
}

//------Dictionary for class vector<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > -------------------------------
void __std__vector_RPRootDumpTrackInfo__db_datamem(Reflex::Class*);
void __std__vector_RPRootDumpTrackInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpTrackInfo__datamem_bld(&__std__vector_RPRootDumpTrackInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpTrackInfo__funcmem_bld(&__std__vector_RPRootDumpTrackInfo__db_funcmem);
void __std__vector_RPRootDumpTrackInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRootDumpTrackInfo>"), typeid(::std::vector<RPRootDumpTrackInfo>), sizeof(::std::vector<RPRootDumpTrackInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2139, ::Reflex::BaseOffset< ::std::vector<RPRootDumpTrackInfo>, ::std::_Vector_base<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1905, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::_Alloc_value_type"))
  .AddTypedef(type_2139, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::_Base"))
  .AddTypedef(type_2721, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::_Tp_alloc_type"))
  .AddTypedef(type_5236, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::_Alloc_traits"))
  .AddTypedef(type_1905, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::value_type"))
  .AddTypedef(type_6205, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::pointer"))
  .AddTypedef(type_8945, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::const_pointer"))
  .AddTypedef(type_8947, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::reference"))
  .AddTypedef(type_8949, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::const_reference"))
  .AddTypedef(type_5141, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::iterator"))
  .AddTypedef(type_5142, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::const_iterator"))
  .AddTypedef(type_2831, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::const_reverse_iterator"))
  .AddTypedef(type_2832, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::reverse_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::difference_type"))
  .AddTypedef(type_2721, Reflex::Literal("std::vector<RPRootDumpTrackInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8958, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17924), Reflex::Literal("vector"), constructor_8959, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2700, type_8949, type_17924), Reflex::Literal("vector"), constructor_8960, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18588), Reflex::Literal("vector"), constructor_8961, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8962, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2539, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRootDumpTrackInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > -------------------
void __std__vector_RPRootDumpTrackInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRootDumpTrackInfo,std::allocator<RPRootDumpTrackInfo> > -------------------
void __std__vector_RPRootDumpTrackInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18589, type_18588), Reflex::Literal("operator="), operator_8963, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700, type_8949), Reflex::Literal("assign"), method_8964, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5141), Reflex::Literal("begin"), method_8965, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5142), Reflex::Literal("begin"), method_8966, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5141), Reflex::Literal("end"), method_8967, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5142), Reflex::Literal("end"), method_8968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_8973, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_8974, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700, type_1905), Reflex::Literal("resize"), method_8975, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("capacity"), method_8976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("empty"), method_8977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700), Reflex::Literal("reserve"), method_8978, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8947, type_2700), Reflex::Literal("operator[]"), operator_8979, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8949, type_2700), Reflex::Literal("operator[]"), operator_8980, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8947, type_2700), Reflex::Literal("at"), method_8982, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8949, type_2700), Reflex::Literal("at"), method_8983, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8947), Reflex::Literal("front"), method_8984, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8949), Reflex::Literal("front"), method_8985, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8947), Reflex::Literal("back"), method_8986, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8949), Reflex::Literal("back"), method_8987, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6205), Reflex::Literal("data"), method_8988, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8945), Reflex::Literal("data"), method_8989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_8949), Reflex::Literal("push_back"), method_8990, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("pop_back"), method_8991, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5141, type_5141, type_8949), Reflex::Literal("insert"), method_8992, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_5141, type_2700, type_8949), Reflex::Literal("insert"), method_8993, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5141, type_5141), Reflex::Literal("erase"), method_8994, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5141, type_5141, type_5141), Reflex::Literal("erase"), method_8995, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_18589), Reflex::Literal("swap"), method_8996, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_8997, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > -------------------------------
static void constructor_9023( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>();
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>();
}

static void constructor_9024( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(const ::std::allocator<RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(const ::std::allocator<RPRootDumpReconstructedProton>*)arg[0]);
}

static void constructor_9025( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpReconstructedProton*)arg[1]);
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpReconstructedProton*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpReconstructedProton*)arg[1],
      *(const ::std::allocator<RPRootDumpReconstructedProton>*)arg[2]);
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpReconstructedProton*)arg[1],
      *(const ::std::allocator<RPRootDumpReconstructedProton>*)arg[2]);
  }
}

static void constructor_9026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(const ::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpReconstructedProton>(*(const ::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
}

static void destructor_9027(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRootDumpReconstructedProton>*)o)->::std::vector<RPRootDumpReconstructedProton>::~vector)();
}
static  void operator_9028( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpReconstructedProton>*)o)->operator=)(*(const ::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->operator=)(*(const ::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_9029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRootDumpReconstructedProton*)arg[1]);
}

static  void method_9030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((::std::vector<RPRootDumpReconstructedProton>*)o)->begin)());
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->begin)();
}

static  void method_9031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->begin)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->begin)();
}

static  void method_9032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((::std::vector<RPRootDumpReconstructedProton>*)o)->end)());
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->end)();
}

static  void method_9033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->end)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->end)();
}

static  void method_9038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->size)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->size)();
}

static  void method_9039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->max_size)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->max_size)();
}

static  void method_9040( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRootDumpReconstructedProton>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRootDumpReconstructedProton>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRootDumpReconstructedProton*)arg[1]);
  }
}

static  void method_9041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->capacity)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->capacity)();
}

static  void method_9042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->empty)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->empty)();
}

static  void method_9043( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9044( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9045( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpReconstructedProton>*)o)->front)();
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->front)();
}

static  void method_9050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpReconstructedProton>*)o)->front)();
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->front)();
}

static  void method_9051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpReconstructedProton>*)o)->back)();
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->back)();
}

static  void method_9052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpReconstructedProton>*)o)->back)();
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->back)();
}

static  void method_9053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRootDumpReconstructedProton>*)o)->data)());
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->data)();
}

static  void method_9054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRootDumpReconstructedProton>*)o)->data)());
  else   (((const ::std::vector<RPRootDumpReconstructedProton>*)o)->data)();
}

static  void method_9055( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->push_back)(*(const ::RPRootDumpReconstructedProton*)arg[0]);
}

static  void method_9056( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->pop_back)();
}

static  void method_9057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((::std::vector<RPRootDumpReconstructedProton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0],
    *(const ::RPRootDumpReconstructedProton*)arg[1]));
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0],
    *(const ::RPRootDumpReconstructedProton*)arg[1]);
}

static  void method_9058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRootDumpReconstructedProton*)arg[2]);
}

static  void method_9059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((::std::vector<RPRootDumpReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0]));
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0]);
}

static  void method_9060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >)((((::std::vector<RPRootDumpReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[1]));
  else   (((::std::vector<RPRootDumpReconstructedProton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpReconstructedProton*,std::vector<RPRootDumpReconstructedProton> >*)arg[1]);
}

static  void method_9061( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->swap)(*(::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_9062( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpReconstructedProton>*)o)->clear)();
}

static void method_newdel_2540( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpReconstructedProton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpReconstructedProton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpReconstructedProton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpReconstructedProton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpReconstructedProton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> >")), ::Reflex::BaseOffset< ::std::vector<RPRootDumpReconstructedProton>,::std::_Vector_base<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRootDumpReconstructedProton> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRootDumpReconstructedProton> >::Generate();
}

//------Dictionary for class vector<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > -------------------------------
void __std__vector_RPRootDumpReconstructedProton__db_datamem(Reflex::Class*);
void __std__vector_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpReconstructedProton__datamem_bld(&__std__vector_RPRootDumpReconstructedProton__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpReconstructedProton__funcmem_bld(&__std__vector_RPRootDumpReconstructedProton__db_funcmem);
void __std__vector_RPRootDumpReconstructedProton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRootDumpReconstructedProton>"), typeid(::std::vector<RPRootDumpReconstructedProton>), sizeof(::std::vector<RPRootDumpReconstructedProton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2136, ::Reflex::BaseOffset< ::std::vector<RPRootDumpReconstructedProton>, ::std::_Vector_base<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_532, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::_Alloc_value_type"))
  .AddTypedef(type_2136, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::_Base"))
  .AddTypedef(type_2725, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::_Tp_alloc_type"))
  .AddTypedef(type_5233, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::_Alloc_traits"))
  .AddTypedef(type_532, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::value_type"))
  .AddTypedef(type_6148, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::pointer"))
  .AddTypedef(type_9010, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::const_pointer"))
  .AddTypedef(type_9012, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::reference"))
  .AddTypedef(type_9014, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::const_reference"))
  .AddTypedef(type_5135, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::iterator"))
  .AddTypedef(type_5136, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::const_iterator"))
  .AddTypedef(type_2825, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::const_reverse_iterator"))
  .AddTypedef(type_2826, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::reverse_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::difference_type"))
  .AddTypedef(type_2725, Reflex::Literal("std::vector<RPRootDumpReconstructedProton>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9023, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17885), Reflex::Literal("vector"), constructor_9024, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2700, type_9014, type_17885), Reflex::Literal("vector"), constructor_9025, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18591), Reflex::Literal("vector"), constructor_9026, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9027, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2540, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRootDumpReconstructedProton__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > -------------------
void __std__vector_RPRootDumpReconstructedProton__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRootDumpReconstructedProton,std::allocator<RPRootDumpReconstructedProton> > -------------------
void __std__vector_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18592, type_18591), Reflex::Literal("operator="), operator_9028, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700, type_9014), Reflex::Literal("assign"), method_9029, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5135), Reflex::Literal("begin"), method_9030, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5136), Reflex::Literal("begin"), method_9031, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5135), Reflex::Literal("end"), method_9032, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5136), Reflex::Literal("end"), method_9033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_9038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_9039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700, type_532), Reflex::Literal("resize"), method_9040, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("capacity"), method_9041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("empty"), method_9042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700), Reflex::Literal("reserve"), method_9043, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9012, type_2700), Reflex::Literal("operator[]"), operator_9044, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9014, type_2700), Reflex::Literal("operator[]"), operator_9045, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9012, type_2700), Reflex::Literal("at"), method_9047, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9014, type_2700), Reflex::Literal("at"), method_9048, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9012), Reflex::Literal("front"), method_9049, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9014), Reflex::Literal("front"), method_9050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9012), Reflex::Literal("back"), method_9051, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9014), Reflex::Literal("back"), method_9052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6148), Reflex::Literal("data"), method_9053, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9010), Reflex::Literal("data"), method_9054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_9014), Reflex::Literal("push_back"), method_9055, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("pop_back"), method_9056, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5135, type_5135, type_9014), Reflex::Literal("insert"), method_9057, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_5135, type_2700, type_9014), Reflex::Literal("insert"), method_9058, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5135, type_5135), Reflex::Literal("erase"), method_9059, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5135, type_5135, type_5135), Reflex::Literal("erase"), method_9060, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_18592), Reflex::Literal("swap"), method_9061, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_9062, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > -------------------------------
static void constructor_9088( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>();
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>();
}

static void constructor_9089( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(const ::std::allocator<RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(const ::std::allocator<RPRootDumpPatternInfo>*)arg[0]);
}

static void constructor_9090( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpPatternInfo*)arg[1]);
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpPatternInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpPatternInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpPatternInfo>*)arg[2]);
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpPatternInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpPatternInfo>*)arg[2]);
  }
}

static void constructor_9091( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(const ::std::vector<RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpPatternInfo>(*(const ::std::vector<RPRootDumpPatternInfo>*)arg[0]);
}

static void destructor_9092(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRootDumpPatternInfo>*)o)->::std::vector<RPRootDumpPatternInfo>::~vector)();
}
static  void operator_9093( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpPatternInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpPatternInfo>*)arg[0]);
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_9094( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRootDumpPatternInfo*)arg[1]);
}

static  void method_9095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((::std::vector<RPRootDumpPatternInfo>*)o)->begin)());
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->begin)();
}

static  void method_9096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->begin)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->begin)();
}

static  void method_9097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((::std::vector<RPRootDumpPatternInfo>*)o)->end)());
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->end)();
}

static  void method_9098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->end)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->end)();
}

static  void method_9103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->size)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->size)();
}

static  void method_9104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->max_size)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->max_size)();
}

static  void method_9105( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRootDumpPatternInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRootDumpPatternInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRootDumpPatternInfo*)arg[1]);
  }
}

static  void method_9106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->capacity)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->capacity)();
}

static  void method_9107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRootDumpPatternInfo>*)o)->empty)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->empty)();
}

static  void method_9108( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpPatternInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpPatternInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpPatternInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9113( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpPatternInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpPatternInfo>*)o)->front)();
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->front)();
}

static  void method_9115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpPatternInfo>*)o)->front)();
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->front)();
}

static  void method_9116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpPatternInfo>*)o)->back)();
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->back)();
}

static  void method_9117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpPatternInfo>*)o)->back)();
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->back)();
}

static  void method_9118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRootDumpPatternInfo>*)o)->data)());
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->data)();
}

static  void method_9119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRootDumpPatternInfo>*)o)->data)());
  else   (((const ::std::vector<RPRootDumpPatternInfo>*)o)->data)();
}

static  void method_9120( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->push_back)(*(const ::RPRootDumpPatternInfo*)arg[0]);
}

static  void method_9121( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->pop_back)();
}

static  void method_9122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((::std::vector<RPRootDumpPatternInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0],
    *(const ::RPRootDumpPatternInfo*)arg[1]));
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0],
    *(const ::RPRootDumpPatternInfo*)arg[1]);
}

static  void method_9123( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRootDumpPatternInfo*)arg[2]);
}

static  void method_9124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((::std::vector<RPRootDumpPatternInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0]));
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0]);
}

static  void method_9125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >)((((::std::vector<RPRootDumpPatternInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[1]));
  else   (((::std::vector<RPRootDumpPatternInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpPatternInfo*,std::vector<RPRootDumpPatternInfo> >*)arg[1]);
}

static  void method_9126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->swap)(*(::std::vector<RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_9127( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpPatternInfo>*)o)->clear)();
}

static void method_newdel_2541( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpPatternInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpPatternInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpPatternInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpPatternInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpPatternInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> >")), ::Reflex::BaseOffset< ::std::vector<RPRootDumpPatternInfo>,::std::_Vector_base<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRootDumpPatternInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRootDumpPatternInfo> >::Generate();
}

//------Dictionary for class vector<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > -------------------------------
void __std__vector_RPRootDumpPatternInfo__db_datamem(Reflex::Class*);
void __std__vector_RPRootDumpPatternInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpPatternInfo__datamem_bld(&__std__vector_RPRootDumpPatternInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpPatternInfo__funcmem_bld(&__std__vector_RPRootDumpPatternInfo__db_funcmem);
void __std__vector_RPRootDumpPatternInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRootDumpPatternInfo>"), typeid(::std::vector<RPRootDumpPatternInfo>), sizeof(::std::vector<RPRootDumpPatternInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2137, ::Reflex::BaseOffset< ::std::vector<RPRootDumpPatternInfo>, ::std::_Vector_base<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_579, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::_Alloc_value_type"))
  .AddTypedef(type_2137, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::_Base"))
  .AddTypedef(type_2726, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::_Tp_alloc_type"))
  .AddTypedef(type_5234, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::_Alloc_traits"))
  .AddTypedef(type_579, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::value_type"))
  .AddTypedef(type_6167, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::pointer"))
  .AddTypedef(type_9075, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::const_pointer"))
  .AddTypedef(type_9077, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::reference"))
  .AddTypedef(type_9079, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::const_reference"))
  .AddTypedef(type_5137, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::iterator"))
  .AddTypedef(type_5138, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::const_iterator"))
  .AddTypedef(type_2827, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::const_reverse_iterator"))
  .AddTypedef(type_2828, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::reverse_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::difference_type"))
  .AddTypedef(type_2726, Reflex::Literal("std::vector<RPRootDumpPatternInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9088, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17898), Reflex::Literal("vector"), constructor_9089, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2700, type_9079, type_17898), Reflex::Literal("vector"), constructor_9090, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18594), Reflex::Literal("vector"), constructor_9091, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9092, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2541, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRootDumpPatternInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > -------------------
void __std__vector_RPRootDumpPatternInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRootDumpPatternInfo,std::allocator<RPRootDumpPatternInfo> > -------------------
void __std__vector_RPRootDumpPatternInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18595, type_18594), Reflex::Literal("operator="), operator_9093, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700, type_9079), Reflex::Literal("assign"), method_9094, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5137), Reflex::Literal("begin"), method_9095, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5138), Reflex::Literal("begin"), method_9096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5137), Reflex::Literal("end"), method_9097, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5138), Reflex::Literal("end"), method_9098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_9103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_9104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700, type_579), Reflex::Literal("resize"), method_9105, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("capacity"), method_9106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("empty"), method_9107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700), Reflex::Literal("reserve"), method_9108, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9077, type_2700), Reflex::Literal("operator[]"), operator_9109, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9079, type_2700), Reflex::Literal("operator[]"), operator_9110, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9077, type_2700), Reflex::Literal("at"), method_9112, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9079, type_2700), Reflex::Literal("at"), method_9113, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9077), Reflex::Literal("front"), method_9114, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9079), Reflex::Literal("front"), method_9115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9077), Reflex::Literal("back"), method_9116, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9079), Reflex::Literal("back"), method_9117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6167), Reflex::Literal("data"), method_9118, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9075), Reflex::Literal("data"), method_9119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_9079), Reflex::Literal("push_back"), method_9120, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("pop_back"), method_9121, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5137, type_5137, type_9079), Reflex::Literal("insert"), method_9122, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_5137, type_2700, type_9079), Reflex::Literal("insert"), method_9123, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5137, type_5137), Reflex::Literal("erase"), method_9124, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5137, type_5137, type_5137), Reflex::Literal("erase"), method_9125, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_18595), Reflex::Literal("swap"), method_9126, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_9127, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > -------------------------------
static void constructor_9153( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>();
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>();
}

static void constructor_9154( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(const ::std::allocator<RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(const ::std::allocator<RPRootDumpDigiInfo>*)arg[0]);
}

static void constructor_9155( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpDigiInfo*)arg[1]);
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpDigiInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpDigiInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpDigiInfo>*)arg[2]);
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(::std::size_t*)arg[0],
      *(const ::RPRootDumpDigiInfo*)arg[1],
      *(const ::std::allocator<RPRootDumpDigiInfo>*)arg[2]);
  }
}

static void constructor_9156( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(const ::std::vector<RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::std::vector<RPRootDumpDigiInfo>(*(const ::std::vector<RPRootDumpDigiInfo>*)arg[0]);
}

static void destructor_9157(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RPRootDumpDigiInfo>*)o)->::std::vector<RPRootDumpDigiInfo>::~vector)();
}
static  void operator_9158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpDigiInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpDigiInfo>*)arg[0]);
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->operator=)(*(const ::std::vector<RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_9159( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RPRootDumpDigiInfo*)arg[1]);
}

static  void method_9160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((::std::vector<RPRootDumpDigiInfo>*)o)->begin)());
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->begin)();
}

static  void method_9161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->begin)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->begin)();
}

static  void method_9162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((::std::vector<RPRootDumpDigiInfo>*)o)->end)());
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->end)();
}

static  void method_9163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->end)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->end)();
}

static  void method_9168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->size)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->size)();
}

static  void method_9169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->max_size)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->max_size)();
}

static  void method_9170( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RPRootDumpDigiInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RPRootDumpDigiInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RPRootDumpDigiInfo*)arg[1]);
  }
}

static  void method_9171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->capacity)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->capacity)();
}

static  void method_9172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RPRootDumpDigiInfo>*)o)->empty)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->empty)();
}

static  void method_9173( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpDigiInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9175( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpDigiInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpDigiInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpDigiInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpDigiInfo>*)o)->front)();
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->front)();
}

static  void method_9180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpDigiInfo>*)o)->front)();
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->front)();
}

static  void method_9181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RPRootDumpDigiInfo>*)o)->back)();
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->back)();
}

static  void method_9182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RPRootDumpDigiInfo>*)o)->back)();
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->back)();
}

static  void method_9183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RPRootDumpDigiInfo>*)o)->data)());
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->data)();
}

static  void method_9184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RPRootDumpDigiInfo>*)o)->data)());
  else   (((const ::std::vector<RPRootDumpDigiInfo>*)o)->data)();
}

static  void method_9185( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->push_back)(*(const ::RPRootDumpDigiInfo*)arg[0]);
}

static  void method_9186( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->pop_back)();
}

static  void method_9187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((::std::vector<RPRootDumpDigiInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0],
    *(const ::RPRootDumpDigiInfo*)arg[1]));
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0],
    *(const ::RPRootDumpDigiInfo*)arg[1]);
}

static  void method_9188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RPRootDumpDigiInfo*)arg[2]);
}

static  void method_9189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((::std::vector<RPRootDumpDigiInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0]));
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0]);
}

static  void method_9190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >)((((::std::vector<RPRootDumpDigiInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[1]));
  else   (((::std::vector<RPRootDumpDigiInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RPRootDumpDigiInfo*,std::vector<RPRootDumpDigiInfo> >*)arg[1]);
}

static  void method_9191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->swap)(*(::std::vector<RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_9192( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RPRootDumpDigiInfo>*)o)->clear)();
}

static void method_newdel_2542( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpDigiInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpDigiInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpDigiInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpDigiInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RPRootDumpDigiInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> >")), ::Reflex::BaseOffset< ::std::vector<RPRootDumpDigiInfo>,::std::_Vector_base<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RPRootDumpDigiInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RPRootDumpDigiInfo> >::Generate();
}

//------Dictionary for class vector<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > -------------------------------
void __std__vector_RPRootDumpDigiInfo__db_datamem(Reflex::Class*);
void __std__vector_RPRootDumpDigiInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpDigiInfo__datamem_bld(&__std__vector_RPRootDumpDigiInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RPRootDumpDigiInfo__funcmem_bld(&__std__vector_RPRootDumpDigiInfo__db_funcmem);
void __std__vector_RPRootDumpDigiInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RPRootDumpDigiInfo>"), typeid(::std::vector<RPRootDumpDigiInfo>), sizeof(::std::vector<RPRootDumpDigiInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2138, ::Reflex::BaseOffset< ::std::vector<RPRootDumpDigiInfo>, ::std::_Vector_base<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_949, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::_Alloc_value_type"))
  .AddTypedef(type_2138, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::_Base"))
  .AddTypedef(type_2727, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::_Tp_alloc_type"))
  .AddTypedef(type_5235, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::_Alloc_traits"))
  .AddTypedef(type_949, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::value_type"))
  .AddTypedef(type_6186, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::pointer"))
  .AddTypedef(type_9140, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::const_pointer"))
  .AddTypedef(type_9142, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::reference"))
  .AddTypedef(type_9144, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::const_reference"))
  .AddTypedef(type_5139, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::iterator"))
  .AddTypedef(type_5140, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::const_iterator"))
  .AddTypedef(type_2829, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::const_reverse_iterator"))
  .AddTypedef(type_2830, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::reverse_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::difference_type"))
  .AddTypedef(type_2727, Reflex::Literal("std::vector<RPRootDumpDigiInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9153, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17911), Reflex::Literal("vector"), constructor_9154, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2700, type_9144, type_17911), Reflex::Literal("vector"), constructor_9155, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18597), Reflex::Literal("vector"), constructor_9156, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9157, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2542, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RPRootDumpDigiInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > -------------------
void __std__vector_RPRootDumpDigiInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RPRootDumpDigiInfo,std::allocator<RPRootDumpDigiInfo> > -------------------
void __std__vector_RPRootDumpDigiInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18598, type_18597), Reflex::Literal("operator="), operator_9158, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700, type_9144), Reflex::Literal("assign"), method_9159, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5139), Reflex::Literal("begin"), method_9160, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5140), Reflex::Literal("begin"), method_9161, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5139), Reflex::Literal("end"), method_9162, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5140), Reflex::Literal("end"), method_9163, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_9168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_9169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700, type_949), Reflex::Literal("resize"), method_9170, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("capacity"), method_9171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("empty"), method_9172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2700), Reflex::Literal("reserve"), method_9173, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9142, type_2700), Reflex::Literal("operator[]"), operator_9174, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9144, type_2700), Reflex::Literal("operator[]"), operator_9175, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9142, type_2700), Reflex::Literal("at"), method_9177, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9144, type_2700), Reflex::Literal("at"), method_9178, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9142), Reflex::Literal("front"), method_9179, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9144), Reflex::Literal("front"), method_9180, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9142), Reflex::Literal("back"), method_9181, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9144), Reflex::Literal("back"), method_9182, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6186), Reflex::Literal("data"), method_9183, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9140), Reflex::Literal("data"), method_9184, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_9144), Reflex::Literal("push_back"), method_9185, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("pop_back"), method_9186, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5139, type_5139, type_9144), Reflex::Literal("insert"), method_9187, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_5139, type_2700, type_9144), Reflex::Literal("insert"), method_9188, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5139, type_5139), Reflex::Literal("erase"), method_9189, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5139, type_5139, type_5139), Reflex::Literal("erase"), method_9190, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_18598), Reflex::Literal("swap"), method_9191, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_9192, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<unsigned int,RPRootDumpReconstructedProton,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > -------------------------------
static void destructor_10602(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->::std::map<unsigned int,RPRootDumpReconstructedProton>::~map)();
}
static void constructor_10603( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>();
  else ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>();
}

static void constructor_10604( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[1]);
  }
}

static void constructor_10605( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpReconstructedProton>(*(const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
}

static  void operator_10606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_10607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->get_allocator)();
}

static  void method_10608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->begin)());
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->begin)();
}

static  void method_10609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->begin)();
}

static  void method_10610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->end)());
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->end)();
}

static  void method_10611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->end)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->end)();
}

static  void method_10616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->empty)();
}

static  void method_10617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->size)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->size)();
}

static  void method_10618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->max_size)();
}

static  void operator_10619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_10620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10621( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10622( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,bool>)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpReconstructedProton>*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_10623( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpReconstructedProton>*)arg[1]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpReconstructedProton>*)arg[1]);
}

static  void method_10624( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[0]);
}

static  void method_10625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_10626( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >*)arg[1]);
}

static  void method_10627( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->swap)(*(::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_10628( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->clear)();
}

static  void method_10629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->key_comp)();
}

static  void method_10631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_10634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10636( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >)((((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_10639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpReconstructedProton> > >)((((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpReconstructedProton>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2661( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpReconstructedProton> >::Generate();
}

//------Dictionary for class map<unsigned int,RPRootDumpReconstructedProton,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > -------------------------------
void __std__map_unsignedsint_RPRootDumpReconstructedProton__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpReconstructedProton__datamem_bld(&__std__map_unsignedsint_RPRootDumpReconstructedProton__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpReconstructedProton__funcmem_bld(&__std__map_unsignedsint_RPRootDumpReconstructedProton__db_funcmem);
void __std__map_unsignedsint_RPRootDumpReconstructedProton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>"), typeid(::std::map<unsigned int,RPRootDumpReconstructedProton>), sizeof(::std::map<unsigned int,RPRootDumpReconstructedProton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_198, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::key_type"))
  .AddTypedef(type_532, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::mapped_type"))
  .AddTypedef(type_2486, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::value_type"))
  .AddTypedef(type_2258, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::key_compare"))
  .AddTypedef(type_2719, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::allocator_type"))
  .AddTypedef(type_2486, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::_Alloc_value_type"))
  .AddTypedef(type_2719, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::_Pair_alloc_type"))
  .AddTypedef(type_2301, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::_Rep_type"))
  .AddTypedef(type_7390, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::pointer"))
  .AddTypedef(type_7392, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::const_pointer"))
  .AddTypedef(type_7394, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::reference"))
  .AddTypedef(type_7396, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::const_reference"))
  .AddTypedef(type_2609, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::iterator"))
  .AddTypedef(type_2702, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::const_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::difference_type"))
  .AddTypedef(type_2864, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::reverse_iterator"))
  .AddTypedef(type_2863, Reflex::Literal("std::map<unsigned int,RPRootDumpReconstructedProton>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_10602, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_10603, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18317, type_18389), Reflex::Literal("map"), constructor_10604, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18749), Reflex::Literal("map"), constructor_10605, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2661, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RPRootDumpReconstructedProton__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RPRootDumpReconstructedProton__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RPRootDumpReconstructedProton,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > -------------------
void __std__map_unsignedsint_RPRootDumpReconstructedProton__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RPRootDumpReconstructedProton_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RPRootDumpReconstructedProton,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > -------------------
void __std__map_unsignedsint_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18750, type_18749), Reflex::Literal("operator="), operator_10606, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2719), Reflex::Literal("get_allocator"), method_10607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609), Reflex::Literal("begin"), method_10608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702), Reflex::Literal("begin"), method_10609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609), Reflex::Literal("end"), method_10610, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702), Reflex::Literal("end"), method_10611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("empty"), method_10616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_10617, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_10618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9012, type_18318), Reflex::Literal("operator[]"), operator_10619, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9012, type_18318), Reflex::Literal("at"), method_10620, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9014, type_18318), Reflex::Literal("at"), method_10621, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2495, type_7396), Reflex::Literal("insert"), method_10622, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609, type_2609, type_7396), Reflex::Literal("insert"), method_10623, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2609), Reflex::Literal("erase"), method_10624, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18318), Reflex::Literal("erase"), method_10625, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2609, type_2609), Reflex::Literal("erase"), method_10626, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_18750), Reflex::Literal("swap"), method_10627, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_10628, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2258), Reflex::Literal("key_comp"), method_10629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609, type_18318), Reflex::Literal("find"), method_10631, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702, type_18318), Reflex::Literal("find"), method_10632, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18318), Reflex::Literal("count"), method_10633, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609, type_18318), Reflex::Literal("lower_bound"), method_10634, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702, type_18318), Reflex::Literal("lower_bound"), method_10635, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2609, type_18318), Reflex::Literal("upper_bound"), method_10636, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702, type_18318), Reflex::Literal("upper_bound"), method_10637, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2494, type_18318), Reflex::Literal("equal_range"), method_10638, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2493, type_18318), Reflex::Literal("equal_range"), method_10639, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > -------------------------------
static void destructor_10660(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::~map)();
}
static void constructor_10661( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >();
  else ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >();
}

static void constructor_10662( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[1]);
  }
}

static void constructor_10663( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >(*(const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void operator_10664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_10665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->get_allocator)();
}

static  void method_10666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->begin)();
}

static  void method_10667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->begin)();
}

static  void method_10668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->end)();
}

static  void method_10669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->end)();
}

static  void method_10674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->empty)();
}

static  void method_10675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->size)();
}

static  void method_10676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->max_size)();
}

static  void operator_10677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_10678( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10680( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,bool>)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_10681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[1]);
}

static  void method_10682( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0]);
}

static  void method_10683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_10684( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[1]);
}

static  void method_10685( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->swap)(*(::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_10686( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->clear)();
}

static  void method_10687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->key_comp)();
}

static  void method_10689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10691( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_10692( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10693( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10694( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >)((((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_10697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<RPRootDumpTrackInfo> > > >)((((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2662( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > -------------------------------
void __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__datamem_bld(&__std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__funcmem_bld(&__std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_funcmem);
void __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >"), typeid(::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >), sizeof(::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_198, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::key_type"))
  .AddTypedef(type_2539, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::mapped_type"))
  .AddTypedef(type_2487, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::value_type"))
  .AddTypedef(type_2258, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::key_compare"))
  .AddTypedef(type_2720, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::allocator_type"))
  .AddTypedef(type_2487, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::_Alloc_value_type"))
  .AddTypedef(type_2720, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::_Pair_alloc_type"))
  .AddTypedef(type_2302, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::_Rep_type"))
  .AddTypedef(type_7499, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::pointer"))
  .AddTypedef(type_7501, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::const_pointer"))
  .AddTypedef(type_7503, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::reference"))
  .AddTypedef(type_7505, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::const_reference"))
  .AddTypedef(type_2610, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::iterator"))
  .AddTypedef(type_2703, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::const_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::difference_type"))
  .AddTypedef(type_2866, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::reverse_iterator"))
  .AddTypedef(type_2865, Reflex::Literal("std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_10660, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_10661, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18317, type_18397), Reflex::Literal("map"), constructor_10662, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18751), Reflex::Literal("map"), constructor_10663, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2662, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2302, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > -------------------
void __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18752, type_18751), Reflex::Literal("operator="), operator_10664, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2720), Reflex::Literal("get_allocator"), method_10665, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2610), Reflex::Literal("begin"), method_10666, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703), Reflex::Literal("begin"), method_10667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2610), Reflex::Literal("end"), method_10668, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703), Reflex::Literal("end"), method_10669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("empty"), method_10674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_10675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_10676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18589, type_18318), Reflex::Literal("operator[]"), operator_10677, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18589, type_18318), Reflex::Literal("at"), method_10678, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18588, type_18318), Reflex::Literal("at"), method_10679, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2499, type_7505), Reflex::Literal("insert"), method_10680, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2610, type_2610, type_7505), Reflex::Literal("insert"), method_10681, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2610), Reflex::Literal("erase"), method_10682, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18318), Reflex::Literal("erase"), method_10683, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2610, type_2610), Reflex::Literal("erase"), method_10684, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_18752), Reflex::Literal("swap"), method_10685, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_10686, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2258), Reflex::Literal("key_comp"), method_10687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2610, type_18318), Reflex::Literal("find"), method_10689, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703, type_18318), Reflex::Literal("find"), method_10690, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18318), Reflex::Literal("count"), method_10691, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2610, type_18318), Reflex::Literal("lower_bound"), method_10692, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703, type_18318), Reflex::Literal("lower_bound"), method_10693, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2610, type_18318), Reflex::Literal("upper_bound"), method_10694, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2703, type_18318), Reflex::Literal("upper_bound"), method_10695, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2498, type_18318), Reflex::Literal("equal_range"), method_10696, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2497, type_18318), Reflex::Literal("equal_range"), method_10697, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,RPRootDumpPatternInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > -------------------------------
static void destructor_10718(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->::std::map<unsigned int,RPRootDumpPatternInfo>::~map)();
}
static void constructor_10719( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>();
  else ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>();
}

static void constructor_10720( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[1]);
  }
}

static void constructor_10721( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpPatternInfo>(*(const ::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
}

static  void operator_10722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_10723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->get_allocator)();
}

static  void method_10724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->begin)());
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->begin)();
}

static  void method_10725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->begin)();
}

static  void method_10726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->end)());
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->end)();
}

static  void method_10727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->end)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->end)();
}

static  void method_10732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->empty)();
}

static  void method_10733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->size)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->size)();
}

static  void method_10734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->max_size)();
}

static  void operator_10735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_10736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10737( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,bool>)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpPatternInfo>*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_10739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpPatternInfo>*)arg[1]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpPatternInfo>*)arg[1]);
}

static  void method_10740( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[0]);
}

static  void method_10741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_10742( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >*)arg[1]);
}

static  void method_10743( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->swap)(*(::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_10744( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->clear)();
}

static  void method_10745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->key_comp)();
}

static  void method_10747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_10750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10751( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >)((((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_10755( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpPatternInfo> > >)((((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpPatternInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2663( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpPatternInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpPatternInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpPatternInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpPatternInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpPatternInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpPatternInfo> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpPatternInfo> >::Generate();
}

//------Dictionary for class map<unsigned int,RPRootDumpPatternInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > -------------------------------
void __std__map_unsignedsint_RPRootDumpPatternInfo__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RPRootDumpPatternInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpPatternInfo__datamem_bld(&__std__map_unsignedsint_RPRootDumpPatternInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpPatternInfo__funcmem_bld(&__std__map_unsignedsint_RPRootDumpPatternInfo__db_funcmem);
void __std__map_unsignedsint_RPRootDumpPatternInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>"), typeid(::std::map<unsigned int,RPRootDumpPatternInfo>), sizeof(::std::map<unsigned int,RPRootDumpPatternInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_198, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::key_type"))
  .AddTypedef(type_579, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::mapped_type"))
  .AddTypedef(type_2488, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::value_type"))
  .AddTypedef(type_2258, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::key_compare"))
  .AddTypedef(type_2722, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::allocator_type"))
  .AddTypedef(type_2488, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::_Alloc_value_type"))
  .AddTypedef(type_2722, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::_Pair_alloc_type"))
  .AddTypedef(type_2303, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::_Rep_type"))
  .AddTypedef(type_7608, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::pointer"))
  .AddTypedef(type_7610, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::const_pointer"))
  .AddTypedef(type_7612, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::reference"))
  .AddTypedef(type_7614, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::const_reference"))
  .AddTypedef(type_2611, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::iterator"))
  .AddTypedef(type_2704, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::const_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::difference_type"))
  .AddTypedef(type_2868, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::reverse_iterator"))
  .AddTypedef(type_2867, Reflex::Literal("std::map<unsigned int,RPRootDumpPatternInfo>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_10718, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_10719, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18317, type_18404), Reflex::Literal("map"), constructor_10720, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18753), Reflex::Literal("map"), constructor_10721, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2663, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RPRootDumpPatternInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RPRootDumpPatternInfo__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RPRootDumpPatternInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpPatternInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2303, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RPRootDumpPatternInfo_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RPRootDumpPatternInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpPatternInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18754, type_18753), Reflex::Literal("operator="), operator_10722, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2722), Reflex::Literal("get_allocator"), method_10723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2611), Reflex::Literal("begin"), method_10724, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704), Reflex::Literal("begin"), method_10725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2611), Reflex::Literal("end"), method_10726, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704), Reflex::Literal("end"), method_10727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("empty"), method_10732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_10733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_10734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9077, type_18318), Reflex::Literal("operator[]"), operator_10735, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9077, type_18318), Reflex::Literal("at"), method_10736, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9079, type_18318), Reflex::Literal("at"), method_10737, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2502, type_7614), Reflex::Literal("insert"), method_10738, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2611, type_2611, type_7614), Reflex::Literal("insert"), method_10739, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2611), Reflex::Literal("erase"), method_10740, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18318), Reflex::Literal("erase"), method_10741, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2611, type_2611), Reflex::Literal("erase"), method_10742, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_18754), Reflex::Literal("swap"), method_10743, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_10744, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2258), Reflex::Literal("key_comp"), method_10745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2611, type_18318), Reflex::Literal("find"), method_10747, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704, type_18318), Reflex::Literal("find"), method_10748, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18318), Reflex::Literal("count"), method_10749, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2611, type_18318), Reflex::Literal("lower_bound"), method_10750, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704, type_18318), Reflex::Literal("lower_bound"), method_10751, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2611, type_18318), Reflex::Literal("upper_bound"), method_10752, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704, type_18318), Reflex::Literal("upper_bound"), method_10753, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2501, type_18318), Reflex::Literal("equal_range"), method_10754, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2500, type_18318), Reflex::Literal("equal_range"), method_10755, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,RPRootDumpDigiInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > -------------------------------
static void destructor_10776(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->::std::map<unsigned int,RPRootDumpDigiInfo>::~map)();
}
static void constructor_10777( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>();
  else ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>();
}

static void constructor_10778( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[1]);
  }
}

static void constructor_10779( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpDigiInfo>(*(const ::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
}

static  void operator_10780( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_10781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->get_allocator)();
}

static  void method_10782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->begin)());
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->begin)();
}

static  void method_10783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->begin)();
}

static  void method_10784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->end)());
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->end)();
}

static  void method_10785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->end)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->end)();
}

static  void method_10790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->empty)();
}

static  void method_10791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->size)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->size)();
}

static  void method_10792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->max_size)();
}

static  void operator_10793( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_10794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,bool>)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpDigiInfo>*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_10797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpDigiInfo>*)arg[1]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpDigiInfo>*)arg[1]);
}

static  void method_10798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[0]);
}

static  void method_10799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_10800( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >*)arg[1]);
}

static  void method_10801( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->swap)(*(::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_10802( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->clear)();
}

static  void method_10803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->key_comp)();
}

static  void method_10805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_10808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10810( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >)((((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_10813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpDigiInfo> > >)((((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpDigiInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2664( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpDigiInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpDigiInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpDigiInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpDigiInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpDigiInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpDigiInfo> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpDigiInfo> >::Generate();
}

//------Dictionary for class map<unsigned int,RPRootDumpDigiInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > -------------------------------
void __std__map_unsignedsint_RPRootDumpDigiInfo__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RPRootDumpDigiInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpDigiInfo__datamem_bld(&__std__map_unsignedsint_RPRootDumpDigiInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpDigiInfo__funcmem_bld(&__std__map_unsignedsint_RPRootDumpDigiInfo__db_funcmem);
void __std__map_unsignedsint_RPRootDumpDigiInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>"), typeid(::std::map<unsigned int,RPRootDumpDigiInfo>), sizeof(::std::map<unsigned int,RPRootDumpDigiInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_198, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::key_type"))
  .AddTypedef(type_949, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::mapped_type"))
  .AddTypedef(type_2489, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::value_type"))
  .AddTypedef(type_2258, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::key_compare"))
  .AddTypedef(type_2723, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::allocator_type"))
  .AddTypedef(type_2489, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::_Alloc_value_type"))
  .AddTypedef(type_2723, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::_Pair_alloc_type"))
  .AddTypedef(type_2304, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::_Rep_type"))
  .AddTypedef(type_7717, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::pointer"))
  .AddTypedef(type_7719, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::const_pointer"))
  .AddTypedef(type_7721, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::reference"))
  .AddTypedef(type_7723, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::const_reference"))
  .AddTypedef(type_2612, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::iterator"))
  .AddTypedef(type_2705, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::const_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::difference_type"))
  .AddTypedef(type_2870, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::reverse_iterator"))
  .AddTypedef(type_2869, Reflex::Literal("std::map<unsigned int,RPRootDumpDigiInfo>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_10776, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_10777, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18317, type_18411), Reflex::Literal("map"), constructor_10778, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18755), Reflex::Literal("map"), constructor_10779, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2664, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RPRootDumpDigiInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RPRootDumpDigiInfo__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RPRootDumpDigiInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpDigiInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2304, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RPRootDumpDigiInfo_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RPRootDumpDigiInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpDigiInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18756, type_18755), Reflex::Literal("operator="), operator_10780, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2723), Reflex::Literal("get_allocator"), method_10781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2612), Reflex::Literal("begin"), method_10782, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2705), Reflex::Literal("begin"), method_10783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2612), Reflex::Literal("end"), method_10784, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2705), Reflex::Literal("end"), method_10785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("empty"), method_10790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_10791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_10792, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9142, type_18318), Reflex::Literal("operator[]"), operator_10793, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9142, type_18318), Reflex::Literal("at"), method_10794, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9144, type_18318), Reflex::Literal("at"), method_10795, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2505, type_7723), Reflex::Literal("insert"), method_10796, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2612, type_2612, type_7723), Reflex::Literal("insert"), method_10797, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2612), Reflex::Literal("erase"), method_10798, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18318), Reflex::Literal("erase"), method_10799, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2612, type_2612), Reflex::Literal("erase"), method_10800, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_18756), Reflex::Literal("swap"), method_10801, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_10802, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2258), Reflex::Literal("key_comp"), method_10803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2612, type_18318), Reflex::Literal("find"), method_10805, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2705, type_18318), Reflex::Literal("find"), method_10806, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18318), Reflex::Literal("count"), method_10807, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2612, type_18318), Reflex::Literal("lower_bound"), method_10808, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2705, type_18318), Reflex::Literal("lower_bound"), method_10809, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2612, type_18318), Reflex::Literal("upper_bound"), method_10810, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2705, type_18318), Reflex::Literal("upper_bound"), method_10811, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504, type_18318), Reflex::Literal("equal_range"), method_10812, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2503, type_18318), Reflex::Literal("equal_range"), method_10813, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,RPRootDumpTrackInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > -------------------------------
static void destructor_10834(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->::std::map<unsigned int,RPRootDumpTrackInfo>::~map)();
}
static void constructor_10835( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>();
  else ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>();
}

static void constructor_10836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[1]);
  }
}

static void constructor_10837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,RPRootDumpTrackInfo>(*(const ::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
}

static  void operator_10838( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->operator=)(*(const ::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_10839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->get_allocator)();
}

static  void method_10840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->begin)());
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->begin)();
}

static  void method_10841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->begin)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->begin)();
}

static  void method_10842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->end)());
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->end)();
}

static  void method_10843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->end)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->end)();
}

static  void method_10848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->empty)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->empty)();
}

static  void method_10849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->size)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->size)();
}

static  void method_10850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->max_size)();
}

static  void operator_10851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_10852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_10854( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,bool>)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpTrackInfo>*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->insert)(*(const ::std::pair<const unsigned int,RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_10855( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpTrackInfo>*)arg[1]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[0],
    *(const ::std::pair<const unsigned int,RPRootDumpTrackInfo>*)arg[1]);
}

static  void method_10856( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_10857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_10858( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >*)arg[1]);
}

static  void method_10859( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->swap)(*(::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_10860( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->clear)();
}

static  void method_10861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->key_comp)();
}

static  void method_10863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_10865( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_10866( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10867( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10868( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_10870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::_Rb_tree_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >)((((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_10871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,RPRootDumpTrackInfo> > >)((((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,RPRootDumpTrackInfo>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_2665( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpTrackInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpTrackInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpTrackInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpTrackInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,RPRootDumpTrackInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpTrackInfo> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,RPRootDumpTrackInfo> >::Generate();
}

//------Dictionary for class map<unsigned int,RPRootDumpTrackInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > -------------------------------
void __std__map_unsignedsint_RPRootDumpTrackInfo__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_RPRootDumpTrackInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpTrackInfo__datamem_bld(&__std__map_unsignedsint_RPRootDumpTrackInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_RPRootDumpTrackInfo__funcmem_bld(&__std__map_unsignedsint_RPRootDumpTrackInfo__db_funcmem);
void __std__map_unsignedsint_RPRootDumpTrackInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>"), typeid(::std::map<unsigned int,RPRootDumpTrackInfo>), sizeof(::std::map<unsigned int,RPRootDumpTrackInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_198, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::key_type"))
  .AddTypedef(type_1905, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::mapped_type"))
  .AddTypedef(type_2490, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::value_type"))
  .AddTypedef(type_2258, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::key_compare"))
  .AddTypedef(type_2724, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::allocator_type"))
  .AddTypedef(type_2490, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::_Alloc_value_type"))
  .AddTypedef(type_2724, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::_Pair_alloc_type"))
  .AddTypedef(type_2305, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::_Rep_type"))
  .AddTypedef(type_7826, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::pointer"))
  .AddTypedef(type_7828, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::const_pointer"))
  .AddTypedef(type_7830, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::reference"))
  .AddTypedef(type_7832, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::const_reference"))
  .AddTypedef(type_2613, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::iterator"))
  .AddTypedef(type_2706, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::const_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::size_type"))
  .AddTypedef(type_2635, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::difference_type"))
  .AddTypedef(type_2872, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::reverse_iterator"))
  .AddTypedef(type_2871, Reflex::Literal("std::map<unsigned int,RPRootDumpTrackInfo>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_10834, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_10835, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18317, type_18418), Reflex::Literal("map"), constructor_10836, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18757), Reflex::Literal("map"), constructor_10837, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2665, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_RPRootDumpTrackInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_RPRootDumpTrackInfo__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,RPRootDumpTrackInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpTrackInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2305, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_RPRootDumpTrackInfo_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,RPRootDumpTrackInfo,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > -------------------
void __std__map_unsignedsint_RPRootDumpTrackInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18758, type_18757), Reflex::Literal("operator="), operator_10838, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2724), Reflex::Literal("get_allocator"), method_10839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2613), Reflex::Literal("begin"), method_10840, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2706), Reflex::Literal("begin"), method_10841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2613), Reflex::Literal("end"), method_10842, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2706), Reflex::Literal("end"), method_10843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("empty"), method_10848, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("size"), method_10849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("max_size"), method_10850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8947, type_18318), Reflex::Literal("operator[]"), operator_10851, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8947, type_18318), Reflex::Literal("at"), method_10852, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8949, type_18318), Reflex::Literal("at"), method_10853, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2508, type_7832), Reflex::Literal("insert"), method_10854, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2613, type_2613, type_7832), Reflex::Literal("insert"), method_10855, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2613), Reflex::Literal("erase"), method_10856, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18318), Reflex::Literal("erase"), method_10857, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_2613, type_2613), Reflex::Literal("erase"), method_10858, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_18758), Reflex::Literal("swap"), method_10859, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580), Reflex::Literal("clear"), method_10860, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2258), Reflex::Literal("key_comp"), method_10861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2613, type_18318), Reflex::Literal("find"), method_10863, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2706, type_18318), Reflex::Literal("find"), method_10864, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700, type_18318), Reflex::Literal("count"), method_10865, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2613, type_18318), Reflex::Literal("lower_bound"), method_10866, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2706, type_18318), Reflex::Literal("lower_bound"), method_10867, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2613, type_18318), Reflex::Literal("upper_bound"), method_10868, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2706, type_18318), Reflex::Literal("upper_bound"), method_10869, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2507, type_18318), Reflex::Literal("equal_range"), method_10870, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2506, type_18318), Reflex::Literal("equal_range"), method_10871, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, RPRootDumpReconstructedProton, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > > -------------------------------
static void constructor_13705( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >();
}

static void constructor_13706( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpReconstructedProton> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpReconstructedProton> >*)arg[0]);
}

static void destructor_13707(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >::~Wrapper)();
}
static  void method_13708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->product)();
}

static  void operator_13709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->operator->)();
}

static  void method_13710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->productTypeInfo)();
}

static  void method_13711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->typeInfo)();
}

static void constructor_13712( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >((::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >((::std::map<unsigned int,RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_13713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->getInterface)();
}

static  void method_13714( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13715( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13716( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo)();
}

static  void method_13718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->isPresent)();
}

static  void method_13719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3396( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, RPRootDumpReconstructedProton, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >"), typeid(::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >), sizeof(::edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2661, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >::value_type"))
  .AddTypedef(type_2661, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13705, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2352), Reflex::Literal("Wrapper"), constructor_13706, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13707, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20498), Reflex::Literal("Wrapper"), constructor_13712, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3396, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, RPRootDumpReconstructedProton, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2661, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, RPRootDumpReconstructedProton, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpReconstructedProton> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20497), Reflex::Literal("product"), method_13708, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20497), Reflex::Literal("operator->"), operator_13709, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13710, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13711, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20499), Reflex::Literal("getInterface"), method_13713, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13714, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13715, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13716, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13719, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > > -------------------------------
static void constructor_13726( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >();
}

static void constructor_13727( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >(*(::std::auto_ptr<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >(*(::std::auto_ptr<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)arg[0]);
}

static void destructor_13728(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::~Wrapper)();
}
static  void method_13729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->product)();
}

static  void operator_13730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->operator->)();
}

static  void method_13731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->productTypeInfo)();
}

static  void method_13732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->typeInfo)();
}

static void constructor_13733( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >((::std::map<unsigned int,std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static  void method_13734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->getInterface)();
}

static  void method_13735( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13737( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->dynamicTypeInfo)();
}

static  void method_13739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->isPresent)();
}

static  void method_13740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3397( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >"), typeid(::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >), sizeof(::edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2662, Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::value_type"))
  .AddTypedef(type_2662, Reflex::Literal("edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13726, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2353), Reflex::Literal("Wrapper"), constructor_13727, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13728, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20503), Reflex::Literal("Wrapper"), constructor_13733, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3397, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2662, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> >, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20502), Reflex::Literal("product"), method_13729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20502), Reflex::Literal("operator->"), operator_13730, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13731, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13732, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20504), Reflex::Literal("getInterface"), method_13734, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13735, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13736, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13737, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, RPRootDumpPatternInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > > -------------------------------
static void constructor_13747( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >();
}

static void constructor_13748( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpPatternInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpPatternInfo> >*)arg[0]);
}

static void destructor_13749(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >::~Wrapper)();
}
static  void method_13750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->product)();
}

static  void operator_13751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->operator->)();
}

static  void method_13752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->productTypeInfo)();
}

static  void method_13753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->typeInfo)();
}

static void constructor_13754( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >((::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >((::std::map<unsigned int,RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_13755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->getInterface)();
}

static  void method_13756( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13757( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13758( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->isPresent)();
}

static  void method_13761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3398( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, RPRootDumpPatternInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >"), typeid(::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >), sizeof(::edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2663, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >::value_type"))
  .AddTypedef(type_2663, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13747, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2354), Reflex::Literal("Wrapper"), constructor_13748, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13749, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20508), Reflex::Literal("Wrapper"), constructor_13754, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3398, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, RPRootDumpPatternInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2663, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, RPRootDumpPatternInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpPatternInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20507), Reflex::Literal("product"), method_13750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20507), Reflex::Literal("operator->"), operator_13751, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13752, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13753, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20509), Reflex::Literal("getInterface"), method_13755, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13756, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13757, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13758, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13759, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13760, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, RPRootDumpDigiInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > > -------------------------------
static void constructor_13768( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >();
}

static void constructor_13769( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpDigiInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpDigiInfo> >*)arg[0]);
}

static void destructor_13770(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >::~Wrapper)();
}
static  void method_13771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->product)();
}

static  void operator_13772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->operator->)();
}

static  void method_13773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->productTypeInfo)();
}

static  void method_13774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->typeInfo)();
}

static void constructor_13775( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >((::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >((::std::map<unsigned int,RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_13776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->getInterface)();
}

static  void method_13777( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13778( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13779( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->isPresent)();
}

static  void method_13782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3399( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, RPRootDumpDigiInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >"), typeid(::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >), sizeof(::edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2664, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >::value_type"))
  .AddTypedef(type_2664, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13768, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2355), Reflex::Literal("Wrapper"), constructor_13769, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13770, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20513), Reflex::Literal("Wrapper"), constructor_13775, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3399, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, RPRootDumpDigiInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2664, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, RPRootDumpDigiInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpDigiInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20512), Reflex::Literal("product"), method_13771, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20512), Reflex::Literal("operator->"), operator_13772, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13773, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13774, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20514), Reflex::Literal("getInterface"), method_13776, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13777, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13778, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13779, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::map<unsigned int, RPRootDumpTrackInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > > -------------------------------
static void constructor_13789( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >();
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >();
}

static void constructor_13790( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpTrackInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >(*(::std::auto_ptr<std::map<unsigned int,RPRootDumpTrackInfo> >*)arg[0]);
}

static void destructor_13791(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >::~Wrapper)();
}
static  void method_13792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->product)();
}

static  void operator_13793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->operator->)();
}

static  void method_13794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->productTypeInfo)();
}

static  void method_13795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->typeInfo)();
}

static void constructor_13796( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >((::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >((::std::map<unsigned int,RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_13797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->getInterface)();
}

static  void method_13798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13799( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13800( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->isPresent)();
}

static  void method_13803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3400( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::map<unsigned int, RPRootDumpTrackInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > > -------------------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__datamem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__funcmem_bld(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_funcmem);
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >"), typeid(::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >), sizeof(::edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2665, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >::value_type"))
  .AddTypedef(type_2665, Reflex::Literal("edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13789, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2356), Reflex::Literal("Wrapper"), constructor_13790, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13791, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20518), Reflex::Literal("Wrapper"), constructor_13796, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3400, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::map<unsigned int, RPRootDumpTrackInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2665, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::map<unsigned int, RPRootDumpTrackInfo, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, RPRootDumpTrackInfo> > > > -------------------
void __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20517), Reflex::Literal("product"), method_13792, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20517), Reflex::Literal("operator->"), operator_13793, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13794, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13795, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20519), Reflex::Literal("getInterface"), method_13797, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13798, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13799, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13800, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<RPRootDumpReconstructedProton, std::allocator<RPRootDumpReconstructedProton> > > -------------------------------
static void constructor_13810( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >();
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >();
}

static void constructor_13811( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >(*(::std::auto_ptr<std::vector<RPRootDumpReconstructedProton> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >(*(::std::auto_ptr<std::vector<RPRootDumpReconstructedProton> >*)arg[0]);
}

static void destructor_13812(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >::~Wrapper)();
}
static  void method_13813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->product)();
}

static  void operator_13814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->operator->)();
}

static  void method_13815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->productTypeInfo)();
}

static  void method_13816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->typeInfo)();
}

static void constructor_13817( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >((::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >((::std::vector<RPRootDumpReconstructedProton>*)arg[0]);
}

static  void method_13818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->getInterface)();
}

static  void method_13819( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13821( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo)();
}

static  void method_13823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->isPresent)();
}

static  void method_13824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3401( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<RPRootDumpReconstructedProton, std::allocator<RPRootDumpReconstructedProton> > > -------------------------------
void __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__datamem_bld(&__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__funcmem_bld(&__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_funcmem);
void __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >"), typeid(::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >), sizeof(::edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2540, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >::value_type"))
  .AddTypedef(type_2540, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpReconstructedProton> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13810, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2357), Reflex::Literal("Wrapper"), constructor_13811, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13812, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20523), Reflex::Literal("Wrapper"), constructor_13817, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3401, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<RPRootDumpReconstructedProton, std::allocator<RPRootDumpReconstructedProton> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2540, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<RPRootDumpReconstructedProton, std::allocator<RPRootDumpReconstructedProton> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20522), Reflex::Literal("product"), method_13813, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20522), Reflex::Literal("operator->"), operator_13814, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13815, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13816, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20524), Reflex::Literal("getInterface"), method_13818, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13819, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13820, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13821, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13823, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13824, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<RPRootDumpPatternInfo, std::allocator<RPRootDumpPatternInfo> > > -------------------------------
static void constructor_13831( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >();
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >();
}

static void constructor_13832( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpPatternInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpPatternInfo> >*)arg[0]);
}

static void destructor_13833(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >::~Wrapper)();
}
static  void method_13834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->product)();
}

static  void operator_13835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->operator->)();
}

static  void method_13836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->productTypeInfo)();
}

static  void method_13837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->typeInfo)();
}

static void constructor_13838( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >((::std::vector<RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >((::std::vector<RPRootDumpPatternInfo>*)arg[0]);
}

static  void method_13839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->getInterface)();
}

static  void method_13840( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13842( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->isPresent)();
}

static  void method_13845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3402( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpPatternInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<RPRootDumpPatternInfo, std::allocator<RPRootDumpPatternInfo> > > -------------------------------
void __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__datamem_bld(&__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__funcmem_bld(&__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_funcmem);
void __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpPatternInfo> >"), typeid(::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >), sizeof(::edm::Wrapper<std::vector<RPRootDumpPatternInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2541, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpPatternInfo> >::value_type"))
  .AddTypedef(type_2541, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpPatternInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13831, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2358), Reflex::Literal("Wrapper"), constructor_13832, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13833, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20528), Reflex::Literal("Wrapper"), constructor_13838, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3402, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<RPRootDumpPatternInfo, std::allocator<RPRootDumpPatternInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2541, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpPatternInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<RPRootDumpPatternInfo, std::allocator<RPRootDumpPatternInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20527), Reflex::Literal("product"), method_13834, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20527), Reflex::Literal("operator->"), operator_13835, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13836, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13837, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20529), Reflex::Literal("getInterface"), method_13839, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13840, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13841, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13842, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<RPRootDumpDigiInfo, std::allocator<RPRootDumpDigiInfo> > > -------------------------------
static void constructor_13852( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >();
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >();
}

static void constructor_13853( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpDigiInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpDigiInfo> >*)arg[0]);
}

static void destructor_13854(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >::~Wrapper)();
}
static  void method_13855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->product)();
}

static  void operator_13856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->operator->)();
}

static  void method_13857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->productTypeInfo)();
}

static  void method_13858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->typeInfo)();
}

static void constructor_13859( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >((::std::vector<RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >((::std::vector<RPRootDumpDigiInfo>*)arg[0]);
}

static  void method_13860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->getInterface)();
}

static  void method_13861( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13862( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13863( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->isPresent)();
}

static  void method_13866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3403( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpDigiInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<RPRootDumpDigiInfo, std::allocator<RPRootDumpDigiInfo> > > -------------------------------
void __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__datamem_bld(&__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__funcmem_bld(&__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_funcmem);
void __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpDigiInfo> >"), typeid(::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >), sizeof(::edm::Wrapper<std::vector<RPRootDumpDigiInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2542, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpDigiInfo> >::value_type"))
  .AddTypedef(type_2542, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpDigiInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13852, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2359), Reflex::Literal("Wrapper"), constructor_13853, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13854, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20533), Reflex::Literal("Wrapper"), constructor_13859, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3403, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<RPRootDumpDigiInfo, std::allocator<RPRootDumpDigiInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2542, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpDigiInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<RPRootDumpDigiInfo, std::allocator<RPRootDumpDigiInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20532), Reflex::Literal("product"), method_13855, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20532), Reflex::Literal("operator->"), operator_13856, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13857, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13858, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20534), Reflex::Literal("getInterface"), method_13860, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13861, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13862, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13863, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > -------------------------------
static void constructor_13873( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >();
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >();
}

static void constructor_13874( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpTrackInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >(*(::std::auto_ptr<std::vector<RPRootDumpTrackInfo> >*)arg[0]);
}

static void destructor_13875(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >::~Wrapper)();
}
static  void method_13876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->product)();
}

static  void operator_13877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->operator->)();
}

static  void method_13878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->productTypeInfo)();
}

static  void method_13879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->typeInfo)();
}

static void constructor_13880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >((::std::vector<RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >((::std::vector<RPRootDumpTrackInfo>*)arg[0]);
}

static  void method_13881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->getInterface)();
}

static  void method_13882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13883( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13884( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_13886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->isPresent)();
}

static  void method_13887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3404( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<RPRootDumpTrackInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > -------------------------------
void __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__datamem_bld(&__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__funcmem_bld(&__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_funcmem);
void __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpTrackInfo> >"), typeid(::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >), sizeof(::edm::Wrapper<std::vector<RPRootDumpTrackInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2539, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpTrackInfo> >::value_type"))
  .AddTypedef(type_2539, Reflex::Literal("edm::Wrapper<std::vector<RPRootDumpTrackInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13873, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2360), Reflex::Literal("Wrapper"), constructor_13874, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13875, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20538), Reflex::Literal("Wrapper"), constructor_13880, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3404, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2539, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_RPRootDumpTrackInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<RPRootDumpTrackInfo, std::allocator<RPRootDumpTrackInfo> > > -------------------
void __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20537), Reflex::Literal("product"), method_13876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20537), Reflex::Literal("operator->"), operator_13877, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13878, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13879, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20539), Reflex::Literal("getInterface"), method_13881, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13882, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13883, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13884, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13885, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpPatternInfo> -------------------------------
static void constructor_13894( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>();
}

static void constructor_13895( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>(*(::std::auto_ptr<RPRootDumpPatternInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>(*(::std::auto_ptr<RPRootDumpPatternInfo>*)arg[0]);
}

static void destructor_13896(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->::edm::Wrapper<RPRootDumpPatternInfo>::~Wrapper)();
}
static  void method_13897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->product)();
}

static  void operator_13898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->operator->)();
}

static  void method_13899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->productTypeInfo)();
}

static  void method_13900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->typeInfo)();
}

static void constructor_13901( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>((::RPRootDumpPatternInfo*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpPatternInfo>((::RPRootDumpPatternInfo*)arg[0]);
}

static  void method_13902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpPatternInfo>*)o)->getInterface)();
}

static  void method_13903( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13904( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13905( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->dynamicTypeInfo)();
}

static  void method_13907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->isPresent)();
}

static  void method_13908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpPatternInfo>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3405( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPatternInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPatternInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPatternInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPatternInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPatternInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpPatternInfo> -------------------------------
void __edm__Wrapper_RPRootDumpPatternInfo__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpPatternInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpPatternInfo__datamem_bld(&__edm__Wrapper_RPRootDumpPatternInfo__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpPatternInfo__funcmem_bld(&__edm__Wrapper_RPRootDumpPatternInfo__db_funcmem);
void __edm__Wrapper_RPRootDumpPatternInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpPatternInfo>"), typeid(::edm::Wrapper<RPRootDumpPatternInfo>), sizeof(::edm::Wrapper<RPRootDumpPatternInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_579, Reflex::Literal("edm::Wrapper<RPRootDumpPatternInfo>::value_type"))
  .AddTypedef(type_579, Reflex::Literal("edm::Wrapper<RPRootDumpPatternInfo>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13894, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2361), Reflex::Literal("Wrapper"), constructor_13895, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13896, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6167), Reflex::Literal("Wrapper"), constructor_13901, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3405, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpPatternInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpPatternInfo__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpPatternInfo> -------------------
void __edm__Wrapper_RPRootDumpPatternInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpPatternInfo_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_579, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpPatternInfo_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpPatternInfo> -------------------
void __edm__Wrapper_RPRootDumpPatternInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9075), Reflex::Literal("product"), method_13897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9075), Reflex::Literal("operator->"), operator_13898, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13899, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13900, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20542), Reflex::Literal("getInterface"), method_13902, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13903, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13904, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13905, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpPattern> -------------------------------
static void constructor_13915( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPattern>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpPattern>();
}

static void constructor_13916( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPattern>(*(::std::auto_ptr<RPRootDumpPattern>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpPattern>(*(::std::auto_ptr<RPRootDumpPattern>*)arg[0]);
}

static void destructor_13917(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpPattern>*)o)->::edm::Wrapper<RPRootDumpPattern>::~Wrapper)();
}
static  void method_13918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpPattern>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->product)();
}

static  void operator_13919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpPattern>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->operator->)();
}

static  void method_13920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpPattern>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpPattern>*)o)->productTypeInfo)();
}

static  void method_13921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpPattern>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpPattern>*)o)->typeInfo)();
}

static void constructor_13922( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpPattern>((::RPRootDumpPattern*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpPattern>((::RPRootDumpPattern*)arg[0]);
}

static  void method_13923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpPattern>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpPattern>*)o)->getInterface)();
}

static  void method_13924( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13925( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13926( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpPattern>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->dynamicTypeInfo)();
}

static  void method_13928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpPattern>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->isPresent)();
}

static  void method_13929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpPattern>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpPattern>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3406( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPattern> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPattern> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPattern> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPattern> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpPattern> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpPattern> -------------------------------
void __edm__Wrapper_RPRootDumpPattern__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpPattern__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpPattern__datamem_bld(&__edm__Wrapper_RPRootDumpPattern__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpPattern__funcmem_bld(&__edm__Wrapper_RPRootDumpPattern__db_funcmem);
void __edm__Wrapper_RPRootDumpPattern__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpPattern>"), typeid(::edm::Wrapper<RPRootDumpPattern>), sizeof(::edm::Wrapper<RPRootDumpPattern>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_814, Reflex::Literal("edm::Wrapper<RPRootDumpPattern>::value_type"))
  .AddTypedef(type_814, Reflex::Literal("edm::Wrapper<RPRootDumpPattern>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13915, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2362), Reflex::Literal("Wrapper"), constructor_13916, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13917, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6489), Reflex::Literal("Wrapper"), constructor_13922, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3406, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpPattern__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpPattern__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpPattern> -------------------
void __edm__Wrapper_RPRootDumpPattern__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpPattern_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_814, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpPattern_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpPattern> -------------------
void __edm__Wrapper_RPRootDumpPattern__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9965), Reflex::Literal("product"), method_13918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9965), Reflex::Literal("operator->"), operator_13919, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13920, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13921, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20545), Reflex::Literal("getInterface"), method_13923, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13924, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13925, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13926, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpReconstructedProtonPair> -------------------------------
static void constructor_13936( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>();
}

static void constructor_13937( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>(*(::std::auto_ptr<RPRootDumpReconstructedProtonPair>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>(*(::std::auto_ptr<RPRootDumpReconstructedProtonPair>*)arg[0]);
}

static void destructor_13938(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->::edm::Wrapper<RPRootDumpReconstructedProtonPair>::~Wrapper)();
}
static  void method_13939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->product)();
}

static  void operator_13940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->operator->)();
}

static  void method_13941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->productTypeInfo)();
}

static  void method_13942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->typeInfo)();
}

static void constructor_13943( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>((::RPRootDumpReconstructedProtonPair*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProtonPair>((::RPRootDumpReconstructedProtonPair*)arg[0]);
}

static  void method_13944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->getInterface)();
}

static  void method_13945( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13946( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13947( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->dynamicTypeInfo)();
}

static  void method_13949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->isPresent)();
}

static  void method_13950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProtonPair>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3407( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProtonPair> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProtonPair> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProtonPair> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProtonPair> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProtonPair> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpReconstructedProtonPair> -------------------------------
void __edm__Wrapper_RPRootDumpReconstructedProtonPair__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpReconstructedProtonPair__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpReconstructedProtonPair__datamem_bld(&__edm__Wrapper_RPRootDumpReconstructedProtonPair__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpReconstructedProtonPair__funcmem_bld(&__edm__Wrapper_RPRootDumpReconstructedProtonPair__db_funcmem);
void __edm__Wrapper_RPRootDumpReconstructedProtonPair__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProtonPair>"), typeid(::edm::Wrapper<RPRootDumpReconstructedProtonPair>), sizeof(::edm::Wrapper<RPRootDumpReconstructedProtonPair>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1686, Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProtonPair>::value_type"))
  .AddTypedef(type_1686, Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProtonPair>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13936, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2363), Reflex::Literal("Wrapper"), constructor_13937, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13938, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20549), Reflex::Literal("Wrapper"), constructor_13943, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3407, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpReconstructedProtonPair__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpReconstructedProtonPair__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpReconstructedProtonPair> -------------------
void __edm__Wrapper_RPRootDumpReconstructedProtonPair__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpReconstructedProtonPair_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1686, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpReconstructedProtonPair_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpReconstructedProtonPair> -------------------
void __edm__Wrapper_RPRootDumpReconstructedProtonPair__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20548), Reflex::Literal("product"), method_13939, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20548), Reflex::Literal("operator->"), operator_13940, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13941, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13942, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20550), Reflex::Literal("getInterface"), method_13944, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13945, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13946, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13947, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpReconstructedProton> -------------------------------
static void constructor_13957( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>();
}

static void constructor_13958( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>(*(::std::auto_ptr<RPRootDumpReconstructedProton>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>(*(::std::auto_ptr<RPRootDumpReconstructedProton>*)arg[0]);
}

static void destructor_13959(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->::edm::Wrapper<RPRootDumpReconstructedProton>::~Wrapper)();
}
static  void method_13960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->product)();
}

static  void operator_13961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->operator->)();
}

static  void method_13962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->productTypeInfo)();
}

static  void method_13963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->typeInfo)();
}

static void constructor_13964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>((::RPRootDumpReconstructedProton*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpReconstructedProton>((::RPRootDumpReconstructedProton*)arg[0]);
}

static  void method_13965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->getInterface)();
}

static  void method_13966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13967( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13968( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->dynamicTypeInfo)();
}

static  void method_13970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->isPresent)();
}

static  void method_13971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpReconstructedProton>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3408( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpReconstructedProton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpReconstructedProton> -------------------------------
void __edm__Wrapper_RPRootDumpReconstructedProton__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpReconstructedProton__datamem_bld(&__edm__Wrapper_RPRootDumpReconstructedProton__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpReconstructedProton__funcmem_bld(&__edm__Wrapper_RPRootDumpReconstructedProton__db_funcmem);
void __edm__Wrapper_RPRootDumpReconstructedProton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProton>"), typeid(::edm::Wrapper<RPRootDumpReconstructedProton>), sizeof(::edm::Wrapper<RPRootDumpReconstructedProton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_532, Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProton>::value_type"))
  .AddTypedef(type_532, Reflex::Literal("edm::Wrapper<RPRootDumpReconstructedProton>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13957, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2364), Reflex::Literal("Wrapper"), constructor_13958, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13959, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6148), Reflex::Literal("Wrapper"), constructor_13964, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3408, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpReconstructedProton__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpReconstructedProton__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpReconstructedProton> -------------------
void __edm__Wrapper_RPRootDumpReconstructedProton__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpReconstructedProton_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_532, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpReconstructedProton_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpReconstructedProton> -------------------
void __edm__Wrapper_RPRootDumpReconstructedProton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9010), Reflex::Literal("product"), method_13960, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9010), Reflex::Literal("operator->"), operator_13961, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13962, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13963, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20553), Reflex::Literal("getInterface"), method_13965, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13966, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13967, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13968, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpDigiInfo> -------------------------------
static void constructor_13978( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>();
}

static void constructor_13979( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>(*(::std::auto_ptr<RPRootDumpDigiInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>(*(::std::auto_ptr<RPRootDumpDigiInfo>*)arg[0]);
}

static void destructor_13980(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->::edm::Wrapper<RPRootDumpDigiInfo>::~Wrapper)();
}
static  void method_13981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->product)();
}

static  void operator_13982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->operator->)();
}

static  void method_13983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->productTypeInfo)();
}

static  void method_13984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->typeInfo)();
}

static void constructor_13985( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>((::RPRootDumpDigiInfo*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpDigiInfo>((::RPRootDumpDigiInfo*)arg[0]);
}

static  void method_13986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpDigiInfo>*)o)->getInterface)();
}

static  void method_13987( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13988( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13989( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->dynamicTypeInfo)();
}

static  void method_13991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->isPresent)();
}

static  void method_13992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpDigiInfo>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3409( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpDigiInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpDigiInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpDigiInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpDigiInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpDigiInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpDigiInfo> -------------------------------
void __edm__Wrapper_RPRootDumpDigiInfo__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpDigiInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpDigiInfo__datamem_bld(&__edm__Wrapper_RPRootDumpDigiInfo__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpDigiInfo__funcmem_bld(&__edm__Wrapper_RPRootDumpDigiInfo__db_funcmem);
void __edm__Wrapper_RPRootDumpDigiInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpDigiInfo>"), typeid(::edm::Wrapper<RPRootDumpDigiInfo>), sizeof(::edm::Wrapper<RPRootDumpDigiInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_949, Reflex::Literal("edm::Wrapper<RPRootDumpDigiInfo>::value_type"))
  .AddTypedef(type_949, Reflex::Literal("edm::Wrapper<RPRootDumpDigiInfo>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13978, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2365), Reflex::Literal("Wrapper"), constructor_13979, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13980, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6186), Reflex::Literal("Wrapper"), constructor_13985, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3409, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpDigiInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpDigiInfo__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpDigiInfo> -------------------
void __edm__Wrapper_RPRootDumpDigiInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpDigiInfo_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_949, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpDigiInfo_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpDigiInfo> -------------------
void __edm__Wrapper_RPRootDumpDigiInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9140), Reflex::Literal("product"), method_13981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9140), Reflex::Literal("operator->"), operator_13982, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_13983, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_13984, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20556), Reflex::Literal("getInterface"), method_13986, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_13987, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_13988, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_13989, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_13990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_13991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_13992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<RPRootDumpTrackInfo> -------------------------------
static void constructor_13999( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>();
  else ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>();
}

static void constructor_14000( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>(*(::std::auto_ptr<RPRootDumpTrackInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>(*(::std::auto_ptr<RPRootDumpTrackInfo>*)arg[0]);
}

static void destructor_14001(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->::edm::Wrapper<RPRootDumpTrackInfo>::~Wrapper)();
}
static  void method_14002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->product)());
  else   (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->product)();
}

static  void operator_14003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->operator->)());
  else   (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->operator->)();
}

static  void method_14004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->productTypeInfo)();
}

static  void method_14005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->typeInfo)();
  else   (((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->typeInfo)();
}

static void constructor_14006( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>((::RPRootDumpTrackInfo*)arg[0]);
  else ::new(mem) ::edm::Wrapper<RPRootDumpTrackInfo>((::RPRootDumpTrackInfo*)arg[0]);
}

static  void method_14007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->getInterface)());
  else   (((::edm::Wrapper<RPRootDumpTrackInfo>*)o)->getInterface)();
}

static  void method_14008( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_14009( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_14010( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_14011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->dynamicTypeInfo)();
}

static  void method_14012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->isPresent)();
}

static  void method_14013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<RPRootDumpTrackInfo>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3410( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpTrackInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpTrackInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpTrackInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpTrackInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<RPRootDumpTrackInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<RPRootDumpTrackInfo> -------------------------------
void __edm__Wrapper_RPRootDumpTrackInfo__db_datamem(Reflex::Class*);
void __edm__Wrapper_RPRootDumpTrackInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpTrackInfo__datamem_bld(&__edm__Wrapper_RPRootDumpTrackInfo__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_RPRootDumpTrackInfo__funcmem_bld(&__edm__Wrapper_RPRootDumpTrackInfo__db_funcmem);
void __edm__Wrapper_RPRootDumpTrackInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<RPRootDumpTrackInfo>"), typeid(::edm::Wrapper<RPRootDumpTrackInfo>), sizeof(::edm::Wrapper<RPRootDumpTrackInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1905, Reflex::Literal("edm::Wrapper<RPRootDumpTrackInfo>::value_type"))
  .AddTypedef(type_1905, Reflex::Literal("edm::Wrapper<RPRootDumpTrackInfo>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13999, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2366), Reflex::Literal("Wrapper"), constructor_14000, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_14001, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6205), Reflex::Literal("Wrapper"), constructor_14006, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3410, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_RPRootDumpTrackInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_RPRootDumpTrackInfo__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<RPRootDumpTrackInfo> -------------------
void __edm__Wrapper_RPRootDumpTrackInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpTrackInfo_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1905, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_RPRootDumpTrackInfo_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<RPRootDumpTrackInfo> -------------------
void __edm__Wrapper_RPRootDumpTrackInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8945), Reflex::Literal("product"), method_14002, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8945), Reflex::Literal("operator->"), operator_14003, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_14004, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_14005, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20559), Reflex::Literal("getInterface"), method_14007, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_14008, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_14009, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_14010, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_14011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_14012, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_14013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TotemRPEvent> -------------------------------
static void constructor_14020( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemRPEvent>();
  else ::new(mem) ::edm::Wrapper<TotemRPEvent>();
}

static void constructor_14021( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemRPEvent>(*(::std::auto_ptr<TotemRPEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemRPEvent>(*(::std::auto_ptr<TotemRPEvent>*)arg[0]);
}

static void destructor_14022(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TotemRPEvent>*)o)->::edm::Wrapper<TotemRPEvent>::~Wrapper)();
}
static  void method_14023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemRPEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<TotemRPEvent>*)o)->product)();
}

static  void operator_14024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TotemRPEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<TotemRPEvent>*)o)->operator->)();
}

static  void method_14025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemRPEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TotemRPEvent>*)o)->productTypeInfo)();
}

static  void method_14026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TotemRPEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<TotemRPEvent>*)o)->typeInfo)();
}

static void constructor_14027( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TotemRPEvent>((::TotemRPEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TotemRPEvent>((::TotemRPEvent*)arg[0]);
}

static  void method_14028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TotemRPEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<TotemRPEvent>*)o)->getInterface)();
}

static  void method_14029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemRPEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_14030( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemRPEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_14031( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TotemRPEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_14032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemRPEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TotemRPEvent>*)o)->dynamicTypeInfo)();
}

static  void method_14033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TotemRPEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TotemRPEvent>*)o)->isPresent)();
}

static  void method_14034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TotemRPEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TotemRPEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3411( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemRPEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemRPEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemRPEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemRPEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TotemRPEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TotemRPEvent> -------------------------------
void __edm__Wrapper_TotemRPEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_TotemRPEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemRPEvent__datamem_bld(&__edm__Wrapper_TotemRPEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TotemRPEvent__funcmem_bld(&__edm__Wrapper_TotemRPEvent__db_funcmem);
void __edm__Wrapper_TotemRPEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TotemRPEvent>"), typeid(::edm::Wrapper<TotemRPEvent>), sizeof(::edm::Wrapper<TotemRPEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1964, Reflex::Literal("edm::Wrapper<TotemRPEvent>::value_type"))
  .AddTypedef(type_1964, Reflex::Literal("edm::Wrapper<TotemRPEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_14020, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2367), Reflex::Literal("Wrapper"), constructor_14021, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_14022, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20563), Reflex::Literal("Wrapper"), constructor_14027, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3411, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TotemRPEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TotemRPEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TotemRPEvent> -------------------
void __edm__Wrapper_TotemRPEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1362, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TotemRPEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1964, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TotemRPEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TotemRPEvent> -------------------
void __edm__Wrapper_TotemRPEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20562), Reflex::Literal("product"), method_14023, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20562), Reflex::Literal("operator->"), operator_14024, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("productTypeInfo"), method_14025, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("typeInfo"), method_14026, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20564), Reflex::Literal("getInterface"), method_14028, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_14062, type_18584, type_20425), Reflex::Literal("fillView"), method_14029, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_291, type_6963), Reflex::Literal("setPtr"), method_14030, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_580, type_12531, type_18585, type_18584), Reflex::Literal("fillPtrVector"), method_14031, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo"), method_14032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1362), Reflex::Literal("isPresent"), method_14033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12531), Reflex::Literal("dynamicTypeInfo_"), method_14034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __RPRootDumpReconstructedProton_dict(); 
      __RPRootDumpPatternInfo_dict(); 
      __RPRootDumpPattern_dict(); 
      __RPRootDumpDigiInfo_dict(); 
      __RPRootDumpReconstructedProtonPair_dict(); 
      __RPRootDumpTrackInfo_dict(); 
      __TotemRPEvent_dict(); 
      __std__vector_RPRootDumpTrackInfo__dict(); 
      __std__vector_RPRootDumpReconstructedProton__dict(); 
      __std__vector_RPRootDumpPatternInfo__dict(); 
      __std__vector_RPRootDumpDigiInfo__dict(); 
      __std__map_unsignedsint_RPRootDumpReconstructedProton__dict(); 
      __std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s__dict(); 
      __std__map_unsignedsint_RPRootDumpPatternInfo__dict(); 
      __std__map_unsignedsint_RPRootDumpDigiInfo__dict(); 
      __std__map_unsignedsint_RPRootDumpTrackInfo__dict(); 
      __edm__Wrapper_std__map_unsignedsint_RPRootDumpReconstructedProton_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_std__vector_RPRootDumpTrackInfo_s_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_RPRootDumpPatternInfo_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_RPRootDumpDigiInfo_s__dict(); 
      __edm__Wrapper_std__map_unsignedsint_RPRootDumpTrackInfo_s__dict(); 
      __edm__Wrapper_std__vector_RPRootDumpReconstructedProton_s__dict(); 
      __edm__Wrapper_std__vector_RPRootDumpPatternInfo_s__dict(); 
      __edm__Wrapper_std__vector_RPRootDumpDigiInfo_s__dict(); 
      __edm__Wrapper_std__vector_RPRootDumpTrackInfo_s__dict(); 
      __edm__Wrapper_RPRootDumpPatternInfo__dict(); 
      __edm__Wrapper_RPRootDumpPattern__dict(); 
      __edm__Wrapper_RPRootDumpReconstructedProtonPair__dict(); 
      __edm__Wrapper_RPRootDumpReconstructedProton__dict(); 
      __edm__Wrapper_RPRootDumpDigiInfo__dict(); 
      __edm__Wrapper_RPRootDumpTrackInfo__dict(); 
      __edm__Wrapper_TotemRPEvent__dict(); 
    }
    ~Dictionaries() {
      type_532.Unload(); // class RPRootDumpReconstructedProton 
      type_579.Unload(); // class RPRootDumpPatternInfo 
      type_814.Unload(); // class RPRootDumpPattern 
      type_949.Unload(); // class RPRootDumpDigiInfo 
      type_1686.Unload(); // class RPRootDumpReconstructedProtonPair 
      type_1905.Unload(); // class RPRootDumpTrackInfo 
      type_1964.Unload(); // class TotemRPEvent 
      type_2539.Unload(); // class std::vector<RPRootDumpTrackInfo> 
      type_2540.Unload(); // class std::vector<RPRootDumpReconstructedProton> 
      type_2541.Unload(); // class std::vector<RPRootDumpPatternInfo> 
      type_2542.Unload(); // class std::vector<RPRootDumpDigiInfo> 
      type_2661.Unload(); // class std::map<unsigned int,RPRootDumpReconstructedProton> 
      type_2662.Unload(); // class std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > 
      type_2663.Unload(); // class std::map<unsigned int,RPRootDumpPatternInfo> 
      type_2664.Unload(); // class std::map<unsigned int,RPRootDumpDigiInfo> 
      type_2665.Unload(); // class std::map<unsigned int,RPRootDumpTrackInfo> 
      type_3396.Unload(); // class edm::Wrapper<std::map<unsigned int,RPRootDumpReconstructedProton> > 
      type_3397.Unload(); // class edm::Wrapper<std::map<unsigned int,std::vector<RPRootDumpTrackInfo> > > 
      type_3398.Unload(); // class edm::Wrapper<std::map<unsigned int,RPRootDumpPatternInfo> > 
      type_3399.Unload(); // class edm::Wrapper<std::map<unsigned int,RPRootDumpDigiInfo> > 
      type_3400.Unload(); // class edm::Wrapper<std::map<unsigned int,RPRootDumpTrackInfo> > 
      type_3401.Unload(); // class edm::Wrapper<std::vector<RPRootDumpReconstructedProton> > 
      type_3402.Unload(); // class edm::Wrapper<std::vector<RPRootDumpPatternInfo> > 
      type_3403.Unload(); // class edm::Wrapper<std::vector<RPRootDumpDigiInfo> > 
      type_3404.Unload(); // class edm::Wrapper<std::vector<RPRootDumpTrackInfo> > 
      type_3405.Unload(); // class edm::Wrapper<RPRootDumpPatternInfo> 
      type_3406.Unload(); // class edm::Wrapper<RPRootDumpPattern> 
      type_3407.Unload(); // class edm::Wrapper<RPRootDumpReconstructedProtonPair> 
      type_3408.Unload(); // class edm::Wrapper<RPRootDumpReconstructedProton> 
      type_3409.Unload(); // class edm::Wrapper<RPRootDumpDigiInfo> 
      type_3410.Unload(); // class edm::Wrapper<RPRootDumpTrackInfo> 
      type_3411.Unload(); // class edm::Wrapper<TotemRPEvent> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
